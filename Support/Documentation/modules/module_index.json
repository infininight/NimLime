[
  {
    "module": "actors", 
    "description": "`Actor`:idx: support for Nim. An actor is implemented as a thread with\u000A## a channel as its inbox. This module requires the ``--threads:on``\u000A## command line switch.\u000A##\u000A## Example:\u000A##\u000A## .. code-block:: nim\u000A##\u000A##      var\u000A##        a: TActorPool[int, void]\u000A##      createActorPool(a)\u000A##      for i in 0 .. < 300:\u000A##        a.spawn(i, proc (x: int) {.thread.} = echo x)\u000A##      a.join()\u000A##\u000A## **Note**: This whole module is deprecated. Use `threadpool` and ``spawn``\u000A## instead."
  }, 
  {
    "module": "algorithm", 
    "description": "This module implements some common generic algorithms."
  }, 
  {
    "module": "asyncdispatch", 
    "description": "AsyncDispatch\u000A## *************\u000A##\u000A## This module implements asynchronous IO. This includes a dispatcher,\u000A## a ``Future`` type implementation, and an ``async`` macro which allows\u000A## asynchronous code to be written in a synchronous style with the ``await``\u000A## keyword.\u000A##\u000A## The dispatcher acts as a kind of event loop. You must call ``poll`` on it\u000A## (or a function which does so for you such as ``waitFor`` or ``runForever``)\u000A## in order to poll for any outstanding events. The underlying implementation\u000A## is based on epoll on Linux, IO Completion Ports on Windows and select on\u000A## other operating systems.\u000A##\u000A## The ``poll`` function will not, on its own, return any events. Instead\u000A## an appropriate ``Future`` object will be completed. A ``Future`` is a\u000A## type which holds a value which is not yet available, but which *may* be\u000A## available in the future. You can check whether a future is finished\u000A## by using the ``finished`` function. When a future is finished it means that\u000A## either the value that it holds is now available or it holds an error instead.\u000A## The latter situation occurs when the operation to complete a future fails\u000A## with an exception. You can distinguish between the two situations with the\u000A## ``failed`` function.\u000A##\u000A## Future objects can also store a callback procedure which will be called\u000A## automatically once the future completes.\u000A##\u000A## Futures therefore can be thought of as an implementation of the proactor\u000A## pattern. In this\u000A## pattern you make a request for an action, and once that action is fulfilled\u000A## a future is completed with the result of that action. Requests can be\u000A## made by calling the appropriate functions. For example: calling the ``recv``\u000A## function will create a request for some data to be read from a socket. The\u000A## future which the ``recv`` function returns will then complete once the\u000A## requested amount of data is read **or** an exception occurs.\u000A##\u000A## Code to read some data from a socket may look something like this:\u000A##\u000A##   .. code-block::nim\u000A##      var future = socket.recv(100)\u000A##      future.callback =\u000A##        proc () =\u000A##          echo(future.read)\u000A##\u000A## All asynchronous functions returning a ``Future`` will not block. They\u000A## will not however return immediately. An asynchronous function will have\u000A## code which will be executed before an asynchronous request is made, in most\u000A## cases this code sets up the request.\u000A##\u000A## In the above example, the ``recv`` function will return a brand new\u000A## ``Future`` instance once the request for data to be read from the socket\u000A## is made. This ``Future`` instance will complete once the requested amount\u000A## of data is read, in this case it is 100 bytes. The second line sets a\u000A## callback on this future which will be called once the future completes.\u000A## All the callback does is write the data stored in the future to ``stdout``.\u000A## The ``read`` function is used for this and it checks whether the future\u000A## completes with an error for you (if it did it will simply raise the\u000A## error), if there is no error however it returns the value of the future.\u000A##\u000A## Asynchronous procedures\u000A## -----------------------\u000A##\u000A## Asynchronous procedures remove the pain of working with callbacks. They do\u000A## this by allowing you to write asynchronous code the same way as you would\u000A## write synchronous code.\u000A##\u000A## An asynchronous procedure is marked using the ``{.async.}`` pragma.\u000A## When marking a procedure with the ``{.async.}`` pragma it must have a\u000A## ``Future[T]`` return type or no return type at all. If you do not specify\u000A## a return type then ``Future[void]`` is assumed.\u000A##\u000A## Inside asynchronous procedures ``await`` can be used to call any\u000A## procedures which return a\u000A## ``Future``; this includes asynchronous procedures. When a procedure is\u000A## \"awaited\", the asynchronous procedure it is awaited in will\u000A## suspend its execution\u000A## until the awaited procedure's Future completes. At which point the\u000A## asynchronous procedure will resume its execution. During the period\u000A## when an asynchronous procedure is suspended other asynchronous procedures\u000A## will be run by the dispatcher.\u000A##\u000A## The ``await`` call may be used in many contexts. It can be used on the right\u000A## hand side of a variable declaration: ``var data = await socket.recv(100)``,\u000A## in which case the variable will be set to the value of the future\u000A## automatically. It can be used to await a ``Future`` object, and it can\u000A## be used to await a procedure returning a ``Future[void]``:\u000A## ``await socket.send(\"foobar\")``.\u000A##\u000A## Discarding futures\u000A## ------------------\u000A##\u000A## Futures should **never** be discarded. This is because they may contain\u000A## errors. If you do not care for the result of a Future then you should\u000A## use the ``asyncCheck`` procedure instead of the ``discard`` keyword.\u000A##\u000A## Examples\u000A## --------\u000A##\u000A## For examples take a look at the documentation for the modules implementing\u000A## asynchronous IO. A good place to start is the\u000A## `asyncnet module <asyncnet.html>`_.\u000A##\u000A## Limitations/Bugs\u000A## ----------------\u000A## \u000A## * ``except`` statement (without `try`) does not work inside async procedures.\u000A## * The effect system (``raises: []``) does not work with async procedures.\u000A## * Can't await in a ``except`` body"
  }, 
  {
    "module": "asyncfile", 
    "description": "This module implements asynchronous file handling.\u000A##\u000A## .. code-block:: Nim\u000A##    import asyncfile, asyncdispatch, os\u000A##\u000A##    proc main() {.async.} =\u000A##      var file = openAsync(getTempDir() / \"foobar.txt\", fmReadWrite)\u000A##      await file.write(\"test\")\u000A##      file.setFilePos(0)\u000A##      let data = await file.readAll()\u000A##      doAssert data == \"test\"\u000A##      file.close()\u000A##\u000A##    waitFor main()"
  }, 
  {
    "module": "asyncftpclient", 
    "description": "This module implement an asynchronous FTP client.\u000A##\u000A## Examples\u000A## --------\u000A##\u000A## .. code-block::nim\u000A##\u000A##      var ftp = newAsyncFtpClient(\"example.com\", user = \"test\", pass = \"test\")\u000A##      proc main(ftp: AsyncFtpClient) {.async.} =\u000A##        await ftp.connect()\u000A##        echo await ftp.pwd()\u000A##        echo await ftp.listDirs()\u000A##        await ftp.store(\"payload.jpg\", \"payload.jpg\")\u000A##        await ftp.retrFile(\"payload.jpg\", \"payload2.jpg\")\u000A##        echo(\"Finished\")\u000A##\u000A##      waitFor main(ftp)"
  }, 
  {
    "module": "asynchttpserver", 
    "description": "This module implements a high performance asynchronous HTTP server.\u000A##\u000A## Examples\u000A## --------\u000A##\u000A## This example will create an HTTP server on port 8080. The server will\u000A## respond to all requests with a ``200 OK`` response code and \"Hello World\"\u000A## as the response body.\u000A##\u000A## .. code-block::nim\u000A##    var server = newAsyncHttpServer()\u000A##    proc cb(req: TRequest) {.async.} =\u000A##      await req.respond(Http200, \"Hello World\")\u000A##\u000A##    asyncCheck server.serve(Port(8080), cb)\u000A##    runForever()"
  }, 
  {
    "module": "asyncio", 
    "description": "This module implements an asynchronous event loop together with asynchronous\u000A## sockets which use this event loop.\u000A## It is akin to Python's asyncore module. Many modules that use sockets\u000A## have an implementation for this module, those modules should all have a \u000A## ``register`` function which you should use to add the desired objects to a \u000A## dispatcher which you created so\u000A## that you can receive the events associated with that module's object.\u000A##\u000A## Once everything is registered in a dispatcher, you need to call the ``poll``\u000A## function in a while loop.\u000A##\u000A## **Note:** Most modules have tasks which need to be ran regularly, this is\u000A## why you should not call ``poll`` with a infinite timeout, or even a \u000A## very long one. In most cases the default timeout is fine.\u000A##\u000A## **Note:** This module currently only supports select(), this is limited by\u000A## FD_SETSIZE, which is usually 1024. So you may only be able to use 1024\u000A## sockets at a time.\u000A## \u000A## Most (if not all) modules that use asyncio provide a userArg which is passed\u000A## on with the events. The type that you set userArg to must be inheriting from\u000A## ``RootObj``!\u000A##\u000A## **Note:** If you want to provide async ability to your module please do not \u000A## use the ``Delegate`` object, instead use ``AsyncSocket``. It is possible \u000A## that in the future this type's fields will not be exported therefore breaking\u000A## your code.\u000A##\u000A## **Warning:** The API of this module is unstable, and therefore is subject\u000A## to change.\u000A##\u000A## Asynchronous sockets\u000A## ====================\u000A##\u000A## For most purposes you do not need to worry about the ``Delegate`` type. The\u000A## ``AsyncSocket`` is what you are after. It's a reference to\u000A## the ``AsyncSocketObj`` object. This object defines events which you should\u000A## overwrite by your own procedures.\u000A##\u000A## For server sockets the only event you need to worry about is the ``handleAccept``\u000A## event, in your handleAccept proc you should call ``accept`` on the server\u000A## socket which will give you the client which is connecting. You should then\u000A## set any events that you want to use on that client and add it to your dispatcher\u000A## using the ``register`` procedure.\u000A## \u000A## An example ``handleAccept`` follows:\u000A## \u000A## .. code-block:: nim\u000A##   \u000A##    var disp = newDispatcher()\u000A##    ...\u000A##    proc handleAccept(s: AsyncSocket) =\u000A##      echo(\"Accepted client.\")\u000A##      var client: AsyncSocket\u000A##      new(client)\u000A##      s.accept(client)\u000A##      client.handleRead = ...\u000A##      disp.register(client)\u000A##    ...\u000A## \u000A## For client sockets you should only be interested in the ``handleRead`` and\u000A## ``handleConnect`` events. The former gets called whenever the socket has\u000A## received messages and can be read from and the latter gets called whenever\u000A## the socket has established a connection to a server socket; from that point\u000A## it can be safely written to.\u000A##\u000A## Getting a blocking client from an AsyncSocket\u000A## =============================================\u000A## \u000A## If you need a asynchronous server socket but you wish to process the clients\u000A## synchronously then you can use the ``getSocket`` converter to get\u000A## a ``Socket`` from the ``AsyncSocket`` object, this can then be combined\u000A## with ``accept`` like so:\u000A##\u000A## .. code-block:: nim\u000A##    \u000A##    proc handleAccept(s: AsyncSocket) =\u000A##      var client: Socket\u000A##      getSocket(s).accept(client)"
  }, 
  {
    "module": "asyncnet", 
    "description": "This module implements a high-level asynchronous sockets API based on the\u000A## asynchronous dispatcher defined in the ``asyncdispatch`` module.\u000A##\u000A## SSL\u000A## ---\u000A##\u000A## SSL can be enabled by compiling with the ``-d:ssl`` flag.\u000A##\u000A## You must create a new SSL context with the ``newContext`` function defined\u000A## in the ``net`` module. You may then call ``wrapSocket`` on your socket using\u000A## the newly created SSL context to get an SSL socket.\u000A##\u000A## Examples\u000A## --------\u000A##\u000A## Chat server\u000A## ^^^^^^^^^^^\u000A## \u000A## The following example demonstrates a simple chat server.\u000A##\u000A## .. code-block::nim\u000A##\u000A##   import asyncnet, asyncdispatch\u000A##\u000A##   var clients {.threadvar.}: seq[AsyncSocket]\u000A##\u000A##   proc processClient(client: AsyncSocket) {.async.} =\u000A##     while true:\u000A##       let line = await client.recvLine()\u000A##       for c in clients:\u000A##         await c.send(line & \"\\c\\L\")\u000A##\u000A##   proc serve() {.async.} =\u000A##     clients = @[]\u000A##     var server = newAsyncSocket()\u000A##     server.bindAddr(Port(12345))\u000A##     server.listen()\u000A##\u000A##     while true:\u000A##       let client = await server.accept()\u000A##       clients.add client\u000A##\u000A##       asyncCheck processClient(client)\u000A##\u000A##   asyncCheck serve()\u000A##   runForever()\u000A##"
  }, 
  {
    "module": "base64", 
    "description": "This module implements a base64 encoder and decoder."
  }, 
  {
    "module": "basic2d", 
    "description": "Basic 2d support with vectors, points, matrices and some basic utilities.\u000A## Vectors are implemented as direction vectors, ie. when transformed with a matrix\u000A## the translation part of matrix is ignored. \u000A## Operators `+` , `-` , `*` , `/` , `+=` , `-=` , `*=` and `/=` are implemented for vectors and scalars.\u000A##\u000A## Quick start example:\u000A##   \u000A##   # Create a matrix wich first rotates, then scales and at last translates\u000A##   \u000A##   var m:TMatrix2d=rotate(DEG90) & scale(2.0) & move(100.0,200.0)\u000A##   \u000A##   # Create a 2d point at (100,0) and a vector (5,2)\u000A##   \u000A##   var pt:TPoint2d=point2d(100.0,0.0) \u000A##   \u000A##   var vec:TVector2d=vector2d(5.0,2.0)\u000A##   \u000A##   \u000A##   pt &= m # transforms pt in place\u000A##   \u000A##   var pt2:TPoint2d=pt & m #concatenates pt with m and returns a new point\u000A##   \u000A##   var vec2:TVector2d=vec & m #concatenates vec with m and returns a new vector"
  }, 
  {
    "module": "browsers", 
    "description": "This module implements a simple proc for opening URLs with the user's\u000A## default browser."
  }, 
  {
    "module": "cgi", 
    "description": "This module implements helper procs for CGI applications. Example:\u000A##\u000A## .. code-block:: Nim\u000A##\u000A##    import strtabs, cgi\u000A##\u000A##    # Fill the values when debugging:\u000A##    when debug:\u000A##      setTestData(\"name\", \"Klaus\", \"password\", \"123456\")\u000A##    # read the data into `myData`\u000A##    var myData = readData()\u000A##    # check that the data's variable names are \"name\" or \"password\"\u000A##    validateData(myData, \"name\", \"password\")\u000A##    # start generating content:\u000A##    writeContentType()\u000A##    # generate content:\u000A##    write(stdout, \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\">\\n\")\u000A##    write(stdout, \"<html><head><title>Test</title></head><body>\\n\")\u000A##    writeln(stdout, \"your name: \" & myData[\"name\"])\u000A##    writeln(stdout, \"your password: \" & myData[\"password\"])\u000A##    writeln(stdout, \"</body></html>\")"
  }, 
  {
    "module": "colors", 
    "description": "This module implements color handling for Nimrod. It is used by \u000A## the ``graphics`` module."
  }, 
  {
    "module": "complex", 
    "description": "This module implements complex numbers."
  }, 
  {
    "module": "cookies", 
    "description": "This module implements helper procs for parsing Cookies."
  }, 
  {
    "module": "cpuinfo", 
    "description": "This module implements procs to determine the number of CPUs / cores."
  }, 
  {
    "module": "cpuload", 
    "description": "This module implements a helper for a thread pool to determine whether\u000A## creating a thread is a good idea."
  }, 
  {
    "module": "critbits", 
    "description": "This module implements a `crit bit tree`:idx: which is an efficient\u000A## container for a set or a mapping of strings. Based on the excellent paper\u000A## by Adam Langley."
  }, 
  {
    "module": "db_mysql", 
    "description": "A higher level `mySQL`:idx: database wrapper. The same interface is \u000A## implemented for other databases too."
  }, 
  {
    "module": "db_postgres", 
    "description": "A higher level `PostgreSQL`:idx: database wrapper. This interface \u000A## is implemented for other databases too."
  }, 
  {
    "module": "db_sqlite", 
    "description": "A higher level `SQLite`:idx: database wrapper. This interface \u000A## is implemented for other databases too."
  }, 
  {
    "module": "dialogs", 
    "description": "This module implements portable dialogs for Nim; the implementation\u000A## builds on the GTK interface. On Windows, native dialogs are shown instead."
  }, 
  {
    "module": "dom", 
    "description": "Declaration of the Document Object Model for the `JavaScript backend\u000A## <backends.html#the-javascript-target>`_."
  }, 
  {
    "module": "dynlib", 
    "description": "This module implements the ability to access symbols from shared\u000A## libraries. On POSIX this uses the ``dlsym`` mechanism, on \u000A## Windows ``LoadLibrary``."
  }, 
  {
    "module": "encodings", 
    "description": "Converts between different character encodings. On UNIX, this uses \u000A## the `iconv`:idx: library, on Windows the Windows API."
  }, 
  {
    "module": "endians", 
    "description": "This module contains helpers that deal with different byte orders\u000A## (`endian`:idx:)."
  }, 
  {
    "module": "epoll"
  }, 
  {
    "module": "events", 
    "description": ":Author: Alex Mitchell\u000A##\u000A## This module implements an event system that is not dependant on external\u000A## graphical toolkits. It was originally called ``NimEE`` because \u000A## it was inspired by Python's PyEE module. There are two ways you can use\u000A## events: one is a python-inspired way; the other is more of a C-style way.\u000A##\u000A## .. code-block:: Nim\u000A##    var ee = initEventEmitter()\u000A##    var genericargs: EventArgs\u000A##    proc handleevent(e: EventArgs) =\u000A##        echo(\"Handled!\")\u000A##\u000A##    # Python way\u000A##    ee.on(\"EventName\", handleevent)\u000A##    ee.emit(\"EventName\", genericargs)\u000A## \u000A##    # C/Java way\u000A##    # Declare a type\u000A##    type\u000A##        SomeObject = object of RootObj\u000A##            SomeEvent: EventHandler\u000A##    var myobj: SomeObject\u000A##    myobj.SomeEvent = initEventHandler(\"SomeEvent\")\u000A##    myobj.SomeEvent.addHandler(handleevent)\u000A##    ee.emit(myobj.SomeEvent, genericargs)"
  }, 
  {
    "module": "expat"
  }, 
  {
    "module": "fenv", 
    "description": "Floating-point environment. Handling of floating-point rounding and\u000A## exceptions (overflow, division by zero, etc.)."
  }, 
  {
    "module": "fsmonitor", 
    "description": "This module allows you to monitor files or directories for changes using\u000A## asyncio.\u000A##\u000A## Windows support is not yet implemented.\u000A##\u000A## **Note:** This module uses ``inotify`` on Linux (Other Unixes are not yet\u000A## supported). ``inotify`` was merged into the 2.6.13 Linux kernel, this\u000A## module will therefore not work with any Linux kernel prior to that, unless\u000A## it has been patched to support inotify."
  }, 
  {
    "module": "ftpclient", 
    "description": "This module **partially** implements an FTP client as specified\u000A## by `RFC 959 <http://tools.ietf.org/html/rfc959>`_. \u000A## \u000A## This module provides both a synchronous and asynchronous implementation.\u000A## The asynchronous implementation requires you to use the ``asyncFTPClient``\u000A## function. You are then required to register the ``AsyncFTPClient`` with a\u000A## asyncio dispatcher using the ``register`` function. Take a look at the\u000A## asyncio module documentation for more information.\u000A##\u000A## **Note**: The asynchronous implementation is only asynchronous for long\u000A## file transfers, calls to functions which use the command socket will block.\u000A##\u000A## Here is some example usage of this module:\u000A## \u000A## .. code-block:: Nim\u000A##    var ftp = ftpClient(\"example.org\", user = \"user\", pass = \"pass\")\u000A##    ftp.connect()\u000A##    ftp.retrFile(\"file.ext\", \"file.ext\")\u000A##\u000A## **Warning:** The API of this module is unstable, and therefore is subject\u000A## to change."
  }, 
  {
    "module": "future", 
    "description": "This module implements experimental features which may soon be moved to\u000A## the system module (or other more appropriate modules)."
  }, 
  {
    "module": "gentabs", 
    "description": "The ``gentabs`` module implements an efficient hash table that is a\u000A## key-value mapping. The keys are required to be strings, but the values\u000A## may be any Nim or user defined type. This module supports matching \u000A## of keys in case-sensitive, case-insensitive and style-insensitive modes."
  }, 
  {
    "module": "graphics", 
    "description": "This module implements graphical output for Nim; the current\u000A## implementation uses SDL but the interface is meant to support multiple\u000A## backends some day. There is no need to init SDL as this module does that \u000A## implicitly."
  }, 
  {
    "module": "hashes", 
    "description": "This module implements efficient computations of hash values for diverse\u000A## Nim types. All the procs are based on these two building blocks: the `!&\u000A## proc <#!&>`_ used to start or mix a hash value, and the `!$ proc <#!$>`_\u000A## used to *finish* the hash value.  If you want to implement hash procs for\u000A## your custom types you will end up writing the following kind of skeleton of\u000A## code:\u000A##\u000A## .. code-block:: Nim\u000A##  proc hash(x: Something): THash =\u000A##    ## Computes a THash from `x`.\u000A##    var h: THash = 0\u000A##    # Iterate over parts of `x`.\u000A##    for xAtom in x:\u000A##      # Mix the atom with the partial hash.\u000A##      h = h !& xAtom\u000A##    # Finish the hash.\u000A##    result = !$h\u000A##\u000A## If your custom types contain fields for which there already is a hash proc,\u000A## like for example objects made up of ``strings``, you can simply hash\u000A## together the hash value of the individual fields:\u000A##\u000A## .. code-block:: Nim\u000A##  proc hash(x: Something): THash =\u000A##    ## Computes a THash from `x`.\u000A##    var h: THash = 0\u000A##    h = h &! hash(x.foo)\u000A##    h = h &! hash(x.bar)\u000A##    result = !$h"
  }, 
  {
    "module": "history"
  }, 
  {
    "module": "htmlgen", 
    "description": "**Warning**: This module uses ``immediate`` macros which are known to\u000A## cause problems. Do yourself a favor and import the module\u000A## as ``from htmlgen import nil`` and then fully qualify the macros.\u000A##\u000A##\u000A## This module implements a simple `XML`:idx: and `HTML`:idx: code \u000A## generator. Each commonly used HTML tag has a corresponding macro\u000A## that generates a string with its HTML representation.\u000A##\u000A## Example:\u000A##\u000A## .. code-block:: Nim\u000A##   var nim = \"Nim\"\u000A##   echo h1(a(href=\"http://nim-lang.org\", nim))\u000A##  \u000A## Writes the string::\u000A##   \u000A##   <h1><a href=\"http://nim-lang.org\">Nim</a></h1>\u000A##"
  }, 
  {
    "module": "htmlparser", 
    "description": "This module parses an HTML document and creates its XML tree representation.\u000A## It is supposed to handle the *wild* HTML the real world uses.\u000A## \u000A## It can be used to parse a wild HTML document and output it as valid XHTML\u000A## document (well, if you are lucky):\u000A##\u000A## .. code-block:: Nim\u000A##\u000A##   echo loadHtml(\"mydirty.html\")\u000A##\u000A## Every tag in the resulting tree is in lower case.\u000A##\u000A## **Note:** The resulting ``PXmlNode`` already uses the ``clientData`` field, \u000A## so it cannot be used by clients of this library.\u000A##\u000A## Example: Transforming hyperlinks\u000A## ================================\u000A##\u000A## This code demonstrates how you can iterate over all the tags in an HTML file\u000A## and write back the modified version. In this case we look for hyperlinks\u000A## ending with the extension ``.rst`` and convert them to ``.html``.\u000A##\u000A## .. code-block:: Nim\u000A##\u000A##   import htmlparser\u000A##   import xmltree  # To use '$' for PXmlNode\u000A##   import strtabs  # To access PXmlAttributes\u000A##   import os       # To use splitFile\u000A##   import strutils # To use cmpIgnoreCase\u000A##\u000A##   proc transformHyperlinks() =\u000A##     let html = loadHTML(\"input.html\")\u000A##\u000A##     for a in html.findAll(\"a\"):\u000A##       let href = a.attrs[\"href\"]\u000A##       if not href.isNil:\u000A##         let (dir, filename, ext) = splitFile(href)\u000A##         if cmpIgnoreCase(ext, \".rst\") == 0:\u000A##           a.attrs[\"href\"] = dir / filename & \".html\"\u000A##\u000A##     writeFile(\"output.html\", $html)"
  }, 
  {
    "module": "httpclient", 
    "description": "This module implements a simple HTTP client that can be used to retrieve\u000A## webpages/other data.\u000A##\u000A##\u000A## **Note**: This module is not ideal, connection is not kept alive so sites with\u000A## many redirects are expensive. As such in the future this module may change,\u000A## and the current procedures will be deprecated.\u000A##\u000A## Retrieving a website\u000A## ====================\u000A##\u000A## This example uses HTTP GET to retrieve\u000A## ``http://google.com``\u000A##\u000A## .. code-block:: Nim\u000A##   echo(getContent(\"http://google.com\"))\u000A##\u000A## Using HTTP POST\u000A## ===============\u000A##\u000A## This example demonstrates the usage of the W3 HTML Validator, it\u000A## uses ``multipart/form-data`` as the ``Content-Type`` to send the HTML to\u000A## the server.\u000A##\u000A## .. code-block:: Nim\u000A##   var headers: string = \"Content-Type: multipart/form-data; boundary=xyz\\c\\L\"\u000A##   var body: string = \"--xyz\\c\\L\"\u000A##   # soap 1.2 output\u000A##   body.add(\"Content-Disposition: form-data; name=\\\"output\\\"\\c\\L\")\u000A##   body.add(\"\\c\\Lsoap12\\c\\L\")\u000A##\u000A##   # html\u000A##   body.add(\"--xyz\\c\\L\")\u000A##   body.add(\"Content-Disposition: form-data; name=\\\"uploaded_file\\\";\" &\u000A##            \" filename=\\\"test.html\\\"\\c\\L\")\u000A##   body.add(\"Content-Type: text/html\\c\\L\")\u000A##   body.add(\"\\c\\L<html><head></head><body><p>test</p></body></html>\\c\\L\")\u000A##   body.add(\"--xyz--\")\u000A##\u000A##   echo(postContent(\"http://validator.w3.org/check\", headers, body))\u000A##\u000A## Asynchronous HTTP requests\u000A## ==========================\u000A##\u000A## You simply have to create a new instance of the ``AsyncHttpClient`` object.\u000A## You may then use ``await`` on the functions defined for that object.\u000A## Keep in mind that the following code needs to be inside an asynchronous\u000A## procedure.\u000A##\u000A## .. code-block::nim\u000A##\u000A##    var client = newAsyncHttpClient()\u000A##    var resp = await client.request(\"http://google.com\")\u000A##\u000A## SSL/TLS support\u000A## ===============\u000A## This requires the OpenSSL library, fortunately it's widely used and installed\u000A## on many operating systems. httpclient will use SSL automatically if you give\u000A## any of the functions a url with the ``https`` schema, for example:\u000A## ``https://github.com/``, you also have to compile with ``ssl`` defined like so:\u000A## ``nim c -d:ssl ...``.\u000A##\u000A## Timeouts\u000A## ========\u000A## Currently all functions support an optional timeout, by default the timeout is set to\u000A## `-1` which means that the function will never time out. The timeout is\u000A## measured in miliseconds, once it is set any call on a socket which may\u000A## block will be susceptible to this timeout, however please remember that the\u000A## function as a whole can take longer than the specified timeout, only\u000A## individual internal calls on the socket are affected. In practice this means\u000A## that as long as the server is sending data an exception will not be raised,\u000A## if however data does not reach client within the specified timeout an ETimeout\u000A## exception will then be raised.\u000A##\u000A## Proxy\u000A## =====\u000A##\u000A## A proxy can be specified as a param to any of these procedures, the ``newProxy``\u000A## constructor should be used for this purpose. However,\u000A## currently only basic authentication is supported."
  }, 
  {
    "module": "httpserver", 
    "description": "This module implements a simple HTTP-Server.\u000A##\u000A## Example:\u000A##\u000A## .. code-block:: nim\u000A##  import strutils, sockets, httpserver\u000A##\u000A##  var counter = 0\u000A##  proc handleRequest(client: Socket, path, query: string): bool {.procvar.} =\u000A##    inc(counter)\u000A##    client.send(\"Hello for the $#th time.\" % $counter & wwwNL)\u000A##    return false # do not stop processing\u000A##\u000A##  run(handleRequest, Port(80))\u000A##"
  }, 
  {
    "module": "inotify"
  }, 
  {
    "module": "intsets", 
    "description": "The ``intsets`` module implements an efficient int set implemented as a\u000A## sparse bit set.\u000A## **Note**: Since Nim currently does not allow the assignment operator to\u000A## be overloaded, ``=`` for int sets performs some rather meaningless shallow\u000A## copy; use ``assign`` to get a deep copy."
  }, 
  {
    "module": "iup"
  }, 
  {
    "module": "joyent_http_parser"
  }, 
  {
    "module": "json", 
    "description": "This module implements a simple high performance `JSON`:idx:\u000A## parser. JSON (JavaScript Object Notation) is a lightweight \u000A## data-interchange format that is easy for humans to read and write \u000A## (unlike XML). It is easy for machines to parse and generate.\u000A## JSON is based on a subset of the JavaScript Programming Language,\u000A## Standard ECMA-262 3rd Edition - December 1999.\u000A##\u000A## Usage example:\u000A##\u000A## .. code-block:: nim\u000A##  let\u000A##    small_json = \"\"\"{\"test\": 1.3, \"key2\": true}\"\"\"\u000A##    jobj = parseJson(small_json)\u000A##  assert (jobj.kind == JObject)\u000A##  echo($jobj[\"test\"].fnum)\u000A##  echo($jobj[\"key2\"].bval)\u000A##\u000A## Results in:\u000A##\u000A## .. code-block:: nim\u000A##\u000A##   1.3000000000000000e+00\u000A##   true"
  }, 
  {
    "module": "lexbase", 
    "description": "This module implements a base object of a lexer with efficient buffer\u000A## handling. Only at line endings checks are necessary if the buffer\u000A## needs refilling."
  }, 
  {
    "module": "libcurl"
  }, 
  {
    "module": "libffi"
  }, 
  {
    "module": "libsvm", 
    "description": "This module is a low level wrapper for `libsvm`:idx:."
  }, 
  {
    "module": "libuv", 
    "description": "libuv is still fast moving target\u000A## This file was last updated against a development HEAD revision of https://github.com/joyent/libuv/"
  }, 
  {
    "module": "libzip", 
    "description": "Interface to the `libzip <http://www.nih.at/libzip/index.html>`_ library by\u000A## Dieter Baron and Thomas Klausner. This version links\u000A## against ``libzip2.so.2`` unless you define the symbol ``useLibzipSrc``; then\u000A## it is compiled against some old ``libizp_all.c`` file."
  }, 
  {
    "module": "linux"
  }, 
  {
    "module": "lists", 
    "description": "Implementation of singly and doubly linked lists. Because it makes no sense\u000A## to do so, the 'next' and 'prev' pointers are not hidden from you and can\u000A## be manipulated directly for efficiency."
  }, 
  {
    "module": "locks", 
    "description": "This module contains Nim's support for locks and condition vars."
  }, 
  {
    "module": "logging", 
    "description": "This module implements a simple logger. It has been designed to be as simple\u000A## as possible to avoid bloat, if this library does not fullfill your needs,\u000A## write your own.\u000A## \u000A## Format strings support the following variables which must be prefixed with\u000A## the dollar operator (``$``):\u000A##\u000A## ============  =======================\u000A##   Operator     Output\u000A## ============  =======================\u000A## $date         Current date\u000A## $time         Current time\u000A## $app          ``os.getAppFilename()``\u000A## ============  =======================\u000A## \u000A##\u000A## The following example demonstrates logging to three different handlers\u000A## simultaneously:\u000A##\u000A## .. code-block:: nim\u000A##     \u000A##    var L = newConsoleLogger()\u000A##    var fL = newFileLogger(\"test.log\", fmtStr = verboseFmtStr)\u000A##    var rL = newRollingFileLogger(\"rolling.log\", fmtStr = verboseFmtStr)\u000A##    handlers.add(L)\u000A##    handlers.add(fL)\u000A##    handlers.add(rL)\u000A##    info(\"920410:52 accepted\")\u000A##    warn(\"4 8 15 16 23 4-- Error\")\u000A##    error(\"922044:16 SYSTEM FAILURE\")\u000A##    fatal(\"SYSTEM FAILURE SYSTEM FAILURE\")"
  }, 
  {
    "module": "macros", 
    "description": "This module contains the interface to the compiler's abstract syntax\u000A## tree (`AST`:idx:). Macros operate on this tree."
  }, 
  {
    "module": "marshal", 
    "description": "This module contains procs for `serialization`:idx: and `deseralization`:idx:\u000A## of arbitrary Nim data structures. The serialization format uses `JSON`:idx:.\u000A##\u000A## **Restriction**: For objects their type is **not** serialized. This means\u000A## essentially that it does not work if the object has some other runtime\u000A## type than its compiletime type:\u000A##\u000A## .. code-block:: nim\u000A## \u000A##   type \u000A##     TA = object\u000A##     TB = object of TA\u000A##       f: int\u000A##\u000A##   var\u000A##     a: ref TA\u000A##     b: ref TB\u000A##\u000A##   new(b)\u000A##   a = b\u000A##   echo($$a[]) # produces \"{}\", not \"{f: 0}\""
  }, 
  {
    "module": "matchers", 
    "description": "This module contains various string matchers for email addresses, etc."
  }, 
  {
    "module": "math", 
    "description": "Constructive mathematics is naturally typed. -- Simon Thompson\u000A## \u000A## Basic math routines for Nim.\u000A## This module is available for the `JavaScript target\u000A## <backends.html#the-javascript-target>`_."
  }, 
  {
    "module": "md5", 
    "description": "Module for computing MD5 checksums."
  }, 
  {
    "module": "memfiles", 
    "description": ":Authors: Zahary Karadjov, Andreas Rumpf\u000A##\u000A## This module provides support for `memory mapped files`:idx:\u000A## (Posix's `mmap`:idx:) on the different operating systems."
  }, 
  {
    "module": "mersenne"
  }, 
  {
    "module": "mimetypes", 
    "description": "This module implements a mimetypes database"
  }, 
  {
    "module": "mmsystem"
  }, 
  {
    "module": "mysql"
  }, 
  {
    "module": "nb30"
  }, 
  {
    "module": "net", 
    "description": "This module implements a high-level cross-platform sockets interface."
  }, 
  {
    "module": "nimprof", 
    "description": "Profiling support for Nim. This is an embedded profiler that requires\u000A## ``--profiler:on``. You only need to import this module to get a profiling\u000A## report at program exit."
  }, 
  {
    "module": "nimrtl", 
    "description": "Main file to generate a DLL from the standard library. \u000A## The default Nimrtl does not only contain the ``system`` module, but these \u000A## too:\u000A##\u000A## * parseutils\u000A## * strutils\u000A## * parseopt\u000A## * parsecfg\u000A## * strtabs\u000A## * times\u000A## * os\u000A## * osproc\u000A## * unicode\u000A## * pegs\u000A## * ropes\u000A##"
  }, 
  {
    "module": "numeric"
  }, 
  {
    "module": "odbcsql"
  }, 
  {
    "module": "oids", 
    "description": "Nim OID support. An OID is a global ID that consists of a timestamp,\u000A## a unique counter and a random value. This combination should suffice to \u000A## produce a globally distributed unique ID. This implementation was extracted\u000A## from the Mongodb interface and it thus binary compatible with a Mongo OID.\u000A##\u000A## This implementation calls ``math.randomize()`` for the first call of\u000A## ``genOid``."
  }, 
  {
    "module": "openssl", 
    "description": "OpenSSL support"
  }, 
  {
    "module": "os", 
    "description": "This module contains basic operating system facilities like\u000A## retrieving environment variables, reading command line arguments,\u000A## working with directories, running shell commands, etc."
  }, 
  {
    "module": "osinfo_posix"
  }, 
  {
    "module": "osinfo_win"
  }, 
  {
    "module": "osproc", 
    "description": "This module implements an advanced facility for executing OS processes\u000A## and process communication."
  }, 
  {
    "module": "parsecfg", 
    "description": "The ``parsecfg`` module implements a high performance configuration file \u000A## parser. The configuration file's syntax is similar to the Windows ``.ini`` \u000A## format, but much more powerful, as it is not a line based parser. String \u000A## literals, raw string literals and triple quoted string literals are supported \u000A## as in the Nim programming language."
  }, 
  {
    "module": "parsecsv", 
    "description": "This module implements a simple high performance `CSV`:idx:\u000A## (`comma separated value`:idx:) parser. \u000A##\u000A## Example: How to use the parser\u000A## ==============================\u000A##\u000A## .. code-block:: nim\u000A##   import os, parsecsv, streams\u000A##   var s = newFileStream(paramStr(1), fmRead)\u000A##   if s == nil: quit(\"cannot open the file\" & paramStr(1))\u000A##   var x: CsvParser\u000A##   open(x, s, paramStr(1))\u000A##   while readRow(x):\u000A##     echo \"new row: \"\u000A##     for val in items(x.row):\u000A##       echo \"##\", val, \"##\"\u000A##   close(x)\u000A##"
  }, 
  {
    "module": "parseopt", 
    "description": "This module provides the standard Nim command line parser.\u000A## It supports one convenience iterator over all command line options and some\u000A## lower-level features.\u000A##\u000A## **Deprecated since version 0.9.3:** Use the `parseopt2 <parseopt2.html>`_\u000A## module instead as this version has issues with spaces in arguments."
  }, 
  {
    "module": "parseopt2", 
    "description": "This module provides the standard Nim command line parser.\u000A## It supports one convenience iterator over all command line options and some\u000A## lower-level features.\u000A##\u000A## Supported syntax:\u000A##\u000A## 1. short options - ``-abcd``, where a, b, c, d are names\u000A## 2. long option - ``--foo:bar``, ``--foo=bar`` or ``--foo``\u000A## 3. argument - everything else"
  }, 
  {
    "module": "parsesql", 
    "description": "The ``parsesql`` module implements a high performance SQL file \u000A## parser. It parses PostgreSQL syntax and the SQL ANSI standard."
  }, 
  {
    "module": "parseurl", 
    "description": "Parses & constructs URLs.\u000A##\u000A## **Note**: This module will be deprecated in the future and merged into a\u000A## new ``url`` module."
  }, 
  {
    "module": "parseutils", 
    "description": "This module contains helpers for parsing tokens, numbers, identifiers, etc."
  }, 
  {
    "module": "parsexml", 
    "description": "This module implements a simple high performance `XML`:idx: / `HTML`:idx:\u000A## parser. \u000A## The only encoding that is supported is UTF-8. The parser has been designed\u000A## to be somewhat error correcting, so that even most \"wild HTML\" found on the \u000A## web can be parsed with it. **Note:** This parser does not check that each\u000A## ``<tag>`` has a corresponding ``</tag>``! These checks have do be \u000A## implemented by the client code for various reasons: \u000A##\u000A## * Old HTML contains tags that have no end tag: ``<br>`` for example.\u000A## * HTML tags are case insensitive, XML tags are case sensitive. Since this\u000A##   library can parse both, only the client knows which comparison is to be\u000A##   used.\u000A## * Thus the checks would have been very difficult to implement properly with\u000A##   little benefit, especially since they are simple to implement in the \u000A##   client. The client should use the `errorMsgExpected` proc to generate\u000A##   a nice error message that fits the other error messages this library\u000A##   creates.\u000A##\u000A##\u000A## Example 1: Retrieve HTML title\u000A## ==============================\u000A##\u000A## The file ``examples/htmltitle.nim`` demonstrates how to use the \u000A## XML parser to accomplish a simple task: To determine the title of an HTML\u000A## document.\u000A##\u000A## .. code-block:: nim\u000A##     :file: examples/htmltitle.nim\u000A##\u000A##\u000A## Example 2: Retrieve all HTML links\u000A## ==================================\u000A##\u000A## The file ``examples/htmlrefs.nim`` demonstrates how to use the \u000A## XML parser to accomplish another simple task: To determine all the links \u000A## an HTML document contains.\u000A##\u000A## .. code-block:: nim\u000A##     :file: examples/htmlrefs.nim\u000A##"
  }, 
  {
    "module": "pcre"
  }, 
  {
    "module": "pdcurses"
  }, 
  {
    "module": "pegs", 
    "description": "Simple PEG (Parsing expression grammar) matching. Uses no memorization, but\u000A## uses superoperators and symbol inlining to improve performance. Note:\u000A## Matching performance is hopefully competitive with optimized regular\u000A## expression engines.\u000A##\u000A## .. include:: ../doc/pegdocs.txt\u000A##"
  }, 
  {
    "module": "poly"
  }, 
  {
    "module": "posix", 
    "description": "This is a raw POSIX interface module. It does not not provide any\u000A## convenience: cstrings are used instead of proper Nim strings and\u000A## return codes indicate errors. If you want exceptions\u000A## and a proper Nim-like interface, use the OS module or write a wrapper."
  }, 
  {
    "module": "postgres"
  }, 
  {
    "module": "prelude", 
    "description": "This is an include file that simply imports common modules for your\u000A## convenience:\u000A##\u000A## .. code-block:: nim\u000A##   include prelude\u000A##\u000A## Same as:\u000A##\u000A## .. code-block:: nim\u000A##   import os, strutils, times, parseutils, parseopt, hashes, tables, sets"
  }, 
  {
    "module": "psapi"
  }, 
  {
    "module": "queues", 
    "description": "Implementation of a queue. The underlying implementation uses a ``seq``.\u000A## Note: For inter thread communication use\u000A## a `TChannel <channels.html>`_ instead."
  }, 
  {
    "module": "rawsockets", 
    "description": "This module implements a low-level cross-platform sockets interface. Look\u000A## at the ``net`` module for the higher-level version."
  }, 
  {
    "module": "rdstdin", 
    "description": "This module contains code for reading from `stdin`:idx:. On UNIX the GNU\u000A## readline library is wrapped and set up to provide default key bindings \u000A## (e.g. you can navigate with the arrow keys). On Windows ``system.readLine``\u000A## is used. This suffices because Windows' console already provides the \u000A## wanted functionality."
  }, 
  {
    "module": "re", 
    "description": "Regular expression support for Nim. Consider using the pegs module\u000A## instead.\u000A## This module is implemented by providing a wrapper around the\u000A## `PRCE (Perl-Compatible Regular Expressions) <http://www.pcre.org>`_\u000A## C library. This means that your application will depend on the PRCE\u000A## library's licence when using this module, which should not be a problem\u000A## though.\u000A## PRCE's licence follows:\u000A##\u000A## .. include:: ../doc/regexprs.txt\u000A##"
  }, 
  {
    "module": "readline"
  }, 
  {
    "module": "redis", 
    "description": "This module implements a redis client. It allows you to connect to a\u000A## redis-server instance, send commands and receive replies.\u000A##\u000A## **Beware**: Most (if not all) functions that return a ``TRedisString`` may\u000A## return ``redisNil``, and functions which return a ``TRedisList`` \u000A## may return ``nil``."
  }, 
  {
    "module": "rltypedefs"
  }, 
  {
    "module": "romans", 
    "description": "Module for converting an integer to a Roman numeral.\u000A## See http://en.wikipedia.org/wiki/Roman_numerals for reference."
  }, 
  {
    "module": "ropes", 
    "description": "This module contains support for a `rope`:idx: data type.\u000A## Ropes can represent very long strings efficiently; especially concatenation\u000A## is done in O(1) instead of O(n). They are essentially concatenation\u000A## trees that are only flattened when converting to a native Nim\u000A## string. The empty string is represented by ``nil``. Ropes are immutable and\u000A## subtrees can be shared without copying.\u000A## Leaves can be cached for better memory efficiency at the cost of\u000A## runtime efficiency."
  }, 
  {
    "module": "rtarrays", 
    "description": "Module that implements a fixed length array whose size\u000A## is determined at runtime. Note: This is not ready for other people to use!"
  }, 
  {
    "module": "scgi", 
    "description": "This module implements helper procs for SCGI applications. Example:\u000A## \u000A## .. code-block:: Nim\u000A##\u000A##    import strtabs, sockets, scgi\u000A##\u000A##    var counter = 0\u000A##    proc handleRequest(client: Socket, input: string, \u000A##                       headers: StringTableRef): bool {.procvar.} =\u000A##      inc(counter)\u000A##      client.writeStatusOkTextContent()\u000A##      client.send(\"Hello for the $#th time.\" % $counter & \"\\c\\L\")\u000A##      return false # do not stop processing\u000A##\u000A##    run(handleRequest)\u000A##\u000A## **Warning:** The API of this module is unstable, and therefore is subject\u000A## to change."
  }, 
  {
    "module": "sdl"
  }, 
  {
    "module": "sdl_gfx"
  }, 
  {
    "module": "sdl_image"
  }, 
  {
    "module": "sdl_mixer"
  }, 
  {
    "module": "sdl_mixer_nosmpeg"
  }, 
  {
    "module": "sdl_net"
  }, 
  {
    "module": "sdl_ttf"
  }, 
  {
    "module": "selectors"
  }, 
  {
    "module": "sequtils", 
    "description": ":Author: Alex Mitchell\u000A##\u000A## This module implements operations for the built-in `seq`:idx: type which\u000A## were inspired by functional programming languages. If you are looking for\u000A## the typical `map` function which applies a function to every element in a\u000A## sequence, it already exists in the `system <system.html>`_ module in both\u000A## mutable and immutable styles.\u000A##\u000A## Also, for functional style programming you may want to pass `anonymous procs\u000A## <manual.html#anonymous-procs>`_ to procs like ``filter`` to reduce typing.\u000A## Anonymous procs can use `the special do notation <manual.html#do-notation>`_\u000A## which is more convenient in certain situations.\u000A##\u000A## **Note**: This interface will change as soon as the compiler supports\u000A## closures and proper coroutines."
  }, 
  {
    "module": "sets", 
    "description": "The ``sets`` module implements an efficient hash set and ordered hash set.\u000A##\u000A## Hash sets are different from the `built in set type\u000A## <manual.html#set-type>`_. Sets allow you to store any value that can be\u000A## `hashed <hashes.html>`_ and they don't contain duplicate entries.\u000A##\u000A## **Note**: The data types declared here have *value semantics*: This means\u000A## that ``=`` performs a copy of the set."
  }, 
  {
    "module": "shellapi"
  }, 
  {
    "module": "shfolder"
  }, 
  {
    "module": "smpeg"
  }, 
  {
    "module": "smtp", 
    "description": "This module implements the SMTP client protocol as specified by RFC 5321, \u000A## this can be used to send mail to any SMTP Server.\u000A## \u000A## This module also implements the protocol used to format messages, \u000A## as specified by RFC 2822.\u000A## \u000A## Example gmail use:\u000A## \u000A## \u000A## .. code-block:: Nim\u000A##   var msg = createMessage(\"Hello from Nim's SMTP\", \u000A##                           \"Hello!.\\n Is this awesome or what?\", \u000A##                           @[\"foo@gmail.com\"])\u000A##   var smtp = connect(\"smtp.gmail.com\", 465, true, true)\u000A##   smtp.auth(\"username\", \"password\")\u000A##   smtp.sendmail(\"username@gmail.com\", @[\"foo@gmail.com\"], $msg)\u000A##   \u000A## \u000A## For SSL support this module relies on OpenSSL. If you want to \u000A## enable SSL, compile with ``-d:ssl``."
  }, 
  {
    "module": "sockets", 
    "description": "This module implements portable sockets, it supports a mix of different types\u000A## of sockets. Sockets are buffered by default meaning that data will be\u000A## received in ``BufferSize`` (4000) sized chunks, buffering\u000A## behaviour can be disabled by setting the ``buffered`` parameter when calling\u000A## the ``socket`` function to `false`. Be aware that some functions may not yet\u000A## support buffered sockets (mainly the recvFrom function).\u000A##\u000A## Most procedures raise OSError on error, but some may return ``-1`` or a\u000A## boolean ``false``.\u000A##\u000A## SSL is supported through the OpenSSL library. This support can be activated\u000A## by compiling with the ``-d:ssl`` switch. When an SSL socket is used it will\u000A## raise ESSL exceptions when SSL errors occur.\u000A##\u000A## Asynchronous sockets are supported, however a better alternative is to use\u000A## the `asyncio <asyncio.html>`_ module.\u000A##\u000A## Since version 0.10.2 this module is deprecated. Use the `net <net.html>`_\u000A## or the `rawsockets <rawsockets.html>`_ module instead."
  }, 
  {
    "module": "sphinx", 
    "description": "Nim wrapper for ``sphinx``."
  }, 
  {
    "module": "sqlite3"
  }, 
  {
    "module": "ssl", 
    "description": "This module provides an easy to use sockets-style \u000A## nim interface to the OpenSSL library."
  }, 
  {
    "module": "streams", 
    "description": "This module provides a stream interface and two implementations thereof:\u000A## the `FileStream` and the `StringStream` which implement the stream\u000A## interface for Nim file objects (`File`) and strings. Other modules\u000A## may provide other implementations for this standard stream interface."
  }, 
  {
    "module": "strtabs", 
    "description": "The ``strtabs`` module implements an efficient hash table that is a mapping\u000A## from strings to strings. Supports a case-sensitive, case-insensitive and\u000A## style-insensitive mode. An efficient string substitution operator  ``%``\u000A## for the string table is also provided."
  }, 
  {
    "module": "strutils", 
    "description": "This module contains various string utility routines.\u000A## See the module `re <re.html>`_ for regular expression support.\u000A## See the module `pegs <pegs.html>`_ for PEG support.\u000A## This module is available for the `JavaScript target\u000A## <backends.html#the-javascript-target>`_."
  }, 
  {
    "module": "subexes", 
    "description": "Nim support for `substitution expressions`:idx: (`subex`:idx:).\u000A##\u000A## .. include:: ../doc/subexes.txt\u000A##"
  }, 
  {
    "module": "system", 
    "description": "The compiler depends on the System module to work properly and the System\u000A## module depends on the compiler. Most of the routines listed here use\u000A## special compiler magic.\u000A## Each module implicitly imports the System module; it must not be listed\u000A## explicitly. Because of this there cannot be a user-defined module named\u000A## ``system``.\u000A##\u000A## Exception hierarchy\u000A## ===================\u000A##\u000A## For visual convenience here is the exception inheritance hierarchy\u000A## represented as a tree:\u000A##\u000A## .. include:: ../doc/exception_hierarchy_fragment.txt\u000A##\u000A## Module system\u000A## =============\u000A##"
  }, 
  {
    "module": "tables", 
    "description": "The ``tables`` module implements variants of an efficient hash table that is\u000A## a mapping from keys to values. ``Table`` is the usual hash table,\u000A## ``OrderedTable`` is like ``Table`` but remembers insertion order\u000A## and ``CountTable`` is a mapping from a key to its number of occurances.\u000A## For consistency with every other data type in Nim these have **value**\u000A## semantics, this means that ``=`` performs a copy of the hash table.\u000A## For **reference** semantics use the ``Ref`` variant: ``TableRef``,\u000A## ``OrderedTableRef``, ``CountTableRef``.\u000A##\u000A## If you are using simple standard types like ``int`` or ``string`` for the\u000A## keys of the table you won't have any problems, but as soon as you try to use\u000A## a more complex object as a key you will be greeted by a strange compiler\u000A## error::\u000A##\u000A##   Error: type mismatch: got (Person)\u000A##   but expected one of:\u000A##   hashes.hash(x: openarray[A]): THash\u000A##   hashes.hash(x: int): THash\u000A##   hashes.hash(x: float): THash\u000A##   \u2026\u000A##\u000A## What is happening here is that the types used for table keys require to have\u000A## a ``hash()`` proc which will convert them to a `THash <hashes.html#THash>`_\u000A## value, and the compiler is listing all the hash functions it knows.\u000A## Additionally there has to be a ``==`` operator that provides the same\u000A## semantics as its corresponding ``hash`` proc.\u000A##\u000A## After you add ``hash`` and ``==`` for your custom type everything will work.\u000A## Currently however ``hash`` for objects is not defined, whereas\u000A## ``system.==`` for objects does exist and performs a \"deep\" comparison (every\u000A## field is compared) which is usually what you want. So in the following\u000A## example implementing only ``hash`` suffices:\u000A##\u000A## .. code-block::\u000A##   type\u000A##     Person = object\u000A##       firstName, lastName: string\u000A##\u000A##   proc hash(x: Person): THash =\u000A##     ## Piggyback on the already available string hash proc.\u000A##     ##\u000A##     ## Without this proc nothing works!\u000A##     result = x.firstName.hash !& x.lastName.hash\u000A##     result = !$result\u000A##\u000A##   var\u000A##     salaries = initTable[Person, int]()\u000A##     p1, p2: Person\u000A##\u000A##   p1.firstName = \"Jon\"\u000A##   p1.lastName = \"Ross\"\u000A##   salaries[p1] = 30_000\u000A##\u000A##   p2.firstName = \"\uC18C\uC9C4\"\u000A##   p2.lastName = \"\uBC15\"\u000A##   salaries[p2] = 45_000"
  }, 
  {
    "module": "terminal", 
    "description": "This module contains a few procedures to control the *terminal*\u000A## (also called *console*). On UNIX, the implementation simply uses ANSI escape\u000A## sequences and does not depend on any other module, on Windows it uses the\u000A## Windows API.\u000A## Changing the style is permanent even after program termination! Use the\u000A## code ``system.addQuitProc(resetAttributes)`` to restore the defaults."
  }, 
  {
    "module": "threadpool", 
    "description": "Implements Nim's 'spawn'."
  }, 
  {
    "module": "times", 
    "description": "This module contains routines and types for dealing with time.\u000A## This module is available for the `JavaScript target\u000A## <backends.html#the-javascript-target>`_."
  }, 
  {
    "module": "tinyc"
  }, 
  {
    "module": "tre"
  }, 
  {
    "module": "typeinfo", 
    "description": "This module implements an interface to Nim's `runtime type information`:idx:\u000A## (`RTTI`:idx:).\u000A## Note that even though ``TAny`` and its operations hide the nasty low level\u000A## details from its clients, it remains inherently unsafe!\u000A##\u000A## See the `marshal <marshal.html>`_ module for what this module allows you\u000A## to do."
  }, 
  {
    "module": "typetraits", 
    "description": "This module defines compile-time reflection procs for\u000A## working with types"
  }, 
  {
    "module": "unicode", 
    "description": "This module provides support to handle the Unicode UTF-8 encoding."
  }, 
  {
    "module": "unidecode", 
    "description": "This module is based on Python's Unidecode module by Tomaz Solc, \u000A## which in turn is based on the ``Text::Unidecode`` Perl module by \u000A## Sean M. Burke \u000A## (http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm ).\u000A##\u000A## It provides a single proc that does Unicode to ASCII transliterations:\u000A## It finds the sequence of ASCII characters that is the closest approximation\u000A## to the Unicode string.\u000A##\u000A## For example, the closest to string \"\u00C4u\u00DFerst\" in ASCII is \"Ausserst\". Some \u000A## information is lost in this transformation, of course, since several Unicode \u000A## strings can be transformed in the same ASCII representation. So this is a\u000A## strictly one-way transformation. However a human reader will probably \u000A## still be able to guess what original string was meant from the context.\u000A##\u000A## This module needs the data file \"unidecode.dat\" to work: You can either\u000A## ship this file with your application and initialize this module with the\u000A## `loadUnidecodeTable` proc or you can define the ``embedUnidecodeTable``\u000A## symbol to embed the file as a resource into your application."
  }, 
  {
    "module": "unittest", 
    "description": ":Author: Zahary Karadjov\u000A##\u000A## This module implements the standard unit testing facilities such as\u000A## suites, fixtures and test cases as well as facilities for combinatorial \u000A## and randomzied test case generation (not yet available) \u000A## and object mocking (not yet available)\u000A##\u000A## It is loosely based on C++'s boost.test and Haskell's QuickTest"
  }, 
  {
    "module": "unsigned", 
    "description": "This module implements basic arithmetic operators for unsigned integers.\u000A## To discourage users from using ``unsigned``, it's not part of ``system``,\u000A## but an extra import."
  }, 
  {
    "module": "uri", 
    "description": "This module implements URI parsing as specified by RFC 3986."
  }, 
  {
    "module": "windows", 
    "description": "Define ``winUnicode`` before importing this module for the\u000A## Unicode version."
  }, 
  {
    "module": "winlean", 
    "description": "This module implements a small wrapper for some needed Win API procedures,\u000A## so that the Nim compiler does not depend on the huge Windows module."
  }, 
  {
    "module": "xmldom", 
    "description": "This module implements XML DOM Level 2 Core\u000A## specification (http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html)"
  }, 
  {
    "module": "xmldomparser", 
    "description": "This module parses a XML Document into a XML DOM Document representation."
  }, 
  {
    "module": "xmlparser", 
    "description": "This module parses an XML document and creates its XML tree representation."
  }, 
  {
    "module": "xmltree", 
    "description": "A simple XML tree. More efficient and simpler than the DOM."
  }, 
  {
    "module": "zipfiles", 
    "description": "This module implements a zip archive creator/reader/modifier."
  }, 
  {
    "module": "zlib", 
    "description": "Interface to the zlib http://www.zlib.net/ compression library."
  }, 
  {
    "module": "zzip", 
    "description": "This module is an interface to the zzip library."
  }
]