[
  {
    "comment": "This module contains basic operating system facilities like\u000A## retrieving environment variables, reading command line arguments,\u000A## working with directories, running shell commands, etc."
  }, 
  {
    "name": "OSErrorCode", 
    "type": "skType", 
    "description": "Specifies an OS Error Code.", 
    "code": "OSErrorCode* = distinct int32"
  }, 
  {
    "name": "DynlibFormat", 
    "type": "skConst", 
    "description": "The format string to turn a filename into a <span id=\"dll_1\">DLL</span> file (also called <span id=\"shared-object_1\">shared object</span> on some operating systems).", 
    "code": "DynlibFormat* = \"lib$1.so\""
  }, 
  {
    "name": "ExtSep", 
    "type": "skConst", 
    "description": "The character which separates the base filename from the extension; for example, the '.' in <tt class=\"docutils literal\"><span class=\"pre\">os.nim</span></tt>.", 
    "code": "ExtSep* = '.'"
  }, 
  {
    "name": "osErrorMsg", 
    "type": "skProc", 
    "description": "<p>Retrieves the operating system's error flag, <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. On Windows <tt class=\"docutils literal\"><span class=\"pre\">GetLastError</span></tt> is checked before <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. Returns &quot;&quot; if no error occured.</p>\u000A<p><strong>Deprecated since version 0.9.4</strong>: use the other <tt class=\"docutils literal\"><span class=\"pre\">osErrorMsg</span></tt> proc.</p>\u000A", 
    "code": "proc osErrorMsg*(): string {.rtl, extern: \"nos$1\", deprecated.}"
  }, 
  {
    "name": "raiseOSError", 
    "type": "skProc", 
    "description": "<p>raises an OSError exception with the given message <tt class=\"docutils literal\"><span class=\"pre\">msg</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">msg == &quot;&quot;</span></tt>, the operating system's error flag (<tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>) is converted to a readable error message. On Windows <tt class=\"docutils literal\"><span class=\"pre\">GetLastError</span></tt> is checked before <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. If no error flag is set, the message <tt class=\"docutils literal\"><span class=\"pre\">unknown OS error</span></tt> is used.</p>\u000A<p><strong>Deprecated since version 0.9.4</strong>: use the other <tt class=\"docutils literal\"><span class=\"pre\">raiseOSError</span></tt> proc.</p>\u000A", 
    "code": "proc raiseOSError*(msg: string = \"\") {.noinline, rtl, extern: \"nos$1\", \u000A                                       deprecated.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(err1, err2: OSErrorCode): bool {.borrow.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "code": "proc `$`*(err: OSErrorCode): string {.borrow.}"
  }, 
  {
    "name": "osErrorMsg", 
    "type": "skProc", 
    "description": "<p>Converts an OS error code into a human readable string.</p>\u000A<p>The error code can be retrieved using the <tt class=\"docutils literal\"><span class=\"pre\">osLastError</span></tt> proc.</p>\u000A<p>If conversion fails, or <tt class=\"docutils literal\"><span class=\"pre\">errorCode</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> then <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt> will be returned.</p>\u000A<p>On Windows, the <tt class=\"docutils literal\"><span class=\"pre\">-d:useWinAnsi</span></tt> compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</p>\u000A", 
    "code": "proc osErrorMsg*(errorCode: OSErrorCode): string"
  }, 
  {
    "name": "raiseOSError", 
    "type": "skProc", 
    "description": "<p>Raises an <tt class=\"docutils literal\"><span class=\"pre\">OSError</span></tt> exception. The <tt class=\"docutils literal\"><span class=\"pre\">errorCode</span></tt> will determine the message, <tt class=\"docutils literal\"><span class=\"pre\">osErrorMsg</span></tt> will be used to get this message.</p>\u000A<p>The error code can be retrieved using the <tt class=\"docutils literal\"><span class=\"pre\">osLastError</span></tt> proc.</p>\u000A<p>If the error code is <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> or an error message could not be retrieved, the message <tt class=\"docutils literal\"><span class=\"pre\">unknown OS error</span></tt> will be used.</p>\u000A", 
    "code": "proc raiseOSError*(errorCode: OSErrorCode)"
  }, 
  {
    "name": "osLastError", 
    "type": "skProc", 
    "description": "<p>Retrieves the last operating system error code.</p>\u000A<p>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The <tt class=\"docutils literal\"><span class=\"pre\">OSErrorMsg</span></tt> procedure can then be used to convert this code into a string.</p>\u000A<p><strong>Warning</strong>: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> causing this procedure to return <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt>. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.</p>\u000A", 
    "code": "proc osLastError*(): OSErrorCode"
  }, 
  {
    "name": "unixToNativePath", 
    "type": "skProc", 
    "description": "<p>Converts an UNIX-like path to a native one.</p>\u000A<p>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</p>\u000A<p>On systems with a concept of &quot;drives&quot;, <cite>drive</cite> is used to determine which drive label to use during absolute path conversion. <cite>drive</cite> defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</p>\u000A", 
    "code": "proc unixToNativePath*(path: string; drive = \"\"): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}"
  }, 
  {
    "name": "existsFile", 
    "type": "skProc", 
    "description": "Returns true if the file exists, false otherwise.", 
    "code": "proc existsFile*(filename: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "existsDir", 
    "type": "skProc", 
    "description": "Returns true iff the directory <cite>dir</cite> exists. If <cite>dir</cite> is a file, false is returned.", 
    "code": "proc existsDir*(dir: string): bool {.rtl, extern: \"nos$1\", tags: [ReadDirEffect].}"
  }, 
  {
    "name": "symlinkExists", 
    "type": "skProc", 
    "description": "Returns true iff the symlink <cite>link</cite> exists. Will return true regardless of whether the link points to a directory or file.", 
    "code": "proc symlinkExists*(link: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "fileExists", 
    "type": "skProc", 
    "description": "Synonym for existsFile", 
    "code": "proc fileExists*(filename: string): bool {.inline.}"
  }, 
  {
    "name": "dirExists", 
    "type": "skProc", 
    "description": "Synonym for existsDir", 
    "code": "proc dirExists*(dir: string): bool {.inline.}"
  }, 
  {
    "name": "getLastModificationTime", 
    "type": "skProc", 
    "description": "Returns the <cite>file</cite>'s last modification time.", 
    "code": "proc getLastModificationTime*(file: string): Time {.rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "getLastAccessTime", 
    "type": "skProc", 
    "description": "Returns the <cite>file</cite>'s last read or write access time.", 
    "code": "proc getLastAccessTime*(file: string): Time {.rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "getCreationTime", 
    "type": "skProc", 
    "description": "Returns the <cite>file</cite>'s creation time. Note that under posix OS's, the returned time may actually be the time at which the file's attribute's were last modified.", 
    "code": "proc getCreationTime*(file: string): Time {.rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "fileNewer", 
    "type": "skProc", 
    "description": "Returns true if the file <cite>a</cite> is newer than file <cite>b</cite>, i.e. if <cite>a</cite>'s modification time is later than <cite>b</cite>'s.", 
    "code": "proc fileNewer*(a, b: string): bool {.rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "getCurrentDir", 
    "type": "skProc", 
    "description": "Returns the <span id=\"current-working-directory_1\">current working directory</span>.", 
    "code": "proc getCurrentDir*(): string {.rtl, extern: \"nos$1\", tags: [].}"
  }, 
  {
    "name": "setCurrentDir", 
    "type": "skProc", 
    "description": "Sets the <span id=\"current-working-directory_2\">current working directory</span>; <cite>OSError</cite> is raised if <cite>newDir</cite> cannot been set.", 
    "code": "proc setCurrentDir*(newDir: string) {.inline, tags: [].}"
  }, 
  {
    "name": "joinPath", 
    "type": "skProc", 
    "description": "<p>Joins two directory names to one.</p>\u000A<p>For example on Unix:</p>\u000A<pre><span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;lib&quot;</span><span class=\"Punctuation\">)</span></pre><p>results in:</p>\u000A<pre><span class=\"StringLit\">&quot;usr/lib&quot;</span></pre><p>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</p>\u000A<pre><span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;/lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;/lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/lib&quot;</span></pre>", 
    "code": "proc joinPath*(head, tail: string): string {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "joinPath", 
    "type": "skProc", 
    "description": "The same as <cite>joinPath(head, tail)</cite>, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.", 
    "code": "proc joinPath*(parts: varargs[string]): string {.noSideEffect, rtl, \u000A    extern: \"nos$1OpenArray\".}"
  }, 
  {
    "name": "`/`", 
    "type": "skProc", 
    "description": "<p>The same as <tt class=\"docutils literal\"><span class=\"pre\">joinPath(head, tail)</span></tt></p>\u000A<p>Here are some examples for Unix:</p>\u000A<pre><span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;usr&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;/lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;usr/&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;/lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/lib&quot;</span></pre>", 
    "code": "proc `/`*(head, tail: string): string {.noSideEffect.}"
  }, 
  {
    "name": "splitPath", 
    "type": "skProc", 
    "description": "<p>Splits a directory into (head, tail), so that <tt class=\"docutils literal\"><span class=\"pre\">joinPath(head, tail) == path</span></tt>.</p>\u000A<p>Examples:</p>\u000A<pre><span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin/&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc splitPath*(path: string): tuple[head, tail: string] {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}"
  }, 
  {
    "name": "parentDir", 
    "type": "skProc", 
    "description": "<p>Returns the parent directory of <cite>path</cite>.</p>\u000A<p>This is often the same as the <tt class=\"docutils literal\"><span class=\"pre\">head</span></tt> result of <tt class=\"docutils literal\"><span class=\"pre\">splitPath</span></tt>. If there is no parent, &quot;&quot; is returned.<p>Example: <tt class=\"docutils literal\"><span class=\"pre\">parentDir(&quot;/usr/local/bin&quot;) == &quot;/usr/local&quot;</span></tt>.<br />Example: <tt class=\"docutils literal\"><span class=\"pre\">parentDir(&quot;/usr/local/bin/&quot;) == &quot;/usr/local&quot;</span></tt>.<br /></p></p>\u000A", 
    "code": "proc parentDir*(path: string): string {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "isRootDir", 
    "type": "skProc", 
    "description": "Checks whether a given <cite>path</cite> is a root directory", 
    "code": "proc isRootDir*(path: string): bool {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "parentDirs", 
    "type": "skIterator", 
    "description": "<p>Walks over all parent directories of a given <cite>path</cite></p>\u000A<p>If <cite>fromRoot</cite> is set, the traversal will start from the file system root diretory. If <cite>inclusive</cite> is set, the original argument will be included in the traversal.</p>\u000A<p>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</p>\u000A", 
    "code": "iterator parentDirs*(path: string; fromRoot = false; inclusive = true): string"
  }, 
  {
    "name": "`/../`", 
    "type": "skProc", 
    "description": "The same as <tt class=\"docutils literal\"><span class=\"pre\">parentDir(head) / tail</span></tt> unless there is no parent directory. Then <tt class=\"docutils literal\"><span class=\"pre\">head / tail</span></tt> is performed instead.", 
    "code": "proc `/../`*(head, tail: string): string {.noSideEffect.}"
  }, 
  {
    "name": "splitFile", 
    "type": "skProc", 
    "description": "<p>Splits a filename into (dir, filename, extension). <cite>dir</cite> does not end in <cite>DirSep</cite>. <cite>extension</cite> includes the leading dot.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">dir</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ext</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">splitFile</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/nimc.html&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">dir</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/local&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">name</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;nimc&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">ext</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;.html&quot;</span></pre><p>If <cite>path</cite> has no extension, <cite>ext</cite> is the empty string. If <cite>path</cite> has no directory component, <cite>dir</cite> is the empty string. If <cite>path</cite> has no filename component, <cite>name</cite> and <cite>ext</cite> are empty strings.</p>\u000A", 
    "code": "proc splitFile*(path: string): tuple[dir, name, ext: string] {.noSideEffect, \u000A    rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "extractFilename", 
    "type": "skProc", 
    "description": "Extracts the filename of a given <cite>path</cite>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">name &amp; ext</span></tt> from <tt class=\"docutils literal\"><span class=\"pre\">splitFile(path)</span></tt>.", 
    "code": "proc extractFilename*(path: string): string {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "expandFilename", 
    "type": "skProc", 
    "description": "Returns the full path of <cite>filename</cite>, raises OSError in case of an error.", 
    "code": "proc expandFilename*(filename: string): string {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "changeFileExt", 
    "type": "skProc", 
    "description": "<p>Changes the file extension to <cite>ext</cite>.</p>\u000A<p>If the <cite>filename</cite> has no extension, <cite>ext</cite> will be added. If <cite>ext</cite> == &quot;&quot; then any extension is removed. <cite>Ext</cite> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>\u000A", 
    "code": "proc changeFileExt*(filename, ext: string): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}"
  }, 
  {
    "name": "addFileExt", 
    "type": "skProc", 
    "description": "<p>Adds the file extension <cite>ext</cite> to <cite>filename</cite>, unless <cite>filename</cite> already has an extension.</p>\u000A<p><cite>Ext</cite> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>\u000A", 
    "code": "proc addFileExt*(filename, ext: string): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}"
  }, 
  {
    "name": "cmpPaths", 
    "type": "skProc", 
    "description": "<p>Compares two paths.</p>\u000A<p>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</p>\u000A<p>0 iff pathA == pathB<br />&lt; 0 iff pathA &lt; pathB<br />&gt; 0 iff pathA &gt; pathB<br /></p>", 
    "code": "proc cmpPaths*(pathA, pathB: string): int {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "isAbsolute", 
    "type": "skProc", 
    "description": "<p>Checks whether a given <cite>path</cite> is absolute.</p>\u000A<p>On Windows, network paths are considered absolute too.</p>\u000A", 
    "code": "proc isAbsolute*(path: string): bool {.rtl, noSideEffect, extern: \"nos$1\".}"
  }, 
  {
    "name": "sameFile", 
    "type": "skProc", 
    "description": "<p>Returns True if both pathname arguments refer to the same physical file or directory. Raises an exception if any of the files does not exist or information about it can not be obtained.</p>\u000A<p>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</p>\u000A", 
    "code": "proc sameFile*(path1, path2: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "sameFileContent", 
    "type": "skProc", 
    "description": "Returns True if both pathname arguments refer to files with identical binary content.", 
    "code": "proc sameFileContent*(path1, path2: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadIOEffect].}"
  }, 
  {
    "name": "FilePermission", 
    "type": "skType", 
    "description": "file access permission; modelled after UNIX", 
    "code": "FilePermission* = enum \u000A  fpUserExec,                 ## execute access for the file owner\u000A  fpUserWrite,                ## write access for the file owner\u000A  fpUserRead,                 ## read access for the file owner\u000A  fpGroupExec,                ## execute access for the group\u000A  fpGroupWrite,               ## write access for the group\u000A  fpGroupRead,                ## read access for the group\u000A  fpOthersExec,               ## execute access for others\u000A  fpOthersWrite,              ## write access for others\u000A  fpOthersRead                ## read access for others"
  }, 
  {
    "name": "getFilePermissions", 
    "type": "skProc", 
    "description": "retrieves file permissions for <cite>filename</cite>. <cite>OSError</cite> is raised in case of an error. On Windows, only the <tt class=\"docutils literal\"><span class=\"pre\">readonly</span></tt> flag is checked, every other permission is available in any case.", 
    "code": "proc getFilePermissions*(filename: string): set[FilePermission] {.rtl, \u000A    extern: \"nos$1\", tags: [ReadDirEffect].}"
  }, 
  {
    "name": "setFilePermissions", 
    "type": "skProc", 
    "description": "sets the file permissions for <cite>filename</cite>. <cite>OSError</cite> is raised in case of an error. On Windows, only the <tt class=\"docutils literal\"><span class=\"pre\">readonly</span></tt> flag is changed, depending on <tt class=\"docutils literal\"><span class=\"pre\">fpUserWrite</span></tt>.", 
    "code": "proc setFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [WriteDirEffect].}"
  }, 
  {
    "name": "copyFile", 
    "type": "skProc", 
    "description": "<p>Copies a file from <cite>source</cite> to <cite>dest</cite>.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use <a class=\"reference external\" href=\"#getFilePermissions\">getFilePermissions()</a> and <a class=\"reference external\" href=\"#setFilePermissions\">setFilePermissions()</a> to copy them by hand (or use the convenience <a class=\"reference external\" href=\"#copyFileWithPermissions\">copyFileWithPermissions()</a> proc), otherwise <cite>dest</cite> will inherit the default permissions of a newly created file for the user. If <cite>dest</cite> already exists, the file attributes will be preserved and the content overwritten.</p>\u000A", 
    "code": "proc copyFile*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                       tags: [ReadIOEffect, WriteIOEffect].}"
  }, 
  {
    "name": "moveFile", 
    "type": "skProc", 
    "description": "Moves a file from <cite>source</cite> to <cite>dest</cite>. If this fails, <cite>OSError</cite> is raised.", 
    "code": "proc moveFile*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                       tags: [ReadIOEffect, WriteIOEffect].}"
  }, 
  {
    "name": "removeFile", 
    "type": "skProc", 
    "description": "Removes the <cite>file</cite>. If this fails, <cite>OSError</cite> is raised. This does not fail if the file never existed in the first place. On Windows, ignores the read-only attribute.", 
    "code": "proc removeFile*(file: string) {.rtl, extern: \"nos$1\", tags: [WriteDirEffect].}"
  }, 
  {
    "name": "execShellCmd", 
    "type": "skProc", 
    "description": "<p>Executes a <span id=\"shell-command_1\">shell command</span>.</p>\u000A<p>Command has the form 'program args' where args are the command line arguments given to program. The proc returns the error code of the shell when it has finished. The proc does not return until the process has finished. To execute a program without having a shell involved, use the <cite>execProcess</cite> proc of the <cite>osproc</cite> module.</p>\u000A", 
    "code": "proc execShellCmd*(command: string): int {.rtl, extern: \"nos$1\", \u000A    tags: [ExecIOEffect].}"
  }, 
  {
    "name": "getEnv", 
    "type": "skProc", 
    "description": "<p>Returns the value of the <span id=\"environment-variable_1\">environment variable</span> named <cite>key</cite>.</p>\u000A<p>If the variable does not exist, &quot;&quot; is returned. To distinguish whether a variable exists or it's value is just &quot;&quot;, call <cite>existsEnv(key)</cite>.</p>\u000A", 
    "code": "proc getEnv*(key: string): TaintedString {.tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "existsEnv", 
    "type": "skProc", 
    "description": "Checks whether the environment variable named <cite>key</cite> exists. Returns true if it exists, false otherwise.", 
    "code": "proc existsEnv*(key: string): bool {.tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "putEnv", 
    "type": "skProc", 
    "description": "Sets the value of the <span id=\"environment-variable_2\">environment variable</span> named <cite>key</cite> to <cite>val</cite>. If an error occurs, <cite>EInvalidEnvVar</cite> is raised.", 
    "code": "proc putEnv*(key, val: string) {.tags: [WriteEnvEffect].}"
  }, 
  {
    "name": "envPairs", 
    "type": "skIterator", 
    "description": "Iterate over all <span id=\"environments-variables_1\">environments variables</span>. In the first component of the tuple is the name of the current variable stored, in the second its value.", 
    "code": "iterator envPairs*(): tuple[key, value: TaintedString] {.tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "walkFiles", 
    "type": "skIterator", 
    "description": "<p>Iterate over all the files that match the <cite>pattern</cite>. On POSIX this uses the <span id=\"glob_1\">glob</span> call.</p>\u000A<p><cite>pattern</cite> is OS dependent, but at least the &quot;*.ext&quot; notation is supported.</p>\u000A", 
    "code": "iterator walkFiles*(pattern: string): string {.tags: [ReadDirEffect].}"
  }, 
  {
    "name": "PathComponent", 
    "type": "skType", 
    "description": "Enumeration specifying a path component.", 
    "code": "PathComponent* = enum \u000A  pcFile,                     ## path refers to a file\u000A  pcLinkToFile,               ## path refers to a symbolic link to a file\u000A  pcDir,                      ## path refers to a directory\u000A  pcLinkToDir                 ## path refers to a symbolic link to a directory"
  }, 
  {
    "name": "walkDir", 
    "type": "skIterator", 
    "description": "<p>walks over the directory <cite>dir</cite> and yields for each directory or file in <cite>dir</cite>. The component type and full path for each item is returned. Walking is not recursive. Example: This directory structure:<pre>dirA / dirB / fileB1.txt\u000A     / dirC\u000A     / fileA1.txt\u000A     / fileA2.txt</pre>\u000A</p>\u000A<p>and this code:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">kind</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">path</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">walkDir</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;dirA&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">path</span><span class=\"Punctuation\">)</span></pre><p>produces this output (but not necessarily in this order!):<pre>dirA/dirB\u000AdirA/dirC\u000AdirA/fileA1.txt\u000AdirA/fileA2.txt</pre>\u000A</p>\u000A", 
    "code": "iterator walkDir*(dir: string): tuple[kind: PathComponent, path: string] {.\u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "walkDirRec", 
    "type": "skIterator", 
    "description": "<p>walks over the directory <cite>dir</cite> and yields for each file in <cite>dir</cite>. The full path for each file is returned. <strong>Warning</strong>: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</p>\u000A<p>Walking is recursive. <cite>filter</cite> controls the behaviour of the iterator:</p>\u000A<table border=\"1\" class=\"docutils\"><tr><th>filter</th><th>meaning</th></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcFile</span></tt></td><td>yield real files</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcLinkToFile</span></tt></td><td>yield symbolic links to files</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcDir</span></tt></td><td>follow real directories</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcLinkToDir</span></tt></td><td>follow symbolic links to directories</td></tr>\u000A</table>", 
    "code": "iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string {.\u000A    tags: [ReadDirEffect].}"
  }, 
  {
    "name": "removeDir", 
    "type": "skProc", 
    "description": "<p>Removes the directory <cite>dir</cite> including all subdirectories and files in <cite>dir</cite> (recursively).</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. This does not fail if the directory never existed in the first place.</p>\u000A", 
    "code": "proc removeDir*(dir: string) {.rtl, extern: \"nos$1\", \u000A                               tags: [WriteDirEffect, ReadDirEffect].}"
  }, 
  {
    "name": "createDir", 
    "type": "skProc", 
    "description": "<p>Creates the <span id=\"directory_1\">directory</span> <cite>dir</cite>.</p>\u000A<p>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, <cite>OSError</cite> is raised. It does <strong>not</strong> fail if the path already exists because for most usages this does not indicate an error.</p>\u000A", 
    "code": "proc createDir*(dir: string) {.rtl, extern: \"nos$1\", tags: [WriteDirEffect].}"
  }, 
  {
    "name": "copyDir", 
    "type": "skProc", 
    "description": "<p>Copies a directory from <cite>source</cite> to <cite>dest</cite>.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. On the Windows platform this proc will copy the attributes from <cite>source</cite> into <cite>dest</cite>. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use <a class=\"reference external\" href=\"#copyDirWithPermissions\">copyDirWithPermissions()</a>.</p>\u000A", 
    "code": "proc copyDir*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                      tags: [WriteIOEffect, ReadIOEffect].}"
  }, 
  {
    "name": "createSymlink", 
    "type": "skProc", 
    "description": "<p>Create a symbolic link at <cite>dest</cite> which points to the item specified by <cite>src</cite>. On most operating systems, will fail if a lonk</p>\u000A<p><strong>Warning</strong>: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</p>\u000A", 
    "code": "proc createSymlink*(src, dest: string)"
  }, 
  {
    "name": "createHardlink", 
    "type": "skProc", 
    "description": "<p>Create a hard link at <cite>dest</cite> which points to the item specified by <cite>src</cite>.</p>\u000A<p><strong>Warning</strong>: Most OS's restrict the creation of hard links to root users (administrators) .</p>\u000A", 
    "code": "proc createHardlink*(src, dest: string)"
  }, 
  {
    "name": "parseCmdLine", 
    "type": "skProc", 
    "description": "<p>Splits a command line into several components; This proc is only occassionally useful, better use the <cite>parseopt</cite> module.</p>\u000A<p>On Windows, it uses the following parsing rules (see <a class=\"reference external\" href=\"http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\">http://msdn.microsoft.com/en-us/library/17w5ykft.aspx</a> ):</p>\u000A<ul class=\"simple\"><li>Arguments are delimited by white space, which is either a space or a tab.</li>\u000A<li>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</li>\u000A<li>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</li>\u000A<li>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</li>\u000A<li>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</li>\u000A<li>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</li>\u000A<li>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</li>\u000A</ul>\u000A<p>On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within <tt class=\"docutils literal\"><span class=\"pre\">&quot;</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">'</span></tt> quotes.</p>\u000A", 
    "code": "proc parseCmdLine*(c: string): seq[string] {.noSideEffect, rtl, extern: \"nos$1\".}"
  }, 
  {
    "name": "copyFileWithPermissions", 
    "type": "skProc", 
    "description": "<p>Copies a file from <cite>source</cite> to <cite>dest</cite> preserving file permissions.</p>\u000A<p>This is a wrapper proc around <a class=\"reference external\" href=\"#copyFile\">copyFile()</a>, <a class=\"reference external\" href=\"#getFilePermissions\">getFilePermissions()</a> and <a class=\"reference external\" href=\"#setFilePermissions\">setFilePermissions()</a> on non Windows platform. On Windows this proc is just a wrapper for <a class=\"reference external\" href=\"#copyFile\">copyFile()</a> since that proc already copies attributes.</p>\u000A<p>On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If <cite>ignorePermissionErrors</cite> is true, errors while reading/setting file attributes will be ignored, otherwise will raise <cite>OSError</cite>.</p>\u000A", 
    "code": "proc copyFileWithPermissions*(source, dest: string; \u000A                              ignorePermissionErrors = true)"
  }, 
  {
    "name": "copyDirWithPermissions", 
    "type": "skProc", 
    "description": "<p>Copies a directory from <cite>source</cite> to <cite>dest</cite> preserving file permissions.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. This is a wrapper proc around <a class=\"reference external\" href=\"#copyDir\">copyDir()</a> and <a class=\"reference external\" href=\"#copyFileWithPermissions\">copyFileWithPermissions()</a> on non Windows platforms. On Windows this proc is just a wrapper for <a class=\"reference external\" href=\"#copyDir\">copyDir()</a> since that proc already copies attributes.</p>\u000A<p>On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If <cite>ignorePermissionErrors</cite> is true, errors while reading/setting file attributes will be ignored, otherwise will raise <cite>OSError</cite>.</p>\u000A", 
    "code": "proc copyDirWithPermissions*(source, dest: string; ignorePermissionErrors = true) {.\u000A    rtl, extern: \"nos$1\", tags: [WriteIOEffect, ReadIOEffect].}"
  }, 
  {
    "name": "inclFilePermissions", 
    "type": "skProc", 
    "description": "a convenience procedure for:<pre><span class=\"Identifier\">setFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">getFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">)</span><span class=\"Operator\">+</span><span class=\"Identifier\">permissions</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc inclFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [ReadDirEffect, WriteDirEffect].}"
  }, 
  {
    "name": "exclFilePermissions", 
    "type": "skProc", 
    "description": "a convenience procedure for:<pre><span class=\"Identifier\">setFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">getFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">)</span><span class=\"Operator\">-</span><span class=\"Identifier\">permissions</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc exclFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [ReadDirEffect, WriteDirEffect].}"
  }, 
  {
    "name": "getHomeDir", 
    "type": "skProc", 
    "description": "<p>Returns the home directory of the current user.</p>\u000A<p>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</p>\u000A", 
    "code": "proc getHomeDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "getConfigDir", 
    "type": "skProc", 
    "description": "Returns the config directory of the current user for applications.", 
    "code": "proc getConfigDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "getTempDir", 
    "type": "skProc", 
    "description": "Returns the temporary directory of the current user for applications to save temporary files in.", 
    "code": "proc getTempDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}"
  }, 
  {
    "name": "paramCount", 
    "type": "skProc", 
    "description": "<p>Returns the number of <span id=\"command-line-arguments_1\">command line arguments</span> given to the application.</p>\u000A<p>If your binary was called without parameters this will return zero.  You can later query each individual paramater with <a class=\"reference external\" href=\"#paramStr\">paramStr()</a> or retrieve all of them in one go with <a class=\"reference external\" href=\"#commandLineParams\">commandLineParams()</a>.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">paramCount</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use paramCount() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>", 
    "code": "proc paramCount*(): int {.tags: [ReadIOEffect].}"
  }, 
  {
    "name": "paramStr", 
    "type": "skProc", 
    "description": "<p>Returns the <cite>i</cite>-th <span id=\"command-line-argument_1\">command line argument</span> given to the application.</p>\u000A<p><cite>i</cite> should be in the range <cite>1..paramCount()</cite>, the <cite>EInvalidIndex</cite> exception will be raised for invalid values.  Instead of iterating over <a class=\"reference external\" href=\"#paramCount\">paramCount()</a> with this proc you can call the convenience <a class=\"reference external\" href=\"#commandLineParams\">commandLineParams()</a>.</p>\u000A<p>It is possible to call <tt class=\"docutils literal\"><span class=\"pre\">paramStr(0)</span></tt> but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call <a class=\"reference external\" href=\"#getAppFilename\">getAppFilename()</a> instead.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">paramStr</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use paramStr() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>", 
    "code": "proc paramStr*(i: int): TaintedString {.tags: [ReadIOEffect].}"
  }, 
  {
    "name": "commandLineParams", 
    "type": "skProc", 
    "description": "<p>Convenience proc which returns the command line parameters.</p>\u000A<p>This returns <strong>only</strong> the parameters. If you want to get the application executable filename, call <a class=\"reference external\" href=\"#getAppFilename\">getAppFilename()</a>.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">commandLineParams</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use commandLineParams() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>", 
    "code": "proc commandLineParams*(): seq[TaintedString]"
  }, 
  {
    "name": "cuint32", 
    "type": "skType", 
    "code": "cuint32* {.importc: \"unsigned int\", nodecl.} = int"
  }, 
  {
    "name": "getAppFilename", 
    "type": "skProc", 
    "description": "<p>Returns the filename of the application's executable.</p>\u000A<p>This procedure will resolve symlinks.</p>\u000A<p><strong>Note</strong>: This does not work reliably on BSD.</p>\u000A", 
    "code": "proc getAppFilename*(): string {.rtl, extern: \"nos$1\", tags: [ReadIOEffect].}"
  }, 
  {
    "name": "getApplicationFilename", 
    "type": "skProc", 
    "description": "Returns the filename of the application's executable. <strong>Deprecated since version 0.8.12</strong>: use <tt class=\"docutils literal\"><span class=\"pre\">getAppFilename</span></tt> instead.", 
    "code": "proc getApplicationFilename*(): string {.rtl, extern: \"nos$1\", deprecated.}"
  }, 
  {
    "name": "getApplicationDir", 
    "type": "skProc", 
    "description": "Returns the directory of the application's executable. <strong>Deprecated since version 0.8.12</strong>: use <tt class=\"docutils literal\"><span class=\"pre\">getAppDir</span></tt> instead.", 
    "code": "proc getApplicationDir*(): string {.rtl, extern: \"nos$1\", deprecated.}"
  }, 
  {
    "name": "getAppDir", 
    "type": "skProc", 
    "description": "Returns the directory of the application's executable. <strong>Note</strong>: This does not work reliably on BSD.", 
    "code": "proc getAppDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadIOEffect].}"
  }, 
  {
    "name": "sleep", 
    "type": "skProc", 
    "description": "sleeps <cite>milsecs</cite> milliseconds.", 
    "code": "proc sleep*(milsecs: int) {.rtl, extern: \"nos$1\", tags: [TimeEffect].}"
  }, 
  {
    "name": "getFileSize", 
    "type": "skProc", 
    "description": "returns the file size of <cite>file</cite>. Can raise <tt class=\"docutils literal\"><span class=\"pre\">OSError</span></tt>.", 
    "code": "proc getFileSize*(file: string): BiggestInt {.rtl, extern: \"nos$1\", \u000A    tags: [ReadIOEffect].}"
  }, 
  {
    "name": "findExe", 
    "type": "skProc", 
    "description": "Searches for <cite>exe</cite> in the current working directory and then in directories listed in the <tt class=\"docutils literal\"><span class=\"pre\">PATH</span></tt> environment variable. Returns &quot;&quot; if the <cite>exe</cite> cannot be found. On DOS-like platforms, <cite>exe</cite> is added an <tt class=\"docutils literal\"><span class=\"pre\">.exe</span></tt> file extension if it has no extension.", 
    "code": "proc findExe*(exe: string): string {.tags: [ReadDirEffect, ReadEnvEffect].}"
  }, 
  {
    "name": "expandTilde", 
    "type": "skProc", 
    "description": "<p>Expands a path starting with <tt class=\"docutils literal\"><span class=\"pre\">~/</span></tt> to a full path.</p>\u000A<p>If <cite>path</cite> starts with the tilde character and is followed by <cite>/</cite> or <cite>\\</cite> this proc will return the reminder of the path appended to the result of the getHomeDir() proc, otherwise the input path will be returned without modification.</p>\u000A<p>The behaviour of this proc is the same on the Windows platform despite not having this convention. Example:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">configFile</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">expandTilde</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;~&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;appname.cfg&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">configFile</span>\u000A<span class=\"Comment\"># --&gt; C:\\Users\\amber\\appname.cfg</span></pre>", 
    "code": "proc expandTilde*(path: string): string"
  }, 
  {
    "name": "FileId", 
    "type": "skType", 
    "code": "FileId* = int64"
  }, 
  {
    "name": "FileInfo", 
    "type": "skType", 
    "description": "Contains information associated with a file object.", 
    "code": "FileInfo* = object \u000A  id*: tuple[device: DeviceId, file: FileId]\u000A  kind*: PathComponent\u000A  size*: BiggestInt\u000A  permissions*: set[FilePermission]\u000A  linkCount*: BiggestInt\u000A  lastAccessTime*: Time\u000A  lastWriteTime*: Time\u000A  creationTime*: Time\u000A"
  }, 
  {
    "name": "getFileInfo", 
    "type": "skProc", 
    "description": "<p>Retrieves file information for the file object represented by the given handle.</p>\u000A<p>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</p>\u000A", 
    "code": "proc getFileInfo*(handle: FileHandle): FileInfo"
  }, 
  {
    "name": "getFileInfo", 
    "type": "skProc", 
    "code": "proc getFileInfo*(file: File): FileInfo"
  }, 
  {
    "name": "getFileInfo", 
    "type": "skProc", 
    "description": "<p>Retrieves file information for the file object pointed to by <cite>path</cite>.</p>\u000A<p>Due to intrinsic differences between operating systems, the information contained by the returned <cite>FileInfo</cite> structure will be slightly different across platforms, and in some cases, incomplete or inaccurate.</p>\u000A<p>When <cite>followSymlink</cite> is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</p>\u000A<p>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</p>\u000A", 
    "code": "proc getFileInfo*(path: string; followSymlink = true): FileInfo"
  }, 
  {
    "name": "isHidden", 
    "type": "skProc", 
    "description": "<p>Determines whether a given path is hidden or not. Returns false if the file doesn't exist. The given path must be accessible from the current working directory of the program.</p>\u000A<p>On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not <em>just</em> '.' or '..' ' .&quot;</p>\u000A", 
    "code": "proc isHidden*(path: string): bool"
  }
]