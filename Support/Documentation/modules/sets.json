[
  {
    "comment": "The ``sets`` module implements an efficient hash set and ordered hash set.\u000A##\u000A## Hash sets are different from the `built in set type\u000A## <manual.html#set-type>`_. Sets allow you to store any value that can be\u000A## `hashed <hashes.html>`_ and they don't contain duplicate entries.\u000A##\u000A## **Note**: The data types declared here have *value semantics*: This means\u000A## that ``=`` performs a copy of the set."
  }, 
  {
    "name": "HashSet", 
    "type": "skType", 
    "description": "<p>\u000AA generic hash set.</p>\u000A<p>Use <a class=\"reference external\" href=\"#init,HashSet[A],int\">init()</a> or <a class=\"reference external\" href=\"#initSet\">initSet[type]()</a> before calling other procs on it.</p>\u000A", 
    "code": "HashSet* {.myShallow.}[A] = object \u000A  data: KeyValuePairSeq[A]\u000A  counter: int\u000A"
  }, 
  {
    "name": "isValid", 
    "type": "skProc", 
    "description": "<p>Returns <cite>true</cite> if the set has been initialized with <a class=\"reference external\" href=\"#initSet\">initSet</a>.</p>\u000A<p>Most operations over an uninitialized set will crash at runtime and <a class=\"reference external\" href=\"system.html#assert\">assert</a> in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</p>\u000A<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">savePreferences</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">options</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">assert</span> <span class=\"Identifier\">options</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Pass an initialized set!&quot;</span>\u000A  <span class=\"Comment\"># Do stuff here, may crash in release builds!</span></pre>", 
    "code": "proc isValid*[A](s: HashSet[A]): bool"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "description": "<p>Returns the number of keys in <cite>s</cite>.</p>\u000A<p>Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span></pre>", 
    "code": "proc len*[A](s: HashSet[A]): int"
  }, 
  {
    "name": "card", 
    "type": "skProc", 
    "description": "<p>Alias for <a class=\"reference external\" href=\"#len,TSet[A]\">len()</a>.</p>\u000A<p>Card stands for the <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cardinality\">cardinality</a> of a set.</p>\u000A", 
    "code": "proc card*[A](s: HashSet[A]): int"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "<p>Iterates over keys in the set <cite>s</cite>.</p>\u000A<p>If you need a sequence with the keys you can use <a class=\"reference external\" href=\"sequtils.html#toSeq\">sequtils.toSeq()</a> on the iterator. Usage example:</p>\u000A<pre><span class=\"Keyword\">type</span>\u000A  <span class=\"Identifier\">pair</span> <span class=\"Operator\">=</span> <span class=\"Keyword\">tuple</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">pair</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">items</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">b</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span> <span class=\"Operator\">-</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">2</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Comment\"># --&gt; {(a: 1, b: 3), (a: 0, b: 4)}</span></pre>", 
    "code": "iterator items*[A](s: HashSet[A]): A"
  }, 
  {
    "name": "mget", 
    "type": "skProc", 
    "description": "returns the element that is actually stored in 's' which has the same value as 'key' or raises the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception. This is useful when one overloaded 'hash' and '==' but still needs reference semantics for sharing.", 
    "code": "proc mget*[A](s: var HashSet[A]; key: A): var A"
  }, 
  {
    "name": "contains", 
    "type": "skProc", 
    "description": "<p>Returns true iff <cite>key</cite> is in <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc contains*[A](s: HashSet[A]; key: A): bool"
  }, 
  {
    "name": "incl", 
    "type": "skProc", 
    "description": "<p>Includes an element <cite>key</cite> in <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is already in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">1</span></pre>", 
    "code": "proc incl*[A](s: var HashSet[A]; key: A)"
  }, 
  {
    "name": "incl", 
    "type": "skProc", 
    "description": "<p>Includes all elements from <cite>other</cite> into <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">others</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">others</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>", 
    "code": "proc incl*[A](s: var HashSet[A]; other: HashSet[A])"
  }, 
  {
    "name": "excl", 
    "type": "skProc", 
    "description": "<p>Excludes <cite>key</cite> from the set <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is not found in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>", 
    "code": "proc excl*[A](s: var HashSet[A]; key: A)"
  }, 
  {
    "name": "excl", 
    "type": "skProc", 
    "description": "<p>Excludes everything in <cite>other</cite> from <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">even</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">even</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">numbers</span>\u000A<span class=\"Comment\"># --&gt; {1, 3, 5}</span></pre>", 
    "code": "proc excl*[A](s: var HashSet[A]; other: HashSet[A])"
  }, 
  {
    "name": "containsOrIncl", 
    "type": "skProc", 
    "description": "<p>Includes <cite>key</cite> in the set <cite>s</cite> and tells if <cite>key</cite> was added to <cite>s</cite>.</p>\u000A<p>The difference with regards to the <a class=\"reference external\" href=\"#incl,TSet[A],A\">incl()</a> proc is that this proc returns <cite>true</cite> if <cite>key</cite> was already present in <cite>s</cite>. The proc will return false if <cite>key</cite> was added as a new value to <cite>s</cite> during this call. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>", 
    "code": "proc containsOrIncl*[A](s: var HashSet[A]; key: A): bool"
  }, 
  {
    "name": "init", 
    "type": "skProc", 
    "description": "<p>Initializes a hash set.</p>\u000A<p>The <cite>initialSize</cite> parameter needs to be a power of too. You can use <a class=\"reference external\" href=\"math.html#nextPowerOfTwo\">math.nextPowerOfTwo()</a> to guarantee that at runtime. All set variables have to be initialized before you can use them with other procs from this module with the exception of <a class=\"reference external\" href=\"#isValid,TSet[A]\">isValid()</a> and <a class=\"reference external\" href=\"#len,TSet[A]\">len()</a>.</p>\u000A<p>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling <a class=\"reference external\" href=\"#excl,TSet[A],A\">excl()</a> on them. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span></pre>", 
    "code": "proc init*[A](s: var HashSet[A]; initialSize = 64)"
  }, 
  {
    "name": "initSet", 
    "type": "skProc", 
    "description": "<p>Wrapper around <a class=\"reference external\" href=\"#init,TSet[A],int\">init()</a> for initialization of hash sets.</p>\u000A<p>Returns an empty hash set you can assign directly in <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> blocks in a single line. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc initSet*[A](initialSize = 64): HashSet[A]"
  }, 
  {
    "name": "toSet", 
    "type": "skProc", 
    "description": "<p>Creates a new hash set that contains the given <cite>keys</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc toSet*[A](keys: openArray[A]): HashSet[A]"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "<p>Converts the set <cite>s</cite> to a string, mostly for logging purposes.</p>\u000A<p>Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Identifier\">echo</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {2, 4, 5}</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;no&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;esc'aping&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is </span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\"> provided&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {no, esc'aping, is &quot; provided}</span></pre>", 
    "code": "proc `$`*[A](s: HashSet[A]): string"
  }, 
  {
    "name": "union", 
    "type": "skProc", 
    "description": "<p>Returns the union of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The union of two sets is represented mathematically as <em>A \u222A B</em> and is the set of all objects that are members of <cite>s1</cite>, <cite>s2</cite> or both. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">union</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc union*[A](s1, s2: HashSet[A]): HashSet[A]"
  }, 
  {
    "name": "intersection", 
    "type": "skProc", 
    "description": "<p>Returns the intersection of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The intersection of two sets is represented mathematically as <em>A \u2229 B</em> and is the set of all objects that are members of <cite>s1</cite> and <cite>s2</cite> at the same time. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc intersection*[A](s1, s2: HashSet[A]): HashSet[A]"
  }, 
  {
    "name": "difference", 
    "type": "skProc", 
    "description": "<p>Returns the difference of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The difference of two sets is represented mathematically as <em>A B</em> and is the set of all objects that are members of <cite>s1</cite> and not members of <cite>s2</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">difference</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc difference*[A](s1, s2: HashSet[A]): HashSet[A]"
  }, 
  {
    "name": "symmetricDifference", 
    "type": "skProc", 
    "description": "<p>Returns the symmetric difference of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The symmetric difference of two sets is represented mathematically as <em>A \u25B3 B</em> or <em>A \u2296 B</em> and is the set of all objects that are members of <cite>s1</cite> or <cite>s2</cite> but not both at the same time. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">symmetricDifference</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc symmetricDifference*[A](s1, s2: HashSet[A]): HashSet[A]"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "description": "Alias for <a class=\"reference external\" href=\"#union\">union(s1, s2)</a>.", 
    "code": "proc `+`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "description": "Alias for <a class=\"reference external\" href=\"#intersection\">intersection(s1, s2)</a>.", 
    "code": "proc `*`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "description": "Alias for <a class=\"reference external\" href=\"#difference\">difference(s1, s2)</a>.", 
    "code": "proc `-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}"
  }, 
  {
    "name": "`-+-`", 
    "type": "skProc", 
    "description": "Alias for <a class=\"reference external\" href=\"#symmetricDifference\">symmetricDifference(s1, s2)</a>.", 
    "code": "proc `-+-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}"
  }, 
  {
    "name": "disjoint", 
    "type": "skProc", 
    "description": "<p>Returns true iff the sets <cite>s1</cite> and <cite>s2</cite> have no items in common.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">disjoint</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">disjoint</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>", 
    "code": "proc disjoint*[A](s1, s2: HashSet[A]): bool"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "description": "<p>Returns true if <cite>s</cite> is a strict or proper subset of <cite>t</cite>.</p>\u000A<p>A strict or proper subset <cite>s</cite> has all of its members in <cite>t</cite> but <cite>t</cite> has more elements than <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">a</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc `<`*[A](s, t: HashSet[A]): bool"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "description": "<p>Returns true if <cite>s</cite> is subset of <cite>t</cite>.</p>\u000A<p>A subset <cite>s</cite> has all of its members in <cite>t</cite> and <cite>t</cite> doesn't necessarily have more members than <cite>s</cite>. That is, <cite>s</cite> can be equal to <cite>t</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">a</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc `<=`*[A](s, t: HashSet[A]): bool"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "description": "<p>Returns true if both <cite>s</cite> and <cite>t</cite> have the same members and set size.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">b</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">b</span></pre>", 
    "code": "proc `==`*[A](s, t: HashSet[A]): bool"
  }, 
  {
    "name": "map", 
    "type": "skProc", 
    "description": "<p>Returns a new set after applying <cite>op</cite> on each of the elements of <cite>data</cite>.</p>\u000A<p>You can use this proc to transform the elements from a set. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">map</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">proc</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span> <span class=\"Operator\">$</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc map*[A, B](data: HashSet[A]; op: proc (x: A): B {.closure.}): HashSet[B]"
  }, 
  {
    "name": "OrderedSet", 
    "type": "skType", 
    "description": "<p>\u000AA generic hash set that remembers insertion order.</p>\u000A<p>Use <a class=\"reference external\" href=\"#init,OrderedSet[A],int\">init()</a> or <a class=\"reference external\" href=\"#initOrderedSet\">initOrderedSet[type]()</a> before calling other procs on it.</p>\u000A", 
    "code": "OrderedSet* {.myShallow.}[A] = object \u000A  data: OrderedKeyValuePairSeq[A]\u000A  counter, first, last: int\u000A"
  }, 
  {
    "name": "isValid", 
    "type": "skProc", 
    "description": "<p>Returns <cite>true</cite> if the ordered set has been initialized with <a class=\"reference external\" href=\"#initOrderedSet\">initSet</a>.</p>\u000A<p>Most operations over an uninitialized ordered set will crash at runtime and <a class=\"reference external\" href=\"system.html#assert\">assert</a> in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</p>\u000A<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">saveTarotCards</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">cards</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">assert</span> <span class=\"Identifier\">cards</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Pass an initialized set!&quot;</span>\u000A  <span class=\"Comment\"># Do stuff here, may crash in release builds!</span></pre>", 
    "code": "proc isValid*[A](s: OrderedSet[A]): bool"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "description": "<p>Returns the number of keys in <cite>s</cite>.</p>\u000A<p>Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span></pre>", 
    "code": "proc len*[A](s: OrderedSet[A]): int {.inline.}"
  }, 
  {
    "name": "card", 
    "type": "skProc", 
    "description": "<p>Alias for <a class=\"reference external\" href=\"#len,TOrderedSet[A]\">len()</a>.</p>\u000A<p>Card stands for the <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cardinality\">cardinality</a> of a set.</p>\u000A", 
    "code": "proc card*[A](s: OrderedSet[A]): int {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "<p>Iterates over keys in the ordered set <cite>s</cite> in insertion order.</p>\u000A<p>If you need a sequence with the keys you can use <a class=\"reference external\" href=\"sequtils.html#toSeq\">sequtils.toSeq()</a> on the iterator. Usage example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">9</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">items</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Got &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span>\u000A<span class=\"Comment\"># --&gt; Got 9</span>\u000A<span class=\"Comment\"># --&gt; Got 2</span>\u000A<span class=\"Comment\"># --&gt; Got 1</span>\u000A<span class=\"Comment\"># --&gt; Got 5</span>\u000A<span class=\"Comment\"># --&gt; Got 8</span>\u000A<span class=\"Comment\"># --&gt; Got 4</span></pre>", 
    "code": "iterator items*[A](s: OrderedSet[A]): A"
  }, 
  {
    "name": "contains", 
    "type": "skProc", 
    "description": "<p>Returns true iff <cite>key</cite> is in <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc contains*[A](s: OrderedSet[A]; key: A): bool"
  }, 
  {
    "name": "incl", 
    "type": "skProc", 
    "description": "<p>Includes an element <cite>key</cite> in <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is already in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">1</span></pre>", 
    "code": "proc incl*[A](s: var OrderedSet[A]; key: A)"
  }, 
  {
    "name": "incl", 
    "type": "skProc", 
    "description": "<p>Includes all elements from <cite>other</cite> into <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">others</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">others</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>", 
    "code": "proc incl*[A](s: var HashSet[A]; other: OrderedSet[A])"
  }, 
  {
    "name": "containsOrIncl", 
    "type": "skProc", 
    "description": "<p>Includes <cite>key</cite> in the set <cite>s</cite> and tells if <cite>key</cite> was added to <cite>s</cite>.</p>\u000A<p>The difference with regards to the <a class=\"reference external\" href=\"#incl,TOrderedSet[A],A\">incl()</a> proc is that this proc returns <cite>true</cite> if <cite>key</cite> was already present in <cite>s</cite>. The proc will return false if <cite>key</cite> was added as a new value to <cite>s</cite> during this call. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>", 
    "code": "proc containsOrIncl*[A](s: var OrderedSet[A]; key: A): bool"
  }, 
  {
    "name": "init", 
    "type": "skProc", 
    "description": "<p>Initializes an ordered hash set.</p>\u000A<p>The <cite>initialSize</cite> parameter needs to be a power of too. You can use <a class=\"reference external\" href=\"math.html#nextPowerOfTwo\">math.nextPowerOfTwo()</a> to guarantee that at runtime. All set variables have to be initialized before you can use them with other procs from this module with the exception of <a class=\"reference external\" href=\"#isValid,TOrderedSet[A]\">isValid()</a> and <a class=\"reference external\" href=\"#len,TOrderedSet[A]\">len()</a>.</p>\u000A<p>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span></pre>", 
    "code": "proc init*[A](s: var OrderedSet[A]; initialSize = 64)"
  }, 
  {
    "name": "initOrderedSet", 
    "type": "skProc", 
    "description": "<p>Wrapper around <a class=\"reference external\" href=\"#init,TOrderedSet[A],int\">init()</a> for initialization of ordered hash sets.</p>\u000A<p>Returns an empty ordered hash set you can assign directly in <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> blocks in a single line. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc initOrderedSet*[A](initialSize = 64): OrderedSet[A]"
  }, 
  {
    "name": "toOrderedSet", 
    "type": "skProc", 
    "description": "<p>Creates a new ordered hash set that contains the given <cite>keys</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span></pre>", 
    "code": "proc toOrderedSet*[A](keys: openArray[A]): OrderedSet[A]"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "<p>Converts the ordered hash set <cite>s</cite> to a string, mostly for logging purposes.</p>\u000A<p>Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Identifier\">echo</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {2, 4, 5}</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;no&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;esc'aping&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is </span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\"> provided&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {no, esc'aping, is &quot; provided}</span></pre>", 
    "code": "proc `$`*[A](s: OrderedSet[A]): string"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "description": "Equality for ordered sets.", 
    "code": "proc `==`*[A](s, t: OrderedSet[A]): bool"
  }
]