[ { "module": "actors",  "name": "spawn",  "code": "proc spawn*[TIn, TOut](action: proc (self: PActor[TIn, TOut]) {.thread.}): PActor[\u000A    TIn, TOut]",  "desc": "creates an actor; that is a thread with an inbox. The caller MUST call <tt class=\"docutils literal\"><span class=\"pre\">join</span></tt> because that also frees the actor's associated resources." },  { "module": "actors",  "name": "inbox",  "code": "proc inbox*[TIn, TOut](self: PActor[TIn, TOut]): ptr TChannel[TIn]",  "desc": "gets a pointer to the associated inbox of the actor <cite>self</cite>." },  { "module": "actors",  "name": "running",  "code": "proc running*[TIn, TOut](a: PActor[TIn, TOut]): bool",  "desc": "returns true if the actor <cite>a</cite> is running." },  { "module": "actors",  "name": "ready",  "code": "proc ready*[TIn, TOut](a: PActor[TIn, TOut]): bool",  "desc": "returns true if the actor <cite>a</cite> is ready to process new messages." },  { "module": "actors",  "name": "join",  "code": "proc join*[TIn, TOut](a: PActor[TIn, TOut])",  "desc": "joins an actor." },  { "module": "actors",  "name": "recv",  "code": "proc recv*[TIn, TOut](a: PActor[TIn, TOut]): TTask[TIn, TOut]",  "desc": "receives a task from <cite>a</cite>'s inbox." },  { "module": "actors",  "name": "send",  "code": "proc send*[TIn, TOut, X, Y](receiver: PActor[TIn, TOut]; msg: TIn; \u000A                            sender: PActor[X, Y])",  "desc": "sends a message to <cite>a</cite>'s inbox." },  { "module": "actors",  "name": "send",  "code": "proc send*[TIn, TOut](receiver: PActor[TIn, TOut]; msg: TIn; \u000A                      sender: ptr TChannel[TOut] = nil)",  "desc": "sends a message to <cite>receiver</cite>'s inbox." },  { "module": "actors",  "name": "sendShutdown",  "code": "proc sendShutdown*[TIn, TOut](receiver: PActor[TIn, TOut])",  "desc": "send a shutdown message to <cite>receiver</cite>." },  { "module": "actors",  "name": "reply",  "code": "proc reply*[TIn, TOut](t: TTask[TIn, TOut]; m: TOut)",  "desc": "sends a message to io's output message box." },  { "module": "actors",  "name": "`^`",  "code": "proc `^`*[T](f: ptr TChannel[T]): T",  "desc": "alias for 'recv'." },  { "module": "actors",  "name": "createActorPool",  "code": "proc createActorPool*[TIn, TOut](a: var TActorPool[TIn, TOut]; poolSize = 4)",  "desc": "creates an actor pool." },  { "module": "actors",  "name": "sync",  "code": "proc sync*[TIn, TOut](a: var TActorPool[TIn, TOut]; polling = 50)",  "desc": "waits for every actor of <cite>a</cite> to finish with its work. Currently this is implemented as polling every <cite>polling</cite> ms and has a slight chance of failing since we check for every actor to be in <cite>ready</cite> state and not for messages still in ether. This will change in a later version, however." },  { "module": "actors",  "name": "terminate",  "code": "proc terminate*[TIn, TOut](a: var TActorPool[TIn, TOut])",  "desc": "terminates each actor in the actor pool <cite>a</cite> and frees the resources attached to <cite>a</cite>." },  { "module": "actors",  "name": "join",  "code": "proc join*[TIn, TOut](a: var TActorPool[TIn, TOut])",  "desc": "short-cut for <cite>sync</cite> and then <cite>terminate</cite>." },  { "module": "actors",  "name": "spawn",  "code": "proc spawn*[TIn, TOut](p: var TActorPool[TIn, TOut]; input: TIn; \u000A                       action: proc (input: TIn): TOut {.thread.}): ptr TChannel[\u000A    TOut]",  "desc": "uses the actor pool to run <tt class=\"docutils literal\"><span class=\"pre\">action(input)</span></tt> concurrently. <cite>spawn</cite> is guaranteed to not block." },  { "module": "actors",  "name": "spawn",  "code": "proc spawn*[TIn](p: var TActorPool[TIn, void]; input: TIn; \u000A                 action: proc (input: TIn) {.thread.})",  "desc": "uses the actor pool to run <tt class=\"docutils literal\"><span class=\"pre\">action(input)</span></tt> concurrently. <cite>spawn</cite> is guaranteed to not block." },  { "module": "algorithm",  "name": "`*`",  "code": "proc `*`*(x: int; order: SortOrder): int {.inline.}",  "desc": "flips <cite>x</cite> if <tt class=\"docutils literal\"><span class=\"pre\">order == Descending</span></tt>; if <tt class=\"docutils literal\"><span class=\"pre\">order == Ascending</span></tt> then <cite>x</cite> is returned. <cite>x</cite> is supposed to be the result of a comparator, ie <tt class=\"docutils literal\"><span class=\"pre\">&lt; 0</span></tt> for <em>less than</em>, <tt class=\"docutils literal\"><span class=\"pre\">== 0</span></tt> for <em>equal</em>, <tt class=\"docutils literal\"><span class=\"pre\">&gt; 0</span></tt> for <em>greater than</em>." },  { "module": "algorithm",  "name": "reverse",  "code": "proc reverse*[T](a: var openArray[T]; first, last: int)",  "desc": "reverses the array <tt class=\"docutils literal\"><span class=\"pre\">a[first..last]</span></tt>." },  { "module": "algorithm",  "name": "reverse",  "code": "proc reverse*[T](a: var openArray[T])",  "desc": "reverses the array <cite>a</cite>." },  { "module": "algorithm",  "name": "reversed",  "code": "proc reversed*[T](a: openArray[T]; first, last: int): seq[T]",  "desc": "returns the reverse of the array <cite>a[first..last]</cite>." },  { "module": "algorithm",  "name": "reversed",  "code": "proc reversed*[T](a: openArray[T]): seq[T]",  "desc": "returns the reverse of the array <cite>a</cite>." },  { "module": "algorithm",  "name": "binarySearch",  "code": "proc binarySearch*[T](a: openArray[T]; key: T): int",  "desc": "binary search for <cite>key</cite> in <cite>a</cite>. Returns -1 if not found." },  { "module": "algorithm",  "name": "smartBinarySearch",  "code": "proc smartBinarySearch*[T](a: openArray[T]; key: T): int",  "desc": "<tt class=\"docutils literal\"><span class=\"pre\">a.len</span></tt> must be a power of 2 for this to work." },  { "module": "algorithm",  "name": "lowerBound",  "code": "proc lowerBound*[T](a: openArray[T]; key: T; cmp: proc (x, y: T): int {.closure.}): int",  "desc": "<p>same as binarySearch except that if key is not in <cite>a</cite> then this returns the location where <cite>key</cite> would be if it were. In other words if you have a sorted sequence and you call insert(thing, elm, lowerBound(thing, elm)) the sequence will still be sorted</p>\u000A<p><cite>cmp</cite> is the comparator function to use, the expected return values are the same as that of system.cmp</p>\u000A<p>example:<pre>\u000Avar arr = @[1,2,3,5,6,7,8,9]\u000Aarr.insert(4, arr.lowerBound(4))</pre>\u000A</p>\u000A<p><cite>after running the above arr is `[1,2,3,4,5,6,7,8,9]</cite></p>\u000A" },  { "module": "algorithm",  "name": "lowerBound",  "code": "proc lowerBound*[T](a: openArray[T]; key: T): int" },  { "module": "algorithm",  "name": "sort",  "code": "proc sort*[T](a: var openArray[T]; cmp: proc (x, y: T): int {.closure.}; \u000A              order = SortOrder.Ascending)",  "desc": "Default Nim sort. The sorting is guaranteed to be stable and the worst case is guaranteed to be O(n log n). The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length <tt class=\"docutils literal\"><span class=\"pre\">a.len div 2</span></tt>. Currently Nim does not support a sensible default argument for <tt class=\"docutils literal\"><span class=\"pre\">cmp</span></tt>, so you have to provide one of your own. However, the <tt class=\"docutils literal\"><span class=\"pre\">system.cmp</span></tt> procs can be used:<pre><span class=\"Identifier\">sort</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">myIntArray</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">system</span><span class=\"Operator\">.</span><span class=\"Identifier\">cmp</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Comment\"># do not use cmp[string] here as we want to use the specialized</span>\u000A<span class=\"Comment\"># overload:</span>\u000A<span class=\"Identifier\">sort</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">myStrArray</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">system</span><span class=\"Operator\">.</span><span class=\"Identifier\">cmp</span><span class=\"Punctuation\">)</span></pre><p>You can inline adhoc comparison procs with the <a class=\"reference external\" href=\"manual.html#do-notation\">do notation</a>. Example:</p>\u000A<pre><span class=\"Identifier\">people</span><span class=\"Operator\">.</span><span class=\"Identifier\">sort</span> <span class=\"Keyword\">do</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">Person</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">cmp</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Operator\">.</span><span class=\"Identifier\">surname</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span><span class=\"Operator\">.</span><span class=\"Identifier\">surname</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Keyword\">if</span> <span class=\"Identifier\">result</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">cmp</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Operator\">.</span><span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span><span class=\"Operator\">.</span><span class=\"Identifier\">name</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "algorithm",  "name": "product",  "code": "proc product*[T](x: openArray[seq[T]]): seq[seq[T]]",  "desc": "produces the Cartesian product of the array. Warning: complexity may explode." },  { "module": "asyncdispatch",  "name": "newFuture",  "code": "proc newFuture*[T](fromProc: string = \"unspecified\"): Future[T]",  "desc": "<p>Creates a new future.</p>\u000A<p>Specifying <tt class=\"docutils literal\"><span class=\"pre\">fromProc</span></tt>, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</p>\u000A" },  { "module": "asyncdispatch",  "name": "complete",  "code": "proc complete*[T](future: Future[T]; val: T)",  "desc": "Completes <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> with value <tt class=\"docutils literal\"><span class=\"pre\">val</span></tt>." },  { "module": "asyncdispatch",  "name": "complete",  "code": "proc complete*(future: Future[void])",  "desc": "Completes a void <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt>." },  { "module": "asyncdispatch",  "name": "fail",  "code": "proc fail*[T](future: Future[T]; error: ref Exception)",  "desc": "Completes <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> with <tt class=\"docutils literal\"><span class=\"pre\">error</span></tt>." },  { "module": "asyncdispatch",  "name": "`callback=`",  "code": "proc `callback =`*(future: FutureBase; cb: proc () {.closure, gcsafe.})",  "desc": "<p>Sets the callback proc to be called when the future completes.</p>\u000A<p>If future has already completed then <tt class=\"docutils literal\"><span class=\"pre\">cb</span></tt> will be called immediately.</p>\u000A<p><strong>Note</strong>: You most likely want the other <tt class=\"docutils literal\"><span class=\"pre\">callback</span></tt> setter which passes <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> as a param to the callback.</p>\u000A" },  { "module": "asyncdispatch",  "name": "`callback=`",  "code": "proc `callback =`*[T](future: Future[T]; \u000A                      cb: proc (future: Future[T]) {.closure, gcsafe.})",  "desc": "<p>Sets the callback proc to be called when the future completes.</p>\u000A<p>If future has already completed then <tt class=\"docutils literal\"><span class=\"pre\">cb</span></tt> will be called immediately.</p>\u000A" },  { "module": "asyncdispatch",  "name": "read",  "code": "proc read*[T](future: Future[T]): T",  "desc": "<p>Retrieves the value of <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt>. Future must be finished otherwise this function will fail with a <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> exception.</p>\u000A<p>If the result of the future is an error then that error will be raised.</p>\u000A" },  { "module": "asyncdispatch",  "name": "readError",  "code": "proc readError*[T](future: Future[T]): ref Exception",  "desc": "<p>Retrieves the exception stored in <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt>.</p>\u000A<p>An <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> exception will be thrown if no exception exists in the specified Future.</p>\u000A" },  { "module": "asyncdispatch",  "name": "finished",  "code": "proc finished*[T](future: Future[T]): bool",  "desc": "<p>Determines whether <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> has completed.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> may indicate an error or a value. Use <tt class=\"docutils literal\"><span class=\"pre\">failed</span></tt> to distinguish.</p>\u000A" },  { "module": "asyncdispatch",  "name": "failed",  "code": "proc failed*(future: FutureBase): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> completed with an error." },  { "module": "asyncdispatch",  "name": "asyncCheck",  "code": "proc asyncCheck*[T](future: Future[T])",  "desc": "<p>Sets a callback on <tt class=\"docutils literal\"><span class=\"pre\">future</span></tt> which raises an exception if the future finished with an error.</p>\u000A<p>This should be used instead of <tt class=\"docutils literal\"><span class=\"pre\">discard</span></tt> to discard void futures.</p>\u000A" },  { "module": "asyncdispatch",  "name": "`and`",  "code": "proc `and`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]",  "desc": "Returns a future which will complete once both <tt class=\"docutils literal\"><span class=\"pre\">fut1</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">fut2</span></tt> complete." },  { "module": "asyncdispatch",  "name": "`or`",  "code": "proc `or`*[T, Y](fut1: Future[T]; fut2: Future[Y]): Future[void]",  "desc": "Returns a future which will complete once either <tt class=\"docutils literal\"><span class=\"pre\">fut1</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">fut2</span></tt> complete." },  { "module": "asyncdispatch",  "name": "`==`",  "code": "proc `==`*(x: TAsyncFD; y: TAsyncFD): bool {.borrow.}" },  { "module": "asyncdispatch",  "name": "newDispatcher",  "code": "proc newDispatcher*(): PDispatcher",  "desc": "Creates a new Dispatcher instance." },  { "module": "asyncdispatch",  "name": "getGlobalDispatcher",  "code": "proc getGlobalDispatcher*(): PDispatcher",  "desc": "Retrieves the global thread-local dispatcher." },  { "module": "asyncdispatch",  "name": "register",  "code": "proc register*(fd: TAsyncFD)",  "desc": "Registers <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt> with the dispatcher." },  { "module": "asyncdispatch",  "name": "poll",  "code": "proc poll*(timeout = 500)",  "desc": "Waits for completion events and processes them." },  { "module": "asyncdispatch",  "name": "connect",  "code": "proc connect*(socket: TAsyncFD; address: string; port: Port; af = AF_INET): Future[\u000A    void]",  "desc": "<p>Connects <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> to server at <tt class=\"docutils literal\"><span class=\"pre\">address:port</span></tt>.</p>\u000A<p>Returns a <tt class=\"docutils literal\"><span class=\"pre\">Future</span></tt> which will complete when the connection succeeds or an error occurs.</p>\u000A" },  { "module": "asyncdispatch",  "name": "recv",  "code": "proc recv*(socket: TAsyncFD; size: int; flags = {SocketFlag.SafeDisconn}): Future[\u000A    string]",  "desc": "<p>Reads <strong>up to</strong> <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p><strong>Warning</strong>: The <tt class=\"docutils literal\"><span class=\"pre\">Peek</span></tt> socket flag is not supported on Windows.</p>\u000A" },  { "module": "asyncdispatch",  "name": "send",  "code": "proc send*(socket: TAsyncFD; data: string; flags = {SocketFlag.SafeDisconn}): Future[\u000A    void]",  "desc": "Sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. The returned future will complete once all data has been sent." },  { "module": "asyncdispatch",  "name": "acceptAddr",  "code": "proc acceptAddr*(socket: TAsyncFD; flags = {SocketFlag.SafeDisconn}): Future[\u000A    tuple[address: string, client: TAsyncFD]]",  "desc": "<p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</p>\u000A<p>The resulting client socket is automatically registered to the dispatcher.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt> call may result in an error if the connecting socket disconnects during the duration of the <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt>. If the <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt> flag is specified then this error will not be raised and instead accept will be called again.</p>\u000A" },  { "module": "asyncdispatch",  "name": "newAsyncRawSocket",  "code": "proc newAsyncRawSocket*(domain, typ, protocol: cint): TAsyncFD",  "desc": "Creates a new socket and registers it with the dispatcher implicitly." },  { "module": "asyncdispatch",  "name": "newAsyncRawSocket",  "code": "proc newAsyncRawSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A                        protocol: Protocol = IPPROTO_TCP): TAsyncFD",  "desc": "Creates a new socket and registers it with the dispatcher implicitly." },  { "module": "asyncdispatch",  "name": "closeSocket",  "code": "proc closeSocket*(socket: TAsyncFD)",  "desc": "Closes a socket and ensures that it is unregistered." },  { "module": "asyncdispatch",  "name": "unregister",  "code": "proc unregister*(fd: TAsyncFD)",  "desc": "Unregisters <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt>." },  { "module": "asyncdispatch",  "name": "sleepAsync",  "code": "proc sleepAsync*(ms: int): Future[void]",  "desc": "Suspends the execution of the current async procedure for the next <tt class=\"docutils literal\"><span class=\"pre\">ms</span></tt> miliseconds." },  { "module": "asyncdispatch",  "name": "accept",  "code": "proc accept*(socket: TAsyncFD; flags = {SocketFlag.SafeDisconn}): Future[\u000A    TAsyncFD]",  "desc": "Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted." },  { "module": "asyncdispatch",  "name": "async",  "code": "macro async*(prc: stmt): stmt {.immediate.}",  "desc": "Macro which processes async procedures into the appropriate iterators and yield statements." },  { "module": "asyncdispatch",  "name": "recvLine",  "code": "proc recvLine*(socket: TAsyncFD): Future[string] {.async.}",  "desc": "<p>Reads a line of data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. Returned future will complete once a full line is read or an error occurs.</p>\u000A<p>If a full line is read <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is not added to <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt>, however if solely <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read then <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to it.</p>\u000A<p>If the socket is disconnected, <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p>If the socket is disconnected in the middle of a line (before <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read) then line will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>. The partial line <strong>will be lost</strong>.</p>\u000A<p><strong>Warning</strong>: This assumes that lines are delimited by <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt>.</p>\u000A<p><strong>Note</strong>: This procedure is mostly used for testing. You likely want to use <tt class=\"docutils literal\"><span class=\"pre\">asyncnet.recvLine</span></tt> instead.</p>\u000A" },  { "module": "asyncdispatch",  "name": "runForever",  "code": "proc runForever*()",  "desc": "Begins a never ending global dispatcher poll loop." },  { "module": "asyncdispatch",  "name": "waitFor",  "code": "proc waitFor*[T](fut: Future[T]): T",  "desc": "<strong>Blocks</strong> the current thread until the specified future completes." },  { "module": "asyncfile",  "name": "openAsync",  "code": "proc openAsync*(filename: string; mode = fmRead): AsyncFile",  "desc": "Opens a file specified by the path in <tt class=\"docutils literal\"><span class=\"pre\">filename</span></tt> using the specified <tt class=\"docutils literal\"><span class=\"pre\">mode</span></tt> asynchronously." },  { "module": "asyncfile",  "name": "read",  "code": "proc read*(f: AsyncFile; size: int): Future[string]",  "desc": "<p>Read <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes from the specified file asynchronously starting at the current position of the file pointer.</p>\u000A<p>If the file pointer is past the end of the file then an empty string is returned.</p>\u000A" },  { "module": "asyncfile",  "name": "readLine",  "code": "proc readLine*(f: AsyncFile): Future[string] {.async.}",  "desc": "Reads a single line from the specified file asynchronously." },  { "module": "asyncfile",  "name": "getFilePos",  "code": "proc getFilePos*(f: AsyncFile): int64",  "desc": "Retrieves the current position of the file pointer that is used to read from the specified file. The file's first byte has the index zero." },  { "module": "asyncfile",  "name": "setFilePos",  "code": "proc setFilePos*(f: AsyncFile; pos: int64)",  "desc": "Sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero. " },  { "module": "asyncfile",  "name": "readAll",  "code": "proc readAll*(f: AsyncFile): Future[string] {.async.}",  "desc": "Reads all data from the specified file." },  { "module": "asyncfile",  "name": "write",  "code": "proc write*(f: AsyncFile; data: string): Future[void]",  "desc": "<p>Writes <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to the file specified asynchronously.</p>\u000A<p>The returned Future will complete once all data has been written to the specified file.</p>\u000A" },  { "module": "asyncfile",  "name": "close",  "code": "proc close*(f: AsyncFile)",  "desc": "Closes the file specified." },  { "module": "asyncftpclient",  "name": "send",  "code": "proc send*(ftp: AsyncFtpClient; m: string): Future[TaintedString] {.async.}",  "desc": "Send a message to the server, and wait for a primary reply. <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt> is added for you." },  { "module": "asyncftpclient",  "name": "connect",  "code": "proc connect*(ftp: AsyncFtpClient) {.async.}",  "desc": "Connect to the FTP server specified by <tt class=\"docutils literal\"><span class=\"pre\">ftp</span></tt>." },  { "module": "asyncftpclient",  "name": "pwd",  "code": "proc pwd*(ftp: AsyncFtpClient): Future[TaintedString] {.async.}",  "desc": "Returns the current working directory." },  { "module": "asyncftpclient",  "name": "cd",  "code": "proc cd*(ftp: AsyncFtpClient; dir: string) {.async.}",  "desc": "Changes the current directory on the remote FTP server to <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>." },  { "module": "asyncftpclient",  "name": "cdup",  "code": "proc cdup*(ftp: AsyncFtpClient) {.async.}",  "desc": "Changes the current directory to the parent of the current directory." },  { "module": "asyncftpclient",  "name": "listDirs",  "code": "proc listDirs*(ftp: AsyncFtpClient; dir = \"\"): Future[seq[string]] {.async.}",  "desc": "Returns a list of filenames in the given directory. If <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> is &quot;&quot;, the current directory is used. If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is true, this function will return immediately and it will be your job to use asyncio's <tt class=\"docutils literal\"><span class=\"pre\">poll</span></tt> to progress this operation." },  { "module": "asyncftpclient",  "name": "existsFile",  "code": "proc existsFile*(ftp: AsyncFtpClient; file: string): Future[bool] {.async.}",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> exists." },  { "module": "asyncftpclient",  "name": "createDir",  "code": "proc createDir*(ftp: AsyncFtpClient; dir: string; recursive = false) {.async.}",  "desc": "Creates a directory <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">recursive</span></tt> is true, the topmost subdirectory of <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> will be created first, following the secondmost... etc. this allows you to give a full path as the <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> without worrying about subdirectories not existing." },  { "module": "asyncftpclient",  "name": "chmod",  "code": "proc chmod*(ftp: AsyncFtpClient; path: string; permissions: set[TFilePermission]) {.\u000A    async.}",  "desc": "Changes permission of <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">permissions</span></tt>." },  { "module": "asyncftpclient",  "name": "list",  "code": "proc list*(ftp: AsyncFtpClient; dir = \"\"): Future[string] {.async.}",  "desc": "Lists all files in <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>, uses the current working directory." },  { "module": "asyncftpclient",  "name": "retrText",  "code": "proc retrText*(ftp: AsyncFtpClient; file: string): Future[string] {.async.}",  "desc": "Retrieves <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>. File must be ASCII text." },  { "module": "asyncftpclient",  "name": "defaultOnProgressChanged",  "code": "proc defaultOnProgressChanged*(total, progress: BiggestInt; speed: float): Future[\u000A    void] {.nimcall, gcsafe.}",  "desc": "Default FTP <tt class=\"docutils literal\"><span class=\"pre\">onProgressChanged</span></tt> handler. Does nothing." },  { "module": "asyncftpclient",  "name": "retrFile",  "code": "proc retrFile*(ftp: AsyncFtpClient; file, dest: string; \u000A               onProgressChanged = defaultOnProgressChanged) {.async.}",  "desc": "Downloads <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> and saves it to <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. The <tt class=\"docutils literal\"><span class=\"pre\">EvRetr</span></tt> event is passed to the specified <tt class=\"docutils literal\"><span class=\"pre\">handleEvent</span></tt> function when the download is finished. The event's <tt class=\"docutils literal\"><span class=\"pre\">filename</span></tt> field will be equal to <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>." },  { "module": "asyncftpclient",  "name": "store",  "code": "proc store*(ftp: AsyncFtpClient; file, dest: string; \u000A            onProgressChanged = defaultOnProgressChanged) {.async.}",  "desc": "Uploads <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt> on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The <tt class=\"docutils literal\"><span class=\"pre\">EvStore</span></tt> event is passed to the specified <tt class=\"docutils literal\"><span class=\"pre\">handleEvent</span></tt> function when the upload is finished, and the <tt class=\"docutils literal\"><span class=\"pre\">filename</span></tt> field will be equal to <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>." },  { "module": "asyncftpclient",  "name": "newAsyncFtpClient",  "code": "proc newAsyncFtpClient*(address: string; port = Port(21); user, pass = \"\"): AsyncFtpClient",  "desc": "Creates a new <tt class=\"docutils literal\"><span class=\"pre\">AsyncFtpClient</span></tt> object." },  { "module": "asynchttpserver",  "name": "`==`",  "code": "proc `==`*(protocol: tuple[orig: string, major, minor: int]; ver: THttpVersion): bool" },  { "module": "asynchttpserver",  "name": "newAsyncHttpServer",  "code": "proc newAsyncHttpServer*(reuseAddr = true): PAsyncHttpServer",  "desc": "Creates a new <tt class=\"docutils literal\"><span class=\"pre\">AsyncHttpServer</span></tt> instance." },  { "module": "asynchttpserver",  "name": "sendHeaders",  "code": "proc sendHeaders*(req: TRequest; headers: PStringTable): Future[void]",  "desc": "Sends the specified headers to the requesting client." },  { "module": "asynchttpserver",  "name": "respond",  "code": "proc respond*(req: TRequest; code: THttpCode; content: string; \u000A              headers: PStringTable = newStringTable()) {.async.}",  "desc": "<p>Responds to the request with the specified <tt class=\"docutils literal\"><span class=\"pre\">HttpCode</span></tt>, headers and content.</p>\u000A<p>This procedure will <strong>not</strong> close the client socket.</p>\u000A" },  { "module": "asynchttpserver",  "name": "serve",  "code": "proc serve*(server: PAsyncHttpServer; port: Port; callback: proc (\u000A    request: TRequest): Future[void] {.closure, gcsafe.}; address = \"\") {.async.}",  "desc": "<p>Starts the process of listening for incoming HTTP connections on the specified address and port.</p>\u000A<p>When a request is made by a client the specified callback will be called.</p>\u000A" },  { "module": "asynchttpserver",  "name": "close",  "code": "proc close*(server: PAsyncHttpServer)",  "desc": "Terminates the async http server instance." },  { "module": "asyncio",  "name": "newDelegate",  "code": "proc newDelegate*(): Delegate",  "desc": "Creates a new delegate." },  { "module": "asyncio",  "name": "asyncSocket",  "code": "proc asyncSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A                  protocol: Protocol = IPPROTO_TCP; buffered = true): AsyncSocket",  "desc": "Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised." },  { "module": "asyncio",  "name": "toAsyncSocket",  "code": "proc toAsyncSocket*(sock: Socket; state: SocketStatus = SockConnected): AsyncSocket",  "desc": "<p>Wraps an already initialized <tt class=\"docutils literal\"><span class=\"pre\">TSocket</span></tt> into a AsyncSocket. This is useful if you want to use an already connected TSocket as an asynchronous AsyncSocket in asyncio's event loop.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">state</span></tt> may be overriden, i.e. if <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> is not connected it should be adjusted properly. By default it will be assumed that the socket is connected. Please note this is only applicable to TCP client sockets, if <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> is a different type of socket <tt class=\"docutils literal\"><span class=\"pre\">state</span></tt> needs to be adjusted!!!</p>\u000A<table border=\"1\" class=\"docutils\"><tr><th>Value</th><th>Meaning</th></tr>\u000A<tr><td>SockIdle</td><td>Socket has only just been initialised, not connected or closed.</td></tr>\u000A<tr><td>SockConnected</td><td>Socket is connected to a server.</td></tr>\u000A<tr><td>SockConnecting</td><td>Socket is in the process of connecting to a server.</td></tr>\u000A<tr><td>SockListening</td><td>Socket is a server socket and is listening for connections.</td></tr>\u000A<tr><td>SockClosed</td><td>Socket has been closed.</td></tr>\u000A<tr><td>SockUDPBound</td><td>Socket is a UDP socket which is listening for data.</td></tr>\u000A</table><p><strong>Warning</strong>: If <tt class=\"docutils literal\"><span class=\"pre\">state</span></tt> is set incorrectly the resulting <tt class=\"docutils literal\"><span class=\"pre\">AsyncSocket</span></tt> object may not work properly.</p>\u000A<p><strong>Note</strong>: This will set <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> to be non-blocking.</p>\u000A" },  { "module": "asyncio",  "name": "close",  "code": "proc close*(sock: AsyncSocket) {.gcsafe.}" },  { "module": "asyncio",  "name": "connect",  "code": "proc connect*(sock: AsyncSocket; name: string; port = Port(0); \u000A              af: Domain = AF_INET)",  "desc": "Begins connecting <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>:<tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>." },  { "module": "asyncio",  "name": "close",  "code": "proc close*(sock: AsyncSocket)",  "desc": "Closes <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt>. Terminates any current connections." },  { "module": "asyncio",  "name": "bindAddr",  "code": "proc bindAddr*(sock: AsyncSocket; port = Port(0); address = \"\")",  "desc": "Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.bindAddr</span></tt>." },  { "module": "asyncio",  "name": "listen",  "code": "proc listen*(sock: AsyncSocket)",  "desc": "Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.listen</span></tt>." },  { "module": "asyncio",  "name": "acceptAddr",  "code": "proc acceptAddr*(server: AsyncSocket; client: var AsyncSocket; \u000A                 address: var string)",  "desc": "<p>Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.acceptAddr</span></tt>. This procedure should be called in a <tt class=\"docutils literal\"><span class=\"pre\">handleAccept</span></tt> event handler <strong>only</strong> once.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> needs to be initialised.</p>\u000A" },  { "module": "asyncio",  "name": "accept",  "code": "proc accept*(server: AsyncSocket; client: var AsyncSocket)",  "desc": "Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.accept</span></tt>." },  { "module": "asyncio",  "name": "acceptAddr",  "code": "proc acceptAddr*(server: AsyncSocket): tuple[sock: AsyncSocket, address: string] {.\u000A    deprecated.}",  "desc": "<p>Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.acceptAddr</span></tt>.</p>\u000A<p><strong>Deprecated since version 0.9.0:</strong> Please use the function above.</p>\u000A" },  { "module": "asyncio",  "name": "accept",  "code": "proc accept*(server: AsyncSocket): AsyncSocket {.deprecated.}",  "desc": "<p>Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">sockets.accept</span></tt>.</p>\u000A<p><strong>Deprecated since version 0.9.0:</strong> Please use the function above.</p>\u000A" },  { "module": "asyncio",  "name": "newDispatcher",  "code": "proc newDispatcher*(): Dispatcher" },  { "module": "asyncio",  "name": "register",  "code": "proc register*(d: Dispatcher; deleg: Delegate)",  "desc": "Registers delegate <tt class=\"docutils literal\"><span class=\"pre\">deleg</span></tt> with dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "asyncio",  "name": "register",  "code": "proc register*(d: Dispatcher; sock: AsyncSocket): Delegate {.discardable.}",  "desc": "Registers async socket <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> with dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "asyncio",  "name": "unregister",  "code": "proc unregister*(d: Dispatcher; deleg: Delegate)",  "desc": "Unregisters deleg <tt class=\"docutils literal\"><span class=\"pre\">deleg</span></tt> from dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "asyncio",  "name": "isWriteable",  "code": "proc isWriteable*(s: AsyncSocket): bool",  "desc": "Determines whether socket <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is ready to be written to." },  { "module": "asyncio",  "name": "getSocket",  "code": "converter getSocket*(s: AsyncSocket): Socket" },  { "module": "asyncio",  "name": "isConnected",  "code": "proc isConnected*(s: AsyncSocket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is connected." },  { "module": "asyncio",  "name": "isListening",  "code": "proc isListening*(s: AsyncSocket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is listening for incoming connections.  " },  { "module": "asyncio",  "name": "isConnecting",  "code": "proc isConnecting*(s: AsyncSocket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is connecting.  " },  { "module": "asyncio",  "name": "isClosed",  "code": "proc isClosed*(s: AsyncSocket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> has been closed." },  { "module": "asyncio",  "name": "isSendDataBuffered",  "code": "proc isSendDataBuffered*(s: AsyncSocket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> has data waiting to be sent, i.e. whether this socket's sendBuffer contains data. " },  { "module": "asyncio",  "name": "setHandleWrite",  "code": "proc setHandleWrite*(s: AsyncSocket; \u000A                     handleWrite: proc (s: AsyncSocket) {.closure, gcsafe.})",  "desc": "<p>Setter for the <tt class=\"docutils literal\"><span class=\"pre\">handleWrite</span></tt> event.</p>\u000A<p>To remove this event you should use the <tt class=\"docutils literal\"><span class=\"pre\">delHandleWrite</span></tt> function. It is advised to use that function instead of just setting the event to <tt class=\"docutils literal\"><span class=\"pre\">proc (s: AsyncSocket) = nil</span></tt> as that would mean that that function would be called constantly.</p>\u000A" },  { "module": "asyncio",  "name": "delHandleWrite",  "code": "proc delHandleWrite*(s: AsyncSocket)",  "desc": "Removes the <tt class=\"docutils literal\"><span class=\"pre\">handleWrite</span></tt> event handler on <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt>." },  { "module": "asyncio",  "name": "recvLine",  "code": "proc recvLine*(s: AsyncSocket; line: var TaintedString): bool {.deprecated.}",  "desc": "<p>Behaves similar to <tt class=\"docutils literal\"><span class=\"pre\">sockets.recvLine</span></tt>, however it handles non-blocking sockets properly. This function guarantees that <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved.</p>\u000A<p>Unlike <tt class=\"docutils literal\"><span class=\"pre\">sockets.recvLine</span></tt> this function will raise an EOS or ESSL exception if an error occurs.</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function has been deprecated in favour of readLine.</p>\u000A" },  { "module": "asyncio",  "name": "readLine",  "code": "proc readLine*(s: AsyncSocket; line: var TaintedString): bool",  "desc": "<p>Behaves similar to <tt class=\"docutils literal\"><span class=\"pre\">sockets.readLine</span></tt>, however it handles non-blocking sockets properly. This function guarantees that <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved, when this happens False will be returned. True will only be returned if a full line has been retrieved or the socket has been disconnected in which case <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to &quot;&quot;.</p>\u000A<p>This function will raise an EOS exception when a socket error occurs.</p>\u000A" },  { "module": "asyncio",  "name": "send",  "code": "proc send*(sock: AsyncSocket; data: string)",  "desc": "<p>Sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to socket <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt>. This is basically a nicer implementation of <tt class=\"docutils literal\"><span class=\"pre\">sockets.sendAsync</span></tt>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> cannot be sent immediately it will be buffered and sent when <tt class=\"docutils literal\"><span class=\"pre\">sock</span></tt> becomes writeable (during the <tt class=\"docutils literal\"><span class=\"pre\">handleWrite</span></tt> event). It's possible that only a part of <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> will be sent immediately, while the rest of it will be buffered and sent later.</p>\u000A" },  { "module": "asyncio",  "name": "poll",  "code": "proc poll*(d: Dispatcher; timeout: int = 500): bool",  "desc": "<p>This function checks for events on all the delegates in the <cite>PDispatcher</cite>. It then proceeds to call the correct event handler.</p>\u000A<p>This function returns <tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> if there are file descriptors that are still open, otherwise <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt>. File descriptors that have been closed are immediately removed from the dispatcher automatically.</p>\u000A<p><strong>Note:</strong> Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to <tt class=\"docutils literal\"><span class=\"pre\">-1</span></tt> the tasks will only be executed after one or more file descriptors becomes readable or writeable.</p>\u000A" },  { "module": "asyncio",  "name": "len",  "code": "proc len*(disp: Dispatcher): int",  "desc": "Retrieves the amount of delegates in <tt class=\"docutils literal\"><span class=\"pre\">disp</span></tt>." },  { "module": "asyncnet",  "name": "newAsyncSocket",  "code": "proc newAsyncSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A                     protocol: Protocol = IPPROTO_TCP; buffered = true): AsyncSocket",  "desc": "Creates a new asynchronous socket." },  { "module": "asyncnet",  "name": "newAsyncSocket",  "code": "proc newAsyncSocket*(domain, typ, protocol: cint; buffered = true): AsyncSocket",  "desc": "Creates a new asynchronous socket." },  { "module": "asyncnet",  "name": "connect",  "code": "proc connect*(socket: AsyncSocket; address: string; port: Port; af = AF_INET) {.\u000A    async.}",  "desc": "<p>Connects <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> to server at <tt class=\"docutils literal\"><span class=\"pre\">address:port</span></tt>.</p>\u000A<p>Returns a <tt class=\"docutils literal\"><span class=\"pre\">Future</span></tt> which will complete when the connection succeeds or an error occurs.</p>\u000A" },  { "module": "asyncnet",  "name": "recv",  "code": "proc recv*(socket: AsyncSocket; size: int; flags = {SocketFlag.SafeDisconn}): Future[\u000A    string] {.async.}",  "desc": "<p>Reads <strong>up to</strong> <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>.</p>\u000A<p>For buffered sockets this function will attempt to read all the requested data. It will read this data in <tt class=\"docutils literal\"><span class=\"pre\">BufferSize</span></tt> chunks.</p>\u000A<p>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</p>\u000A<p>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</p>\u000A<p>If socket is disconnected and no data is available to be read then the future will complete with a value of <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A" },  { "module": "asyncnet",  "name": "send",  "code": "proc send*(socket: AsyncSocket; data: string; flags = {SocketFlag.SafeDisconn}) {.\u000A    async.}",  "desc": "Sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. The returned future will complete once all data has been sent." },  { "module": "asyncnet",  "name": "acceptAddr",  "code": "proc acceptAddr*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[\u000A    tuple[address: string, client: AsyncSocket]]",  "desc": "Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted." },  { "module": "asyncnet",  "name": "accept",  "code": "proc accept*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[\u000A    AsyncSocket]",  "desc": "Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted." },  { "module": "asyncnet",  "name": "recvLine",  "code": "proc recvLine*(socket: AsyncSocket; flags = {SocketFlag.SafeDisconn}): Future[\u000A    string] {.async.}",  "desc": "<p>Reads a line of data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. Returned future will complete once a full line is read or an error occurs.</p>\u000A<p>If a full line is read <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is not added to <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt>, however if solely <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read then <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to it.</p>\u000A<p>If the socket is disconnected, <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p>If the socket is disconnected in the middle of a line (before <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read) then line will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>. The partial line <strong>will be lost</strong>.</p>\u000A<p><strong>Warning</strong>: The <tt class=\"docutils literal\"><span class=\"pre\">Peek</span></tt> flag is not yet implemented.</p>\u000A<p><strong>Warning</strong>: <tt class=\"docutils literal\"><span class=\"pre\">recvLine</span></tt> on unbuffered sockets assumes that the protocol uses <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> to delimit a new line.</p>\u000A" },  { "module": "asyncnet",  "name": "listen",  "code": "proc listen*(socket: AsyncSocket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}",  "desc": "<p>Marks <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> as accepting connections. <tt class=\"docutils literal\"><span class=\"pre\">Backlog</span></tt> specifies the maximum length of the queue of pending connections.</p>\u000A<p>Raises an EOS error upon failure.</p>\u000A" },  { "module": "asyncnet",  "name": "bindAddr",  "code": "proc bindAddr*(socket: AsyncSocket; port = Port(0); address = \"\") {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Binds <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>:<tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> to the socket.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> is &quot;&quot; then ADDR_ANY will be bound.</p>\u000A" },  { "module": "asyncnet",  "name": "close",  "code": "proc close*(socket: AsyncSocket)",  "desc": "Closes the socket." },  { "module": "asyncnet",  "name": "wrapSocket",  "code": "proc wrapSocket*(ctx: SslContext; socket: AsyncSocket)",  "desc": "<p>Wraps a socket in an SSL context. This function effectively turns <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> into an SSL socket.</p>\u000A<p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p>\u000A" },  { "module": "asyncnet",  "name": "getSockOpt",  "code": "proc getSockOpt*(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {.\u000A    tags: [ReadIOEffect].}",  "desc": "Retrieves option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> as a boolean value." },  { "module": "asyncnet",  "name": "setSockOpt",  "code": "proc setSockOpt*(socket: AsyncSocket; opt: SOBool; value: bool; \u000A                 level = SOL_SOCKET) {.tags: [WriteIOEffect].}",  "desc": "Sets option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> to a boolean value specified by <tt class=\"docutils literal\"><span class=\"pre\">value</span></tt>." },  { "module": "base64",  "name": "encode",  "code": "proc encode*[T: SomeInteger | char](s: openarray[T]; lineLen = 75; \u000A                                    newLine = \"\\x0D\\x0A\"): string",  "desc": "encodes <cite>s</cite> into base64 representation. After <cite>lineLen</cite> characters, a <cite>newline</cite> is added." },  { "module": "base64",  "name": "encode",  "code": "proc encode*(s: string; lineLen = 75; newLine = \"\\x0D\\x0A\"): string",  "desc": "encodes <cite>s</cite> into base64 representation. After <cite>lineLen</cite> characters, a <cite>newline</cite> is added." },  { "module": "base64",  "name": "decode",  "code": "proc decode*(s: string): string",  "desc": "decodes a string in base64 representation back into its original form. Whitespace is skipped." },  { "module": "basic2d",  "name": "matrix2d",  "code": "proc matrix2d*(ax, ay, bx, by, tx, ty: float): TMatrix2d {.noInit.}",  "desc": "Creates a new matrix. <cite>ax</cite>,`ay` is the local x axis <cite>bx</cite>,`by` is the local y axis <cite>tx</cite>,`ty` is the translation" },  { "module": "basic2d",  "name": "vector2d",  "code": "proc vector2d*(x, y: float): TVector2d {.noInit, inline.}",  "desc": "Returns a new vector (<cite>x</cite>,`y`)" },  { "module": "basic2d",  "name": "point2d",  "code": "proc point2d*(x, y: float): TPoint2d {.noInit, inline.}",  "desc": "Returns a new point (<cite>x</cite>,`y`)" },  { "module": "basic2d",  "name": "setElements",  "code": "proc setElements*(t: var TMatrix2d; ax, ay, bx, by, tx, ty: float) {.inline.}",  "desc": "Sets arbitrary elements in an existing matrix." },  { "module": "basic2d",  "name": "matrix2d",  "code": "proc matrix2d*(ax, ay, bx, by, tx, ty: float): TMatrix2d" },  { "module": "basic2d",  "name": "`&amp;`",  "code": "proc `&`*(a, b: TMatrix2d): TMatrix2d {.noInit.}",  "desc": "Concatenates matrices returning a new matrix." },  { "module": "basic2d",  "name": "scale",  "code": "proc scale*(s: float): TMatrix2d {.noInit.}",  "desc": "Returns a new scale matrix." },  { "module": "basic2d",  "name": "scale",  "code": "proc scale*(s: float; org: TPoint2d): TMatrix2d {.noInit.}",  "desc": "Returns a new scale matrix using, <cite>org</cite> as scale origin." },  { "module": "basic2d",  "name": "stretch",  "code": "proc stretch*(sx, sy: float): TMatrix2d {.noInit.}",  "desc": "Returns new a stretch matrix, which is a scale matrix with non uniform scale in x and y." },  { "module": "basic2d",  "name": "stretch",  "code": "proc stretch*(sx, sy: float; org: TPoint2d): TMatrix2d {.noInit.}",  "desc": "Returns a new stretch matrix, which is a scale matrix with non uniform scale in x and y. <cite>org</cite> is used as stretch origin." },  { "module": "basic2d",  "name": "move",  "code": "proc move*(dx, dy: float): TMatrix2d {.noInit.}",  "desc": "Returns a new translation matrix." },  { "module": "basic2d",  "name": "move",  "code": "proc move*(v: TVector2d): TMatrix2d {.noInit.}",  "desc": "Returns a new translation matrix from a vector." },  { "module": "basic2d",  "name": "rotate",  "code": "proc rotate*(rad: float): TMatrix2d {.noInit.}",  "desc": "Returns a new rotation matrix, which represents a rotation by <cite>rad</cite> radians" },  { "module": "basic2d",  "name": "rotate",  "code": "proc rotate*(rad: float; org: TPoint2d): TMatrix2d {.noInit.}",  "desc": "Returns a new rotation matrix, which represents a rotation by <cite>rad</cite> radians around the origin <cite>org</cite>" },  { "module": "basic2d",  "name": "mirror",  "code": "proc mirror*(v: TVector2d): TMatrix2d {.noInit.}",  "desc": "Returns a new mirror matrix, mirroring around the line that passes through origo and has the direction of <cite>v</cite>" },  { "module": "basic2d",  "name": "mirror",  "code": "proc mirror*(org: TPoint2d; v: TVector2d): TMatrix2d {.noInit.}",  "desc": "Returns a new mirror matrix, mirroring around the line that passes through <cite>org</cite> and has the direction of <cite>v</cite>" },  { "module": "basic2d",  "name": "skew",  "code": "proc skew*(xskew, yskew: float): TMatrix2d {.noInit.}",  "desc": "Returns a new skew matrix, which has its x axis rotated <cite>xskew</cite> radians from the local x axis, and y axis rotated <cite>yskew</cite> radians from the local y axis" },  { "module": "basic2d",  "name": "`$`",  "code": "proc `$`*(t: TMatrix2d): string {.noInit.}",  "desc": "Returns a string representation of the matrix" },  { "module": "basic2d",  "name": "isUniform",  "code": "proc isUniform*(t: TMatrix2d; tol = 1e-06): bool",  "desc": "Checks if the transform is uniform, that is perpendicular axes of equal lenght, which means (for example) it cannot transform a circle into an ellipse. <cite>tol</cite> is used as tolerance for both equal length comparison and perp. comparison." },  { "module": "basic2d",  "name": "determinant",  "code": "proc determinant*(t: TMatrix2d): float",  "desc": "Computes the determinant of the matrix." },  { "module": "basic2d",  "name": "isMirroring",  "code": "proc isMirroring*(m: TMatrix2d): bool",  "desc": "Checks if the <cite>m</cite> is a mirroring matrix, which means it will reverse direction of a curve transformed with it" },  { "module": "basic2d",  "name": "inverse",  "code": "proc inverse*(m: TMatrix2d): TMatrix2d {.noInit.}",  "desc": "Returns a new matrix, which is the inverse of the matrix If the matrix is not invertible (determinant=0), an EDivByZero will be raised." },  { "module": "basic2d",  "name": "equals",  "code": "proc equals*(m1: TMatrix2d; m2: TMatrix2d; tol = 1e-06): bool",  "desc": "Checks if all elements of <cite>m1`and `m2</cite> is equal within a given tolerance <cite>tol</cite>." },  { "module": "basic2d",  "name": "`=~`",  "code": "proc `=~`*(m1, m2: TMatrix2d): bool",  "desc": "Checks if <cite>m1`and `m2</cite> is aproximately equal, using a tolerance of 1e-6." },  { "module": "basic2d",  "name": "isIdentity",  "code": "proc isIdentity*(m: TMatrix2d; tol = 1e-06): bool",  "desc": "Checks is a matrix is approximately an identity matrix, using <cite>tol</cite> as tolerance for each element." },  { "module": "basic2d",  "name": "apply",  "code": "proc apply*(m: TMatrix2d; x, y: var float; translate = false)",  "desc": "Applies transformation <cite>m</cite> onto <cite>x</cite>,`y`, optionally using the translation part of the matrix." },  { "module": "basic2d",  "name": "vector2d",  "code": "proc vector2d*(x, y: float): TVector2d" },  { "module": "basic2d",  "name": "polarVector2d",  "code": "proc polarVector2d*(ang: float; len: float): TVector2d {.noInit.}",  "desc": "Returns a new vector with angle <cite>ang</cite> and magnitude <cite>len</cite>" },  { "module": "basic2d",  "name": "slopeVector2d",  "code": "proc slopeVector2d*(slope: float; len: float): TVector2d {.noInit.}",  "desc": "Returns a new vector having slope (dy/dx) given by <cite>slope</cite>, and a magnitude of <cite>len</cite>" },  { "module": "basic2d",  "name": "len",  "code": "proc len*(v: TVector2d): float {.inline.}",  "desc": "Returns the length of the vector." },  { "module": "basic2d",  "name": "`len=`",  "code": "proc `len =`*(v: var TVector2d; newlen: float) {.noInit.}",  "desc": "Sets the length of the vector, keeping its angle." },  { "module": "basic2d",  "name": "sqrLen",  "code": "proc sqrLen*(v: TVector2d): float {.inline.}",  "desc": "Computes the squared length of the vector, which is faster than computing the absolute length." },  { "module": "basic2d",  "name": "angle",  "code": "proc angle*(v: TVector2d): float",  "desc": "Returns the angle of the vector. (The counter clockwise plane angle between posetive x axis and <cite>v</cite>)" },  { "module": "basic2d",  "name": "`$`",  "code": "proc `$`*(v: TVector2d): string",  "desc": "String representation of <cite>v</cite>" },  { "module": "basic2d",  "name": "`&amp;`",  "code": "proc `&`*(v: TVector2d; m: TMatrix2d): TVector2d {.noInit.}",  "desc": "Concatenate vector <cite>v</cite> with a transformation matrix. Transforming a vector ignores the translational part of the matrix." },  { "module": "basic2d",  "name": "`&amp;=`",  "code": "proc `&=`*(v: var TVector2d; m: TMatrix2d) {.inline.}",  "desc": "Applies transformation <cite>m</cite> onto <cite>v</cite> in place. Transforming a vector ignores the translational part of the matrix." },  { "module": "basic2d",  "name": "tryNormalize",  "code": "proc tryNormalize*(v: var TVector2d): bool",  "desc": "Modifies <cite>v</cite> to have a length of 1.0, keeping its angle. If <cite>v</cite> has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned." },  { "module": "basic2d",  "name": "normalize",  "code": "proc normalize*(v: var TVector2d) {.inline.}",  "desc": "Modifies <cite>v</cite> to have a length of 1.0, keeping its angle. If  <cite>v</cite> has zero length, an EDivByZero will be raised." },  { "module": "basic2d",  "name": "transformNorm",  "code": "proc transformNorm*(v: var TVector2d; t: TMatrix2d)",  "desc": "Applies a normal direction transformation <cite>t</cite> onto <cite>v</cite> in place. The resulting vector is <em>not</em> normalized.  Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised." },  { "module": "basic2d",  "name": "transformInv",  "code": "proc transformInv*(v: var TVector2d; t: TMatrix2d)",  "desc": "Applies inverse of a transformation <cite>t</cite> to <cite>v</cite> in place. This is faster than creating an inverse matrix and apply() it. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised." },  { "module": "basic2d",  "name": "transformNormInv",  "code": "proc transformNormInv*(v: var TVector2d; t: TMatrix2d)",  "desc": "Applies an inverse normal direction transformation <cite>t</cite> onto <cite>v</cite> in place. This is faster than creating an inverse matrix and transformNorm(...) it. Transforming a vector ignores the translational part of the matrix." },  { "module": "basic2d",  "name": "rotate90",  "code": "proc rotate90*(v: var TVector2d) {.inline.}",  "desc": "Quickly rotates vector <cite>v</cite> 90 degrees counter clockwise, without using any trigonometrics." },  { "module": "basic2d",  "name": "rotate180",  "code": "proc rotate180*(v: var TVector2d) {.inline.}",  "desc": "Quickly rotates vector <cite>v</cite> 180 degrees counter clockwise, without using any trigonometrics." },  { "module": "basic2d",  "name": "rotate270",  "code": "proc rotate270*(v: var TVector2d) {.inline.}",  "desc": "Quickly rotates vector <cite>v</cite> 270 degrees counter clockwise, without using any trigonometrics." },  { "module": "basic2d",  "name": "rotate",  "code": "proc rotate*(v: var TVector2d; rad: float)",  "desc": "Rotates vector <cite>v</cite> <cite>rad</cite> radians in place." },  { "module": "basic2d",  "name": "scale",  "code": "proc scale*(v: var TVector2d; fac: float) {.inline.}",  "desc": "Scales vector <cite>v</cite> <cite>rad</cite> radians in place." },  { "module": "basic2d",  "name": "stretch",  "code": "proc stretch*(v: var TVector2d; facx, facy: float) {.inline.}",  "desc": "Stretches vector <cite>v</cite> <cite>facx</cite> times horizontally, and <cite>facy</cite> times vertically." },  { "module": "basic2d",  "name": "mirror",  "code": "proc mirror*(v: var TVector2d; mirrvec: TVector2d)",  "desc": "Mirrors vector <cite>v</cite> using <cite>mirrvec</cite> as mirror direction." },  { "module": "basic2d",  "name": "`-`",  "code": "proc `-`*(v: TVector2d): TVector2d",  "desc": "Negates a vector" },  { "module": "basic2d",  "name": "dot",  "code": "proc dot*(v1, v2: TVector2d): float",  "desc": "Computes the dot product of two vectors. Returns 0.0 if the vectors are perpendicular." },  { "module": "basic2d",  "name": "cross",  "code": "proc cross*(v1, v2: TVector2d): float",  "desc": "Computes the cross product of two vectors, also called the 'perpendicular dot product' in 2d. Returns 0.0 if the vectors are parallel." },  { "module": "basic2d",  "name": "equals",  "code": "proc equals*(v1, v2: TVector2d; tol = 1e-06): bool",  "desc": "Checks if two vectors approximately equals with a tolerance." },  { "module": "basic2d",  "name": "`=~`",  "code": "proc `=~`*(v1, v2: TVector2d): bool",  "desc": "Checks if two vectors approximately equals with a hardcoded tolerance 1e-6" },  { "module": "basic2d",  "name": "angleTo",  "code": "proc angleTo*(v1, v2: TVector2d): float",  "desc": "Returns the smallest of the two possible angles between <cite>v1</cite> and <cite>v2</cite> in radians." },  { "module": "basic2d",  "name": "angleCCW",  "code": "proc angleCCW*(v1, v2: TVector2d): float",  "desc": "Returns the counter clockwise plane angle from <cite>v1</cite> to <cite>v2</cite>, in range 0 - 2*PI" },  { "module": "basic2d",  "name": "angleCW",  "code": "proc angleCW*(v1, v2: TVector2d): float",  "desc": "Returns the clockwise plane angle from <cite>v1</cite> to <cite>v2</cite>, in range 0 - 2*PI" },  { "module": "basic2d",  "name": "turnAngle",  "code": "proc turnAngle*(v1, v2: TVector2d): float",  "desc": "Returns the amount v1 should be rotated (in radians) to equal v2, in range -PI to PI" },  { "module": "basic2d",  "name": "bisect",  "code": "proc bisect*(v1, v2: TVector2d): TVector2d {.noInit.}",  "desc": "Computes the bisector between v1 and v2 as a normalized vector. If one of the input vectors has zero length, a normalized version of the other is returned. If both input vectors has zero length, an arbitrary normalized vector is returned." },  { "module": "basic2d",  "name": "point2d",  "code": "proc point2d*(x, y: float): TPoint2d" },  { "module": "basic2d",  "name": "sqrDist",  "code": "proc sqrDist*(a, b: TPoint2d): float",  "desc": "Computes the squared distance between <cite>a</cite> and <cite>b</cite>" },  { "module": "basic2d",  "name": "dist",  "code": "proc dist*(a, b: TPoint2d): float {.inline.}",  "desc": "Computes the absolute distance between <cite>a</cite> and <cite>b</cite>" },  { "module": "basic2d",  "name": "angle",  "code": "proc angle*(a, b: TPoint2d): float",  "desc": "Computes the angle of the vector <cite>b</cite>-<cite>a</cite>" },  { "module": "basic2d",  "name": "`$`",  "code": "proc `$`*(p: TPoint2d): string",  "desc": "String representation of <cite>p</cite>" },  { "module": "basic2d",  "name": "`&amp;`",  "code": "proc `&`*(p: TPoint2d; t: TMatrix2d): TPoint2d {.noInit, inline.}",  "desc": "Concatenates a point <cite>p</cite> with a transform <cite>t</cite>, resulting in a new, transformed point." },  { "module": "basic2d",  "name": "`&amp;=`",  "code": "proc `&=`*(p: var TPoint2d; t: TMatrix2d) {.inline.}",  "desc": "Applies transformation <cite>t</cite> onto <cite>p</cite> in place." },  { "module": "basic2d",  "name": "transformInv",  "code": "proc transformInv*(p: var TPoint2d; t: TMatrix2d) {.inline.}",  "desc": "Applies the inverse of transformation <cite>t</cite> onto <cite>p</cite> in place. If the matrix is not invertable (determinant=0) , EDivByZero will be raised." },  { "module": "basic2d",  "name": "`+`",  "code": "proc `+`*(p: TPoint2d; v: TVector2d): TPoint2d {.noInit, inline.}",  "desc": "Adds a vector <cite>v</cite> to a point <cite>p</cite>, resulting in a new point." },  { "module": "basic2d",  "name": "`+=`",  "code": "proc `+=`*(p: var TPoint2d; v: TVector2d) {.noInit, inline.}",  "desc": "Adds a vector <cite>v</cite> to a point <cite>p</cite> in place." },  { "module": "basic2d",  "name": "`-`",  "code": "proc `-`*(p: TPoint2d; v: TVector2d): TPoint2d {.noInit, inline.}",  "desc": "Subtracts a vector <cite>v</cite> from a point <cite>p</cite>, resulting in a new point." },  { "module": "basic2d",  "name": "`-`",  "code": "proc `-`*(p1, p2: TPoint2d): TVector2d {.noInit, inline.}",  "desc": "Subtracts <cite>p2`from `p1</cite> resulting in a difference vector." },  { "module": "basic2d",  "name": "`-=`",  "code": "proc `-=`*(p: var TPoint2d; v: TVector2d) {.noInit, inline.}",  "desc": "Subtracts a vector <cite>v</cite> from a point <cite>p</cite> in place." },  { "module": "basic2d",  "name": "`=~`",  "code": "proc `=~`*(p1, p2: TPoint2d): bool {.inline.}",  "desc": "Checks if two vectors approximately equals with a hardcoded tolerance 1e-6" },  { "module": "basic2d",  "name": "polar",  "code": "proc polar*(p: TPoint2d; ang, dist: float): TPoint2d {.noInit.}",  "desc": "Returns a point with a given angle and distance away from <cite>p</cite>" },  { "module": "basic2d",  "name": "rotate",  "code": "proc rotate*(p: var TPoint2d; rad: float)",  "desc": "Rotates a point in place <cite>rad</cite> radians around origo." },  { "module": "basic2d",  "name": "rotate",  "code": "proc rotate*(p: var TPoint2d; rad: float; org: TPoint2d)",  "desc": "Rotates a point in place <cite>rad</cite> radians using <cite>org</cite> as center of rotation." },  { "module": "basic2d",  "name": "scale",  "code": "proc scale*(p: var TPoint2d; fac: float) {.inline.}",  "desc": "Scales a point in place <cite>fac</cite> times with world origo as origin." },  { "module": "basic2d",  "name": "scale",  "code": "proc scale*(p: var TPoint2d; fac: float; org: TPoint2d) {.inline.}",  "desc": "Scales the point in place <cite>fac</cite> times with <cite>org</cite> as origin." },  { "module": "basic2d",  "name": "stretch",  "code": "proc stretch*(p: var TPoint2d; facx, facy: float) {.inline.}",  "desc": "Scales a point in place non uniformly <cite>facx</cite> and <cite>facy</cite> times with world origo as origin." },  { "module": "basic2d",  "name": "stretch",  "code": "proc stretch*(p: var TPoint2d; facx, facy: float; org: TPoint2d) {.inline.}",  "desc": "Scales the point in place non uniformly <cite>facx</cite> and <cite>facy</cite> times with <cite>org</cite> as origin." },  { "module": "basic2d",  "name": "move",  "code": "proc move*(p: var TPoint2d; dx, dy: float) {.inline.}",  "desc": "Translates a point <cite>dx</cite>, <cite>dy</cite> in place." },  { "module": "basic2d",  "name": "move",  "code": "proc move*(p: var TPoint2d; v: TVector2d) {.inline.}",  "desc": "Translates a point with vector <cite>v</cite> in place." },  { "module": "basic2d",  "name": "sgnArea",  "code": "proc sgnArea*(a, b, c: TPoint2d): float",  "desc": "Computes the signed area of the triangle thru points <cite>a</cite>,`b` and <cite>c</cite> result&gt;0.0 for counter clockwise triangle result&lt;0.0 for clockwise triangle This is commonly used to determinate side of a point with respect to a line." },  { "module": "basic2d",  "name": "area",  "code": "proc area*(a, b, c: TPoint2d): float",  "desc": "Computes the area of the triangle thru points <cite>a</cite>,`b` and <cite>c</cite>" },  { "module": "basic2d",  "name": "closestPoint",  "code": "proc closestPoint*(p: TPoint2d; pts: varargs[TPoint2d]): TPoint2d",  "desc": "Returns a point selected from <cite>pts</cite>, that has the closest euclidean distance to <cite>p</cite>" },  { "module": "basic2d",  "name": "normAngle",  "code": "proc normAngle*(ang: float): float",  "desc": "Returns an angle in radians, that is equal to <cite>ang</cite>, but in the range 0 to &lt;2*PI" },  { "module": "basic2d",  "name": "degToRad",  "code": "proc degToRad*(deg: float): float {.inline.}",  "desc": "converts <cite>deg</cite> degrees to radians" },  { "module": "basic2d",  "name": "radToDeg",  "code": "proc radToDeg*(rad: float): float {.inline.}",  "desc": "converts <cite>rad</cite> radians to degrees" },  { "module": "browsers",  "name": "openDefaultBrowser",  "code": "proc openDefaultBrowser*(url: string)",  "desc": "<p>opens <cite>url</cite> with the user's default browser. This does not block.</p>\u000A<p>Under Windows, <tt class=\"docutils literal\"><span class=\"pre\">ShellExecute</span></tt> is used. Under Mac OS X the <tt class=\"docutils literal\"><span class=\"pre\">open</span></tt> command is used. Under Unix, it is checked if <tt class=\"docutils literal\"><span class=\"pre\">gnome-open</span></tt> exists and used if it does. Next attempt is <tt class=\"docutils literal\"><span class=\"pre\">kde-open</span></tt>, then <tt class=\"docutils literal\"><span class=\"pre\">xdg-open</span></tt>. Otherwise the environment variable <tt class=\"docutils literal\"><span class=\"pre\">BROWSER</span></tt> is used to determine the default browser to use.</p>\u000A" },  { "module": "cgi",  "name": "encodeUrl",  "code": "proc encodeUrl*(s: string): string",  "desc": "Encodes a value to be HTTP safe: This means that characters in the set <tt class=\"docutils literal\"><span class=\"pre\">{'A'..'Z', 'a'..'z', '0'..'9', '_'}</span></tt> are carried over to the result, a space is converted to <tt class=\"docutils literal\"><span class=\"pre\">'+'</span></tt> and every other character is encoded as <tt class=\"docutils literal\"><span class=\"pre\">'%xx'</span></tt> where <tt class=\"docutils literal\"><span class=\"pre\">xx</span></tt> denotes its hexadecimal value." },  { "module": "cgi",  "name": "decodeUrl",  "code": "proc decodeUrl*(s: string): string",  "desc": "Decodes a value from its HTTP representation: This means that a <tt class=\"docutils literal\"><span class=\"pre\">'+'</span></tt> is converted to a space, <tt class=\"docutils literal\"><span class=\"pre\">'%xx'</span></tt> (where <tt class=\"docutils literal\"><span class=\"pre\">xx</span></tt> denotes a hexadecimal value) is converted to the character with ordinal number <tt class=\"docutils literal\"><span class=\"pre\">xx</span></tt>, and and every other character is carried over." },  { "module": "cgi",  "name": "xmlEncode",  "code": "proc xmlEncode*(s: string): string",  "desc": "Encodes a value to be XML safe:<ul class=\"simple\"><li><tt class=\"docutils literal\"><span class=\"pre\">&quot;</span></tt> is replaced by <tt class=\"docutils literal\"><span class=\"pre\">&amp;quot;</span></tt></li>\u000A<li><tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> is replaced by <tt class=\"docutils literal\"><span class=\"pre\">&amp;lt;</span></tt></li>\u000A<li><tt class=\"docutils literal\"><span class=\"pre\">&gt;</span></tt> is replaced by <tt class=\"docutils literal\"><span class=\"pre\">&amp;gt;</span></tt></li>\u000A<li><tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt> is replaced by <tt class=\"docutils literal\"><span class=\"pre\">&amp;amp;</span></tt></li>\u000A<li>every other character is carried over.</li>\u000A</ul>\u000A" },  { "module": "cgi",  "name": "cgiError",  "code": "proc cgiError*(msg: string) {.noreturn.}",  "desc": "raises an ECgi exception with message <cite>msg</cite>." },  { "module": "cgi",  "name": "decodeData",  "code": "iterator decodeData*(data: string): tuple[key, value: TaintedString]",  "desc": "Reads and decodes CGI data and yields the (name, value) pairs the data consists of." },  { "module": "cgi",  "name": "decodeData",  "code": "iterator decodeData*(allowedMethods: set[RequestMethod] = {methodNone, \u000A    methodPost, methodGet}): tuple[key, value: TaintedString]",  "desc": "Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the <cite>allowedMethods</cite> set, an <cite>ECgi</cite> exception is raised." },  { "module": "cgi",  "name": "readData",  "code": "proc readData*(allowedMethods: set[RequestMethod] = {methodNone, methodPost, \u000A    methodGet}): StringTableRef",  "desc": "Read CGI data. If the client does not use a method listed in the <cite>allowedMethods</cite> set, an <cite>ECgi</cite> exception is raised." },  { "module": "cgi",  "name": "validateData",  "code": "proc validateData*(data: StringTableRef; validKeys: varargs[string])",  "desc": "validates data; raises <cite>ECgi</cite> if this fails. This checks that each variable name of the CGI <cite>data</cite> occurs in the <cite>validKeys</cite> array." },  { "module": "cgi",  "name": "getContentLength",  "code": "proc getContentLength*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">CONTENT_LENGTH</span></tt> environment variable" },  { "module": "cgi",  "name": "getContentType",  "code": "proc getContentType*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">CONTENT_TYPE</span></tt> environment variable" },  { "module": "cgi",  "name": "getDocumentRoot",  "code": "proc getDocumentRoot*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">DOCUMENT_ROOT</span></tt> environment variable" },  { "module": "cgi",  "name": "getGatewayInterface",  "code": "proc getGatewayInterface*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">GATEWAY_INTERFACE</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpAccept",  "code": "proc getHttpAccept*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_ACCEPT</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpAcceptCharset",  "code": "proc getHttpAcceptCharset*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_ACCEPT_CHARSET</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpAcceptEncoding",  "code": "proc getHttpAcceptEncoding*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_ACCEPT_ENCODING</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpAcceptLanguage",  "code": "proc getHttpAcceptLanguage*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_ACCEPT_LANGUAGE</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpConnection",  "code": "proc getHttpConnection*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_CONNECTION</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpCookie",  "code": "proc getHttpCookie*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_COOKIE</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpHost",  "code": "proc getHttpHost*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_HOST</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpReferer",  "code": "proc getHttpReferer*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_REFERER</span></tt> environment variable" },  { "module": "cgi",  "name": "getHttpUserAgent",  "code": "proc getHttpUserAgent*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">HTTP_USER_AGENT</span></tt> environment variable" },  { "module": "cgi",  "name": "getPathInfo",  "code": "proc getPathInfo*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">PATH_INFO</span></tt> environment variable" },  { "module": "cgi",  "name": "getPathTranslated",  "code": "proc getPathTranslated*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">PATH_TRANSLATED</span></tt> environment variable" },  { "module": "cgi",  "name": "getQueryString",  "code": "proc getQueryString*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">QUERY_STRING</span></tt> environment variable" },  { "module": "cgi",  "name": "getRemoteAddr",  "code": "proc getRemoteAddr*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REMOTE_ADDR</span></tt> environment variable" },  { "module": "cgi",  "name": "getRemoteHost",  "code": "proc getRemoteHost*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REMOTE_HOST</span></tt> environment variable" },  { "module": "cgi",  "name": "getRemoteIdent",  "code": "proc getRemoteIdent*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REMOTE_IDENT</span></tt> environment variable" },  { "module": "cgi",  "name": "getRemotePort",  "code": "proc getRemotePort*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REMOTE_PORT</span></tt> environment variable" },  { "module": "cgi",  "name": "getRemoteUser",  "code": "proc getRemoteUser*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REMOTE_USER</span></tt> environment variable" },  { "module": "cgi",  "name": "getRequestMethod",  "code": "proc getRequestMethod*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REQUEST_METHOD</span></tt> environment variable" },  { "module": "cgi",  "name": "getRequestURI",  "code": "proc getRequestURI*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">REQUEST_URI</span></tt> environment variable" },  { "module": "cgi",  "name": "getScriptFilename",  "code": "proc getScriptFilename*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SCRIPT_FILENAME</span></tt> environment variable" },  { "module": "cgi",  "name": "getScriptName",  "code": "proc getScriptName*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SCRIPT_NAME</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerAddr",  "code": "proc getServerAddr*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_ADDR</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerAdmin",  "code": "proc getServerAdmin*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_ADMIN</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerName",  "code": "proc getServerName*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_NAME</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerPort",  "code": "proc getServerPort*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_PORT</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerProtocol",  "code": "proc getServerProtocol*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_PROTOCOL</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerSignature",  "code": "proc getServerSignature*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_SIGNATURE</span></tt> environment variable" },  { "module": "cgi",  "name": "getServerSoftware",  "code": "proc getServerSoftware*(): string",  "desc": "returns contents of the <tt class=\"docutils literal\"><span class=\"pre\">SERVER_SOFTWARE</span></tt> environment variable" },  { "module": "cgi",  "name": "setTestData",  "code": "proc setTestData*(keysvalues: varargs[string])",  "desc": "fills the appropriate environment variables to test your CGI application. This can only simulate the 'GET' request method. <cite>keysvalues</cite> should provide embedded (name, value)-pairs. Example:<pre><span class=\"Identifier\">setTestData</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;name&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Hanz&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;password&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;12345&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "cgi",  "name": "writeContentType",  "code": "proc writeContentType*()",  "desc": "call this before starting to send your HTML data to <cite>stdout</cite>. This implements this part of the CGI protocol:<pre><span class=\"Identifier\">write</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Content-type: text/html</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">\\n</span><span class=\"StringLit\">&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "cgi",  "name": "writeErrorMessage",  "code": "proc writeErrorMessage*(data: string)",  "desc": "Tries to reset browser state and writes <cite>data</cite> to stdout in &lt;plaintext&gt; tag." },  { "module": "cgi",  "name": "setStackTraceStdout",  "code": "proc setStackTraceStdout*()",  "desc": "Makes Nim output stacktraces to stdout, instead of server log." },  { "module": "cgi",  "name": "setStackTraceNewLine",  "code": "proc setStackTraceNewLine*() {.deprecated.}",  "desc": "Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout." },  { "module": "cgi",  "name": "setCookie",  "code": "proc setCookie*(name, value: string)",  "desc": "Sets a cookie." },  { "module": "cgi",  "name": "getCookie",  "code": "proc getCookie*(name: string): TaintedString",  "desc": "Gets a cookie. If no cookie of <cite>name</cite> exists, &quot;&quot; is returned." },  { "module": "cgi",  "name": "existsCookie",  "code": "proc existsCookie*(name: string): bool",  "desc": "Checks if a cookie of <cite>name</cite> exists." },  { "module": "colors",  "name": "`==`",  "code": "proc `==`*(a, b: Color): bool {.borrow.}",  "desc": "compares two colors." },  { "module": "colors",  "name": "`+`",  "code": "proc `+`*(a, b: Color): Color",  "desc": "adds two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum)." },  { "module": "colors",  "name": "`-`",  "code": "proc `-`*(a, b: Color): Color",  "desc": "substracts two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum)." },  { "module": "colors",  "name": "extractRGB",  "code": "proc extractRGB*(a: Color): tuple[r, g, b: range[0 .. 255]]",  "desc": "extracts the red/green/blue components of the color <cite>a</cite>." },  { "module": "colors",  "name": "intensity",  "code": "proc intensity*(a: Color; f: float): Color",  "desc": "returns <cite>a</cite> with intensity <cite>f</cite>. <cite>f</cite> should be a float from 0.0 (completely dark) to 1.0 (full color intensity)." },  { "module": "colors",  "name": "mix",  "code": "template mix*(a, b: Color; fn: expr): expr",  "desc": "uses <cite>fn</cite> to mix the colors <cite>a</cite> and <cite>b</cite>. <cite>fn</cite> is invoked for each component R, G, and B. This is a template because <cite>fn</cite> should be inlined and the compiler cannot inline proc pointers yet. If <cite>fn</cite>'s result is not in the range[0..255], it will be saturated to be so." },  { "module": "colors",  "name": "`$`",  "code": "proc `$`*(c: Color): string",  "desc": "converts a color into its textual representation. Example: <tt class=\"docutils literal\"><span class=\"pre\">#00FF00</span></tt>." },  { "module": "colors",  "name": "parseColor",  "code": "proc parseColor*(name: string): Color",  "desc": "parses <cite>name</cite> to a color value. If no valid color could be parsed <tt class=\"docutils literal\"><span class=\"pre\">EInvalidValue</span></tt> is raised." },  { "module": "colors",  "name": "isColor",  "code": "proc isColor*(name: string): bool",  "desc": "returns true if <cite>name</cite> is a known color name or a hexadecimal color prefixed with <tt class=\"docutils literal\"><span class=\"pre\">#</span></tt>." },  { "module": "colors",  "name": "rgb",  "code": "proc rgb*(r, g, b: range[0 .. 255]): Color",  "desc": "constructs a color from RGB values." },  { "module": "complex",  "name": "`==`",  "code": "proc `==`*(x, y: Complex): bool",  "desc": "Compare two complex numbers <cite>x</cite> and <cite>y</cite> for equality." },  { "module": "complex",  "name": "`=~`",  "code": "proc `=~`*(x, y: Complex): bool",  "desc": "Compare two complex numbers <cite>x</cite> and <cite>y</cite> approximately." },  { "module": "complex",  "name": "`+`",  "code": "proc `+`*(x, y: Complex): Complex",  "desc": "Add two complex numbers." },  { "module": "complex",  "name": "`+`",  "code": "proc `+`*(x: Complex; y: float): Complex",  "desc": "Add complex <cite>x</cite> to float <cite>y</cite>." },  { "module": "complex",  "name": "`+`",  "code": "proc `+`*(x: float; y: Complex): Complex",  "desc": "Add float <cite>x</cite> to complex <cite>y</cite>." },  { "module": "complex",  "name": "`-`",  "code": "proc `-`*(z: Complex): Complex",  "desc": "Unary minus for complex numbers." },  { "module": "complex",  "name": "`-`",  "code": "proc `-`*(x, y: Complex): Complex",  "desc": "Subtract two complex numbers." },  { "module": "complex",  "name": "`-`",  "code": "proc `-`*(x: Complex; y: float): Complex",  "desc": "Subtracts float <cite>y</cite> from complex <cite>x</cite>." },  { "module": "complex",  "name": "`-`",  "code": "proc `-`*(x: float; y: Complex): Complex",  "desc": "Subtracts complex <cite>y</cite> from float <cite>x</cite>." },  { "module": "complex",  "name": "`/`",  "code": "proc `/`*(x, y: Complex): Complex",  "desc": "Divide <cite>x</cite> by <cite>y</cite>." },  { "module": "complex",  "name": "`/`",  "code": "proc `/`*(x: Complex; y: float): Complex",  "desc": "Divide complex <cite>x</cite> by float <cite>y</cite>." },  { "module": "complex",  "name": "`/`",  "code": "proc `/`*(x: float; y: Complex): Complex",  "desc": "Divide float <cite>x</cite> by complex <cite>y</cite>." },  { "module": "complex",  "name": "`*`",  "code": "proc `*`*(x, y: Complex): Complex",  "desc": "Multiply <cite>x</cite> with <cite>y</cite>." },  { "module": "complex",  "name": "`*`",  "code": "proc `*`*(x: float; y: Complex): Complex",  "desc": "Multiply float <cite>x</cite> with complex <cite>y</cite>." },  { "module": "complex",  "name": "`*`",  "code": "proc `*`*(x: Complex; y: float): Complex",  "desc": "Multiply complex <cite>x</cite> with float <cite>y</cite>." },  { "module": "complex",  "name": "`+=`",  "code": "proc `+=`*(x: var Complex; y: Complex)",  "desc": "Add <cite>y</cite> to <cite>x</cite>." },  { "module": "complex",  "name": "`+=`",  "code": "proc `+=`*(x: var Complex; y: float)",  "desc": "Add <cite>y</cite> to the complex number <cite>x</cite>." },  { "module": "complex",  "name": "`-=`",  "code": "proc `-=`*(x: var Complex; y: Complex)",  "desc": "Subtract <cite>y</cite> from <cite>x</cite>." },  { "module": "complex",  "name": "`-=`",  "code": "proc `-=`*(x: var Complex; y: float)",  "desc": "Subtract <cite>y</cite> from the complex number <cite>x</cite>." },  { "module": "complex",  "name": "`*=`",  "code": "proc `*=`*(x: var Complex; y: Complex)",  "desc": "Multiply <cite>y</cite> to <cite>x</cite>." },  { "module": "complex",  "name": "`*=`",  "code": "proc `*=`*(x: var Complex; y: float)",  "desc": "Multiply <cite>y</cite> to the complex number <cite>x</cite>." },  { "module": "complex",  "name": "`/=`",  "code": "proc `/=`*(x: var Complex; y: Complex)",  "desc": "Divide <cite>x</cite> by <cite>y</cite> in place." },  { "module": "complex",  "name": "`/=`",  "code": "proc `/=`*(x: var Complex; y: float)",  "desc": "Divide complex <cite>x</cite> by float <cite>y</cite> in place." },  { "module": "complex",  "name": "abs",  "code": "proc abs*(z: Complex): float",  "desc": "Return the distance from (0,0) to <cite>z</cite>." },  { "module": "complex",  "name": "sqrt",  "code": "proc sqrt*(z: Complex): Complex",  "desc": "Square root for a complex number <cite>z</cite>." },  { "module": "complex",  "name": "exp",  "code": "proc exp*(z: Complex): Complex",  "desc": "e raised to the power <cite>z</cite>." },  { "module": "complex",  "name": "ln",  "code": "proc ln*(z: Complex): Complex",  "desc": "Returns the natural log of <cite>z</cite>." },  { "module": "complex",  "name": "log10",  "code": "proc log10*(z: Complex): Complex",  "desc": "Returns the log base 10 of <cite>z</cite>." },  { "module": "complex",  "name": "log2",  "code": "proc log2*(z: Complex): Complex",  "desc": "Returns the log base 2 of <cite>z</cite>." },  { "module": "complex",  "name": "pow",  "code": "proc pow*(x, y: Complex): Complex",  "desc": "<cite>x</cite> raised to the power <cite>y</cite>." },  { "module": "complex",  "name": "sin",  "code": "proc sin*(z: Complex): Complex",  "desc": "Returns the sine of <cite>z</cite>." },  { "module": "complex",  "name": "arcsin",  "code": "proc arcsin*(z: Complex): Complex",  "desc": "Returns the inverse sine of <cite>z</cite>." },  { "module": "complex",  "name": "cos",  "code": "proc cos*(z: Complex): Complex",  "desc": "Returns the cosine of <cite>z</cite>." },  { "module": "complex",  "name": "arccos",  "code": "proc arccos*(z: Complex): Complex",  "desc": "Returns the inverse cosine of <cite>z</cite>." },  { "module": "complex",  "name": "tan",  "code": "proc tan*(z: Complex): Complex",  "desc": "Returns the tangent of <cite>z</cite>." },  { "module": "complex",  "name": "cot",  "code": "proc cot*(z: Complex): Complex",  "desc": "Returns the cotangent of <cite>z</cite>." },  { "module": "complex",  "name": "sec",  "code": "proc sec*(z: Complex): Complex",  "desc": "Returns the secant of <cite>z</cite>." },  { "module": "complex",  "name": "csc",  "code": "proc csc*(z: Complex): Complex",  "desc": "Returns the cosecant of <cite>z</cite>." },  { "module": "complex",  "name": "sinh",  "code": "proc sinh*(z: Complex): Complex",  "desc": "Returns the hyperbolic sine of <cite>z</cite>." },  { "module": "complex",  "name": "cosh",  "code": "proc cosh*(z: Complex): Complex",  "desc": "Returns the hyperbolic cosine of <cite>z</cite>." },  { "module": "complex",  "name": "`$`",  "code": "proc `$`*(z: Complex): string",  "desc": "Returns <cite>z</cite>'s string representation as <tt class=\"docutils literal\"><span class=\"pre\">&quot;(re, im)&quot;</span></tt>." },  { "module": "cookies",  "name": "parseCookies",  "code": "proc parseCookies*(s: string): StringTableRef",  "desc": "parses cookies into a string table." },  { "module": "cookies",  "name": "setCookie",  "code": "proc setCookie*(key, value: string; domain = \"\"; path = \"\"; expires = \"\"; \u000A                noName = false; secure = false; httpOnly = false): string",  "desc": "Creates a command in the format of <tt class=\"docutils literal\"><span class=\"pre\">Set-Cookie: key=value; Domain=...; ...</span></tt>" },  { "module": "cookies",  "name": "setCookie",  "code": "proc setCookie*(key, value: string; expires: TimeInfo; domain = \"\"; path = \"\"; \u000A                noName = false; secure = false; httpOnly = false): string",  "desc": "<p>Creates a command in the format of <tt class=\"docutils literal\"><span class=\"pre\">Set-Cookie: key=value; Domain=...; ...</span></tt></p>\u000A<p><strong>Note:</strong> UTC is assumed as the timezone for <tt class=\"docutils literal\"><span class=\"pre\">expires</span></tt>.  </p>\u000A" },  { "module": "cpuinfo",  "name": "countProcessors",  "code": "proc countProcessors*(): int {.rtl, extern: \"ncpi$1\".}",  "desc": "returns the numer of the processors/cores the machine has. Returns 0 if it cannot be detected." },  { "module": "cpuload",  "name": "advice",  "code": "proc advice*(s: var ThreadPoolState): ThreadPoolAdvice" },  { "module": "critbits",  "name": "len",  "code": "proc len*[T](c: CritBitTree[T]): int",  "desc": "returns the number of elements in <cite>c</cite> in O(1)." },  { "module": "critbits",  "name": "contains",  "code": "proc contains*[T](c: CritBitTree[T]; key: string): bool {.inline.}",  "desc": "returns true iff <cite>c</cite> contains the given <cite>key</cite>." },  { "module": "critbits",  "name": "hasKey",  "code": "proc hasKey*[T](c: CritBitTree[T]; key: string): bool {.inline.}",  "desc": "alias for <cite>contains</cite>." },  { "module": "critbits",  "name": "containsOrIncl",  "code": "proc containsOrIncl*[T](c: var CritBitTree[T]; key: string; val: T): bool",  "desc": "returns true iff <cite>c</cite> contains the given <cite>key</cite>. If the key does not exist <tt class=\"docutils literal\"><span class=\"pre\">c[key] = val</span></tt> is performed." },  { "module": "critbits",  "name": "containsOrIncl",  "code": "proc containsOrIncl*(c: var CritBitTree[void]; key: string): bool",  "desc": "returns true iff <cite>c</cite> contains the given <cite>key</cite>. If the key does not exist it is inserted into <cite>c</cite>." },  { "module": "critbits",  "name": "incl",  "code": "proc incl*(c: var CritBitTree[void]; key: string)",  "desc": "includes <cite>key</cite> in <cite>c</cite>." },  { "module": "critbits",  "name": "`[]=`",  "code": "proc `[]=`*[T](c: var CritBitTree[T]; key: string; val: T)",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "critbits",  "name": "`[]`",  "code": "proc `[]`*[T](c: CritBitTree[T]; key: string): T {.inline.}",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">c[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, default empty value for the type <cite>B</cite> is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "critbits",  "name": "mget",  "code": "proc mget*[T](c: var CritBitTree[T]; key: string): var T {.inline.}",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">c[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">KeyError</span></tt> exception is raised." },  { "module": "critbits",  "name": "excl",  "code": "proc excl*[T](c: var CritBitTree[T]; key: string)",  "desc": "removes <cite>key</cite> (and its associated value) from the set <cite>c</cite>. If the <cite>key</cite> does not exist, nothing happens." },  { "module": "critbits",  "name": "keys",  "code": "iterator keys*[T](c: CritBitTree[T]): string",  "desc": "yields all keys in lexicographical order." },  { "module": "critbits",  "name": "values",  "code": "iterator values*[T](c: CritBitTree[T]): T",  "desc": "yields all values of <cite>c</cite> in the lexicographical order of the corresponding keys." },  { "module": "critbits",  "name": "mvalues",  "code": "iterator mvalues*[T](c: var CritBitTree[T]): var T",  "desc": "yields all values of <cite>c</cite> in the lexicographical order of the corresponding keys. The values can be modified." },  { "module": "critbits",  "name": "items",  "code": "iterator items*[T](c: CritBitTree[T]): string",  "desc": "yields all keys in lexicographical order." },  { "module": "critbits",  "name": "pairs",  "code": "iterator pairs*[T](c: CritBitTree[T]): tuple[key: string, val: T]",  "desc": "yields all (key, value)-pairs of <cite>c</cite>." },  { "module": "critbits",  "name": "mpairs",  "code": "iterator mpairs*[T](c: var CritBitTree[T]): tuple[key: string, val: var T]",  "desc": "yields all (key, value)-pairs of <cite>c</cite>. The yielded values can be modified." },  { "module": "critbits",  "name": "itemsWithPrefix",  "code": "iterator itemsWithPrefix*[T](c: CritBitTree[T]; prefix: string): string",  "desc": "yields all keys starting with <cite>prefix</cite>." },  { "module": "critbits",  "name": "keysWithPrefix",  "code": "iterator keysWithPrefix*[T](c: CritBitTree[T]; prefix: string): string",  "desc": "yields all keys starting with <cite>prefix</cite>." },  { "module": "critbits",  "name": "valuesWithPrefix",  "code": "iterator valuesWithPrefix*[T](c: CritBitTree[T]; prefix: string): T",  "desc": "yields all values of <cite>c</cite> starting with <cite>prefix</cite> of the corresponding keys." },  { "module": "critbits",  "name": "mvaluesWithPrefix",  "code": "iterator mvaluesWithPrefix*[T](c: var CritBitTree[T]; prefix: string): var T",  "desc": "yields all values of <cite>c</cite> starting with <cite>prefix</cite> of the corresponding keys. The values can be modified." },  { "module": "critbits",  "name": "pairsWithPrefix",  "code": "iterator pairsWithPrefix*[T](c: CritBitTree[T]; prefix: string): tuple[\u000A    key: string, val: T]",  "desc": "yields all (key, value)-pairs of <cite>c</cite> starting with <cite>prefix</cite>." },  { "module": "critbits",  "name": "mpairsWithPrefix",  "code": "iterator mpairsWithPrefix*[T](c: var CritBitTree[T]; prefix: string): tuple[\u000A    key: string, val: var T]",  "desc": "yields all (key, value)-pairs of <cite>c</cite> starting with <cite>prefix</cite>. The yielded values can be modified." },  { "module": "critbits",  "name": "`$`",  "code": "proc `$`*[T](c: CritBitTree[T]): string",  "desc": "turns <cite>c</cite> into a string representation. Example outputs: <tt class=\"docutils literal\"><span class=\"pre\">{keyA: value, keyB: value}</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">{:}</span></tt> If <cite>T</cite> is void the outputs look like: <tt class=\"docutils literal\"><span class=\"pre\">{keyA, keyB}</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">{}</span></tt>." },  { "module": "db_mysql",  "name": "sql",  "code": "proc sql*(query: string): TSqlQuery {.noSideEffect, inline.}",  "desc": "<p>constructs a TSqlQuery from the string <cite>query</cite>. This is supposed to be used as a raw-string-literal modifier: <tt class=\"docutils literal\"><span class=\"pre\">sql&quot;update user set counter = counter + 1&quot;</span></tt></p>\u000A<p>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</p>\u000A" },  { "module": "db_mysql",  "name": "dbError",  "code": "proc dbError*(msg: string) {.noreturn.}",  "desc": "raises an EDb exception with message <cite>msg</cite>." },  { "module": "db_mysql",  "name": "dbQuote",  "code": "proc dbQuote*(s: string): string",  "desc": "DB quotes the string." },  { "module": "db_mysql",  "name": "tryExec",  "code": "proc tryExec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): bool {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "tries to execute the query and returns true if successful, false otherwise." },  { "module": "db_mysql",  "name": "exec",  "code": "proc exec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]) {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "executes the query and raises EDB if not successful." },  { "module": "db_mysql",  "name": "fastRows",  "code": "iterator fastRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "executes the query and iterates over the result dataset. This is very fast, but potenially dangerous: If the for-loop-body executes another query, the results can be undefined. For MySQL this is the case!." },  { "module": "db_mysql",  "name": "getRow",  "code": "proc getRow*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "retrieves a single row. If the query doesn't return any rows, this proc will return a TRow with empty strings for each column." },  { "module": "db_mysql",  "name": "getAllRows",  "code": "proc getAllRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): seq[\u000A    TRow] {.tags: [FReadDB].}",  "desc": "executes the query and returns the whole result dataset." },  { "module": "db_mysql",  "name": "rows",  "code": "iterator rows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "same as <cite>fastRows</cite>, but slower and safe." },  { "module": "db_mysql",  "name": "getValue",  "code": "proc getValue*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): string {.\u000A    tags: [FReadDB].}",  "desc": "executes the query and returns the first column of the first row of the result dataset. Returns &quot;&quot; if the dataset contains no rows or the database value is NULL." },  { "module": "db_mysql",  "name": "tryInsertId",  "code": "proc tryInsertId*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row or -1 in case of an error." },  { "module": "db_mysql",  "name": "insertId",  "code": "proc insertId*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row." },  { "module": "db_mysql",  "name": "execAffectedRows",  "code": "proc execAffectedRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "runs the query (typically &quot;UPDATE&quot;) and returns the number of affected rows" },  { "module": "db_mysql",  "name": "close",  "code": "proc close*(db: TDbConn) {.tags: [FDb].}",  "desc": "closes the database connection." },  { "module": "db_mysql",  "name": "open",  "code": "proc open*(connection, user, password, database: string): TDbConn {.tags: [FDb].}",  "desc": "opens a database connection. Raises <cite>EDb</cite> if the connection could not be established." },  { "module": "db_postgres",  "name": "sql",  "code": "proc sql*(query: string): TSqlQuery {.noSideEffect, inline.}",  "desc": "<p>constructs a TSqlQuery from the string <cite>query</cite>. This is supposed to be used as a raw-string-literal modifier: <tt class=\"docutils literal\"><span class=\"pre\">sql&quot;update user set counter = counter + 1&quot;</span></tt></p>\u000A<p>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</p>\u000A" },  { "module": "db_postgres",  "name": "dbError",  "code": "proc dbError*(db: TDbConn) {.noreturn.}",  "desc": "raises an EDb exception." },  { "module": "db_postgres",  "name": "dbError",  "code": "proc dbError*(msg: string) {.noreturn.}",  "desc": "raises an EDb exception with message <cite>msg</cite>." },  { "module": "db_postgres",  "name": "dbQuote",  "code": "proc dbQuote*(s: string): string",  "desc": "DB quotes the string." },  { "module": "db_postgres",  "name": "tryExec",  "code": "proc tryExec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): bool {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "tries to execute the query and returns true if successful, false otherwise." },  { "module": "db_postgres",  "name": "exec",  "code": "proc exec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]) {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "executes the query and raises EDB if not successful." },  { "module": "db_postgres",  "name": "exec",  "code": "proc exec*(db: TDbConn; stmtName: TSqlPrepared; args: varargs[string]) {.\u000A    tags: [FReadDB, FWriteDb].}" },  { "module": "db_postgres",  "name": "prepare",  "code": "proc prepare*(db: TDbConn; stmtName: string; query: TSqlQuery; nParams: int): TSqlPrepared" },  { "module": "db_postgres",  "name": "fastRows",  "code": "iterator fastRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "executes the query and iterates over the result dataset. This is very fast, but potenially dangerous: If the for-loop-body executes another query, the results can be undefined. For Postgres it is safe though." },  { "module": "db_postgres",  "name": "fastRows",  "code": "iterator fastRows*(db: TDbConn; stmtName: TSqlPrepared; \u000A                   args: varargs[string, `$`]): TRow {.tags: [FReadDB].}",  "desc": "executes the prepared query and iterates over the result dataset." },  { "module": "db_postgres",  "name": "getRow",  "code": "proc getRow*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "retrieves a single row. If the query doesn't return any rows, this proc will return a TRow with empty strings for each column." },  { "module": "db_postgres",  "name": "getRow",  "code": "proc getRow*(db: TDbConn; stmtName: TSqlPrepared; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}" },  { "module": "db_postgres",  "name": "getAllRows",  "code": "proc getAllRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): seq[\u000A    TRow] {.tags: [FReadDB].}",  "desc": "executes the query and returns the whole result dataset." },  { "module": "db_postgres",  "name": "getAllRows",  "code": "proc getAllRows*(db: TDbConn; stmtName: TSqlPrepared; args: varargs[string, `$`]): seq[\u000A    TRow] {.tags: [FReadDB].}",  "desc": "executes the prepared query and returns the whole result dataset." },  { "module": "db_postgres",  "name": "rows",  "code": "iterator rows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDB].}",  "desc": "same as <cite>fastRows</cite>, but slower and safe." },  { "module": "db_postgres",  "name": "getValue",  "code": "proc getValue*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): string {.\u000A    tags: [FReadDB].}",  "desc": "executes the query and returns the first column of the first row of the result dataset. Returns &quot;&quot; if the dataset contains no rows or the database value is NULL." },  { "module": "db_postgres",  "name": "tryInsertID",  "code": "proc tryInsertID*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row or -1 in case of an error. For Postgre this adds <tt class=\"docutils literal\"><span class=\"pre\">RETURNING id</span></tt> to the query, so it only works if your primary key is named <tt class=\"docutils literal\"><span class=\"pre\">id</span></tt>. " },  { "module": "db_postgres",  "name": "insertID",  "code": "proc insertID*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row. For Postgre this adds <tt class=\"docutils literal\"><span class=\"pre\">RETURNING id</span></tt> to the query, so it only works if your primary key is named <tt class=\"docutils literal\"><span class=\"pre\">id</span></tt>. " },  { "module": "db_postgres",  "name": "execAffectedRows",  "code": "proc execAffectedRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FReadDB, FWriteDb].}",  "desc": "executes the query (typically &quot;UPDATE&quot;) and returns the number of affected rows." },  { "module": "db_postgres",  "name": "close",  "code": "proc close*(db: TDbConn) {.tags: [FDb].}",  "desc": "closes the database connection." },  { "module": "db_postgres",  "name": "open",  "code": "proc open*(connection, user, password, database: string): TDbConn {.tags: [FDb].}",  "desc": "<p>opens a database connection. Raises <cite>EDb</cite> if the connection could not be established.</p>\u000A<p>Clients can also use Postgres keyword/value connection strings to connect.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Identifier\">con</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">open</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;host=localhost port=5432 dbname=mydb&quot;</span><span class=\"Punctuation\">)</span></pre><p>See <a class=\"reference external\" href=\"http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING\">http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING</a> for more information.</p>\u000A<p>Note that the connection parameter is not used but exists to maintain the nim db api.</p>\u000A" },  { "module": "db_sqlite",  "name": "sql",  "code": "proc sql*(query: string): TSqlQuery {.noSideEffect, inline.}",  "desc": "<p>constructs a TSqlQuery from the string <cite>query</cite>. This is supposed to be used as a raw-string-literal modifier: <tt class=\"docutils literal\"><span class=\"pre\">sql&quot;update user set counter = counter + 1&quot;</span></tt></p>\u000A<p>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</p>\u000A" },  { "module": "db_sqlite",  "name": "dbError",  "code": "proc dbError*(msg: string) {.noreturn.}",  "desc": "raises an EDb exception with message <cite>msg</cite>." },  { "module": "db_sqlite",  "name": "tryExec",  "code": "proc tryExec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): bool {.\u000A    tags: [FReadDb, FWriteDb].}",  "desc": "tries to execute the query and returns true if successful, false otherwise." },  { "module": "db_sqlite",  "name": "exec",  "code": "proc exec*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]) {.\u000A    tags: [FReadDb, FWriteDb].}",  "desc": "executes the query and raises EDB if not successful." },  { "module": "db_sqlite",  "name": "fastRows",  "code": "iterator fastRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDb].}",  "desc": "executes the query and iterates over the result dataset. This is very fast, but potenially dangerous: If the for-loop-body executes another query, the results can be undefined. For Sqlite it is safe though." },  { "module": "db_sqlite",  "name": "getRow",  "code": "proc getRow*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDb].}",  "desc": "retrieves a single row. If the query doesn't return any rows, this proc will return a TRow with empty strings for each column." },  { "module": "db_sqlite",  "name": "getAllRows",  "code": "proc getAllRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): seq[\u000A    TRow] {.tags: [FReadDb].}",  "desc": "executes the query and returns the whole result dataset." },  { "module": "db_sqlite",  "name": "rows",  "code": "iterator rows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): TRow {.\u000A    tags: [FReadDb].}",  "desc": "same as <cite>FastRows</cite>, but slower and safe." },  { "module": "db_sqlite",  "name": "getValue",  "code": "proc getValue*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): string {.\u000A    tags: [FReadDb].}",  "desc": "executes the query and returns the first column of the first row of the result dataset. Returns &quot;&quot; if the dataset contains no rows or the database value is NULL." },  { "module": "db_sqlite",  "name": "tryInsertID",  "code": "proc tryInsertID*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb], raises: [].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row or -1 in case of an error. " },  { "module": "db_sqlite",  "name": "insertID",  "code": "proc insertID*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FWriteDb].}",  "desc": "executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row. For Postgre this adds <tt class=\"docutils literal\"><span class=\"pre\">RETURNING id</span></tt> to the query, so it only works if your primary key is named <tt class=\"docutils literal\"><span class=\"pre\">id</span></tt>. " },  { "module": "db_sqlite",  "name": "execAffectedRows",  "code": "proc execAffectedRows*(db: TDbConn; query: TSqlQuery; args: varargs[string, `$`]): int64 {.\u000A    tags: [FReadDb, FWriteDb].}",  "desc": "executes the query (typically &quot;UPDATE&quot;) and returns the number of affected rows." },  { "module": "db_sqlite",  "name": "close",  "code": "proc close*(db: TDbConn) {.tags: [FDb].}",  "desc": "closes the database connection." },  { "module": "db_sqlite",  "name": "open",  "code": "proc open*(connection, user, password, database: string): TDbConn {.tags: [FDb].}",  "desc": "opens a database connection. Raises <cite>EDb</cite> if the connection could not be established. Only the <tt class=\"docutils literal\"><span class=\"pre\">connection</span></tt> parameter is used for <tt class=\"docutils literal\"><span class=\"pre\">sqlite</span></tt>." },  { "module": "dialogs",  "name": "info",  "code": "proc info*(window: PWindow; msg: string)",  "desc": "Shows an information message to the user. The process waits until the user presses the OK button." },  { "module": "dialogs",  "name": "warning",  "code": "proc warning*(window: PWindow; msg: string)",  "desc": "Shows a warning message to the user. The process waits until the user presses the OK button." },  { "module": "dialogs",  "name": "error",  "code": "proc error*(window: PWindow; msg: string)",  "desc": "Shows an error message to the user. The process waits until the user presses the OK button." },  { "module": "dialogs",  "name": "chooseFileToOpen",  "code": "proc chooseFileToOpen*(window: PWindow; root: string = \"\"): string",  "desc": "Opens a dialog that requests a filename from the user. Returns &quot;&quot; if the user closed the dialog without selecting a file. On Windows, the native dialog is used, else the GTK dialog is used." },  { "module": "dialogs",  "name": "chooseFilesToOpen",  "code": "proc chooseFilesToOpen*(window: PWindow; root: string = \"\"): seq[string]",  "desc": "Opens a dialog that requests filenames from the user. Returns <tt class=\"docutils literal\"><span class=\"pre\">@[]</span></tt> if the user closed the dialog without selecting a file. On Windows, the native dialog is used, else the GTK dialog is used." },  { "module": "dialogs",  "name": "chooseFileToSave",  "code": "proc chooseFileToSave*(window: PWindow; root: string = \"\"): string",  "desc": "Opens a dialog that requests a filename to save to from the user. Returns &quot;&quot; if the user closed the dialog without selecting a file. On Windows, the native dialog is used, else the GTK dialog is used." },  { "module": "dialogs",  "name": "chooseDir",  "code": "proc chooseDir*(window: PWindow; root: string = \"\"): string",  "desc": "Opens a dialog that requests a directory from the user. Returns &quot;&quot; if the user closed the dialog without selecting a directory. On Windows, the native dialog is used, else the GTK dialog is used." },  { "module": "dom",  "name": "decodeURI",  "code": "proc decodeURI*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "encodeURI",  "code": "proc encodeURI*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "escape",  "code": "proc escape*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "unescape",  "code": "proc unescape*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "decodeURIComponent",  "code": "proc decodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "encodeURIComponent",  "code": "proc encodeURIComponent*(uri: cstring): cstring {.importc, nodecl.}" },  { "module": "dom",  "name": "isFinite",  "code": "proc isFinite*(x: BiggestFloat): bool {.importc, nodecl.}" },  { "module": "dom",  "name": "isNaN",  "code": "proc isNaN*(x: BiggestFloat): bool {.importc, nodecl.}" },  { "module": "dom",  "name": "parseFloat",  "code": "proc parseFloat*(s: cstring): BiggestFloat {.importc, nodecl.}" },  { "module": "dom",  "name": "parseInt",  "code": "proc parseInt*(s: cstring): int {.importc, nodecl.}" },  { "module": "dynlib",  "name": "loadLib",  "code": "proc loadLib*(path: string; global_symbols = false): LibHandle",  "desc": "loads a library from <cite>path</cite>. Returns nil if the library could not be loaded." },  { "module": "dynlib",  "name": "loadLib",  "code": "proc loadLib*(): LibHandle",  "desc": "gets the handle from the current executable. Returns nil if the library could not be loaded." },  { "module": "dynlib",  "name": "unloadLib",  "code": "proc unloadLib*(lib: LibHandle)",  "desc": "unloads the library <cite>lib</cite>" },  { "module": "dynlib",  "name": "raiseInvalidLibrary",  "code": "proc raiseInvalidLibrary*(name: cstring) {.noinline, noreturn.}",  "desc": "raises an <cite>EInvalidLibrary</cite> exception." },  { "module": "dynlib",  "name": "symAddr",  "code": "proc symAddr*(lib: LibHandle; name: cstring): pointer",  "desc": "retrieves the address of a procedure/variable from <cite>lib</cite>. Returns nil if the symbol could not be found." },  { "module": "dynlib",  "name": "checkedSymAddr",  "code": "proc checkedSymAddr*(lib: LibHandle; name: cstring): pointer",  "desc": "retrieves the address of a procedure/variable from <cite>lib</cite>. Raises <cite>EInvalidLibrary</cite> if the symbol could not be found." },  { "module": "encodings",  "name": "getCurrentEncoding",  "code": "proc getCurrentEncoding*(): string",  "desc": "retrieves the current encoding. On Unix, always &quot;UTF-8&quot; is returned." },  { "module": "encodings",  "name": "open",  "code": "proc open*(destEncoding = \"UTF-8\"; srcEncoding = \"CP1252\"): EncodingConverter",  "desc": "opens a converter that can convert from <cite>srcEncoding</cite> to <cite>destEncoding</cite>. Raises <cite>EIO</cite> if it cannot fullfill the request." },  { "module": "encodings",  "name": "close",  "code": "proc close*(c: EncodingConverter)",  "desc": "frees the resources the converter <cite>c</cite> holds." },  { "module": "encodings",  "name": "convert",  "code": "proc convert*(c: EncodingConverter; s: string): string",  "desc": "converts <cite>s</cite> to <cite>destEncoding</cite> that was given to the converter <cite>c</cite>. It assumed that <cite>s</cite> is in <cite>srcEncoding</cite>." },  { "module": "encodings",  "name": "convert",  "code": "proc convert*(s: string; destEncoding = \"UTF-8\"; srcEncoding = \"CP1252\"): string",  "desc": "converts <cite>s</cite> to <cite>destEncoding</cite>. It assumed that <cite>s</cite> is in <cite>srcEncoding</cite>. This opens a converter, uses it and closes it again and is thus more convienent but also likely less efficient than re-using a converter." },  { "module": "endians",  "name": "swapEndian64",  "code": "proc swapEndian64*(outp, inp: pointer)",  "desc": "copies <cite>inp</cite> to <cite>outp</cite> swapping bytes. Both buffers are supposed to contain at least 8 bytes." },  { "module": "endians",  "name": "swapEndian32",  "code": "proc swapEndian32*(outp, inp: pointer)",  "desc": "copies <cite>inp</cite> to <cite>outp</cite> swapping bytes. Both buffers are supposed to contain at least 4 bytes." },  { "module": "endians",  "name": "swapEndian16",  "code": "proc swapEndian16*(outp, inp: pointer)",  "desc": "copies <cite>inp</cite> to <cite>outp</cite> swapping bytes. Both buffers are supposed to contain at least 2 bytes." },  { "module": "endians",  "name": "littleEndian64",  "code": "proc littleEndian64*(outp, inp: pointer) {.inline.}" },  { "module": "endians",  "name": "littleEndian32",  "code": "proc littleEndian32*(outp, inp: pointer) {.inline.}" },  { "module": "endians",  "name": "littleEndian16",  "code": "proc littleEndian16*(outp, inp: pointer) {.inline.}" },  { "module": "endians",  "name": "bigEndian64",  "code": "proc bigEndian64*(outp, inp: pointer) {.inline.}" },  { "module": "endians",  "name": "bigEndian32",  "code": "proc bigEndian32*(outp, inp: pointer) {.inline.}" },  { "module": "endians",  "name": "bigEndian16",  "code": "proc bigEndian16*(outp, inp: pointer) {.inline.}" },  { "module": "epoll",  "name": "epoll_create",  "code": "proc epoll_create*(size: cint): cint {.importc: \"epoll_create\", \u000A                                       header: \"<sys/epoll.h>\".}",  "desc": "<dl class=\"docutils\"><dt>Creates an epoll instance.  Returns an fd for the new instance.</dt>\u000A<dd>The &quot;size&quot; parameter is a hint specifying the number of file descriptors to be associated with the new instance.  The fd returned by epoll_create() should be closed with close().  </dd>\u000A</dl>\u000A" },  { "module": "epoll",  "name": "epoll_create1",  "code": "proc epoll_create1*(flags: cint): cint {.importc: \"epoll_create1\", \u000A    header: \"<sys/epoll.h>\".}",  "desc": "<dl class=\"docutils\"><dt>Same as epoll_create but with an FLAGS parameter.  The unused SIZE</dt>\u000A<dd>parameter has been dropped.  </dd>\u000A</dl>\u000A" },  { "module": "epoll",  "name": "epoll_ctl",  "code": "proc epoll_ctl*(epfd: cint; op: cint; fd: cint | SocketHandle; \u000A                event: ptr epoll_event): cint {.importc: \"epoll_ctl\", \u000A    header: \"<sys/epoll.h>\".}",  "desc": "<dl class=\"docutils\"><dt>Manipulate an epoll instance &quot;epfd&quot;. Returns 0 in case of success,</dt>\u000A<dd><table frame=\"void\"><tr><th align=\"left\">-1 in case of error ( the &quot;errno&quot; variable will contain the</th><td align=\"left\"></td>\u000A</tr>\u000A</table><p>specific error code ) The &quot;op&quot; parameter is one of the EPOLL_CTL_* constants defined above. The &quot;fd&quot; parameter is the target of the operation. The &quot;event&quot; parameter describes which events the caller is interested in and any associated user data.  </p>\u000A</dd>\u000A</dl>\u000A" },  { "module": "epoll",  "name": "epoll_wait",  "code": "proc epoll_wait*(epfd: cint; events: ptr epoll_event; maxevents: cint; \u000A                 timeout: cint): cint {.importc: \"epoll_wait\", \u000A                                        header: \"<sys/epoll.h>\".}",  "desc": "<dl class=\"docutils\"><dt>Wait for events on an epoll instance &quot;epfd&quot;. Returns the number of</dt>\u000A<dd><p>triggered events returned in &quot;events&quot; buffer. Or -1 in case of error with the &quot;errno&quot; variable set to the specific error code. The &quot;events&quot; parameter is a buffer that will contain triggered events. The &quot;maxevents&quot; is the maximum number of events to be returned ( usually size of &quot;events&quot; ). The &quot;timeout&quot; parameter specifies the maximum wait time in milliseconds (-1 == infinite).</p>\u000A<p>This function is a cancellation point and therefore not marked with __THROW.</p>\u000A</dd>\u000A</dl>\u000A" },  { "module": "events",  "name": "initEventHandler",  "code": "proc initEventHandler*(name: string): EventHandler",  "desc": "Initializes an EventHandler with the specified name and returns it." },  { "module": "events",  "name": "addHandler",  "code": "proc addHandler*(handler: var EventHandler; fn: proc (e: EventArgs) {.closure.})",  "desc": "Adds the callback to the specified event handler." },  { "module": "events",  "name": "removeHandler",  "code": "proc removeHandler*(handler: var EventHandler; \u000A                    fn: proc (e: EventArgs) {.closure.})",  "desc": "Removes the callback from the specified event handler." },  { "module": "events",  "name": "containsHandler",  "code": "proc containsHandler*(handler: var EventHandler; \u000A                      fn: proc (e: EventArgs) {.closure.}): bool",  "desc": "Checks if a callback is registered to this event handler." },  { "module": "events",  "name": "clearHandlers",  "code": "proc clearHandlers*(handler: var EventHandler)",  "desc": "Clears all of the callbacks from the event handler." },  { "module": "events",  "name": "on",  "code": "proc on*(emitter: var EventEmitter; event: string; \u000A         fn: proc (e: EventArgs) {.closure.})",  "desc": "Assigns a event handler with the specified callback. If the event doesn't exist, it will be created." },  { "module": "events",  "name": "emit",  "code": "proc emit*(emitter: var EventEmitter; eventhandler: var EventHandler; \u000A           args: EventArgs)",  "desc": "Fires an event handler with specified event arguments." },  { "module": "events",  "name": "emit",  "code": "proc emit*(emitter: var EventEmitter; event: string; args: EventArgs)",  "desc": "Fires an event handler with specified event arguments." },  { "module": "events",  "name": "initEventEmitter",  "code": "proc initEventEmitter*(): EventEmitter",  "desc": "Creates and returns a new EventEmitter." },  { "module": "expat",  "name": "setElementDeclHandler",  "code": "proc setElementDeclHandler*(parser: PParser; eldecl: TElementDeclHandler) {.\u000A    cdecl, importc: \"XML_SetElementDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setAttlistDeclHandler",  "code": "proc setAttlistDeclHandler*(parser: PParser; attdecl: TAttlistDeclHandler) {.\u000A    cdecl, importc: \"XML_SetAttlistDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setXmlDeclHandler",  "code": "proc setXmlDeclHandler*(parser: PParser; xmldecl: TXmlDeclHandler) {.cdecl, \u000A    importc: \"XML_SetXmlDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parserCreate",  "code": "proc parserCreate*(encoding: cstring): PParser {.cdecl, \u000A    importc: \"XML_ParserCreate\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parserCreateNS",  "code": "proc parserCreateNS*(encoding: cstring; namespaceSeparator: char): PParser {.\u000A    cdecl, importc: \"XML_ParserCreateNS\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parserCreateMM",  "code": "proc parserCreateMM*(encoding: cstring; memsuite: ptr TMemoryHandlingSuite; \u000A                     namespaceSeparator: cstring): PParser {.cdecl, \u000A    importc: \"XML_ParserCreate_MM\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parserReset",  "code": "proc parserReset*(parser: PParser; encoding: cstring): bool {.cdecl, \u000A    importc: \"XML_ParserReset\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setEntityDeclHandler",  "code": "proc setEntityDeclHandler*(parser: PParser; handler: TEntityDeclHandler) {.\u000A    cdecl, importc: \"XML_SetEntityDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setElementHandler",  "code": "proc setElementHandler*(parser: PParser; start: TStartElementHandler; \u000A                        endHandler: TEndElementHandler) {.cdecl, \u000A    importc: \"XML_SetElementHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setStartElementHandler",  "code": "proc setStartElementHandler*(parser: PParser; handler: TStartElementHandler) {.\u000A    cdecl, importc: \"XML_SetStartElementHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setEndElementHandler",  "code": "proc setEndElementHandler*(parser: PParser; handler: TEndElementHandler) {.\u000A    cdecl, importc: \"XML_SetEndElementHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setCharacterDataHandler",  "code": "proc setCharacterDataHandler*(parser: PParser; handler: TCharacterDataHandler) {.\u000A    cdecl, importc: \"XML_SetCharacterDataHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setProcessingInstructionHandler",  "code": "proc setProcessingInstructionHandler*(parser: PParser; \u000A                                      handler: TProcessingInstructionHandler) {.\u000A    cdecl, importc: \"XML_SetProcessingInstructionHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setCommentHandler",  "code": "proc setCommentHandler*(parser: PParser; handler: TCommentHandler) {.cdecl, \u000A    importc: \"XML_SetCommentHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setCdataSectionHandler",  "code": "proc setCdataSectionHandler*(parser: PParser; start: TStartCdataSectionHandler; \u000A                             endHandler: TEndCdataSectionHandler) {.cdecl, \u000A    importc: \"XML_SetCdataSectionHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setStartCdataSectionHandler",  "code": "proc setStartCdataSectionHandler*(parser: PParser; \u000A                                  start: TStartCdataSectionHandler) {.cdecl, \u000A    importc: \"XML_SetStartCdataSectionHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setEndCdataSectionHandler",  "code": "proc setEndCdataSectionHandler*(parser: PParser; \u000A                                endHandler: TEndCdataSectionHandler) {.cdecl, \u000A    importc: \"XML_SetEndCdataSectionHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setDefaultHandler",  "code": "proc setDefaultHandler*(parser: PParser; handler: TDefaultHandler) {.cdecl, \u000A    importc: \"XML_SetDefaultHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setDefaultHandlerExpand",  "code": "proc setDefaultHandlerExpand*(parser: PParser; handler: TDefaultHandler) {.\u000A    cdecl, importc: \"XML_SetDefaultHandlerExpand\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setDoctypeDeclHandler",  "code": "proc setDoctypeDeclHandler*(parser: PParser; start: TStartDoctypeDeclHandler; \u000A                            endHandler: TEndDoctypeDeclHandler) {.cdecl, \u000A    importc: \"XML_SetDoctypeDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setStartDoctypeDeclHandler",  "code": "proc setStartDoctypeDeclHandler*(parser: PParser; \u000A                                 start: TStartDoctypeDeclHandler) {.cdecl, \u000A    importc: \"XML_SetStartDoctypeDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setEndDoctypeDeclHandler",  "code": "proc setEndDoctypeDeclHandler*(parser: PParser; \u000A                               endHandler: TEndDoctypeDeclHandler) {.cdecl, \u000A    importc: \"XML_SetEndDoctypeDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setUnparsedEntityDeclHandler",  "code": "proc setUnparsedEntityDeclHandler*(parser: PParser; \u000A                                   handler: TUnparsedEntityDeclHandler) {.cdecl, \u000A    importc: \"XML_SetUnparsedEntityDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setNotationDeclHandler",  "code": "proc setNotationDeclHandler*(parser: PParser; handler: TNotationDeclHandler) {.\u000A    cdecl, importc: \"XML_SetNotationDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setNamespaceDeclHandler",  "code": "proc setNamespaceDeclHandler*(parser: PParser; \u000A                              start: TStartNamespaceDeclHandler; \u000A                              endHandler: TEndNamespaceDeclHandler) {.cdecl, \u000A    importc: \"XML_SetNamespaceDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setStartNamespaceDeclHandler",  "code": "proc setStartNamespaceDeclHandler*(parser: PParser; \u000A                                   start: TStartNamespaceDeclHandler) {.cdecl, \u000A    importc: \"XML_SetStartNamespaceDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setEndNamespaceDeclHandler",  "code": "proc setEndNamespaceDeclHandler*(parser: PParser; \u000A                                 endHandler: TEndNamespaceDeclHandler) {.cdecl, \u000A    importc: \"XML_SetEndNamespaceDeclHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setNotStandaloneHandler",  "code": "proc setNotStandaloneHandler*(parser: PParser; handler: TNotStandaloneHandler) {.\u000A    cdecl, importc: \"XML_SetNotStandaloneHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setExternalEntityRefHandler",  "code": "proc setExternalEntityRefHandler*(parser: PParser; \u000A                                  handler: TExternalEntityRefHandler) {.cdecl, \u000A    importc: \"XML_SetExternalEntityRefHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setExternalEntityRefHandlerArg",  "code": "proc setExternalEntityRefHandlerArg*(parser: PParser; arg: pointer) {.cdecl, \u000A    importc: \"XML_SetExternalEntityRefHandlerArg\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setSkippedEntityHandler",  "code": "proc setSkippedEntityHandler*(parser: PParser; handler: TSkippedEntityHandler) {.\u000A    cdecl, importc: \"XML_SetSkippedEntityHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setUnknownEncodingHandler",  "code": "proc setUnknownEncodingHandler*(parser: PParser; \u000A                                handler: TUnknownEncodingHandler; \u000A                                encodingHandlerData: pointer) {.cdecl, \u000A    importc: \"XML_SetUnknownEncodingHandler\", dynlib: expatDll.}" },  { "module": "expat",  "name": "defaultCurrent",  "code": "proc defaultCurrent*(parser: PParser) {.cdecl, importc: \"XML_DefaultCurrent\", \u000A                                        dynlib: expatDll.}" },  { "module": "expat",  "name": "setReturnNSTriplet",  "code": "proc setReturnNSTriplet*(parser: PParser; doNst: cint) {.cdecl, \u000A    importc: \"XML_SetReturnNSTriplet\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setUserData",  "code": "proc setUserData*(parser: PParser; userData: pointer) {.cdecl, \u000A    importc: \"XML_SetUserData\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getUserData",  "code": "template getUserData*(parser: expr): expr" },  { "module": "expat",  "name": "setEncoding",  "code": "proc setEncoding*(parser: PParser; encoding: cstring): TStatus {.cdecl, \u000A    importc: \"XML_SetEncoding\", dynlib: expatDll.}" },  { "module": "expat",  "name": "useParserAsHandlerArg",  "code": "proc useParserAsHandlerArg*(parser: PParser) {.cdecl, \u000A    importc: \"XML_UseParserAsHandlerArg\", dynlib: expatDll.}" },  { "module": "expat",  "name": "useForeignDTD",  "code": "proc useForeignDTD*(parser: PParser; useDTD: bool): TError {.cdecl, \u000A    importc: \"XML_UseForeignDTD\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setBase",  "code": "proc setBase*(parser: PParser; base: cstring): TStatus {.cdecl, \u000A    importc: \"XML_SetBase\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getBase",  "code": "proc getBase*(parser: PParser): cstring {.cdecl, importc: \"XML_GetBase\", \u000A    dynlib: expatDll.}" },  { "module": "expat",  "name": "getSpecifiedAttributeCount",  "code": "proc getSpecifiedAttributeCount*(parser: PParser): cint {.cdecl, \u000A    importc: \"XML_GetSpecifiedAttributeCount\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getIdAttributeIndex",  "code": "proc getIdAttributeIndex*(parser: PParser): cint {.cdecl, \u000A    importc: \"XML_GetIdAttributeIndex\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parse",  "code": "proc parse*(parser: PParser; s: cstring; len: cint; isFinal: cint): TStatus {.\u000A    cdecl, importc: \"XML_Parse\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getBuffer",  "code": "proc getBuffer*(parser: PParser; len: cint): pointer {.cdecl, \u000A    importc: \"XML_GetBuffer\", dynlib: expatDll.}" },  { "module": "expat",  "name": "parseBuffer",  "code": "proc parseBuffer*(parser: PParser; len: cint; isFinal: cint): TStatus {.cdecl, \u000A    importc: \"XML_ParseBuffer\", dynlib: expatDll.}" },  { "module": "expat",  "name": "stopParser",  "code": "proc stopParser*(parser: PParser; resumable: bool): TStatus {.cdecl, \u000A    importc: \"XML_StopParser\", dynlib: expatDll.}" },  { "module": "expat",  "name": "resumeParser",  "code": "proc resumeParser*(parser: PParser): TStatus {.cdecl, \u000A    importc: \"XML_ResumeParser\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getParsingStatus",  "code": "proc getParsingStatus*(parser: PParser; status: ptr TParsingStatus) {.cdecl, \u000A    importc: \"XML_GetParsingStatus\", dynlib: expatDll.}" },  { "module": "expat",  "name": "externalEntityParserCreate",  "code": "proc externalEntityParserCreate*(parser: PParser; context: cstring; \u000A                                 encoding: cstring): PParser {.cdecl, \u000A    importc: \"XML_ExternalEntityParserCreate\", dynlib: expatDll.}" },  { "module": "expat",  "name": "setParamEntityParsing",  "code": "proc setParamEntityParsing*(parser: PParser; parsing: TParamEntityParsing): cint {.\u000A    cdecl, importc: \"XML_SetParamEntityParsing\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getErrorCode",  "code": "proc getErrorCode*(parser: PParser): TError {.cdecl, \u000A    importc: \"XML_GetErrorCode\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getCurrentLineNumber",  "code": "proc getCurrentLineNumber*(parser: PParser): int {.cdecl, \u000A    importc: \"XML_GetCurrentLineNumber\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getCurrentColumnNumber",  "code": "proc getCurrentColumnNumber*(parser: PParser): int {.cdecl, \u000A    importc: \"XML_GetCurrentColumnNumber\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getCurrentByteIndex",  "code": "proc getCurrentByteIndex*(parser: PParser): int {.cdecl, \u000A    importc: \"XML_GetCurrentByteIndex\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getCurrentByteCount",  "code": "proc getCurrentByteCount*(parser: PParser): cint {.cdecl, \u000A    importc: \"XML_GetCurrentByteCount\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getInputContext",  "code": "proc getInputContext*(parser: PParser; offset: ptr cint; size: ptr cint): cstring {.\u000A    cdecl, importc: \"XML_GetInputContext\", dynlib: expatDll.}" },  { "module": "expat",  "name": "freeContentModel",  "code": "proc freeContentModel*(parser: PParser; model: ptr TContent) {.cdecl, \u000A    importc: \"XML_FreeContentModel\", dynlib: expatDll.}" },  { "module": "expat",  "name": "memMalloc",  "code": "proc memMalloc*(parser: PParser; size: int): pointer {.cdecl, \u000A    importc: \"XML_MemMalloc\", dynlib: expatDll.}" },  { "module": "expat",  "name": "memRealloc",  "code": "proc memRealloc*(parser: PParser; p: pointer; size: int): pointer {.cdecl, \u000A    importc: \"XML_MemRealloc\", dynlib: expatDll.}" },  { "module": "expat",  "name": "memFree",  "code": "proc memFree*(parser: PParser; p: pointer) {.cdecl, importc: \"XML_MemFree\", \u000A    dynlib: expatDll.}" },  { "module": "expat",  "name": "parserFree",  "code": "proc parserFree*(parser: PParser) {.cdecl, importc: \"XML_ParserFree\", \u000A                                    dynlib: expatDll.}" },  { "module": "expat",  "name": "errorString",  "code": "proc errorString*(code: TError): cstring {.cdecl, importc: \"XML_ErrorString\", \u000A    dynlib: expatDll.}" },  { "module": "expat",  "name": "expatVersion",  "code": "proc expatVersion*(): cstring {.cdecl, importc: \"XML_ExpatVersion\", \u000A                                dynlib: expatDll.}" },  { "module": "expat",  "name": "expatVersionInfo",  "code": "proc expatVersionInfo*(): TExpatVersion {.cdecl, \u000A    importc: \"XML_ExpatVersionInfo\", dynlib: expatDll.}" },  { "module": "expat",  "name": "getFeatureList",  "code": "proc getFeatureList*(): ptr TFeature {.cdecl, importc: \"XML_GetFeatureList\", \u000A                                       dynlib: expatDll.}" },  { "module": "fenv",  "name": "feclearexcept",  "code": "proc feclearexcept*(excepts: cint): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Clear the supported exceptions represented by <cite>excepts</cite>." },  { "module": "fenv",  "name": "fegetexceptflag",  "code": "proc fegetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc, \u000A    header: \"<fenv.h>\".}",  "desc": "Store implementation-defined representation of the exception flags indicated by <cite>excepts</cite> in the object pointed to by <cite>flagp</cite>." },  { "module": "fenv",  "name": "feraiseexcept",  "code": "proc feraiseexcept*(excepts: cint): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Raise the supported exceptions represented by <cite>excepts</cite>." },  { "module": "fenv",  "name": "fesetexceptflag",  "code": "proc fesetexceptflag*(flagp: ptr Tfexcept; excepts: cint): cint {.importc, \u000A    header: \"<fenv.h>\".}",  "desc": "Set complete status for exceptions indicated by <cite>excepts</cite> according to the representation in the object pointed to by <cite>flagp</cite>." },  { "module": "fenv",  "name": "fetestexcept",  "code": "proc fetestexcept*(excepts: cint): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Determine which of subset of the exceptions specified by <cite>excepts</cite> are currently set." },  { "module": "fenv",  "name": "fegetround",  "code": "proc fegetround*(): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Get current rounding direction." },  { "module": "fenv",  "name": "fesetround",  "code": "proc fesetround*(roundingDirection: cint): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Establish the rounding direction represented by <cite>roundingDirection</cite>." },  { "module": "fenv",  "name": "fegetenv",  "code": "proc fegetenv*(envp: ptr Tfenv): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Store the current floating-point environment in the object pointed to by <cite>envp</cite>." },  { "module": "fenv",  "name": "feholdexcept",  "code": "proc feholdexcept*(envp: ptr Tfenv): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Save the current environment in the object pointed to by <cite>envp</cite>, clear exception flags and install a non-stop mode (if available) for all exceptions." },  { "module": "fenv",  "name": "fesetenv",  "code": "proc fesetenv*(a1: ptr Tfenv): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Establish the floating-point environment represented by the object pointed to by <cite>envp</cite>." },  { "module": "fenv",  "name": "feupdateenv",  "code": "proc feupdateenv*(envp: ptr Tfenv): cint {.importc, header: \"<fenv.h>\".}",  "desc": "Save current exceptions in temporary storage, install environment represented by object pointed to by <cite>envp</cite> and raise exceptions according to saved exceptions." },  { "module": "fsmonitor",  "name": "newMonitor",  "code": "proc newMonitor*(): PFSMonitor",  "desc": "Creates a new file system monitor." },  { "module": "fsmonitor",  "name": "add",  "code": "proc add*(monitor: PFSMonitor; target: string; filters = {MonitorAll}): cint {.\u000A    discardable.}",  "desc": "Adds <tt class=\"docutils literal\"><span class=\"pre\">target</span></tt> which may be a directory or a file to the list of watched paths of <tt class=\"docutils literal\"><span class=\"pre\">monitor</span></tt>. You can specify the events to report using the <tt class=\"docutils literal\"><span class=\"pre\">filters</span></tt> parameter." },  { "module": "fsmonitor",  "name": "del",  "code": "proc del*(monitor: PFSMonitor; wd: cint)",  "desc": "<p>Removes watched directory or file as specified by <tt class=\"docutils literal\"><span class=\"pre\">wd</span></tt> from <tt class=\"docutils literal\"><span class=\"pre\">monitor</span></tt>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">wd</span></tt> is not a part of <tt class=\"docutils literal\"><span class=\"pre\">monitor</span></tt> an EOS error is raised.</p>\u000A" },  { "module": "fsmonitor",  "name": "register",  "code": "proc register*(d: PDispatcher; monitor: PFSMonitor; \u000A               handleEvent: proc (m: PFSMonitor; ev: TMonitorEvent) {.closure.})",  "desc": "Registers <tt class=\"docutils literal\"><span class=\"pre\">monitor</span></tt> with dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "ftpclient",  "name": "ftpClient",  "code": "proc ftpClient*(address: string; port = TPort(21); user, pass = \"\"): FtpClient",  "desc": "Create a <tt class=\"docutils literal\"><span class=\"pre\">FtpClient</span></tt> object." },  { "module": "ftpclient",  "name": "send",  "code": "proc send*[T](ftp: FtpBase[T]; m: string): TaintedString",  "desc": "Send a message to the server, and wait for a primary reply. <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt> is added for you." },  { "module": "ftpclient",  "name": "connect",  "code": "proc connect*[T](ftp: FtpBase[T])",  "desc": "Connect to the FTP server specified by <tt class=\"docutils literal\"><span class=\"pre\">ftp</span></tt>." },  { "module": "ftpclient",  "name": "pwd",  "code": "proc pwd*[T](ftp: FtpBase[T]): string",  "desc": "Returns the current working directory." },  { "module": "ftpclient",  "name": "cd",  "code": "proc cd*[T](ftp: FtpBase[T]; dir: string)",  "desc": "Changes the current directory on the remote FTP server to <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>." },  { "module": "ftpclient",  "name": "cdup",  "code": "proc cdup*[T](ftp: FtpBase[T])",  "desc": "Changes the current directory to the parent of the current directory." },  { "module": "ftpclient",  "name": "listDirs",  "code": "proc listDirs*[T](ftp: FtpBase[T]; dir: string = \"\"; async = false): seq[string]",  "desc": "Returns a list of filenames in the given directory. If <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> is &quot;&quot;, the current directory is used. If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is true, this function will return immediately and it will be your job to use asyncio's <tt class=\"docutils literal\"><span class=\"pre\">poll</span></tt> to progress this operation." },  { "module": "ftpclient",  "name": "fileExists",  "code": "proc fileExists*(ftp: FtpClient; file: string): bool {.deprecated.}",  "desc": "<p><strong>Deprecated since version 0.9.0:</strong> Please use <tt class=\"docutils literal\"><span class=\"pre\">existsFile</span></tt>.</p>\u000A<p>Determines whether <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> exists.</p>\u000A<p>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</p>\u000A" },  { "module": "ftpclient",  "name": "existsFile",  "code": "proc existsFile*(ftp: FtpClient; file: string): bool",  "desc": "<p>Determines whether <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> exists.</p>\u000A<p>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</p>\u000A" },  { "module": "ftpclient",  "name": "createDir",  "code": "proc createDir*[T](ftp: FtpBase[T]; dir: string; recursive: bool = false)",  "desc": "Creates a directory <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">recursive</span></tt> is true, the topmost subdirectory of <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> will be created first, following the secondmost... etc. this allows you to give a full path as the <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> without worrying about subdirectories not existing." },  { "module": "ftpclient",  "name": "chmod",  "code": "proc chmod*[T](ftp: FtpBase[T]; path: string; permissions: set[TFilePermission])",  "desc": "Changes permission of <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">permissions</span></tt>." },  { "module": "ftpclient",  "name": "list",  "code": "proc list*[T](ftp: FtpBase[T]; dir: string = \"\"; async = false): string",  "desc": "Lists all files in <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">dir</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>, uses the current working directory. If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is true, this function will return immediately and it will be your job to call asyncio's <tt class=\"docutils literal\"><span class=\"pre\">poll</span></tt> to progress this operation." },  { "module": "ftpclient",  "name": "retrText",  "code": "proc retrText*[T](ftp: FtpBase[T]; file: string; async = false): string",  "desc": "Retrieves <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>. File must be ASCII text. If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is true, this function will return immediately and it will be your job to call asyncio's <tt class=\"docutils literal\"><span class=\"pre\">poll</span></tt> to progress this operation." },  { "module": "ftpclient",  "name": "retrFile",  "code": "proc retrFile*[T](ftp: FtpBase[T]; file, dest: string; async = false)",  "desc": "Downloads <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> and saves it to <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. Usage of this function asynchronously is recommended to view the progress of the download. The <tt class=\"docutils literal\"><span class=\"pre\">EvRetr</span></tt> event is passed to the specified <tt class=\"docutils literal\"><span class=\"pre\">handleEvent</span></tt> function when the download is finished, and the <tt class=\"docutils literal\"><span class=\"pre\">filename</span></tt> field will be equal to <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>." },  { "module": "ftpclient",  "name": "store",  "code": "proc store*[T](ftp: FtpBase[T]; file, dest: string; async = false)",  "desc": "Uploads <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt> on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The <tt class=\"docutils literal\"><span class=\"pre\">EvStore</span></tt> event is passed to the specified <tt class=\"docutils literal\"><span class=\"pre\">handleEvent</span></tt> function when the upload is finished, and the <tt class=\"docutils literal\"><span class=\"pre\">filename</span></tt> field will be equal to <tt class=\"docutils literal\"><span class=\"pre\">file</span></tt>." },  { "module": "ftpclient",  "name": "close",  "code": "proc close*[T](ftp: FtpBase[T])",  "desc": "Terminates the connection to the server." },  { "module": "ftpclient",  "name": "asyncFTPClient",  "code": "proc asyncFTPClient*(address: string; port = TPort(21); user, pass = \"\"; \u000A    handleEvent: proc (ftp: PAsyncFTPClient; ev: TFTPEvent) {.closure, gcsafe.} = (proc (\u000A    ftp: PAsyncFTPClient; ev: TFTPEvent) = \u000A  discard )): PAsyncFTPClient",  "desc": "<p>Create a <tt class=\"docutils literal\"><span class=\"pre\">PAsyncFTPClient</span></tt> object.</p>\u000A<p>Use this if you want to use asyncio's dispatcher.</p>\u000A" },  { "module": "ftpclient",  "name": "register",  "code": "proc register*(d: PDispatcher; ftp: PAsyncFTPClient): PDelegate {.discardable.}",  "desc": "Registers <tt class=\"docutils literal\"><span class=\"pre\">ftp</span></tt> with dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "future",  "name": "`=&gt;`",  "code": "macro `=>`*(p, b: expr): expr {.immediate.}",  "desc": "Syntax sugar for anonymous procedures.<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">passTwoAndTwo</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">f</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">f</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Identifier\">passTwoAndTwo</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=&gt;</span> <span class=\"Identifier\">x</span> <span class=\"Operator\">+</span> <span class=\"Identifier\">y</span><span class=\"Punctuation\">)</span> <span class=\"Comment\"># 4</span></pre>" },  { "module": "future",  "name": "`-&gt;`",  "code": "macro `->`*(p, b: expr): expr {.immediate.}",  "desc": "Syntax sugar for procedure types.<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">pass2</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">f</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">float</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">float</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Identifier\">float</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">float</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">f</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Comment\"># is the same as:</span>\u000A\u000A<span class=\"Keyword\">proc</span> <span class=\"Identifier\">pass2</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">f</span><span class=\"Punctuation\">:</span> <span class=\"Keyword\">proc</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">float</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">float</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">float</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">f</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "future",  "name": "`[]`",  "code": "macro `[]`*(lc: ListComprehension; comp, typ: expr): expr",  "desc": "List comprehension, returns a sequence. <cite>comp</cite> is the actual list comprehension, for example <tt class=\"docutils literal\"><span class=\"pre\">x | (x &lt;- 1..10, x mod 2 == 0)</span></tt>. <cite>typ</cite> is the type that will be stored inside the result seq.<pre><span class=\"Identifier\">echo</span> <span class=\"Identifier\">lc</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">x</span> <span class=\"Operator\">|</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span> <span class=\"Operator\">&lt;-</span> <span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">x</span> <span class=\"Keyword\">mod</span> <span class=\"DecNumber\">2</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A\u000A<span class=\"Keyword\">const</span> <span class=\"Identifier\">n</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">20</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">lc</span><span class=\"Punctuation\">[</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span><span class=\"Identifier\">y</span><span class=\"Punctuation\">,</span><span class=\"Identifier\">z</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">|</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span> <span class=\"Operator\">&lt;-</span> <span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"Identifier\">n</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span> <span class=\"Operator\">&lt;-</span> <span class=\"Identifier\">x</span><span class=\"Operator\">..</span><span class=\"Identifier\">n</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">z</span> <span class=\"Operator\">&lt;-</span> <span class=\"Identifier\">y</span><span class=\"Operator\">..</span><span class=\"Identifier\">n</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">x</span><span class=\"Operator\">*</span><span class=\"Identifier\">x</span> <span class=\"Operator\">+</span> <span class=\"Identifier\">y</span><span class=\"Operator\">*</span><span class=\"Identifier\">y</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">z</span><span class=\"Operator\">*</span><span class=\"Identifier\">z</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span>\u000A        <span class=\"Keyword\">tuple</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span><span class=\"Identifier\">b</span><span class=\"Punctuation\">,</span><span class=\"Identifier\">c</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "gentabs",  "name": "len",  "code": "proc len*[T](tbl: PGenTable[T]): int {.inline.}",  "desc": "returns the number of keys in <cite>tbl</cite>." },  { "module": "gentabs",  "name": "pairs",  "code": "iterator pairs*[T](tbl: PGenTable[T]): tuple[key: string, value: T]",  "desc": "iterates over any (key, value) pair in the table <cite>tbl</cite>." },  { "module": "gentabs",  "name": "newGenTable",  "code": "proc newGenTable*[T](mode: TGenTableMode): PGenTable[T]",  "desc": "creates a new generic hash table that is empty." },  { "module": "gentabs",  "name": "hasKey",  "code": "proc hasKey*[T](tbl: PGenTable[T]; key: string): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>tbl</cite>." },  { "module": "gentabs",  "name": "`[]`",  "code": "proc `[]`*[T](tbl: PGenTable[T]; key: string): T",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">tbl[key]</span></tt>. If <cite>key</cite> is not in <cite>tbl</cite>, default(T) is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "gentabs",  "name": "`[]=`",  "code": "proc `[]=`*[T](tbl: PGenTable[T]; key: string; val: T)",  "desc": "puts a (key, value)-pair into <cite>tbl</cite>." },  { "module": "graphics",  "name": "toSdlColor",  "code": "proc toSdlColor*(c: Color): sdl.TColor",  "desc": "Convert colors.TColor to sdl.TColor" },  { "module": "graphics",  "name": "createSdlColor",  "code": "proc createSdlColor*(sur: PSurface; c: Color; alpha: int = 0): int32",  "desc": "Creates a color using <tt class=\"docutils literal\"><span class=\"pre\">sdl.MapRGBA</span></tt>." },  { "module": "graphics",  "name": "toSdlRect",  "code": "proc toSdlRect*(r: TRect): sdl.TRect",  "desc": "Convert <tt class=\"docutils literal\"><span class=\"pre\">graphics.TRect</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">sdl.TRect</span></tt>." },  { "module": "graphics",  "name": "newSurface",  "code": "proc newSurface*(width, height: int): PSurface",  "desc": "creates a new surface." },  { "module": "graphics",  "name": "newFont",  "code": "proc newFont*(name = \"VeraMono.ttf\"; size = 9; color = colBlack): PFont",  "desc": "Creates a new font object. Raises <tt class=\"docutils literal\"><span class=\"pre\">EIO</span></tt> if the font cannot be loaded." },  { "module": "graphics",  "name": "initDefaultFont",  "code": "proc initDefaultFont*(name = \"VeraMono.ttf\"; size = 9; color = colBlack)",  "desc": "initializes the <cite>defaultFont</cite> var." },  { "module": "graphics",  "name": "newScreenSurface",  "code": "proc newScreenSurface*(width, height: int): PSurface",  "desc": "Creates a new screen surface" },  { "module": "graphics",  "name": "writeToBMP",  "code": "proc writeToBMP*(sur: PSurface; filename: string)",  "desc": "Saves the contents of the surface <cite>sur</cite> to the file <cite>filename</cite> as a BMP file." },  { "module": "graphics",  "name": "`[]`",  "code": "proc `[]`*(sur: PSurface; p: TPoint): Color",  "desc": "get pixel at position <cite>p</cite>. No range checking is done!" },  { "module": "graphics",  "name": "`[]`",  "code": "proc `[]`*(sur: PSurface; x, y: int): Color",  "desc": "get pixel at position <tt class=\"docutils literal\"><span class=\"pre\">(x, y)</span></tt>. No range checking is done!" },  { "module": "graphics",  "name": "`[]=`",  "code": "proc `[]=`*(sur: PSurface; p: TPoint; col: Color)",  "desc": "set the pixel at position <cite>p</cite>. No range checking is done!" },  { "module": "graphics",  "name": "`[]=`",  "code": "proc `[]=`*(sur: PSurface; x, y: int; col: Color)",  "desc": "set the pixel at position <tt class=\"docutils literal\"><span class=\"pre\">(x, y)</span></tt>. No range checking is done!" },  { "module": "graphics",  "name": "blit",  "code": "proc blit*(destSurf: PSurface; destRect: TRect; srcSurf: PSurface; \u000A           srcRect: TRect)",  "desc": "Copies <tt class=\"docutils literal\"><span class=\"pre\">srcSurf</span></tt> into <tt class=\"docutils literal\"><span class=\"pre\">destSurf</span></tt>" },  { "module": "graphics",  "name": "textBounds",  "code": "proc textBounds*(text: string; font = defaultFont): tuple[width, height: int]" },  { "module": "graphics",  "name": "drawText",  "code": "proc drawText*(sur: PSurface; p: TPoint; text: string; font = defaultFont)",  "desc": "Draws text with a transparent background, at location <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> with the given font." },  { "module": "graphics",  "name": "drawText",  "code": "proc drawText*(sur: PSurface; p: TPoint; text: string; bg: Color; \u000A               font = defaultFont)",  "desc": "Draws text, at location <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> with font <tt class=\"docutils literal\"><span class=\"pre\">font</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">bg</span></tt> is the background color." },  { "module": "graphics",  "name": "drawCircle",  "code": "proc drawCircle*(sur: PSurface; p: TPoint; r: Natural; color: Color)",  "desc": "draws a circle with center <cite>p</cite> and radius <cite>r</cite> with the given color onto the surface <cite>sur</cite>." },  { "module": "graphics",  "name": "drawLine",  "code": "proc drawLine*(sur: PSurface; p1, p2: TPoint; color: Color)",  "desc": "draws a line between the two points <cite>p1</cite> and <cite>p2</cite> with the given color onto the surface <cite>sur</cite>." },  { "module": "graphics",  "name": "drawHorLine",  "code": "proc drawHorLine*(sur: PSurface; x, y, w: Natural; color: Color)",  "desc": "draws a horizontal line from (x,y) to (x+w-1, y)." },  { "module": "graphics",  "name": "drawVerLine",  "code": "proc drawVerLine*(sur: PSurface; x, y, h: Natural; color: Color)",  "desc": "draws a vertical line from (x,y) to (x, y+h-1)." },  { "module": "graphics",  "name": "fillCircle",  "code": "proc fillCircle*(s: PSurface; p: TPoint; r: Natural; color: Color)",  "desc": "draws a circle with center <cite>p</cite> and radius <cite>r</cite> with the given color onto the surface <cite>sur</cite> and fills it." },  { "module": "graphics",  "name": "drawRect",  "code": "proc drawRect*(sur: PSurface; r: TRect; color: Color)",  "desc": "draws a rectangle." },  { "module": "graphics",  "name": "fillRect",  "code": "proc fillRect*(sur: PSurface; r: TRect; col: Color)",  "desc": "Fills a rectangle using sdl's <tt class=\"docutils literal\"><span class=\"pre\">FillRect</span></tt> function." },  { "module": "graphics",  "name": "drawEllipse",  "code": "proc drawEllipse*(sur: PSurface; cx, cy, xRadius, yRadius: Natural; col: Color)",  "desc": "Draws an ellipse, <tt class=\"docutils literal\"><span class=\"pre\">CX</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">CY</span></tt> specify the center X and Y of the ellipse, <tt class=\"docutils literal\"><span class=\"pre\">XRadius</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">YRadius</span></tt> specify half the width and height of the ellipse." },  { "module": "graphics",  "name": "drawLineAA",  "code": "proc drawLineAA*(sur: PSurface; p1, p2: TPoint; color: Color)",  "desc": "Draws a anti-aliased line from <tt class=\"docutils literal\"><span class=\"pre\">p1</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">p2</span></tt>, using Xiaolin Wu's line algorithm" },  { "module": "graphics",  "name": "fillSurface",  "code": "proc fillSurface*(sur: PSurface; color: Color)",  "desc": "Fills the entire surface with <tt class=\"docutils literal\"><span class=\"pre\">color</span></tt>." },  { "module": "graphics",  "name": "withEvents",  "code": "template withEvents*(surf: PSurface; event: expr; actions: stmt): stmt {.\u000A    immediate.}",  "desc": "Simple template which creates an event loop. <tt class=\"docutils literal\"><span class=\"pre\">Event</span></tt> is the name of the variable containing the TEvent object." },  { "module": "hashes",  "name": "`!&amp;`",  "code": "proc `!&`*(h: THash; val: int): THash {.inline.}",  "desc": "mixes a hash value <cite>h</cite> with <cite>val</cite> to produce a new hash value. This is only needed if you need to implement a hash proc for a new datatype." },  { "module": "hashes",  "name": "`!$`",  "code": "proc `!$`*(h: THash): THash {.inline.}",  "desc": "finishes the computation of the hash value. This is only needed if you need to implement a hash proc for a new datatype." },  { "module": "hashes",  "name": "hashData",  "code": "proc hashData*(data: pointer; size: int): THash",  "desc": "hashes an array of bytes of size <cite>size</cite>" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: pointer): THash {.inline.}",  "desc": "efficient hashing of pointers" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*[T: proc](x: T): THash {.inline.}",  "desc": "efficient hashing of proc vars; closures are supported too." },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: int): THash {.inline.}",  "desc": "efficient hashing of integers" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: int64): THash {.inline.}",  "desc": "efficient hashing of integers" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: char): THash {.inline.}",  "desc": "efficient hashing of characters" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: string): THash",  "desc": "efficient hashing of strings" },  { "module": "hashes",  "name": "hashIgnoreStyle",  "code": "proc hashIgnoreStyle*(x: string): THash",  "desc": "efficient hashing of strings; style is ignored" },  { "module": "hashes",  "name": "hashIgnoreCase",  "code": "proc hashIgnoreCase*(x: string): THash",  "desc": "efficient hashing of strings; case is ignored" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*[T: tuple](x: T): THash",  "desc": "efficient hashing of tuples." },  { "module": "hashes",  "name": "hash",  "code": "proc hash*(x: float): THash {.inline.}" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*[A](x: openArray[A]): THash" },  { "module": "hashes",  "name": "hash",  "code": "proc hash*[A](x: set[A]): THash" },  { "module": "history",  "name": "HISTENT_BYTES",  "code": "template HISTENT_BYTES*(hs: expr): expr" },  { "module": "history",  "name": "using_history",  "code": "proc using_history*() {.cdecl, importc: \"using_history\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_get_history_state",  "code": "proc history_get_history_state*(): ptr THISTORY_STATE {.cdecl, \u000A    importc: \"history_get_history_state\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_set_history_state",  "code": "proc history_set_history_state*(a2: ptr THISTORY_STATE) {.cdecl, \u000A    importc: \"history_set_history_state\", dynlib: historyDll.}" },  { "module": "history",  "name": "add_history",  "code": "proc add_history*(a2: cstring) {.cdecl, importc: \"add_history\", \u000A                                 dynlib: historyDll.}" },  { "module": "history",  "name": "add_history_time",  "code": "proc add_history_time*(a2: cstring) {.cdecl, importc: \"add_history_time\", \u000A                                      dynlib: historyDll.}" },  { "module": "history",  "name": "remove_history",  "code": "proc remove_history*(a2: cint): ptr THIST_ENTRY {.cdecl, \u000A    importc: \"remove_history\", dynlib: historyDll.}" },  { "module": "history",  "name": "free_history_entry",  "code": "proc free_history_entry*(a2: ptr THIST_ENTRY): Thistdata {.cdecl, \u000A    importc: \"free_history_entry\", dynlib: historyDll.}" },  { "module": "history",  "name": "replace_history_entry",  "code": "proc replace_history_entry*(a2: cint; a3: cstring; a4: Thistdata): ptr THIST_ENTRY {.\u000A    cdecl, importc: \"replace_history_entry\", dynlib: historyDll.}" },  { "module": "history",  "name": "clear_history",  "code": "proc clear_history*() {.cdecl, importc: \"clear_history\", dynlib: historyDll.}" },  { "module": "history",  "name": "stifle_history",  "code": "proc stifle_history*(a2: cint) {.cdecl, importc: \"stifle_history\", \u000A                                 dynlib: historyDll.}" },  { "module": "history",  "name": "unstifle_history",  "code": "proc unstifle_history*(): cint {.cdecl, importc: \"unstifle_history\", \u000A                                 dynlib: historyDll.}" },  { "module": "history",  "name": "history_is_stifled",  "code": "proc history_is_stifled*(): cint {.cdecl, importc: \"history_is_stifled\", \u000A                                   dynlib: historyDll.}" },  { "module": "history",  "name": "history_list",  "code": "proc history_list*(): ptr ptr THIST_ENTRY {.cdecl, importc: \"history_list\", \u000A    dynlib: historyDll.}" },  { "module": "history",  "name": "where_history",  "code": "proc where_history*(): cint {.cdecl, importc: \"where_history\", \u000A                              dynlib: historyDll.}" },  { "module": "history",  "name": "current_history",  "code": "proc current_history*(): ptr THIST_ENTRY {.cdecl, importc: \"current_history\", \u000A    dynlib: historyDll.}" },  { "module": "history",  "name": "history_get",  "code": "proc history_get*(a2: cint): ptr THIST_ENTRY {.cdecl, importc: \"history_get\", \u000A    dynlib: historyDll.}" },  { "module": "history",  "name": "history_get_time",  "code": "proc history_get_time*(a2: ptr THIST_ENTRY): Time {.cdecl, \u000A    importc: \"history_get_time\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_total_bytes",  "code": "proc history_total_bytes*(): cint {.cdecl, importc: \"history_total_bytes\", \u000A                                    dynlib: historyDll.}" },  { "module": "history",  "name": "history_set_pos",  "code": "proc history_set_pos*(a2: cint): cint {.cdecl, importc: \"history_set_pos\", \u000A                                        dynlib: historyDll.}" },  { "module": "history",  "name": "previous_history",  "code": "proc previous_history*(): ptr THIST_ENTRY {.cdecl, importc: \"previous_history\", \u000A    dynlib: historyDll.}" },  { "module": "history",  "name": "next_history",  "code": "proc next_history*(): ptr THIST_ENTRY {.cdecl, importc: \"next_history\", \u000A                                        dynlib: historyDll.}" },  { "module": "history",  "name": "history_search",  "code": "proc history_search*(a2: cstring; a3: cint): cint {.cdecl, \u000A    importc: \"history_search\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_search_prefix",  "code": "proc history_search_prefix*(a2: cstring; a3: cint): cint {.cdecl, \u000A    importc: \"history_search_prefix\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_search_pos",  "code": "proc history_search_pos*(a2: cstring; a3: cint; a4: cint): cint {.cdecl, \u000A    importc: \"history_search_pos\", dynlib: historyDll.}" },  { "module": "history",  "name": "read_history",  "code": "proc read_history*(a2: cstring): cint {.cdecl, importc: \"read_history\", \u000A                                        dynlib: historyDll.}" },  { "module": "history",  "name": "read_history_range",  "code": "proc read_history_range*(a2: cstring; a3: cint; a4: cint): cint {.cdecl, \u000A    importc: \"read_history_range\", dynlib: historyDll.}" },  { "module": "history",  "name": "write_history",  "code": "proc write_history*(a2: cstring): cint {.cdecl, importc: \"write_history\", \u000A    dynlib: historyDll.}" },  { "module": "history",  "name": "append_history",  "code": "proc append_history*(a2: cint; a3: cstring): cint {.cdecl, \u000A    importc: \"append_history\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_truncate_file",  "code": "proc history_truncate_file*(a2: cstring; a3: cint): cint {.cdecl, \u000A    importc: \"history_truncate_file\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_expand",  "code": "proc history_expand*(a2: cstring; a3: cstringArray): cint {.cdecl, \u000A    importc: \"history_expand\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_arg_extract",  "code": "proc history_arg_extract*(a2: cint; a3: cint; a4: cstring): cstring {.cdecl, \u000A    importc: \"history_arg_extract\", dynlib: historyDll.}" },  { "module": "history",  "name": "get_history_event",  "code": "proc get_history_event*(a2: cstring; a3: ptr cint; a4: cint): cstring {.cdecl, \u000A    importc: \"get_history_event\", dynlib: historyDll.}" },  { "module": "history",  "name": "history_tokenize",  "code": "proc history_tokenize*(a2: cstring): cstringArray {.cdecl, \u000A    importc: \"history_tokenize\", dynlib: historyDll.}" },  { "module": "htmlgen",  "name": "xmlCheckedTag",  "code": "proc xmlCheckedTag*(e: PNimrodNode; tag: string; optAttr = \"\"; reqAttr = \"\"; \u000A                    isLeaf = false): PNimrodNode {.compileTime.}",  "desc": "use this procedure to define a new XML tag" },  { "module": "htmlgen",  "name": "a",  "code": "macro a*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt> element." },  { "module": "htmlgen",  "name": "acronym",  "code": "macro acronym*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">acronym</span></tt> element." },  { "module": "htmlgen",  "name": "address",  "code": "macro address*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> element." },  { "module": "htmlgen",  "name": "area",  "code": "macro area*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">area</span></tt> element." },  { "module": "htmlgen",  "name": "b",  "code": "macro b*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">b</span></tt> element." },  { "module": "htmlgen",  "name": "base",  "code": "macro base*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">base</span></tt> element." },  { "module": "htmlgen",  "name": "big",  "code": "macro big*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">big</span></tt> element." },  { "module": "htmlgen",  "name": "blockquote",  "code": "macro blockquote*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">blockquote</span></tt> element." },  { "module": "htmlgen",  "name": "body",  "code": "macro body*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">body</span></tt> element." },  { "module": "htmlgen",  "name": "br",  "code": "macro br*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">br</span></tt> element." },  { "module": "htmlgen",  "name": "button",  "code": "macro button*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">button</span></tt> element." },  { "module": "htmlgen",  "name": "caption",  "code": "macro caption*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">caption</span></tt> element." },  { "module": "htmlgen",  "name": "cite",  "code": "macro cite*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">cite</span></tt> element." },  { "module": "htmlgen",  "name": "code",  "code": "macro code*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">code</span></tt> element." },  { "module": "htmlgen",  "name": "col",  "code": "macro col*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">col</span></tt> element." },  { "module": "htmlgen",  "name": "colgroup",  "code": "macro colgroup*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">colgroup</span></tt> element." },  { "module": "htmlgen",  "name": "dd",  "code": "macro dd*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">dd</span></tt> element." },  { "module": "htmlgen",  "name": "del",  "code": "macro del*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">del</span></tt> element." },  { "module": "htmlgen",  "name": "dfn",  "code": "macro dfn*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">dfn</span></tt> element." },  { "module": "htmlgen",  "name": "`div`",  "code": "macro `div`*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">div</span></tt> element." },  { "module": "htmlgen",  "name": "dl",  "code": "macro dl*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">dl</span></tt> element." },  { "module": "htmlgen",  "name": "dt",  "code": "macro dt*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">dt</span></tt> element." },  { "module": "htmlgen",  "name": "em",  "code": "macro em*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">em</span></tt> element." },  { "module": "htmlgen",  "name": "fieldset",  "code": "macro fieldset*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">fieldset</span></tt> element." },  { "module": "htmlgen",  "name": "form",  "code": "macro form*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">form</span></tt> element." },  { "module": "htmlgen",  "name": "h1",  "code": "macro h1*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h1</span></tt> element." },  { "module": "htmlgen",  "name": "h2",  "code": "macro h2*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h2</span></tt> element." },  { "module": "htmlgen",  "name": "h3",  "code": "macro h3*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h3</span></tt> element." },  { "module": "htmlgen",  "name": "h4",  "code": "macro h4*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h4</span></tt> element." },  { "module": "htmlgen",  "name": "h5",  "code": "macro h5*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h5</span></tt> element." },  { "module": "htmlgen",  "name": "h6",  "code": "macro h6*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">h6</span></tt> element." },  { "module": "htmlgen",  "name": "head",  "code": "macro head*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">head</span></tt> element." },  { "module": "htmlgen",  "name": "html",  "code": "macro html*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">html</span></tt> element." },  { "module": "htmlgen",  "name": "hr",  "code": "macro hr*(): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">hr</span></tt> element." },  { "module": "htmlgen",  "name": "i",  "code": "macro i*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">i</span></tt> element." },  { "module": "htmlgen",  "name": "img",  "code": "macro img*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">img</span></tt> element." },  { "module": "htmlgen",  "name": "input",  "code": "macro input*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">input</span></tt> element." },  { "module": "htmlgen",  "name": "ins",  "code": "macro ins*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">ins</span></tt> element." },  { "module": "htmlgen",  "name": "kbd",  "code": "macro kbd*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">kbd</span></tt> element." },  { "module": "htmlgen",  "name": "label",  "code": "macro label*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">label</span></tt> element." },  { "module": "htmlgen",  "name": "legend",  "code": "macro legend*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">legend</span></tt> element." },  { "module": "htmlgen",  "name": "li",  "code": "macro li*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">li</span></tt> element." },  { "module": "htmlgen",  "name": "link",  "code": "macro link*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">link</span></tt> element." },  { "module": "htmlgen",  "name": "map",  "code": "macro map*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> element." },  { "module": "htmlgen",  "name": "meta",  "code": "macro meta*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">meta</span></tt> element." },  { "module": "htmlgen",  "name": "noscript",  "code": "macro noscript*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">noscript</span></tt> element." },  { "module": "htmlgen",  "name": "`object`",  "code": "macro `object`*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">object</span></tt> element." },  { "module": "htmlgen",  "name": "ol",  "code": "macro ol*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">ol</span></tt> element." },  { "module": "htmlgen",  "name": "optgroup",  "code": "macro optgroup*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">optgroup</span></tt> element." },  { "module": "htmlgen",  "name": "option",  "code": "macro option*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">option</span></tt> element." },  { "module": "htmlgen",  "name": "p",  "code": "macro p*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> element." },  { "module": "htmlgen",  "name": "param",  "code": "macro param*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">param</span></tt> element." },  { "module": "htmlgen",  "name": "pre",  "code": "macro pre*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">pre</span></tt> element." },  { "module": "htmlgen",  "name": "q",  "code": "macro q*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">q</span></tt> element." },  { "module": "htmlgen",  "name": "samp",  "code": "macro samp*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">samp</span></tt> element." },  { "module": "htmlgen",  "name": "script",  "code": "macro script*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">script</span></tt> element." },  { "module": "htmlgen",  "name": "select",  "code": "macro select*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">select</span></tt> element." },  { "module": "htmlgen",  "name": "small",  "code": "macro small*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">small</span></tt> element." },  { "module": "htmlgen",  "name": "span",  "code": "macro span*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">span</span></tt> element." },  { "module": "htmlgen",  "name": "strong",  "code": "macro strong*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">strong</span></tt> element." },  { "module": "htmlgen",  "name": "style",  "code": "macro style*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">style</span></tt> element." },  { "module": "htmlgen",  "name": "sub",  "code": "macro sub*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">sub</span></tt> element." },  { "module": "htmlgen",  "name": "sup",  "code": "macro sup*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">sup</span></tt> element." },  { "module": "htmlgen",  "name": "table",  "code": "macro table*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">table</span></tt> element." },  { "module": "htmlgen",  "name": "tbody",  "code": "macro tbody*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">tbody</span></tt> element." },  { "module": "htmlgen",  "name": "td",  "code": "macro td*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">td</span></tt> element." },  { "module": "htmlgen",  "name": "textarea",  "code": "macro textarea*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">textarea</span></tt> element." },  { "module": "htmlgen",  "name": "tfoot",  "code": "macro tfoot*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">tfoot</span></tt> element." },  { "module": "htmlgen",  "name": "th",  "code": "macro th*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">th</span></tt> element." },  { "module": "htmlgen",  "name": "thead",  "code": "macro thead*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">thead</span></tt> element." },  { "module": "htmlgen",  "name": "title",  "code": "macro title*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">title</span></tt> element." },  { "module": "htmlgen",  "name": "tr",  "code": "macro tr*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">tr</span></tt> element." },  { "module": "htmlgen",  "name": "tt",  "code": "macro tt*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">tt</span></tt> element." },  { "module": "htmlgen",  "name": "ul",  "code": "macro ul*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">ul</span></tt> element." },  { "module": "htmlgen",  "name": "`var`",  "code": "macro `var`*(e: expr): expr {.immediate.}",  "desc": "generates the HTML <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> element." },  { "module": "htmlparser",  "name": "htmlTag",  "code": "proc htmlTag*(n: XmlNode): THtmlTag",  "desc": "gets <cite>n</cite>'s tag as a <tt class=\"docutils literal\"><span class=\"pre\">THtmlTag</span></tt>." },  { "module": "htmlparser",  "name": "htmlTag",  "code": "proc htmlTag*(s: string): THtmlTag",  "desc": "converts <cite>s</cite> to a <tt class=\"docutils literal\"><span class=\"pre\">THtmlTag</span></tt>. If <cite>s</cite> is no HTML tag, <tt class=\"docutils literal\"><span class=\"pre\">tagUnknown</span></tt> is returned." },  { "module": "htmlparser",  "name": "entityToUtf8",  "code": "proc entityToUtf8*(entity: string): string",  "desc": "converts an HTML entity name like <tt class=\"docutils literal\"><span class=\"pre\">&amp;Uuml;</span></tt> to its UTF-8 equivalent. &quot;&quot; is returned if the entity name is unknown. The HTML parser already converts entities to UTF-8." },  { "module": "htmlparser",  "name": "parseHtml",  "code": "proc parseHtml*(s: Stream; filename: string; errors: var seq[string]): XmlNode",  "desc": "parses the XML from stream <cite>s</cite> and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. Every occured parsing error is added to the <cite>errors</cite> sequence." },  { "module": "htmlparser",  "name": "parseHtml",  "code": "proc parseHtml*(s: Stream): XmlNode",  "desc": "parses the XTML from stream <cite>s</cite> and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. All parsing errors are ignored." },  { "module": "htmlparser",  "name": "loadHtml",  "code": "proc loadHtml*(path: string; errors: var seq[string]): XmlNode",  "desc": "Loads and parses HTML from file specified by <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>.  Every occured parsing error is added to the <cite>errors</cite> sequence." },  { "module": "htmlparser",  "name": "loadHtml",  "code": "proc loadHtml*(path: string): XmlNode",  "desc": "Loads and parses HTML from file specified by <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. All parsing errors are ignored." },  { "module": "httpclient",  "name": "newProxy",  "code": "proc newProxy*(url: string; auth = \"\"): Proxy",  "desc": "Constructs a new <tt class=\"docutils literal\"><span class=\"pre\">TProxy</span></tt> object." },  { "module": "httpclient",  "name": "request",  "code": "proc request*(url: string; httpMethod = httpGET; extraHeaders = \"\"; body = \"\"; \u000A              sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A              userAgent = defUserAgent; proxy: Proxy = nil): Response",  "desc": "<p>Requests <tt class=\"docutils literal\"><span class=\"pre\">url</span></tt> with the specified <tt class=\"docutils literal\"><span class=\"pre\">httpMethod</span></tt>.<br />Extra headers can be specified and must be seperated by <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt><br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "get",  "code": "proc get*(url: string; extraHeaders = \"\"; maxRedirects = 5; \u000A          sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A          userAgent = defUserAgent; proxy: Proxy = nil): Response",  "desc": "<p>GETs the <tt class=\"docutils literal\"><span class=\"pre\">url</span></tt> and returns a <tt class=\"docutils literal\"><span class=\"pre\">Response</span></tt> object<br />This proc also handles redirection<br />Extra headers can be specified and must be separated by <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt>.<br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "getContent",  "code": "proc getContent*(url: string; extraHeaders = \"\"; maxRedirects = 5; \u000A                 sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A                 userAgent = defUserAgent; proxy: Proxy = nil): string",  "desc": "<p>GETs the body and returns it as a string.<br />Raises exceptions for the status codes <tt class=\"docutils literal\"><span class=\"pre\">4xx</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">5xx</span></tt><br />Extra headers can be specified and must be separated by <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt>.<br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "post",  "code": "proc post*(url: string; extraHeaders = \"\"; body = \"\"; maxRedirects = 5; \u000A           sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A           userAgent = defUserAgent; proxy: Proxy = nil): Response",  "desc": "<p>POSTs <tt class=\"docutils literal\"><span class=\"pre\">body</span></tt> to the <tt class=\"docutils literal\"><span class=\"pre\">url</span></tt> and returns a <tt class=\"docutils literal\"><span class=\"pre\">Response</span></tt> object.<br />This proc adds the necessary Content-Length header.<br />This proc also handles redirection.<br />Extra headers can be specified and must be separated by <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt>.<br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "postContent",  "code": "proc postContent*(url: string; extraHeaders = \"\"; body = \"\"; maxRedirects = 5; \u000A                  sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A                  userAgent = defUserAgent; proxy: Proxy = nil): string",  "desc": "<p>POSTs <tt class=\"docutils literal\"><span class=\"pre\">body</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">url</span></tt> and returns the response's body as a string<br />Raises exceptions for the status codes <tt class=\"docutils literal\"><span class=\"pre\">4xx</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">5xx</span></tt><br />Extra headers can be specified and must be separated by <tt class=\"docutils literal\"><span class=\"pre\">\\c\\L</span></tt>.<br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "downloadFile",  "code": "proc downloadFile*(url: string; outputFilename: string; \u000A                   sslContext: SSLContext = defaultSSLContext; timeout = - 1; \u000A                   userAgent = defUserAgent; proxy: Proxy = nil)",  "desc": "<p>Downloads <tt class=\"docutils literal\"><span class=\"pre\">url</span></tt> and saves it to <tt class=\"docutils literal\"><span class=\"pre\">outputFilename</span></tt><br />An optional timeout can be specified in miliseconds, if reading from the<br /></p><p>server takes longer than specified an ETimeout exception will be raised.</p>\u000A" },  { "module": "httpclient",  "name": "newAsyncHttpClient",  "code": "proc newAsyncHttpClient*(userAgent = defUserAgent; maxRedirects = 5; \u000A                         sslContext = defaultSslContext): AsyncHttpClient",  "desc": "<p>Creates a new AsyncHttpClient instance.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">userAgent</span></tt> specifies the user agent that will be used when making requests.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">maxRedirects</span></tt> specifies the maximum amount of redirects to follow, default is 5.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">sslContext</span></tt> specifies the SSL context to use for HTTPS requests.</p>\u000A" },  { "module": "httpclient",  "name": "close",  "code": "proc close*(client: AsyncHttpClient)",  "desc": "Closes any connections held by the HTTP client." },  { "module": "httpclient",  "name": "request",  "code": "proc request*(client: AsyncHttpClient; url: string; httpMethod = httpGET; \u000A              body = \"\"): Future[Response] {.async.}",  "desc": "<p>Connects to the hostname specified by the URL and performs a request using the method specified.</p>\u000A<p>Connection will kept alive. Further requests on the same <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> to the same hostname will not require a new connection to be made. The connection can be closed by using the <tt class=\"docutils literal\"><span class=\"pre\">close</span></tt> procedure.</p>\u000A<p>The returned future will complete once the request is completed.</p>\u000A" },  { "module": "httpclient",  "name": "get",  "code": "proc get*(client: AsyncHttpClient; url: string): Future[Response] {.async.}",  "desc": "<p>Connects to the hostname specified by the URL and performs a GET request.</p>\u000A<p>This procedure will follow redirects up to a maximum number of redirects specified in <tt class=\"docutils literal\"><span class=\"pre\">newAsyncHttpClient</span></tt>.</p>\u000A" },  { "module": "httpserver",  "name": "serveFile",  "code": "proc serveFile*(client: Socket; filename: string)",  "desc": "serves a file to the client." },  { "module": "httpserver",  "name": "open",  "code": "proc open*(s: var TServer; port = Port(80); reuseAddr = false)",  "desc": "creates a new server at port <cite>port</cite>. If <tt class=\"docutils literal\"><span class=\"pre\">port == 0</span></tt> a free port is acquired that can be accessed later by the <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> proc." },  { "module": "httpserver",  "name": "port",  "code": "proc port*(s: var TServer): Port",  "desc": "get the port number the server has acquired." },  { "module": "httpserver",  "name": "next",  "code": "proc next*(s: var TServer)",  "desc": "proceed to the first/next request." },  { "module": "httpserver",  "name": "close",  "code": "proc close*(s: TServer)",  "desc": "closes the server (and the socket the server uses)." },  { "module": "httpserver",  "name": "run",  "code": "proc run*(handleRequest: proc (client: Socket; path, query: string): bool {.\u000A    closure.}; port = Port(80))",  "desc": "encapsulates the server object and main loop" },  { "module": "httpserver",  "name": "asyncHTTPServer",  "code": "proc asyncHTTPServer*(handleRequest: proc (server: PAsyncHTTPServer; \u000A    client: Socket; path, query: string): bool {.closure, gcsafe.}; \u000A                      port = Port(80); address = \"\"; reuseAddr = false): PAsyncHTTPServer",  "desc": "Creates an Asynchronous HTTP server at <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>." },  { "module": "httpserver",  "name": "register",  "code": "proc register*(d: Dispatcher; s: PAsyncHTTPServer)",  "desc": "Registers a <tt class=\"docutils literal\"><span class=\"pre\">PAsyncHTTPServer</span></tt> with a <tt class=\"docutils literal\"><span class=\"pre\">Dispatcher</span></tt>." },  { "module": "httpserver",  "name": "close",  "code": "proc close*(h: PAsyncHTTPServer)",  "desc": "Closes the <tt class=\"docutils literal\"><span class=\"pre\">PAsyncHTTPServer</span></tt>." },  { "module": "inotify",  "name": "inotify_init",  "code": "proc inotify_init*(): cint {.cdecl, importc: \"inotify_init\", \u000A                             header: \"<sys/inotify.h>\".}" },  { "module": "inotify",  "name": "inotify_init1",  "code": "proc inotify_init1*(flags: cint): cint {.cdecl, importc: \"inotify_init1\", \u000A    header: \"<sys/inotify.h>\".}" },  { "module": "inotify",  "name": "inotify_add_watch",  "code": "proc inotify_add_watch*(fd: cint; name: cstring; mask: uint32): cint {.cdecl, \u000A    importc: \"inotify_add_watch\", header: \"<sys/inotify.h>\".}" },  { "module": "inotify",  "name": "inotify_rm_watch",  "code": "proc inotify_rm_watch*(fd: cint; wd: cint): cint {.cdecl, \u000A    importc: \"inotify_rm_watch\", header: \"<sys/inotify.h>\".}" },  { "module": "intsets",  "name": "contains",  "code": "proc contains*(s: IntSet; key: int): bool",  "desc": "returns true iff <cite>key</cite> is in <cite>s</cite>.  " },  { "module": "intsets",  "name": "incl",  "code": "proc incl*(s: var IntSet; key: int)",  "desc": "includes an element <cite>key</cite> in <cite>s</cite>." },  { "module": "intsets",  "name": "excl",  "code": "proc excl*(s: var IntSet; key: int)",  "desc": "excludes <cite>key</cite> from the set <cite>s</cite>." },  { "module": "intsets",  "name": "containsOrIncl",  "code": "proc containsOrIncl*(s: var IntSet; key: int): bool",  "desc": "returns true if <cite>s</cite> contains <cite>key</cite>, otherwise <cite>key</cite> is included in <cite>s</cite> and false is returned." },  { "module": "intsets",  "name": "initIntSet",  "code": "proc initIntSet*(): IntSet",  "desc": "creates a new int set that is empty." },  { "module": "intsets",  "name": "assign",  "code": "proc assign*(dest: var IntSet; src: IntSet)",  "desc": "copies <cite>src</cite> to <cite>dest</cite>. <cite>dest</cite> does not need to be initialized by <cite>initIntSet</cite>. " },  { "module": "intsets",  "name": "items",  "code": "iterator items*(s: IntSet): int {.inline.}",  "desc": "iterates over any included element of <cite>s</cite>." },  { "module": "intsets",  "name": "`$`",  "code": "proc `$`*(s: IntSet): string",  "desc": "The <cite>$</cite> operator for int sets." },  { "module": "intsets",  "name": "empty",  "code": "proc empty*(s: IntSet): bool {.inline.}",  "desc": "returns true if <cite>s</cite> is empty. This is safe to call even before the set has been initialized with <cite>initIntSet</cite>." },  { "module": "iup",  "name": "fileDlg",  "code": "proc fileDlg*(): PIhandle {.importc: \"IupFileDlg\", dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "messageDlg",  "code": "proc messageDlg*(): PIhandle {.importc: \"IupMessageDlg\", dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "colorDlg",  "code": "proc colorDlg*(): PIhandle {.importc: \"IupColorDlg\", dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "fontDlg",  "code": "proc fontDlg*(): PIhandle {.importc: \"IupFontDlg\", dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "getFile",  "code": "proc getFile*(arq: cstring): cint {.importc: \"IupGetFile\", dynlib: dllname, \u000A                                    cdecl.}" },  { "module": "iup",  "name": "message",  "code": "proc message*(title, msg: cstring) {.importc: \"IupMessage\", dynlib: dllname, \u000A                                     cdecl.}" },  { "module": "iup",  "name": "messagef",  "code": "proc messagef*(title, format: cstring) {.importc: \"IupMessagef\", \u000A    dynlib: dllname, cdecl, varargs.}" },  { "module": "iup",  "name": "alarm",  "code": "proc alarm*(title, msg, b1, b2, b3: cstring): cint {.importc: \"IupAlarm\", \u000A    dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "scanf",  "code": "proc scanf*(format: cstring): cint {.importc: \"IupScanf\", dynlib: dllname, \u000A                                     cdecl, varargs.}" },  { "module": "iup",  "name": "listDialog",  "code": "proc listDialog*(theType: cint; title: cstring; size: cint; list: cstringArray; \u000A                 op, maxCol, maxLin: cint; marks: ptr cint): cint {.\u000A    importc: \"IupListDialog\", dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "getText",  "code": "proc getText*(title, text: cstring): cint {.importc: \"IupGetText\", \u000A    dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "getColor",  "code": "proc getColor*(x, y: cint; r, g, b: var byte): cint {.importc: \"IupGetColor\", \u000A    dynlib: dllname, cdecl.}" },  { "module": "iup",  "name": "getParam",  "code": "proc getParam*(title: cstring; action: Iparamcb; userData: pointer; \u000A               format: cstring): cint {.importc: \"IupGetParam\", cdecl, varargs, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "getParamv",  "code": "proc getParamv*(title: cstring; action: Iparamcb; userData: pointer; \u000A                format: cstring; paramCount, paramExtra: cint; \u000A                paramData: pointer): cint {.importc: \"IupGetParamv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "open",  "code": "proc open*(argc: ptr cint; argv: ptr cstringArray): cint {.importc: \"IupOpen\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "close",  "code": "proc close*() {.importc: \"IupClose\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "imageLibOpen",  "code": "proc imageLibOpen*() {.importc: \"IupImageLibOpen\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "mainLoop",  "code": "proc mainLoop*(): cint {.importc: \"IupMainLoop\", cdecl, dynlib: dllname, \u000A                         discardable.}" },  { "module": "iup",  "name": "loopStep",  "code": "proc loopStep*(): cint {.importc: \"IupLoopStep\", cdecl, dynlib: dllname, \u000A                         discardable.}" },  { "module": "iup",  "name": "mainLoopLevel",  "code": "proc mainLoopLevel*(): cint {.importc: \"IupMainLoopLevel\", cdecl, \u000A                              dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "flush",  "code": "proc flush*() {.importc: \"IupFlush\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "exitLoop",  "code": "proc exitLoop*() {.importc: \"IupExitLoop\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "update",  "code": "proc update*(ih: PIhandle) {.importc: \"IupUpdate\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "updateChildren",  "code": "proc updateChildren*(ih: PIhandle) {.importc: \"IupUpdateChildren\", cdecl, \u000A                                     dynlib: dllname.}" },  { "module": "iup",  "name": "redraw",  "code": "proc redraw*(ih: PIhandle; children: cint) {.importc: \"IupRedraw\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "refresh",  "code": "proc refresh*(ih: PIhandle) {.importc: \"IupRefresh\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "mapFont",  "code": "proc mapFont*(iupfont: cstring): cstring {.importc: \"IupMapFont\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "unMapFont",  "code": "proc unMapFont*(driverfont: cstring): cstring {.importc: \"IupUnMapFont\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "help",  "code": "proc help*(url: cstring): cint {.importc: \"IupHelp\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "load",  "code": "proc load*(filename: cstring): cstring {.importc: \"IupLoad\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "iupVersion",  "code": "proc iupVersion*(): cstring {.importc: \"IupVersion\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "iupVersionDate",  "code": "proc iupVersionDate*(): cstring {.importc: \"IupVersionDate\", cdecl, \u000A                                  dynlib: dllname.}" },  { "module": "iup",  "name": "iupVersionNumber",  "code": "proc iupVersionNumber*(): cint {.importc: \"IupVersionNumber\", cdecl, \u000A                                 dynlib: dllname.}" },  { "module": "iup",  "name": "setLanguage",  "code": "proc setLanguage*(lng: cstring) {.importc: \"IupSetLanguage\", cdecl, \u000A                                  dynlib: dllname.}" },  { "module": "iup",  "name": "getLanguage",  "code": "proc getLanguage*(): cstring {.importc: \"IupGetLanguage\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "destroy",  "code": "proc destroy*(ih: PIhandle) {.importc: \"IupDestroy\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "detach",  "code": "proc detach*(child: PIhandle) {.importc: \"IupDetach\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "append",  "code": "proc append*(ih, child: PIhandle): PIhandle {.importc: \"IupAppend\", cdecl, \u000A    dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "insert",  "code": "proc insert*(ih, refChild, child: PIhandle): PIhandle {.importc: \"IupInsert\", \u000A    cdecl, dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "getChild",  "code": "proc getChild*(ih: PIhandle; pos: cint): PIhandle {.importc: \"IupGetChild\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getChildPos",  "code": "proc getChildPos*(ih, child: PIhandle): cint {.importc: \"IupGetChildPos\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getChildCount",  "code": "proc getChildCount*(ih: PIhandle): cint {.importc: \"IupGetChildCount\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getNextChild",  "code": "proc getNextChild*(ih, child: PIhandle): PIhandle {.importc: \"IupGetNextChild\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getBrother",  "code": "proc getBrother*(ih: PIhandle): PIhandle {.importc: \"IupGetBrother\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getParent",  "code": "proc getParent*(ih: PIhandle): PIhandle {.importc: \"IupGetParent\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getDialog",  "code": "proc getDialog*(ih: PIhandle): PIhandle {.importc: \"IupGetDialog\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getDialogChild",  "code": "proc getDialogChild*(ih: PIhandle; name: cstring): PIhandle {.\u000A    importc: \"IupGetDialogChild\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "reparent",  "code": "proc reparent*(ih, newParent: PIhandle): cint {.importc: \"IupReparent\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "popup",  "code": "proc popup*(ih: PIhandle; x, y: cint): cint {.importc: \"IupPopup\", cdecl, \u000A    dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "show",  "code": "proc show*(ih: PIhandle): cint {.importc: \"IupShow\", cdecl, dynlib: dllname, \u000A                                 discardable.}" },  { "module": "iup",  "name": "showXY",  "code": "proc showXY*(ih: PIhandle; x, y: cint): cint {.importc: \"IupShowXY\", cdecl, \u000A    dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "hide",  "code": "proc hide*(ih: PIhandle): cint {.importc: \"IupHide\", cdecl, dynlib: dllname, \u000A                                 discardable.}" },  { "module": "iup",  "name": "map",  "code": "proc map*(ih: PIhandle): cint {.importc: \"IupMap\", cdecl, dynlib: dllname, \u000A                                discardable.}" },  { "module": "iup",  "name": "unmap",  "code": "proc unmap*(ih: PIhandle) {.importc: \"IupUnmap\", cdecl, dynlib: dllname, \u000A                            discardable.}" },  { "module": "iup",  "name": "setAttribute",  "code": "proc setAttribute*(ih: PIhandle; name, value: cstring) {.\u000A    importc: \"IupSetAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "storeAttribute",  "code": "proc storeAttribute*(ih: PIhandle; name, value: cstring) {.\u000A    importc: \"IupStoreAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "setAttributes",  "code": "proc setAttributes*(ih: PIhandle; str: cstring): PIhandle {.\u000A    importc: \"IupSetAttributes\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getAttribute",  "code": "proc getAttribute*(ih: PIhandle; name: cstring): cstring {.\u000A    importc: \"IupGetAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getAttributes",  "code": "proc getAttributes*(ih: PIhandle): cstring {.importc: \"IupGetAttributes\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getInt",  "code": "proc getInt*(ih: PIhandle; name: cstring): cint {.importc: \"IupGetInt\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getInt2",  "code": "proc getInt2*(ih: PIhandle; name: cstring): cint {.importc: \"IupGetInt2\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getIntInt",  "code": "proc getIntInt*(ih: PIhandle; name: cstring; i1, i2: var cint): cint {.\u000A    importc: \"IupGetIntInt\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getFloat",  "code": "proc getFloat*(ih: PIhandle; name: cstring): cfloat {.importc: \"IupGetFloat\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "setfAttribute",  "code": "proc setfAttribute*(ih: PIhandle; name, format: cstring) {.\u000A    importc: \"IupSetfAttribute\", cdecl, dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "getAllAttributes",  "code": "proc getAllAttributes*(ih: PIhandle; names: cstringArray; n: cint): cint {.\u000A    importc: \"IupGetAllAttributes\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "setAtt",  "code": "proc setAtt*(handleName: cstring; ih: PIhandle; name: cstring): PIhandle {.\u000A    importc: \"IupSetAtt\", cdecl, dynlib: dllname, varargs, discardable.}" },  { "module": "iup",  "name": "setGlobal",  "code": "proc setGlobal*(name, value: cstring) {.importc: \"IupSetGlobal\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "storeGlobal",  "code": "proc storeGlobal*(name, value: cstring) {.importc: \"IupStoreGlobal\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getGlobal",  "code": "proc getGlobal*(name: cstring): cstring {.importc: \"IupGetGlobal\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "setFocus",  "code": "proc setFocus*(ih: PIhandle): PIhandle {.importc: \"IupSetFocus\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getFocus",  "code": "proc getFocus*(): PIhandle {.importc: \"IupGetFocus\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "previousField",  "code": "proc previousField*(ih: PIhandle): PIhandle {.importc: \"IupPreviousField\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "nextField",  "code": "proc nextField*(ih: PIhandle): PIhandle {.importc: \"IupNextField\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getCallback",  "code": "proc getCallback*(ih: PIhandle; name: cstring): Icallback {.\u000A    importc: \"IupGetCallback\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "setCallback",  "code": "proc setCallback*(ih: PIhandle; name: cstring; fn: Icallback): Icallback {.\u000A    importc: \"IupSetCallback\", cdecl, dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "setCallbacks",  "code": "proc setCallbacks*(ih: PIhandle; name: cstring; fn: Icallback): PIhandle {.\u000A    importc: \"IupSetCallbacks\", cdecl, dynlib: dllname, varargs, discardable.}" },  { "module": "iup",  "name": "getFunction",  "code": "proc getFunction*(name: cstring): Icallback {.importc: \"IupGetFunction\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "setFunction",  "code": "proc setFunction*(name: cstring; fn: Icallback): Icallback {.\u000A    importc: \"IupSetFunction\", cdecl, dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "getActionName",  "code": "proc getActionName*(): cstring {.importc: \"IupGetActionName\", cdecl, \u000A                                 dynlib: dllname.}" },  { "module": "iup",  "name": "getHandle",  "code": "proc getHandle*(name: cstring): PIhandle {.importc: \"IupGetHandle\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "setHandle",  "code": "proc setHandle*(name: cstring; ih: PIhandle): PIhandle {.\u000A    importc: \"IupSetHandle\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getAllNames",  "code": "proc getAllNames*(names: cstringArray; n: cint): cint {.\u000A    importc: \"IupGetAllNames\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getAllDialogs",  "code": "proc getAllDialogs*(names: cstringArray; n: cint): cint {.\u000A    importc: \"IupGetAllDialogs\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getName",  "code": "proc getName*(ih: PIhandle): cstring {.importc: \"IupGetName\", cdecl, \u000A                                       dynlib: dllname.}" },  { "module": "iup",  "name": "setAttributeHandle",  "code": "proc setAttributeHandle*(ih: PIhandle; name: cstring; ihNamed: PIhandle) {.\u000A    importc: \"IupSetAttributeHandle\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getAttributeHandle",  "code": "proc getAttributeHandle*(ih: PIhandle; name: cstring): PIhandle {.\u000A    importc: \"IupGetAttributeHandle\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "getClassName",  "code": "proc getClassName*(ih: PIhandle): cstring {.importc: \"IupGetClassName\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getClassType",  "code": "proc getClassType*(ih: PIhandle): cstring {.importc: \"IupGetClassType\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "getClassAttributes",  "code": "proc getClassAttributes*(classname: cstring; names: cstringArray; n: cint): cint {.\u000A    importc: \"IupGetClassAttributes\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "saveClassAttributes",  "code": "proc saveClassAttributes*(ih: PIhandle) {.importc: \"IupSaveClassAttributes\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "setClassDefaultAttribute",  "code": "proc setClassDefaultAttribute*(classname, name, value: cstring) {.\u000A    importc: \"IupSetClassDefaultAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "create",  "code": "proc create*(classname: cstring): PIhandle {.importc: \"IupCreate\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "createv",  "code": "proc createv*(classname: cstring; params: pointer): PIhandle {.\u000A    importc: \"IupCreatev\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "createp",  "code": "proc createp*(classname: cstring; first: pointer): PIhandle {.\u000A    importc: \"IupCreatep\", cdecl, dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "fill",  "code": "proc fill*(): PIhandle {.importc: \"IupFill\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "radio",  "code": "proc radio*(child: PIhandle): PIhandle {.importc: \"IupRadio\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "vbox",  "code": "proc vbox*(child: PIhandle): PIhandle {.importc: \"IupVbox\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "vboxv",  "code": "proc vboxv*(children: ptr PIhandle): PIhandle {.importc: \"IupVboxv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "zbox",  "code": "proc zbox*(child: PIhandle): PIhandle {.importc: \"IupZbox\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "zboxv",  "code": "proc zboxv*(children: ptr PIhandle): PIhandle {.importc: \"IupZboxv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "hbox",  "code": "proc hbox*(child: PIhandle): PIhandle {.importc: \"IupHbox\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "hboxv",  "code": "proc hboxv*(children: ptr PIhandle): PIhandle {.importc: \"IupHboxv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "normalizer",  "code": "proc normalizer*(ihFirst: PIhandle): PIhandle {.importc: \"IupNormalizer\", cdecl, \u000A    dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "normalizerv",  "code": "proc normalizerv*(ihList: ptr PIhandle): PIhandle {.importc: \"IupNormalizerv\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "cbox",  "code": "proc cbox*(child: PIhandle): PIhandle {.importc: \"IupCbox\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "cboxv",  "code": "proc cboxv*(children: ptr PIhandle): PIhandle {.importc: \"IupCboxv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "sbox",  "code": "proc sbox*(child: PIhandle): PIhandle {.importc: \"IupSbox\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "frame",  "code": "proc frame*(child: PIhandle): PIhandle {.importc: \"IupFrame\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "image",  "code": "proc image*(width, height: cint; pixmap: pointer): PIhandle {.\u000A    importc: \"IupImage\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "imageRGB",  "code": "proc imageRGB*(width, height: cint; pixmap: pointer): PIhandle {.\u000A    importc: \"IupImageRGB\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "imageRGBA",  "code": "proc imageRGBA*(width, height: cint; pixmap: pointer): PIhandle {.\u000A    importc: \"IupImageRGBA\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "item",  "code": "proc item*(title, action: cstring): PIhandle {.importc: \"IupItem\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "submenu",  "code": "proc submenu*(title: cstring; child: PIhandle): PIhandle {.\u000A    importc: \"IupSubmenu\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "separator",  "code": "proc separator*(): PIhandle {.importc: \"IupSeparator\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "menu",  "code": "proc menu*(child: PIhandle): PIhandle {.importc: \"IupMenu\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "menuv",  "code": "proc menuv*(children: ptr PIhandle): PIhandle {.importc: \"IupMenuv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "button",  "code": "proc button*(title, action: cstring): PIhandle {.importc: \"IupButton\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "canvas",  "code": "proc canvas*(action: cstring): PIhandle {.importc: \"IupCanvas\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "dialog",  "code": "proc dialog*(child: PIhandle): PIhandle {.importc: \"IupDialog\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "user",  "code": "proc user*(): PIhandle {.importc: \"IupUser\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "label",  "code": "proc label*(title: cstring): PIhandle {.importc: \"IupLabel\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "list",  "code": "proc list*(action: cstring): PIhandle {.importc: \"IupList\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "text",  "code": "proc text*(action: cstring): PIhandle {.importc: \"IupText\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "multiLine",  "code": "proc multiLine*(action: cstring): PIhandle {.importc: \"IupMultiLine\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "toggle",  "code": "proc toggle*(title, action: cstring): PIhandle {.importc: \"IupToggle\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "timer",  "code": "proc timer*(): PIhandle {.importc: \"IupTimer\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "progressBar",  "code": "proc progressBar*(): PIhandle {.importc: \"IupProgressBar\", cdecl, \u000A                                dynlib: dllname.}" },  { "module": "iup",  "name": "val",  "code": "proc val*(theType: cstring): PIhandle {.importc: \"IupVal\", cdecl, \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "tabs",  "code": "proc tabs*(child: PIhandle): PIhandle {.importc: \"IupTabs\", cdecl, \u000A                                        dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "tabsv",  "code": "proc tabsv*(children: ptr PIhandle): PIhandle {.importc: \"IupTabsv\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "tree",  "code": "proc tree*(): PIhandle {.importc: \"IupTree\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "spin",  "code": "proc spin*(): PIhandle {.importc: \"IupSpin\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "spinbox",  "code": "proc spinbox*(child: PIhandle): PIhandle {.importc: \"IupSpinbox\", cdecl, \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "textConvertLinColToPos",  "code": "proc textConvertLinColToPos*(ih: PIhandle; lin, col: cint; pos: var cint) {.\u000A    importc: \"IupTextConvertLinColToPos\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "textConvertPosToLinCol",  "code": "proc textConvertPosToLinCol*(ih: PIhandle; pos: cint; lin, col: var cint) {.\u000A    importc: \"IupTextConvertPosToLinCol\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "convertXYToPos",  "code": "proc convertXYToPos*(ih: PIhandle; x, y: cint): cint {.\u000A    importc: \"IupConvertXYToPos\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeSetUserId",  "code": "proc treeSetUserId*(ih: PIhandle; id: cint; userid: pointer): cint {.\u000A    importc: \"IupTreeSetUserId\", cdecl, dynlib: dllname, discardable.}" },  { "module": "iup",  "name": "treeGetUserId",  "code": "proc treeGetUserId*(ih: PIhandle; id: cint): pointer {.\u000A    importc: \"IupTreeGetUserId\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeGetId",  "code": "proc treeGetId*(ih: PIhandle; userid: pointer): cint {.importc: \"IupTreeGetId\", \u000A    cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeSetAttribute",  "code": "proc treeSetAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.\u000A    importc: \"IupTreeSetAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeStoreAttribute",  "code": "proc treeStoreAttribute*(ih: PIhandle; name: cstring; id: cint; value: cstring) {.\u000A    importc: \"IupTreeStoreAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeGetAttribute",  "code": "proc treeGetAttribute*(ih: PIhandle; name: cstring; id: cint): cstring {.\u000A    importc: \"IupTreeGetAttribute\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeGetInt",  "code": "proc treeGetInt*(ih: PIhandle; name: cstring; id: cint): cint {.\u000A    importc: \"IupTreeGetInt\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeGetFloat",  "code": "proc treeGetFloat*(ih: PIhandle; name: cstring; id: cint): cfloat {.\u000A    importc: \"IupTreeGetFloat\", cdecl, dynlib: dllname.}" },  { "module": "iup",  "name": "treeSetfAttribute",  "code": "proc treeSetfAttribute*(ih: PIhandle; name: cstring; id: cint; format: cstring) {.\u000A    importc: \"IupTreeSetfAttribute\", cdecl, dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "isShift",  "code": "proc isShift*(s: cstring): bool" },  { "module": "iup",  "name": "isControl",  "code": "proc isControl*(s: cstring): bool" },  { "module": "iup",  "name": "isButton1",  "code": "proc isButton1*(s: cstring): bool" },  { "module": "iup",  "name": "isButton2",  "code": "proc isButton2*(s: cstring): bool" },  { "module": "iup",  "name": "isbutton3",  "code": "proc isbutton3*(s: cstring): bool" },  { "module": "iup",  "name": "isDouble",  "code": "proc isDouble*(s: cstring): bool" },  { "module": "iup",  "name": "isAlt",  "code": "proc isAlt*(s: cstring): bool" },  { "module": "iup",  "name": "isSys",  "code": "proc isSys*(s: cstring): bool" },  { "module": "iup",  "name": "isButton4",  "code": "proc isButton4*(s: cstring): bool" },  { "module": "iup",  "name": "isButton5",  "code": "proc isButton5*(s: cstring): bool" },  { "module": "iup",  "name": "isPrint",  "code": "proc isPrint*(c: cint): bool" },  { "module": "iup",  "name": "isXkey",  "code": "proc isXkey*(c: cint): bool" },  { "module": "iup",  "name": "isShiftXkey",  "code": "proc isShiftXkey*(c: cint): bool" },  { "module": "iup",  "name": "isCtrlXkey",  "code": "proc isCtrlXkey*(c: cint): bool" },  { "module": "iup",  "name": "isAltXkey",  "code": "proc isAltXkey*(c: cint): bool" },  { "module": "iup",  "name": "isSysXkey",  "code": "proc isSysXkey*(c: cint): bool" },  { "module": "iup",  "name": "iUPxCODE",  "code": "proc iUPxCODE*(c: cint): cint" },  { "module": "iup",  "name": "iUPsxCODE",  "code": "proc iUPsxCODE*(c: cint): cint" },  { "module": "iup",  "name": "iUPcxCODE",  "code": "proc iUPcxCODE*(c: cint): cint" },  { "module": "iup",  "name": "iUPmxCODE",  "code": "proc iUPmxCODE*(c: cint): cint" },  { "module": "iup",  "name": "iUPyxCODE",  "code": "proc iUPyxCODE*(c: cint): cint" },  { "module": "iup",  "name": "controlsOpen",  "code": "proc controlsOpen*(): cint {.cdecl, importc: \"IupControlsOpen\", dynlib: dllname.}" },  { "module": "iup",  "name": "controlsClose",  "code": "proc controlsClose*() {.cdecl, importc: \"IupControlsClose\", dynlib: dllname.}" },  { "module": "iup",  "name": "oldValOpen",  "code": "proc oldValOpen*() {.cdecl, importc: \"IupOldValOpen\", dynlib: dllname.}" },  { "module": "iup",  "name": "oldTabsOpen",  "code": "proc oldTabsOpen*() {.cdecl, importc: \"IupOldTabsOpen\", dynlib: dllname.}" },  { "module": "iup",  "name": "colorbar",  "code": "proc colorbar*(): PIhandle {.cdecl, importc: \"IupColorbar\", dynlib: dllname.}" },  { "module": "iup",  "name": "cells",  "code": "proc cells*(): PIhandle {.cdecl, importc: \"IupCells\", dynlib: dllname.}" },  { "module": "iup",  "name": "colorBrowser",  "code": "proc colorBrowser*(): PIhandle {.cdecl, importc: \"IupColorBrowser\", \u000A                                 dynlib: dllname.}" },  { "module": "iup",  "name": "gauge",  "code": "proc gauge*(): PIhandle {.cdecl, importc: \"IupGauge\", dynlib: dllname.}" },  { "module": "iup",  "name": "dial",  "code": "proc dial*(theType: cstring): PIhandle {.cdecl, importc: \"IupDial\", \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "matrix",  "code": "proc matrix*(action: cstring): PIhandle {.cdecl, importc: \"IupMatrix\", \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "matSetAttribute",  "code": "proc matSetAttribute*(ih: PIhandle; name: cstring; lin, col: cint; \u000A                      value: cstring) {.cdecl, importc: \"IupMatSetAttribute\", \u000A                                        dynlib: dllname.}" },  { "module": "iup",  "name": "matStoreAttribute",  "code": "proc matStoreAttribute*(ih: PIhandle; name: cstring; lin, col: cint; \u000A                        value: cstring) {.cdecl, \u000A    importc: \"IupMatStoreAttribute\", dynlib: dllname.}" },  { "module": "iup",  "name": "matGetAttribute",  "code": "proc matGetAttribute*(ih: PIhandle; name: cstring; lin, col: cint): cstring {.\u000A    cdecl, importc: \"IupMatGetAttribute\", dynlib: dllname.}" },  { "module": "iup",  "name": "matGetInt",  "code": "proc matGetInt*(ih: PIhandle; name: cstring; lin, col: cint): cint {.cdecl, \u000A    importc: \"IupMatGetInt\", dynlib: dllname.}" },  { "module": "iup",  "name": "matGetFloat",  "code": "proc matGetFloat*(ih: PIhandle; name: cstring; lin, col: cint): cfloat {.cdecl, \u000A    importc: \"IupMatGetFloat\", dynlib: dllname.}" },  { "module": "iup",  "name": "matSetfAttribute",  "code": "proc matSetfAttribute*(ih: PIhandle; name: cstring; lin, col: cint; \u000A                       format: cstring) {.cdecl, importc: \"IupMatSetfAttribute\", \u000A    dynlib: dllname, varargs.}" },  { "module": "iup",  "name": "pPlotOpen",  "code": "proc pPlotOpen*() {.cdecl, importc: \"IupPPlotOpen\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlot",  "code": "proc pPlot*(): PIhandle {.cdecl, importc: \"IupPPlot\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotBegin",  "code": "proc pPlotBegin*(ih: PIhandle; strXdata: cint) {.cdecl, \u000A    importc: \"IupPPlotBegin\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotAdd",  "code": "proc pPlotAdd*(ih: PIhandle; x, y: cfloat) {.cdecl, importc: \"IupPPlotAdd\", \u000A    dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotAddStr",  "code": "proc pPlotAddStr*(ih: PIhandle; x: cstring; y: cfloat) {.cdecl, \u000A    importc: \"IupPPlotAddStr\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotEnd",  "code": "proc pPlotEnd*(ih: PIhandle): cint {.cdecl, importc: \"IupPPlotEnd\", \u000A                                     dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotInsertStr",  "code": "proc pPlotInsertStr*(ih: PIhandle; index, sampleIndex: cint; x: cstring; \u000A                     y: cfloat) {.cdecl, importc: \"IupPPlotInsertStr\", \u000A                                  dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotInsert",  "code": "proc pPlotInsert*(ih: PIhandle; index, sampleIndex: cint; x, y: cfloat) {.cdecl, \u000A    importc: \"IupPPlotInsert\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotTransform",  "code": "proc pPlotTransform*(ih: PIhandle; x, y: cfloat; ix, iy: var cint) {.cdecl, \u000A    importc: \"IupPPlotTransform\", dynlib: dllname.}" },  { "module": "iup",  "name": "pPlotPaintTo",  "code": "proc pPlotPaintTo*(ih: PIhandle; cnv: pointer) {.cdecl, \u000A    importc: \"IupPPlotPaintTo\", dynlib: dllname.}" },  { "module": "joyent_http_parser",  "name": "http_parser_init",  "code": "proc http_parser_init*(parser: var THttpParser; typ: THttpParserType) {.\u000A    importc: \"http_parser_init\", header: \"http_parser.h\".}" },  { "module": "joyent_http_parser",  "name": "http_parser_execute",  "code": "proc http_parser_execute*(parser: var THttpParser; \u000A                          settings: var THttpParserSettings; data: cstring; \u000A                          len: csize): csize {.importc: \"http_parser_execute\", \u000A    header: \"http_parser.h\".}" },  { "module": "joyent_http_parser",  "name": "http_should_keep_alive",  "code": "proc http_should_keep_alive*(parser: var THttpParser): cint {.\u000A    importc: \"http_should_keep_alive\", header: \"http_parser.h\".}" },  { "module": "joyent_http_parser",  "name": "http_method_str",  "code": "proc http_method_str*(m: THttpMethod): cstring {.importc: \"http_method_str\", \u000A    header: \"http_parser.h\".}" },  { "module": "joyent_http_parser",  "name": "http_errno_name",  "code": "proc http_errno_name*(err: THttpErrNo): cstring {.importc: \"http_errno_name\", \u000A    header: \"http_parser.h\".}" },  { "module": "joyent_http_parser",  "name": "http_errno_description",  "code": "proc http_errno_description*(err: THttpErrNo): cstring {.\u000A    importc: \"http_errno_description\", header: \"http_parser.h\".}" },  { "module": "json",  "name": "open",  "code": "proc open*(my: var JsonParser; input: Stream; filename: string)",  "desc": "initializes the parser with an input stream. <cite>Filename</cite> is only used for nice error messages." },  { "module": "json",  "name": "close",  "code": "proc close*(my: var JsonParser) {.inline.}",  "desc": "closes the parser <cite>my</cite> and its associated input stream." },  { "module": "json",  "name": "str",  "code": "proc str*(my: JsonParser): string {.inline.}",  "desc": "returns the character data for the events: <tt class=\"docutils literal\"><span class=\"pre\">jsonInt</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">jsonFloat</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">jsonString</span></tt>" },  { "module": "json",  "name": "getInt",  "code": "proc getInt*(my: JsonParser): BiggestInt {.inline.}",  "desc": "returns the number for the event: <tt class=\"docutils literal\"><span class=\"pre\">jsonInt</span></tt>" },  { "module": "json",  "name": "getFloat",  "code": "proc getFloat*(my: JsonParser): float {.inline.}",  "desc": "returns the number for the event: <tt class=\"docutils literal\"><span class=\"pre\">jsonFloat</span></tt>" },  { "module": "json",  "name": "kind",  "code": "proc kind*(my: JsonParser): JsonEventKind {.inline.}",  "desc": "returns the current event type for the JSON parser" },  { "module": "json",  "name": "getColumn",  "code": "proc getColumn*(my: JsonParser): int {.inline.}",  "desc": "get the current column the parser has arrived at." },  { "module": "json",  "name": "getLine",  "code": "proc getLine*(my: JsonParser): int {.inline.}",  "desc": "get the current line the parser has arrived at." },  { "module": "json",  "name": "getFilename",  "code": "proc getFilename*(my: JsonParser): string {.inline.}",  "desc": "get the filename of the file that the parser processes." },  { "module": "json",  "name": "errorMsg",  "code": "proc errorMsg*(my: JsonParser): string",  "desc": "returns a helpful error message for the event <tt class=\"docutils literal\"><span class=\"pre\">jsonError</span></tt>" },  { "module": "json",  "name": "errorMsgExpected",  "code": "proc errorMsgExpected*(my: JsonParser; e: string): string",  "desc": "returns an error message &quot;<cite>e</cite> expected&quot; in the same format as the other error messages " },  { "module": "json",  "name": "next",  "code": "proc next*(my: var JsonParser)",  "desc": "retrieves the first/next event. This controls the parser." },  { "module": "json",  "name": "raiseParseErr",  "code": "proc raiseParseErr*(p: JsonParser; msg: string) {.noinline, noreturn.}",  "desc": "raises an <cite>EJsonParsingError</cite> exception." },  { "module": "json",  "name": "newJString",  "code": "proc newJString*(s: string): JsonNode",  "desc": "Creates a new <cite>JString JsonNode</cite>." },  { "module": "json",  "name": "newJInt",  "code": "proc newJInt*(n: BiggestInt): JsonNode",  "desc": "Creates a new <cite>JInt JsonNode</cite>." },  { "module": "json",  "name": "newJFloat",  "code": "proc newJFloat*(n: float): JsonNode",  "desc": "Creates a new <cite>JFloat JsonNode</cite>." },  { "module": "json",  "name": "newJBool",  "code": "proc newJBool*(b: bool): JsonNode",  "desc": "Creates a new <cite>JBool JsonNode</cite>." },  { "module": "json",  "name": "newJNull",  "code": "proc newJNull*(): JsonNode",  "desc": "Creates a new <cite>JNull JsonNode</cite>." },  { "module": "json",  "name": "newJObject",  "code": "proc newJObject*(): JsonNode",  "desc": "Creates a new <cite>JObject JsonNode</cite>" },  { "module": "json",  "name": "newJArray",  "code": "proc newJArray*(): JsonNode",  "desc": "Creates a new <cite>JArray JsonNode</cite>" },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(s: string): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JString JsonNode</cite>." },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(n: BiggestInt): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JInt JsonNode</cite>." },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(n: float): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JFloat JsonNode</cite>." },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(b: bool): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JBool JsonNode</cite>." },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(keyVals: openArray[tuple[key: string, val: JsonNode]]): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JObject JsonNode</cite>" },  { "module": "json",  "name": "`%`",  "code": "proc `%`*(elements: openArray[JsonNode]): JsonNode",  "desc": "Generic constructor for JSON data. Creates a new <cite>JArray JsonNode</cite>" },  { "module": "json",  "name": "`==`",  "code": "proc `==`*(a, b: JsonNode): bool",  "desc": "Check two nodes for equality" },  { "module": "json",  "name": "hash",  "code": "proc hash*(n: JsonNode): THash",  "desc": "Compute the hash for a JSON node" },  { "module": "json",  "name": "len",  "code": "proc len*(n: JsonNode): int",  "desc": "If <cite>n</cite> is a <cite>JArray</cite>, it returns the number of elements. If <cite>n</cite> is a <cite>JObject</cite>, it returns the number of pairs. Else it returns 0." },  { "module": "json",  "name": "`[]`",  "code": "proc `[]`*(node: JsonNode; name: string): JsonNode",  "desc": "Gets a field from a <cite>JObject</cite>, which must not be nil. If the value at <cite>name</cite> does not exist, returns nil" },  { "module": "json",  "name": "`[]`",  "code": "proc `[]`*(node: JsonNode; index: int): JsonNode",  "desc": "Gets the node at <cite>index</cite> in an Array. Result is undefined if <cite>index</cite> is out of bounds" },  { "module": "json",  "name": "hasKey",  "code": "proc hasKey*(node: JsonNode; key: string): bool",  "desc": "Checks if <cite>key</cite> exists in <cite>node</cite>." },  { "module": "json",  "name": "existsKey",  "code": "proc existsKey*(node: JsonNode; key: string): bool {.deprecated.}",  "desc": "Deprecated for <cite>hasKey</cite>" },  { "module": "json",  "name": "add",  "code": "proc add*(father, child: JsonNode)",  "desc": "Adds <cite>child</cite> to a JArray node <cite>father</cite>. " },  { "module": "json",  "name": "add",  "code": "proc add*(obj: JsonNode; key: string; val: JsonNode)",  "desc": "Adds <tt class=\"docutils literal\"><span class=\"pre\">(key, val)</span></tt> pair to the JObject node <cite>obj</cite>. For speed reasons no check for duplicate keys is performed! But <tt class=\"docutils literal\"><span class=\"pre\">[]=</span></tt> performs the check." },  { "module": "json",  "name": "`[]=`",  "code": "proc `[]=`*(obj: JsonNode; key: string; val: JsonNode)",  "desc": "Sets a field from a <cite>JObject</cite>. Performs a check for duplicate keys." },  { "module": "json",  "name": "`{}`",  "code": "proc `{}`*(node: JsonNode; key: string): JsonNode",  "desc": "Transverses the node and gets the given value. If any of the names does not exist, returns nil" },  { "module": "json",  "name": "`{}=`",  "code": "proc `{}=`*(node: JsonNode; names: varargs[string]; value: JsonNode)",  "desc": "Transverses the node and tries to set the value at the given location to <cite>value</cite> If any of the names are missing, they are added" },  { "module": "json",  "name": "delete",  "code": "proc delete*(obj: JsonNode; key: string)",  "desc": "Deletes <tt class=\"docutils literal\"><span class=\"pre\">obj[key]</span></tt> preserving the order of the other (key, value)-pairs." },  { "module": "json",  "name": "copy",  "code": "proc copy*(p: JsonNode): JsonNode",  "desc": "Performs a deep copy of <cite>a</cite>." },  { "module": "json",  "name": "escapeJson",  "code": "proc escapeJson*(s: string): string",  "desc": "Converts a string <cite>s</cite> to its JSON representation." },  { "module": "json",  "name": "pretty",  "code": "proc pretty*(node: JsonNode; indent = 2): string",  "desc": "Converts <cite>node</cite> to its JSON Representation, with indentation and on multiple lines." },  { "module": "json",  "name": "`$`",  "code": "proc `$`*(node: JsonNode): string",  "desc": "Converts <cite>node</cite> to its JSON Representation on one line." },  { "module": "json",  "name": "items",  "code": "iterator items*(node: JsonNode): JsonNode",  "desc": "Iterator for the items of <cite>node</cite>. <cite>node</cite> has to be a JArray." },  { "module": "json",  "name": "pairs",  "code": "iterator pairs*(node: JsonNode): tuple[key: string, val: JsonNode]",  "desc": "Iterator for the child elements of <cite>node</cite>. <cite>node</cite> has to be a JObject." },  { "module": "json",  "name": "parseJson",  "code": "proc parseJson*(s: Stream; filename: string): JsonNode",  "desc": "Parses from a stream <cite>s</cite> into a <cite>JsonNode</cite>. <cite>filename</cite> is only needed for nice error messages." },  { "module": "json",  "name": "parseJson",  "code": "proc parseJson*(buffer: string): JsonNode",  "desc": "Parses JSON from <cite>buffer</cite>." },  { "module": "json",  "name": "parseFile",  "code": "proc parseFile*(filename: string): JsonNode",  "desc": "Parses <cite>file</cite> into a <cite>JsonNode</cite>." },  { "module": "lexbase",  "name": "open",  "code": "proc open*(L: var BaseLexer; input: Stream; bufLen: int = 8192)",  "desc": "inits the TBaseLexer with a stream to read from" },  { "module": "lexbase",  "name": "close",  "code": "proc close*(L: var BaseLexer)",  "desc": "closes the base lexer. This closes <cite>L</cite>'s associated stream too." },  { "module": "lexbase",  "name": "getCurrentLine",  "code": "proc getCurrentLine*(L: BaseLexer; marker: bool = true): string",  "desc": "retrieves the current line." },  { "module": "lexbase",  "name": "getColNumber",  "code": "proc getColNumber*(L: BaseLexer; pos: int): int",  "desc": "retrieves the current column." },  { "module": "lexbase",  "name": "handleCR",  "code": "proc handleCR*(L: var BaseLexer; pos: int): int",  "desc": "Call this if you scanned over 'c' in the buffer; it returns the the position to continue the scanning from. <cite>pos</cite> must be the position of the 'c'." },  { "module": "lexbase",  "name": "handleLF",  "code": "proc handleLF*(L: var BaseLexer; pos: int): int",  "desc": "Call this if you scanned over 'L' in the buffer; it returns the the position to continue the scanning from. <cite>pos</cite> must be the position of the 'L'." },  { "module": "libcurl",  "name": "strequal",  "code": "proc strequal*(s1, s2: cstring): int32 {.cdecl, dynlib: libname, \u000A    importc: \"curl_strequal\".}" },  { "module": "libcurl",  "name": "strnequal",  "code": "proc strnequal*(s1, s2: cstring; n: int): int32 {.cdecl, dynlib: libname, \u000A    importc: \"curl_strnequal\".}" },  { "module": "libcurl",  "name": "formadd",  "code": "proc formadd*(httppost, last_post: PPcurl_httppost): TFORMcode {.cdecl, varargs, \u000A    dynlib: libname, importc: \"curl_formadd\".}" },  { "module": "libcurl",  "name": "formget",  "code": "proc formget*(form: Phttppost; arg: pointer; append: Tformget_callback): int32 {.\u000A    cdecl, dynlib: libname, importc: \"curl_formget\".}" },  { "module": "libcurl",  "name": "formfree",  "code": "proc formfree*(form: Phttppost) {.cdecl, dynlib: libname, \u000A                                  importc: \"curl_formfree\".}" },  { "module": "libcurl",  "name": "getenv",  "code": "proc getenv*(variable: cstring): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_getenv\".}" },  { "module": "libcurl",  "name": "version",  "code": "proc version*(): cstring {.cdecl, dynlib: libname, importc: \"curl_version\".}" },  { "module": "libcurl",  "name": "easy_escape",  "code": "proc easy_escape*(handle: PCurl; str: cstring; len: int32): cstring {.cdecl, \u000A    dynlib: libname, importc: \"curl_easy_escape\".}" },  { "module": "libcurl",  "name": "escape",  "code": "proc escape*(str: cstring; len: int32): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_escape\".}" },  { "module": "libcurl",  "name": "easy_unescape",  "code": "proc easy_unescape*(handle: PCurl; str: cstring; len: int32; \u000A                    outlength: var int32): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_easy_unescape\".}" },  { "module": "libcurl",  "name": "unescape",  "code": "proc unescape*(str: cstring; len: int32): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_unescape\".}" },  { "module": "libcurl",  "name": "free",  "code": "proc free*(p: pointer) {.cdecl, dynlib: libname, importc: \"curl_free\".}" },  { "module": "libcurl",  "name": "global_init",  "code": "proc global_init*(flags: int32): Tcode {.cdecl, dynlib: libname, \u000A    importc: \"curl_global_init\".}" },  { "module": "libcurl",  "name": "global_init_mem",  "code": "proc global_init_mem*(flags: int32; m: Tmalloc_callback; f: Tfree_callback; \u000A                      r: Trealloc_callback; s: Tstrdup_callback; \u000A                      c: Tcalloc_callback): Tcode {.cdecl, dynlib: libname, \u000A    importc: \"curl_global_init_mem\".}" },  { "module": "libcurl",  "name": "global_cleanup",  "code": "proc global_cleanup*() {.cdecl, dynlib: libname, importc: \"curl_global_cleanup\".}" },  { "module": "libcurl",  "name": "slist_append",  "code": "proc slist_append*(slist: Pslist; p: cstring): Pslist {.cdecl, dynlib: libname, \u000A    importc: \"curl_slist_append\".}" },  { "module": "libcurl",  "name": "slist_free_all",  "code": "proc slist_free_all*(para1: Pslist) {.cdecl, dynlib: libname, \u000A                                      importc: \"curl_slist_free_all\".}" },  { "module": "libcurl",  "name": "getdate",  "code": "proc getdate*(p: cstring; unused: ptr Time): Time {.cdecl, dynlib: libname, \u000A    importc: \"curl_getdate\".}" },  { "module": "libcurl",  "name": "share_init",  "code": "proc share_init*(): PSH {.cdecl, dynlib: libname, importc: \"curl_share_init\".}" },  { "module": "libcurl",  "name": "share_setopt",  "code": "proc share_setopt*(para1: PSH; option: TSHoption): TSHcode {.cdecl, varargs, \u000A    dynlib: libname, importc: \"curl_share_setopt\".}" },  { "module": "libcurl",  "name": "share_cleanup",  "code": "proc share_cleanup*(para1: PSH): TSHcode {.cdecl, dynlib: libname, \u000A    importc: \"curl_share_cleanup\".}" },  { "module": "libcurl",  "name": "version_info",  "code": "proc version_info*(para1: Tversion): Pversion_info_data {.cdecl, \u000A    dynlib: libname, importc: \"curl_version_info\".}" },  { "module": "libcurl",  "name": "easy_strerror",  "code": "proc easy_strerror*(para1: Tcode): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_easy_strerror\".}" },  { "module": "libcurl",  "name": "share_strerror",  "code": "proc share_strerror*(para1: TSHcode): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_share_strerror\".}" },  { "module": "libcurl",  "name": "easy_init",  "code": "proc easy_init*(): PCurl {.cdecl, dynlib: libname, importc: \"curl_easy_init\".}" },  { "module": "libcurl",  "name": "easy_setopt",  "code": "proc easy_setopt*(curl: PCurl; option: Toption): Tcode {.cdecl, varargs, \u000A    dynlib: libname, importc: \"curl_easy_setopt\".}" },  { "module": "libcurl",  "name": "easy_perform",  "code": "proc easy_perform*(curl: PCurl): Tcode {.cdecl, dynlib: libname, \u000A    importc: \"curl_easy_perform\".}" },  { "module": "libcurl",  "name": "easy_cleanup",  "code": "proc easy_cleanup*(curl: PCurl) {.cdecl, dynlib: libname, \u000A                                  importc: \"curl_easy_cleanup\".}" },  { "module": "libcurl",  "name": "easy_getinfo",  "code": "proc easy_getinfo*(curl: PCurl; info: TINFO): Tcode {.cdecl, varargs, \u000A    dynlib: libname, importc: \"curl_easy_getinfo\".}" },  { "module": "libcurl",  "name": "easy_duphandle",  "code": "proc easy_duphandle*(curl: PCurl): PCurl {.cdecl, dynlib: libname, \u000A    importc: \"curl_easy_duphandle\".}" },  { "module": "libcurl",  "name": "easy_reset",  "code": "proc easy_reset*(curl: PCurl) {.cdecl, dynlib: libname, \u000A                                importc: \"curl_easy_reset\".}" },  { "module": "libcurl",  "name": "multi_init",  "code": "proc multi_init*(): PM {.cdecl, dynlib: libname, importc: \"curl_multi_init\".}" },  { "module": "libcurl",  "name": "multi_add_handle",  "code": "proc multi_add_handle*(multi_handle: PM; handle: PCurl): TMcode {.cdecl, \u000A    dynlib: libname, importc: \"curl_multi_add_handle\".}" },  { "module": "libcurl",  "name": "multi_remove_handle",  "code": "proc multi_remove_handle*(multi_handle: PM; handle: PCurl): TMcode {.cdecl, \u000A    dynlib: libname, importc: \"curl_multi_remove_handle\".}" },  { "module": "libcurl",  "name": "multi_fdset",  "code": "proc multi_fdset*(multi_handle: PM; read_fd_set: Pfd_set; write_fd_set: Pfd_set; \u000A                  exc_fd_set: Pfd_set; max_fd: var int32): TMcode {.cdecl, \u000A    dynlib: libname, importc: \"curl_multi_fdset\".}" },  { "module": "libcurl",  "name": "multi_perform",  "code": "proc multi_perform*(multi_handle: PM; running_handles: var int32): TMcode {.\u000A    cdecl, dynlib: libname, importc: \"curl_multi_perform\".}" },  { "module": "libcurl",  "name": "multi_cleanup",  "code": "proc multi_cleanup*(multi_handle: PM): TMcode {.cdecl, dynlib: libname, \u000A    importc: \"curl_multi_cleanup\".}" },  { "module": "libcurl",  "name": "multi_info_read",  "code": "proc multi_info_read*(multi_handle: PM; msgs_in_queue: var int32): PMsg {.cdecl, \u000A    dynlib: libname, importc: \"curl_multi_info_read\".}" },  { "module": "libcurl",  "name": "multi_strerror",  "code": "proc multi_strerror*(para1: TMcode): cstring {.cdecl, dynlib: libname, \u000A    importc: \"curl_multi_strerror\".}" },  { "module": "libcurl",  "name": "multi_socket",  "code": "proc multi_socket*(multi_handle: PM; s: Tsocket; running_handles: var int32): TMcode {.\u000A    cdecl, dynlib: libname, importc: \"curl_multi_socket\".}" },  { "module": "libcurl",  "name": "multi_socket_all",  "code": "proc multi_socket_all*(multi_handle: PM; running_handles: var int32): TMcode {.\u000A    cdecl, dynlib: libname, importc: \"curl_multi_socket_all\".}" },  { "module": "libcurl",  "name": "multi_timeout",  "code": "proc multi_timeout*(multi_handle: PM; milliseconds: var int32): TMcode {.cdecl, \u000A    dynlib: libname, importc: \"curl_multi_timeout\".}" },  { "module": "libcurl",  "name": "multi_setopt",  "code": "proc multi_setopt*(multi_handle: PM; option: TMoption): TMcode {.cdecl, varargs, \u000A    dynlib: libname, importc: \"curl_multi_setopt\".}" },  { "module": "libcurl",  "name": "multi_assign",  "code": "proc multi_assign*(multi_handle: PM; sockfd: Tsocket; sockp: pointer): TMcode {.\u000A    cdecl, dynlib: libname, importc: \"curl_multi_assign\".}" },  { "module": "libffi",  "name": "raw_call",  "code": "proc raw_call*(cif: var Tcif; fn: proc () {.cdecl.}; rvalue: pointer; \u000A               avalue: ptr TRaw) {.cdecl, importc: \"ffi_raw_call\", mylib.}" },  { "module": "libffi",  "name": "ptrarray_to_raw",  "code": "proc ptrarray_to_raw*(cif: var Tcif; args: ptr pointer; raw: ptr TRaw) {.cdecl, \u000A    importc: \"ffi_ptrarray_to_raw\", mylib.}" },  { "module": "libffi",  "name": "raw_to_ptrarray",  "code": "proc raw_to_ptrarray*(cif: var Tcif; raw: ptr TRaw; args: ptr pointer) {.cdecl, \u000A    importc: \"ffi_raw_to_ptrarray\", mylib.}" },  { "module": "libffi",  "name": "raw_size",  "code": "proc raw_size*(cif: var Tcif): int {.cdecl, importc: \"ffi_raw_size\", mylib.}" },  { "module": "libffi",  "name": "prep_cif",  "code": "proc prep_cif*(cif: var Tcif; abi: TABI; nargs: cuint; rtype: ptr TType; \u000A               atypes: ptr ptr TType): TStatus {.cdecl, importc: \"ffi_prep_cif\", \u000A    mylib.}" },  { "module": "libffi",  "name": "call",  "code": "proc call*(cif: var Tcif; fn: proc () {.cdecl.}; rvalue: pointer; \u000A           avalue: ptr pointer) {.cdecl, importc: \"ffi_call\", mylib.}" },  { "module": "libffi",  "name": "prep_cif",  "code": "proc prep_cif*(cif: var Tcif; abi: TABI; nargs: cuint; rtype: ptr TType; \u000A               atypes: TParamList): TStatus {.cdecl, importc: \"ffi_prep_cif\", \u000A    mylib.}" },  { "module": "libffi",  "name": "call",  "code": "proc call*(cif: var Tcif; fn, rvalue: pointer; avalue: TArgList) {.cdecl, \u000A    importc: \"ffi_call\", mylib.}" },  { "module": "libsvm",  "name": "train",  "code": "proc train*(prob: ptr Tproblem; param: ptr Tparameter): ptr Tmodel {.cdecl, \u000A    importc: \"svm_train\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "cross_validation",  "code": "proc cross_validation*(prob: ptr Tproblem; param: ptr Tparameter; nr_fold: cint; \u000A                       target: ptr cdouble) {.cdecl, \u000A    importc: \"svm_cross_validation\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "save_model",  "code": "proc save_model*(model_file_name: cstring; model: ptr Tmodel): cint {.cdecl, \u000A    importc: \"svm_save_model\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "load_model",  "code": "proc load_model*(model_file_name: cstring): ptr Tmodel {.cdecl, \u000A    importc: \"svm_load_model\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "get_svm_type",  "code": "proc get_svm_type*(model: ptr Tmodel): cint {.cdecl, \u000A    importc: \"svm_get_svm_type\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "get_nr_class",  "code": "proc get_nr_class*(model: ptr Tmodel): cint {.cdecl, \u000A    importc: \"svm_get_nr_class\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "get_labels",  "code": "proc get_labels*(model: ptr Tmodel; label: ptr cint) {.cdecl, \u000A    importc: \"svm_get_labels\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "get_svr_probability",  "code": "proc get_svr_probability*(model: ptr Tmodel): cdouble {.cdecl, \u000A    importc: \"svm_get_svr_probability\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "predict_values",  "code": "proc predict_values*(model: ptr Tmodel; x: ptr Tnode; dec_values: ptr cdouble): cdouble {.\u000A    cdecl, importc: \"svm_predict_values\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "predict",  "code": "proc predict*(model: ptr Tmodel; x: ptr Tnode): cdouble {.cdecl, \u000A    importc: \"svm_predict\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "predict_probability",  "code": "proc predict_probability*(model: ptr Tmodel; x: ptr Tnode; \u000A                          prob_estimates: ptr cdouble): cdouble {.cdecl, \u000A    importc: \"svm_predict_probability\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "free_model_content",  "code": "proc free_model_content*(model_ptr: ptr Tmodel) {.cdecl, \u000A    importc: \"svm_free_model_content\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "free_and_destroy_model",  "code": "proc free_and_destroy_model*(model_ptr_ptr: ptr ptr Tmodel) {.cdecl, \u000A    importc: \"svm_free_and_destroy_model\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "destroy_param",  "code": "proc destroy_param*(param: ptr Tparameter) {.cdecl, \u000A    importc: \"svm_destroy_param\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "check_parameter",  "code": "proc check_parameter*(prob: ptr Tproblem; param: ptr Tparameter): cstring {.\u000A    cdecl, importc: \"svm_check_parameter\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "check_probability_model",  "code": "proc check_probability_model*(model: ptr Tmodel): cint {.cdecl, \u000A    importc: \"svm_check_probability_model\", dynlib: svmdll.}" },  { "module": "libsvm",  "name": "set_print_string_function",  "code": "proc set_print_string_function*(print_func: proc (arg: cstring) {.cdecl.}) {.\u000A    cdecl, importc: \"svm_set_print_string_function\", dynlib: svmdll.}" },  { "module": "libuv",  "name": "loop_new",  "code": "proc loop_new*(): PLoop {.importc: \"uv_loop_new\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "loop_delete",  "code": "proc loop_delete*(a2: PLoop) {.importc: \"uv_loop_delete\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "default_loop",  "code": "proc default_loop*(): PLoop {.importc: \"uv_default_loop\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "run",  "code": "proc run*(a2: PLoop): cint {.importc: \"uv_run\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "addref",  "code": "proc addref*(a2: PLoop) {.importc: \"uv_ref\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "unref",  "code": "proc unref*(a2: PLoop) {.importc: \"uv_unref\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "update_time",  "code": "proc update_time*(a2: PLoop) {.importc: \"uv_update_time\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "now",  "code": "proc now*(a2: PLoop): int64 {.importc: \"uv_now\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "last_error",  "code": "proc last_error*(a2: PLoop): TErr {.importc: \"uv_last_error\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "strerror",  "code": "proc strerror*(err: TErr): cstring {.importc: \"uv_strerror\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "err_name",  "code": "proc err_name*(err: TErr): cstring {.importc: \"uv_err_name\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "shutdown",  "code": "proc shutdown*(req: PShutdown; handle: PStream; cb: ShutdownProc): cint {.\u000A    importc: \"uv_shutdown\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "is_active",  "code": "proc is_active*(handle: PHandle): cint {.importc: \"uv_is_active\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "close",  "code": "proc close*(handle: PHandle; close_cb: CloseProc) {.importc: \"uv_close\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "buf_init",  "code": "proc buf_init*(base: cstring; len: csize): TBuf {.importc: \"uv_buf_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "listen",  "code": "proc listen*(stream: PStream; backlog: cint; cb: ConnectionProc): cint {.\u000A    importc: \"uv_listen\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "accept",  "code": "proc accept*(server: PStream; client: PStream): cint {.importc: \"uv_accept\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "read_start",  "code": "proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc): cint {.\u000A    importc: \"uv_read_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "read_start",  "code": "proc read_start*(a2: PStream; alloc_cb: AllocProc; read_cb: ReadProc2): cint {.\u000A    importc: \"uv_read2_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "read_stop",  "code": "proc read_stop*(a2: PStream): cint {.importc: \"uv_read_stop\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "write",  "code": "proc write*(req: PWrite; handle: PStream; bufs: ptr TBuf; bufcnt: cint; \u000A            cb: WriteProc): cint {.importc: \"uv_write\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "write",  "code": "proc write*(req: PWrite; handle: PStream; bufs: ptr TBuf; bufcnt: cint; \u000A            send_handle: PStream; cb: WriteProc): cint {.importc: \"uv_write2\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_init",  "code": "proc tcp_init*(a2: PLoop; handle: PTcp): cint {.importc: \"uv_tcp_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_bind",  "code": "proc tcp_bind*(handle: PTcp; a3: TSockAddrIn): cint {.importc: \"uv_tcp_bind\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_bind6",  "code": "proc tcp_bind6*(handle: PTcp; a3: TSockAddrIn6): cint {.importc: \"uv_tcp_bind6\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_getsockname",  "code": "proc tcp_getsockname*(handle: PTcp; name: ptr TSockAddr; namelen: var cint): cint {.\u000A    importc: \"uv_tcp_getsockname\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_getpeername",  "code": "proc tcp_getpeername*(handle: PTcp; name: ptr TSockAddr; namelen: var cint): cint {.\u000A    importc: \"uv_tcp_getpeername\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_connect",  "code": "proc tcp_connect*(req: PConnect; handle: PTcp; address: TSockAddrIn; \u000A                  cb: ConnectProc): cint {.importc: \"uv_tcp_connect\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tcp_connect6",  "code": "proc tcp_connect6*(req: PConnect; handle: PTcp; address: TSockAddrIn6; \u000A                   cb: ConnectProc): cint {.importc: \"uv_tcp_connect6\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_init",  "code": "proc udp_init*(a2: PLoop; handle: PUdp): cint {.importc: \"uv_udp_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_bind",  "code": "proc udp_bind*(handle: PUdp; adr: TSockAddrIn; flags: cunsigned): cint {.\u000A    importc: \"uv_udp_bind\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_bind6",  "code": "proc udp_bind6*(handle: PUdp; adr: TSockAddrIn6; flags: cunsigned): cint {.\u000A    importc: \"uv_udp_bind6\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_getsockname",  "code": "proc udp_getsockname*(handle: PUdp; name: ptr TSockAddr; namelen: var cint): cint {.\u000A    importc: \"uv_udp_getsockname\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_send",  "code": "proc udp_send*(req: PUdpSend; handle: PUdp; bufs: ptr TBuf; bufcnt: cint; \u000A               adr: TSockAddrIn; send_cb: UdpSendProc): cint {.\u000A    importc: \"uv_udp_send\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_send6",  "code": "proc udp_send6*(req: PUdpSend; handle: PUdp; bufs: ptr TBuf; bufcnt: cint; \u000A                adr: TSockAddrIn6; send_cb: UdpSendProc): cint {.\u000A    importc: \"uv_udp_send6\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_recv_start",  "code": "proc udp_recv_start*(handle: PUdp; alloc_cb: AllocProc; recv_cb: UdpRecvProc): cint {.\u000A    importc: \"uv_udp_recv_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "udp_recv_stop",  "code": "proc udp_recv_stop*(handle: PUdp): cint {.importc: \"uv_udp_recv_stop\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tty_init",  "code": "proc tty_init*(a2: PLoop; a3: pTTy; fd: TFile): cint {.importc: \"uv_tty_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tty_set_mode",  "code": "proc tty_set_mode*(a2: pTTy; mode: cint): cint {.importc: \"uv_tty_set_mode\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "tty_get_winsize",  "code": "proc tty_get_winsize*(a2: pTTy; width: var cint; height: var cint): cint {.\u000A    importc: \"uv_tty_get_winsize\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "tty_reset_mode",  "code": "proc tty_reset_mode*() {.importc: \"uv_tty_reset_mode\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "guess_handle",  "code": "proc guess_handle*(file: TFile): THandleType {.importc: \"uv_guess_handle\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "pipe_init",  "code": "proc pipe_init*(a2: PLoop; handle: PPipe; ipc: int): cint {.\u000A    importc: \"uv_pipe_init\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "pipe_open",  "code": "proc pipe_open*(a2: PPipe; file: TFile) {.importc: \"uv_pipe_open\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "pipe_bind",  "code": "proc pipe_bind*(handle: PPipe; name: cstring): cint {.importc: \"uv_pipe_bind\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "pipe_connect",  "code": "proc pipe_connect*(req: PConnect; handle: PPipe; name: cstring; cb: ConnectProc): cint {.\u000A    importc: \"uv_pipe_connect\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "prepare_init",  "code": "proc prepare_init*(a2: PLoop; prepare: PPrepare): cint {.\u000A    importc: \"uv_prepare_init\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "prepare_start",  "code": "proc prepare_start*(prepare: PPrepare; cb: PrepareProc): cint {.\u000A    importc: \"uv_prepare_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "prepare_stop",  "code": "proc prepare_stop*(prepare: PPrepare): cint {.importc: \"uv_prepare_stop\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "check_init",  "code": "proc check_init*(a2: PLoop; check: PCheck): cint {.importc: \"uv_check_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "check_start",  "code": "proc check_start*(check: PCheck; cb: CheckProc): cint {.\u000A    importc: \"uv_check_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "check_stop",  "code": "proc check_stop*(check: PCheck): cint {.importc: \"uv_check_stop\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "idle_init",  "code": "proc idle_init*(a2: PLoop; idle: PIdle): cint {.importc: \"uv_idle_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "idle_start",  "code": "proc idle_start*(idle: PIdle; cb: IdleProc): cint {.importc: \"uv_idle_start\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "idle_stop",  "code": "proc idle_stop*(idle: PIdle): cint {.importc: \"uv_idle_stop\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "async_init",  "code": "proc async_init*(a2: PLoop; async: PAsync; async_cb: AsyncProc): cint {.\u000A    importc: \"uv_async_init\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "async_send",  "code": "proc async_send*(async: PAsync): cint {.importc: \"uv_async_send\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_init",  "code": "proc timer_init*(a2: PLoop; timer: PTimer): cint {.importc: \"uv_timer_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_start",  "code": "proc timer_start*(timer: PTimer; cb: TimerProc; timeout: int64; repeat: int64): cint {.\u000A    importc: \"uv_timer_start\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_stop",  "code": "proc timer_stop*(timer: PTimer): cint {.importc: \"uv_timer_stop\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_again",  "code": "proc timer_again*(timer: PTimer): cint {.importc: \"uv_timer_again\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_set_repeat",  "code": "proc timer_set_repeat*(timer: PTimer; repeat: int64) {.\u000A    importc: \"uv_timer_set_repeat\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "timer_get_repeat",  "code": "proc timer_get_repeat*(timer: PTimer): int64 {.importc: \"uv_timer_get_repeat\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "ares_init_options",  "code": "proc ares_init_options*(a2: PLoop; channel: PAresChannel; options: PAresOptions; \u000A                        optmask: cint): cint {.importc: \"uv_ares_init_options\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "ares_destroy",  "code": "proc ares_destroy*(a2: PLoop; channel: PAresChannel) {.\u000A    importc: \"uv_ares_destroy\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "getaddrinfo",  "code": "proc getaddrinfo*(a2: PLoop; handle: PGetAddrInfo; \u000A                  getaddrinfo_cb: GetAddrInfoProc; node: cstring; \u000A                  service: cstring; hints: ptr TAddrInfo): cint {.\u000A    importc: \"uv_getaddrinfo\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "freeaddrinfo",  "code": "proc freeaddrinfo*(ai: ptr TAddrInfo) {.importc: \"uv_freeaddrinfo\", \u000A                                        header: \"uv.h\".}" },  { "module": "libuv",  "name": "spawn",  "code": "proc spawn*(a2: PLoop; a3: PProcess; options: TProcessOptions): cint {.\u000A    importc: \"uv_spawn\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "process_kill",  "code": "proc process_kill*(a2: PProcess; signum: cint): cint {.\u000A    importc: \"uv_process_kill\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "queue_work",  "code": "proc queue_work*(loop: PLoop; req: PWork; work_cb: WorkProc; \u000A                 after_work_cb: AfterWorkProc): cint {.importc: \"uv_queue_work\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "req_cleanup",  "code": "proc req_cleanup*(req: PFS) {.importc: \"uv_fs_req_cleanup\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "close",  "code": "proc close*(loop: PLoop; req: PFS; file: TFile; cb: FsProc): cint {.\u000A    importc: \"uv_fs_close\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "open",  "code": "proc open*(loop: PLoop; req: PFS; path: cstring; flags: cint; mode: cint; \u000A           cb: FsProc): cint {.importc: \"uv_fs_open\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "read",  "code": "proc read*(loop: PLoop; req: PFS; file: TFile; buf: pointer; length: csize; \u000A           offset: coff; cb: FsProc): cint {.importc: \"uv_fs_read\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "unlink",  "code": "proc unlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_unlink\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "write",  "code": "proc write*(loop: PLoop; req: PFS; file: TFile; buf: pointer; length: csize; \u000A            offset: coff; cb: FsProc): cint {.importc: \"uv_fs_write\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "mkdir",  "code": "proc mkdir*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.\u000A    importc: \"uv_fs_mkdir\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "rmdir",  "code": "proc rmdir*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_rmdir\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "readdir",  "code": "proc readdir*(loop: PLoop; req: PFS; path: cstring; flags: cint; cb: FsProc): cint {.\u000A    importc: \"uv_fs_readdir\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "stat",  "code": "proc stat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_stat\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "fstat",  "code": "proc fstat*(loop: PLoop; req: PFS; file: TFile; cb: FsProc): cint {.\u000A    importc: \"uv_fs_fstat\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "rename",  "code": "proc rename*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_rename\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "fsync",  "code": "proc fsync*(loop: PLoop; req: PFS; file: TFile; cb: FsProc): cint {.\u000A    importc: \"uv_fs_fsync\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "fdatasync",  "code": "proc fdatasync*(loop: PLoop; req: PFS; file: TFile; cb: FsProc): cint {.\u000A    importc: \"uv_fs_fdatasync\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "ftruncate",  "code": "proc ftruncate*(loop: PLoop; req: PFS; file: TFile; offset: coff; cb: FsProc): cint {.\u000A    importc: \"uv_fs_ftruncate\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "sendfile",  "code": "proc sendfile*(loop: PLoop; req: PFS; out_fd: TFile; in_fd: TFile; \u000A               in_offset: coff; length: csize; cb: FsProc): cint {.\u000A    importc: \"uv_fs_sendfile\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "chmod",  "code": "proc chmod*(loop: PLoop; req: PFS; path: cstring; mode: cint; cb: FsProc): cint {.\u000A    importc: \"uv_fs_chmod\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "utime",  "code": "proc utime*(loop: PLoop; req: PFS; path: cstring; atime: cdouble; \u000A            mtime: cdouble; cb: FsProc): cint {.importc: \"uv_fs_utime\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "futime",  "code": "proc futime*(loop: PLoop; req: PFS; file: TFile; atime: cdouble; mtime: cdouble; \u000A             cb: FsProc): cint {.importc: \"uv_fs_futime\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "lstat",  "code": "proc lstat*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_lstat\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "link",  "code": "proc link*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_link\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "symlink",  "code": "proc symlink*(loop: PLoop; req: PFS; path: cstring; new_path: cstring; \u000A              flags: cint; cb: FsProc): cint {.importc: \"uv_fs_symlink\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "readlink",  "code": "proc readlink*(loop: PLoop; req: PFS; path: cstring; cb: FsProc): cint {.\u000A    importc: \"uv_fs_readlink\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "fchmod",  "code": "proc fchmod*(loop: PLoop; req: PFS; file: TFile; mode: cint; cb: FsProc): cint {.\u000A    importc: \"uv_fs_fchmod\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "chown",  "code": "proc chown*(loop: PLoop; req: PFS; path: cstring; uid: cint; gid: cint; \u000A            cb: FsProc): cint {.importc: \"uv_fs_chown\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "fchown",  "code": "proc fchown*(loop: PLoop; req: PFS; file: TFile; uid: cint; gid: cint; \u000A             cb: FsProc): cint {.importc: \"uv_fs_fchown\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "event_init",  "code": "proc event_init*(loop: PLoop; handle: PFSEvent; filename: cstring; \u000A                 cb: FsEventProc): cint {.importc: \"uv_fs_event_init\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "ip4_addr",  "code": "proc ip4_addr*(ip: cstring; port: cint): TSockAddrIn {.importc: \"uv_ip4_addr\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "ip6_addr",  "code": "proc ip6_addr*(ip: cstring; port: cint): TSockAddrIn6 {.importc: \"uv_ip6_addr\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "ip4_name",  "code": "proc ip4_name*(src: ptr TSockAddrIn; dst: cstring; size: csize): cint {.\u000A    importc: \"uv_ip4_name\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "ip6_name",  "code": "proc ip6_name*(src: ptr TSockAddrIn6; dst: cstring; size: csize): cint {.\u000A    importc: \"uv_ip6_name\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "exepath",  "code": "proc exepath*(buffer: cstring; size: var csize): cint {.importc: \"uv_exepath\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "hrtime",  "code": "proc hrtime*(): uint64 {.importc: \"uv_hrtime\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "loadavg",  "code": "proc loadavg*(load: var array[0 .. 2, cdouble]) {.importc: \"uv_loadavg\", \u000A    header: \"uv.h\".}" },  { "module": "libuv",  "name": "get_free_memory",  "code": "proc get_free_memory*(): cdouble {.importc: \"uv_get_free_memory\", header: \"uv.h\".}" },  { "module": "libuv",  "name": "get_total_memory",  "code": "proc get_total_memory*(): cdouble {.importc: \"uv_get_total_memory\", \u000A                                    header: \"uv.h\".}" },  { "module": "libzip",  "name": "zip_add",  "code": "proc zip_add*(para1: PZip; para2: cstring; para3: PZipSource): int32 {.cdecl, \u000A    importc: \"zip_add\", mydll.}" },  { "module": "libzip",  "name": "zip_add_dir",  "code": "proc zip_add_dir*(para1: PZip; para2: cstring): int32 {.cdecl, \u000A    importc: \"zip_add_dir\", mydll.}" },  { "module": "libzip",  "name": "zip_close",  "code": "proc zip_close*(para1: PZip) {.cdecl, importc: \"zip_close\", mydll.}" },  { "module": "libzip",  "name": "zip_delete",  "code": "proc zip_delete*(para1: PZip; para2: int32): int32 {.cdecl, mydll, \u000A    importc: \"zip_delete\".}" },  { "module": "libzip",  "name": "zip_error_clear",  "code": "proc zip_error_clear*(para1: PZip) {.cdecl, importc: \"zip_error_clear\", mydll.}" },  { "module": "libzip",  "name": "zip_error_get",  "code": "proc zip_error_get*(para1: PZip; para2: ptr int32; para3: ptr int32) {.cdecl, \u000A    importc: \"zip_error_get\", mydll.}" },  { "module": "libzip",  "name": "zip_error_get_sys_type",  "code": "proc zip_error_get_sys_type*(para1: int32): int32 {.cdecl, mydll, \u000A    importc: \"zip_error_get_sys_type\".}" },  { "module": "libzip",  "name": "zip_error_to_str",  "code": "proc zip_error_to_str*(para1: cstring; para2: int; para3: int32; para4: int32): int32 {.\u000A    cdecl, mydll, importc: \"zip_error_to_str\".}" },  { "module": "libzip",  "name": "zip_fclose",  "code": "proc zip_fclose*(para1: PZipFile) {.cdecl, mydll, importc: \"zip_fclose\".}" },  { "module": "libzip",  "name": "zip_file_error_clear",  "code": "proc zip_file_error_clear*(para1: PZipFile) {.cdecl, mydll, \u000A    importc: \"zip_file_error_clear\".}" },  { "module": "libzip",  "name": "zip_file_error_get",  "code": "proc zip_file_error_get*(para1: PZipFile; para2: ptr int32; para3: ptr int32) {.\u000A    cdecl, mydll, importc: \"zip_file_error_get\".}" },  { "module": "libzip",  "name": "zip_file_strerror",  "code": "proc zip_file_strerror*(para1: PZipFile): cstring {.cdecl, mydll, \u000A    importc: \"zip_file_strerror\".}" },  { "module": "libzip",  "name": "zip_fopen",  "code": "proc zip_fopen*(para1: PZip; para2: cstring; para3: int32): PZipFile {.cdecl, \u000A    mydll, importc: \"zip_fopen\".}" },  { "module": "libzip",  "name": "zip_fopen_index",  "code": "proc zip_fopen_index*(para1: PZip; para2: int32; para3: int32): PZipFile {.\u000A    cdecl, mydll, importc: \"zip_fopen_index\".}" },  { "module": "libzip",  "name": "zip_fread",  "code": "proc zip_fread*(para1: PZipFile; para2: pointer; para3: int): int {.cdecl, \u000A    mydll, importc: \"zip_fread\".}" },  { "module": "libzip",  "name": "zip_get_archive_comment",  "code": "proc zip_get_archive_comment*(para1: PZip; para2: ptr int32; para3: int32): cstring {.\u000A    cdecl, mydll, importc: \"zip_get_archive_comment\".}" },  { "module": "libzip",  "name": "zip_get_archive_flag",  "code": "proc zip_get_archive_flag*(para1: PZip; para2: int32; para3: int32): int32 {.\u000A    cdecl, mydll, importc: \"zip_get_archive_flag\".}" },  { "module": "libzip",  "name": "zip_get_file_comment",  "code": "proc zip_get_file_comment*(para1: PZip; para2: int32; para3: ptr int32; \u000A                           para4: int32): cstring {.cdecl, mydll, \u000A    importc: \"zip_get_file_comment\".}" },  { "module": "libzip",  "name": "zip_get_name",  "code": "proc zip_get_name*(para1: PZip; para2: int32; para3: int32): cstring {.cdecl, \u000A    mydll, importc: \"zip_get_name\".}" },  { "module": "libzip",  "name": "zip_get_num_files",  "code": "proc zip_get_num_files*(para1: PZip): int32 {.cdecl, mydll, \u000A    importc: \"zip_get_num_files\".}" },  { "module": "libzip",  "name": "zip_name_locate",  "code": "proc zip_name_locate*(para1: PZip; para2: cstring; para3: int32): int32 {.cdecl, \u000A    mydll, importc: \"zip_name_locate\".}" },  { "module": "libzip",  "name": "zip_open",  "code": "proc zip_open*(para1: cstring; para2: int32; para3: ptr int32): PZip {.cdecl, \u000A    mydll, importc: \"zip_open\".}" },  { "module": "libzip",  "name": "zip_rename",  "code": "proc zip_rename*(para1: PZip; para2: int32; para3: cstring): int32 {.cdecl, \u000A    mydll, importc: \"zip_rename\".}" },  { "module": "libzip",  "name": "zip_replace",  "code": "proc zip_replace*(para1: PZip; para2: int32; para3: PZipSource): int32 {.cdecl, \u000A    mydll, importc: \"zip_replace\".}" },  { "module": "libzip",  "name": "zip_set_archive_comment",  "code": "proc zip_set_archive_comment*(para1: PZip; para2: cstring; para3: int32): int32 {.\u000A    cdecl, mydll, importc: \"zip_set_archive_comment\".}" },  { "module": "libzip",  "name": "zip_set_archive_flag",  "code": "proc zip_set_archive_flag*(para1: PZip; para2: int32; para3: int32): int32 {.\u000A    cdecl, mydll, importc: \"zip_set_archive_flag\".}" },  { "module": "libzip",  "name": "zip_set_file_comment",  "code": "proc zip_set_file_comment*(para1: PZip; para2: int32; para3: cstring; \u000A                           para4: int32): int32 {.cdecl, mydll, \u000A    importc: \"zip_set_file_comment\".}" },  { "module": "libzip",  "name": "zip_source_buffer",  "code": "proc zip_source_buffer*(para1: PZip; para2: pointer; para3: int; para4: int32): PZipSource {.\u000A    cdecl, mydll, importc: \"zip_source_buffer\".}" },  { "module": "libzip",  "name": "zip_source_file",  "code": "proc zip_source_file*(para1: PZip; para2: cstring; para3: int; para4: int): PZipSource {.\u000A    cdecl, mydll, importc: \"zip_source_file\".}" },  { "module": "libzip",  "name": "zip_source_filep",  "code": "proc zip_source_filep*(para1: PZip; para2: File; para3: int; para4: int): PZipSource {.\u000A    cdecl, mydll, importc: \"zip_source_filep\".}" },  { "module": "libzip",  "name": "zip_source_free",  "code": "proc zip_source_free*(para1: PZipSource) {.cdecl, mydll, \u000A    importc: \"zip_source_free\".}" },  { "module": "libzip",  "name": "zip_source_function",  "code": "proc zip_source_function*(para1: PZip; para2: TZipSourceCallback; para3: pointer): PZipSource {.\u000A    cdecl, mydll, importc: \"zip_source_function\".}" },  { "module": "libzip",  "name": "zip_source_zip",  "code": "proc zip_source_zip*(para1: PZip; para2: PZip; para3: int32; para4: int32; \u000A                     para5: int; para6: int): PZipSource {.cdecl, mydll, \u000A    importc: \"zip_source_zip\".}" },  { "module": "libzip",  "name": "zip_stat",  "code": "proc zip_stat*(para1: PZip; para2: cstring; para3: int32; para4: PZipStat): int32 {.\u000A    cdecl, mydll, importc: \"zip_stat\".}" },  { "module": "libzip",  "name": "zip_stat_index",  "code": "proc zip_stat_index*(para1: PZip; para2: int32; para3: int32; para4: PZipStat): int32 {.\u000A    cdecl, mydll, importc: \"zip_stat_index\".}" },  { "module": "libzip",  "name": "zip_stat_init",  "code": "proc zip_stat_init*(para1: PZipStat) {.cdecl, mydll, importc: \"zip_stat_init\".}" },  { "module": "libzip",  "name": "zip_strerror",  "code": "proc zip_strerror*(para1: PZip): cstring {.cdecl, mydll, importc: \"zip_strerror\".}" },  { "module": "libzip",  "name": "zip_unchange",  "code": "proc zip_unchange*(para1: PZip; para2: int32): int32 {.cdecl, mydll, \u000A    importc: \"zip_unchange\".}" },  { "module": "libzip",  "name": "zip_unchange_all",  "code": "proc zip_unchange_all*(para1: PZip): int32 {.cdecl, mydll, \u000A    importc: \"zip_unchange_all\".}" },  { "module": "libzip",  "name": "zip_unchange_archive",  "code": "proc zip_unchange_archive*(para1: PZip): int32 {.cdecl, mydll, \u000A    importc: \"zip_unchange_archive\".}" },  { "module": "linux",  "name": "clone",  "code": "proc clone*(fn: pointer; child_stack: pointer; flags: cint; arg: pointer; \u000A            ptid: ptr TPid; tls: pointer; ctid: ptr TPid): cint {.importc, \u000A    header: \"<sched.h>\".}" },  { "module": "lists",  "name": "initSinglyLinkedList",  "code": "proc initSinglyLinkedList*[T](): SinglyLinkedList[T]",  "desc": "creates a new singly linked list that is empty." },  { "module": "lists",  "name": "initDoublyLinkedList",  "code": "proc initDoublyLinkedList*[T](): DoublyLinkedList[T]",  "desc": "creates a new doubly linked list that is empty." },  { "module": "lists",  "name": "initSinglyLinkedRing",  "code": "proc initSinglyLinkedRing*[T](): SinglyLinkedRing[T]",  "desc": "creates a new singly linked ring that is empty." },  { "module": "lists",  "name": "initDoublyLinkedRing",  "code": "proc initDoublyLinkedRing*[T](): DoublyLinkedRing[T]",  "desc": "creates a new doubly linked ring that is empty." },  { "module": "lists",  "name": "newDoublyLinkedNode",  "code": "proc newDoublyLinkedNode*[T](value: T): DoublyLinkedNode[T]",  "desc": "creates a new doubly linked node with the given <cite>value</cite>." },  { "module": "lists",  "name": "newSinglyLinkedNode",  "code": "proc newSinglyLinkedNode*[T](value: T): SinglyLinkedNode[T]",  "desc": "creates a new singly linked node with the given <cite>value</cite>." },  { "module": "lists",  "name": "items",  "code": "iterator items*[T](L: DoublyLinkedList[T]): T",  "desc": "yields every value of <cite>L</cite>." },  { "module": "lists",  "name": "items",  "code": "iterator items*[T](L: SinglyLinkedList[T]): T",  "desc": "yields every value of <cite>L</cite>." },  { "module": "lists",  "name": "items",  "code": "iterator items*[T](L: SinglyLinkedRing[T]): T",  "desc": "yields every value of <cite>L</cite>." },  { "module": "lists",  "name": "items",  "code": "iterator items*[T](L: DoublyLinkedRing[T]): T",  "desc": "yields every value of <cite>L</cite>." },  { "module": "lists",  "name": "nodes",  "code": "iterator nodes*[T](L: SinglyLinkedList[T]): SinglyLinkedNode[T]",  "desc": "iterates over every node of <cite>x</cite>. Removing the current node from the list during traversal is supported." },  { "module": "lists",  "name": "nodes",  "code": "iterator nodes*[T](L: DoublyLinkedList[T]): DoublyLinkedNode[T]",  "desc": "iterates over every node of <cite>x</cite>. Removing the current node from the list during traversal is supported." },  { "module": "lists",  "name": "nodes",  "code": "iterator nodes*[T](L: SinglyLinkedRing[T]): SinglyLinkedNode[T]",  "desc": "iterates over every node of <cite>x</cite>. Removing the current node from the list during traversal is supported." },  { "module": "lists",  "name": "nodes",  "code": "iterator nodes*[T](L: DoublyLinkedRing[T]): DoublyLinkedNode[T]",  "desc": "iterates over every node of <cite>x</cite>. Removing the current node from the list during traversal is supported." },  { "module": "lists",  "name": "`$`",  "code": "proc `$`*[T](L: SinglyLinkedList[T]): string",  "desc": "turns a list into its string representation." },  { "module": "lists",  "name": "`$`",  "code": "proc `$`*[T](L: DoublyLinkedList[T]): string",  "desc": "turns a list into its string representation." },  { "module": "lists",  "name": "`$`",  "code": "proc `$`*[T](L: SinglyLinkedRing[T]): string",  "desc": "turns a list into its string representation." },  { "module": "lists",  "name": "`$`",  "code": "proc `$`*[T](L: DoublyLinkedRing[T]): string",  "desc": "turns a list into its string representation." },  { "module": "lists",  "name": "find",  "code": "proc find*[T](L: SinglyLinkedList[T]; value: T): SinglyLinkedNode[T]",  "desc": "searches in the list for a value. Returns nil if the value does not exist." },  { "module": "lists",  "name": "find",  "code": "proc find*[T](L: DoublyLinkedList[T]; value: T): DoublyLinkedNode[T]",  "desc": "searches in the list for a value. Returns nil if the value does not exist." },  { "module": "lists",  "name": "find",  "code": "proc find*[T](L: SinglyLinkedRing[T]; value: T): SinglyLinkedNode[T]",  "desc": "searches in the list for a value. Returns nil if the value does not exist." },  { "module": "lists",  "name": "find",  "code": "proc find*[T](L: DoublyLinkedRing[T]; value: T): DoublyLinkedNode[T]",  "desc": "searches in the list for a value. Returns nil if the value does not exist." },  { "module": "lists",  "name": "contains",  "code": "proc contains*[T](L: SinglyLinkedList[T]; value: T): bool {.inline.}",  "desc": "searches in the list for a value. Returns false if the value does not exist, true otherwise." },  { "module": "lists",  "name": "contains",  "code": "proc contains*[T](L: DoublyLinkedList[T]; value: T): bool {.inline.}",  "desc": "searches in the list for a value. Returns false if the value does not exist, true otherwise." },  { "module": "lists",  "name": "contains",  "code": "proc contains*[T](L: SinglyLinkedRing[T]; value: T): bool {.inline.}",  "desc": "searches in the list for a value. Returns false if the value does not exist, true otherwise." },  { "module": "lists",  "name": "contains",  "code": "proc contains*[T](L: DoublyLinkedRing[T]; value: T): bool {.inline.}",  "desc": "searches in the list for a value. Returns false if the value does not exist, true otherwise." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var SinglyLinkedList[T]; n: SinglyLinkedNode[T]) {.inline.}",  "desc": "prepends a node to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var SinglyLinkedList[T]; value: T) {.inline.}",  "desc": "prepends a node to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "append",  "code": "proc append*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])",  "desc": "appends a node <cite>n</cite> to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "append",  "code": "proc append*[T](L: var DoublyLinkedList[T]; value: T)",  "desc": "appends a value to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])",  "desc": "prepends a node <cite>n</cite> to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var DoublyLinkedList[T]; value: T)",  "desc": "prepends a value to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "remove",  "code": "proc remove*[T](L: var DoublyLinkedList[T]; n: DoublyLinkedNode[T])",  "desc": "removes <cite>n</cite> from <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var SinglyLinkedRing[T]; n: SinglyLinkedNode[T])",  "desc": "prepends a node <cite>n</cite> to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var SinglyLinkedRing[T]; value: T)",  "desc": "prepends a value to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "append",  "code": "proc append*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])",  "desc": "appends a node <cite>n</cite> to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "append",  "code": "proc append*[T](L: var DoublyLinkedRing[T]; value: T)",  "desc": "appends a value to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])",  "desc": "prepends a node <cite>n</cite> to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "prepend",  "code": "proc prepend*[T](L: var DoublyLinkedRing[T]; value: T)",  "desc": "prepends a value to <cite>L</cite>. Efficiency: O(1)." },  { "module": "lists",  "name": "remove",  "code": "proc remove*[T](L: var DoublyLinkedRing[T]; n: DoublyLinkedNode[T])",  "desc": "removes <cite>n</cite> from <cite>L</cite>. Efficiency: O(1)." },  { "module": "locks",  "name": "initLock",  "code": "proc initLock*(lock: var TLock) {.inline.}",  "desc": "Initializes the given lock." },  { "module": "locks",  "name": "deinitLock",  "code": "proc deinitLock*(lock: var TLock) {.inline.}",  "desc": "Frees the resources associated with the lock." },  { "module": "locks",  "name": "tryAcquire",  "code": "proc tryAcquire*(lock: var TLock): bool",  "desc": "Tries to acquire the given lock. Returns <cite>true</cite> on success." },  { "module": "locks",  "name": "acquire",  "code": "proc acquire*(lock: var TLock)",  "desc": "Acquires the given lock." },  { "module": "locks",  "name": "release",  "code": "proc release*(lock: var TLock)",  "desc": "Releases the given lock." },  { "module": "locks",  "name": "initCond",  "code": "proc initCond*(cond: var TCond) {.inline.}",  "desc": "Initializes the given condition variable." },  { "module": "locks",  "name": "deinitCond",  "code": "proc deinitCond*(cond: var TCond) {.inline.}",  "desc": "Frees the resources associated with the lock." },  { "module": "locks",  "name": "wait",  "code": "proc wait*(cond: var TCond; lock: var TLock) {.inline.}",  "desc": "waits on the condition variable <cite>cond</cite>. " },  { "module": "locks",  "name": "signal",  "code": "proc signal*(cond: var TCond) {.inline.}",  "desc": "sends a signal to the condition variable <cite>cond</cite>. " },  { "module": "logging",  "name": "log",  "code": "method log*(logger: Logger; level: Level; frmt: string; \u000A            args: varargs[string, `$`]) {.raises: [Exception], \u000A    tags: [TimeEffect, WriteIOEffect, ReadIOEffect].}",  "desc": "Override this method in custom loggers. Default implementation does nothing." },  { "module": "logging",  "name": "log",  "code": "method log*(logger: ConsoleLogger; level: Level; frmt: string; \u000A            args: varargs[string, `$`])",  "desc": "Logs to the console using <tt class=\"docutils literal\"><span class=\"pre\">logger</span></tt> only." },  { "module": "logging",  "name": "log",  "code": "method log*(logger: FileLogger; level: Level; frmt: string; \u000A            args: varargs[string, `$`])",  "desc": "Logs to a file using <tt class=\"docutils literal\"><span class=\"pre\">logger</span></tt> only." },  { "module": "logging",  "name": "defaultFilename",  "code": "proc defaultFilename*(): string",  "desc": "Returns the default filename for a logger." },  { "module": "logging",  "name": "newConsoleLogger",  "code": "proc newConsoleLogger*(levelThreshold = lvlAll; fmtStr = defaultFmtStr): ConsoleLogger",  "desc": "Creates a new console logger. This logger logs to the console." },  { "module": "logging",  "name": "newFileLogger",  "code": "proc newFileLogger*(filename = defaultFilename(); mode: FileMode = fmAppend; \u000A                    levelThreshold = lvlAll; fmtStr = defaultFmtStr): FileLogger",  "desc": "Creates a new file logger. This logger logs to a file." },  { "module": "logging",  "name": "newRollingFileLogger",  "code": "proc newRollingFileLogger*(filename = defaultFilename(); \u000A                           mode: FileMode = fmReadWrite; \u000A                           levelThreshold = lvlAll; fmtStr = defaultFmtStr; \u000A                           maxLines = 1000): RollingFileLogger",  "desc": "Creates a new rolling file logger. Once a file reaches <tt class=\"docutils literal\"><span class=\"pre\">maxLines</span></tt> lines a new log file will be started and the old will be renamed." },  { "module": "logging",  "name": "log",  "code": "method log*(logger: RollingFileLogger; level: Level; frmt: string; \u000A            args: varargs[string, `$`])",  "desc": "Logs to a file using rolling <tt class=\"docutils literal\"><span class=\"pre\">logger</span></tt> only." },  { "module": "logging",  "name": "log",  "code": "template log*(level: Level; frmt: string; args: varargs[string, `$`])",  "desc": "Logs a message to all registered handlers at the given level." },  { "module": "logging",  "name": "debug",  "code": "template debug*(frmt: string; args: varargs[string, `$`])",  "desc": "Logs a debug message to all registered handlers." },  { "module": "logging",  "name": "info",  "code": "template info*(frmt: string; args: varargs[string, `$`])",  "desc": "Logs an info message to all registered handlers." },  { "module": "logging",  "name": "warn",  "code": "template warn*(frmt: string; args: varargs[string, `$`])",  "desc": "Logs a warning message to all registered handlers." },  { "module": "logging",  "name": "error",  "code": "template error*(frmt: string; args: varargs[string, `$`])",  "desc": "Logs an error message to all registered handlers." },  { "module": "logging",  "name": "fatal",  "code": "template fatal*(frmt: string; args: varargs[string, `$`])",  "desc": "Logs a fatal error message to all registered handlers." },  { "module": "macros",  "name": "`[]`",  "code": "proc `[]`*(n: PNimrodNode; i: int): PNimrodNode {.magic: \"NChild\", noSideEffect.}",  "desc": "get <cite>n</cite>'s <cite>i</cite>'th child." },  { "module": "macros",  "name": "`[]=`",  "code": "proc `[]=`*(n: PNimrodNode; i: int; child: PNimrodNode) {.magic: \"NSetChild\", \u000A    noSideEffect.}",  "desc": "set <cite>n</cite>'s <cite>i</cite>'th child to <cite>child</cite>." },  { "module": "macros",  "name": "`!`",  "code": "proc `!`*(s: string): TNimrodIdent {.magic: \"StrToIdent\", noSideEffect.}",  "desc": "constructs an identifier from the string <cite>s</cite>" },  { "module": "macros",  "name": "`$`",  "code": "proc `$`*(i: TNimrodIdent): string {.magic: \"IdentToStr\", noSideEffect.}",  "desc": "converts a Nimrod identifier to a string" },  { "module": "macros",  "name": "`$`",  "code": "proc `$`*(s: PNimrodSymbol): string {.magic: \"IdentToStr\", noSideEffect.}",  "desc": "converts a Nimrod symbol to a string" },  { "module": "macros",  "name": "`==`",  "code": "proc `==`*(a, b: TNimrodIdent): bool {.magic: \"EqIdent\", noSideEffect.}",  "desc": "compares two Nimrod identifiers" },  { "module": "macros",  "name": "`==`",  "code": "proc `==`*(a, b: PNimrodNode): bool {.magic: \"EqNimrodNode\", noSideEffect.}",  "desc": "compares two Nimrod nodes" },  { "module": "macros",  "name": "len",  "code": "proc len*(n: PNimrodNode): int {.magic: \"NLen\", noSideEffect.}",  "desc": "returns the number of children of <cite>n</cite>." },  { "module": "macros",  "name": "add",  "code": "proc add*(father, child: PNimrodNode): PNimrodNode {.magic: \"NAdd\", discardable, \u000A    noSideEffect.}",  "desc": "Adds the <cite>child</cite> to the <cite>father</cite> node. Returns the father node so that calls can be nested." },  { "module": "macros",  "name": "add",  "code": "proc add*(father: PNimrodNode; children: varargs[PNimrodNode]): PNimrodNode {.\u000A    magic: \"NAddMultiple\", discardable, noSideEffect.}",  "desc": "Adds each child of <cite>children</cite> to the <cite>father</cite> node. Returns the <cite>father</cite> node so that calls can be nested." },  { "module": "macros",  "name": "del",  "code": "proc del*(father: PNimrodNode; idx = 0; n = 1) {.magic: \"NDel\", noSideEffect.}",  "desc": "deletes <cite>n</cite> children of <cite>father</cite> starting at index <cite>idx</cite>." },  { "module": "macros",  "name": "kind",  "code": "proc kind*(n: PNimrodNode): TNimrodNodeKind {.magic: \"NKind\", noSideEffect.}",  "desc": "returns the <cite>kind</cite> of the node <cite>n</cite>." },  { "module": "macros",  "name": "intVal",  "code": "proc intVal*(n: PNimrodNode): BiggestInt {.magic: \"NIntVal\", noSideEffect.}" },  { "module": "macros",  "name": "floatVal",  "code": "proc floatVal*(n: PNimrodNode): BiggestFloat {.magic: \"NFloatVal\", noSideEffect.}" },  { "module": "macros",  "name": "symbol",  "code": "proc symbol*(n: PNimrodNode): PNimrodSymbol {.magic: \"NSymbol\", noSideEffect.}" },  { "module": "macros",  "name": "ident",  "code": "proc ident*(n: PNimrodNode): TNimrodIdent {.magic: \"NIdent\", noSideEffect.}" },  { "module": "macros",  "name": "typ",  "code": "proc typ*(n: PNimrodNode): typedesc {.magic: \"NGetType\", noSideEffect.}" },  { "module": "macros",  "name": "strVal",  "code": "proc strVal*(n: PNimrodNode): string {.magic: \"NStrVal\", noSideEffect.}" },  { "module": "macros",  "name": "`intVal=`",  "code": "proc `intVal =`*(n: PNimrodNode; val: BiggestInt) {.magic: \"NSetIntVal\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "`floatVal=`",  "code": "proc `floatVal =`*(n: PNimrodNode; val: BiggestFloat) {.magic: \"NSetFloatVal\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "`symbol=`",  "code": "proc `symbol =`*(n: PNimrodNode; val: PNimrodSymbol) {.magic: \"NSetSymbol\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "`ident=`",  "code": "proc `ident =`*(n: PNimrodNode; val: TNimrodIdent) {.magic: \"NSetIdent\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "`strVal=`",  "code": "proc `strVal =`*(n: PNimrodNode; val: string) {.magic: \"NSetStrVal\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "newNimNode",  "code": "proc newNimNode*(kind: TNimrodNodeKind; n: PNimrodNode = nil): PNimrodNode {.\u000A    magic: \"NNewNimNode\", noSideEffect.}" },  { "module": "macros",  "name": "copyNimNode",  "code": "proc copyNimNode*(n: PNimrodNode): PNimrodNode {.magic: \"NCopyNimNode\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "copyNimTree",  "code": "proc copyNimTree*(n: PNimrodNode): PNimrodNode {.magic: \"NCopyNimTree\", \u000A    noSideEffect.}" },  { "module": "macros",  "name": "error",  "code": "proc error*(msg: string) {.magic: \"NError\", gcsafe.}",  "desc": "writes an error message at compile time" },  { "module": "macros",  "name": "warning",  "code": "proc warning*(msg: string) {.magic: \"NWarning\", gcsafe.}",  "desc": "writes a warning message at compile time" },  { "module": "macros",  "name": "hint",  "code": "proc hint*(msg: string) {.magic: \"NHint\", gcsafe.}",  "desc": "writes a hint message at compile time" },  { "module": "macros",  "name": "newStrLitNode",  "code": "proc newStrLitNode*(s: string): PNimrodNode {.compileTime, noSideEffect.}",  "desc": "creates a string literal node from <cite>s</cite>" },  { "module": "macros",  "name": "newIntLitNode",  "code": "proc newIntLitNode*(i: BiggestInt): PNimrodNode {.compileTime.}",  "desc": "creates a int literal node from <cite>i</cite>" },  { "module": "macros",  "name": "newFloatLitNode",  "code": "proc newFloatLitNode*(f: BiggestFloat): PNimrodNode {.compileTime.}",  "desc": "creates a float literal node from <cite>f</cite>" },  { "module": "macros",  "name": "newIdentNode",  "code": "proc newIdentNode*(i: TNimrodIdent): PNimrodNode {.compileTime.}",  "desc": "creates an identifier node from <cite>i</cite>" },  { "module": "macros",  "name": "newIdentNode",  "code": "proc newIdentNode*(i: string): PNimrodNode {.compileTime.}",  "desc": "creates an identifier node from <cite>i</cite>" },  { "module": "macros",  "name": "bindSym",  "code": "proc bindSym*(ident: string; rule: TBindSymRule = brClosed): PNimrodNode {.\u000A    magic: \"NBindSym\", noSideEffect.}",  "desc": "creates a node that binds <cite>ident</cite> to a symbol node. The bound symbol may be an overloaded symbol. If <tt class=\"docutils literal\"><span class=\"pre\">rule == brClosed</span></tt> either an <tt class=\"docutils literal\"><span class=\"pre\">nkClosedSymChoice</span></tt> tree is returned or <tt class=\"docutils literal\"><span class=\"pre\">nkSym</span></tt> if the symbol is not ambiguous. If <tt class=\"docutils literal\"><span class=\"pre\">rule == brOpen</span></tt> either an <tt class=\"docutils literal\"><span class=\"pre\">nkOpenSymChoice</span></tt> tree is returned or <tt class=\"docutils literal\"><span class=\"pre\">nkSym</span></tt> if the symbol is not ambiguous. If <tt class=\"docutils literal\"><span class=\"pre\">rule == brForceOpen</span></tt> always an <tt class=\"docutils literal\"><span class=\"pre\">nkOpenSymChoice</span></tt> tree is returned even if the symbol is not ambiguous." },  { "module": "macros",  "name": "genSym",  "code": "proc genSym*(kind: TNimrodSymKind = nskLet; ident = \"\"): PNimrodNode {.\u000A    magic: \"NGenSym\", noSideEffect.}",  "desc": "generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context." },  { "module": "macros",  "name": "callsite",  "code": "proc callsite*(): PNimrodNode {.magic: \"NCallSite\", gcsafe.}",  "desc": "returns the AST if the invokation expression that invoked this macro." },  { "module": "macros",  "name": "toStrLit",  "code": "proc toStrLit*(n: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "converts the AST <cite>n</cite> to the concrete Nimrod code and wraps that in a string literal node" },  { "module": "macros",  "name": "lineinfo",  "code": "proc lineinfo*(n: PNimrodNode): string {.magic: \"NLineInfo\", noSideEffect.}",  "desc": "returns the position the node appears in the original source file in the form filename(line, col)" },  { "module": "macros",  "name": "internalErrorFlag",  "code": "proc internalErrorFlag*(): string {.magic: \"NError\", noSideEffect.}",  "desc": "Some builtins set an error flag. This is then turned into a proper exception. <strong>Note</strong>: Ordinary application code should not call this." },  { "module": "macros",  "name": "parseExpr",  "code": "proc parseExpr*(s: string): PNimrodNode {.noSideEffect, compileTime.}",  "desc": "Compiles the passed string to its AST representation. Expects a single expression. Raises <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> for parsing errors." },  { "module": "macros",  "name": "parseStmt",  "code": "proc parseStmt*(s: string): PNimrodNode {.noSideEffect, compileTime.}",  "desc": "Compiles the passed string to its AST representation. Expects one or more statements. Raises <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> for parsing errors." },  { "module": "macros",  "name": "getAst",  "code": "proc getAst*(macroOrTemplate: expr): PNimrodNode {.magic: \"ExpandToAst\", \u000A    noSideEffect.}",  "desc": "Obtains the AST nodes returned from a macro or template invocation. Example:<pre><span class=\"Keyword\">macro</span> <span class=\"Identifier\">FooMacro</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">var</span> <span class=\"Identifier\">ast</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">getAst</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">BarTemplate</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "macros",  "name": "quote",  "code": "proc quote*(bl: stmt; op = \"``\"): PNimrodNode {.magic: \"QuoteAst\", noSideEffect.}",  "desc": "<p>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate PNimrodNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself): e.g. <cite>@</cite> is escaped as <cite>@@</cite>, <cite>@@</cite> is escaped as <cite>@@@</cite> and so on.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">macro</span> <span class=\"Identifier\">check</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">ex</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">expr</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">stmt</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Comment\"># this is a simplified version of the check macro from the</span>\u000A  <span class=\"Comment\"># unittest module.</span>\u000A  \u000A  <span class=\"Comment\"># If there is a failed check, we want to make it easy for</span>\u000A  <span class=\"Comment\"># the user to jump to the faulty line in the code, so we</span>\u000A  <span class=\"Comment\"># get the line info here:</span>\u000A  <span class=\"Keyword\">var</span> <span class=\"Identifier\">info</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">ex</span><span class=\"Operator\">.</span><span class=\"Identifier\">lineinfo</span>\u000A  \u000A  <span class=\"Comment\"># We will also display the code string of the failed check:</span>\u000A  <span class=\"Keyword\">var</span> <span class=\"Identifier\">expString</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">ex</span><span class=\"Operator\">.</span><span class=\"Identifier\">toStrLit</span>\u000A  \u000A  <span class=\"Comment\"># Finally we compose the code to implement the check:</span>\u000A  <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">quote</span> <span class=\"Keyword\">do</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">if</span> <span class=\"Keyword\">not</span> <span class=\"Punctuation\">`</span><span class=\"Identifier\">ex</span><span class=\"Punctuation\">`</span><span class=\"Punctuation\">:</span>\u000A      <span class=\"Identifier\">echo</span> <span class=\"Punctuation\">`</span><span class=\"Identifier\">info</span><span class=\"Punctuation\">`</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;: Check failed: &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Punctuation\">`</span><span class=\"Identifier\">expString</span><span class=\"Punctuation\">`</span></pre>" },  { "module": "macros",  "name": "expectKind",  "code": "proc expectKind*(n: PNimrodNode; k: TNimrodNodeKind) {.compileTime.}",  "desc": "checks that <cite>n</cite> is of kind <cite>k</cite>. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them." },  { "module": "macros",  "name": "expectMinLen",  "code": "proc expectMinLen*(n: PNimrodNode; min: int) {.compileTime.}",  "desc": "checks that <cite>n</cite> has at least <cite>min</cite> children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments." },  { "module": "macros",  "name": "expectLen",  "code": "proc expectLen*(n: PNimrodNode; len: int) {.compileTime.}",  "desc": "checks that <cite>n</cite> has exactly <cite>len</cite> children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments." },  { "module": "macros",  "name": "newCall",  "code": "proc newCall*(theProc: PNimrodNode; args: varargs[PNimrodNode]): PNimrodNode {.\u000A    compileTime.}",  "desc": "produces a new call node. <cite>theProc</cite> is the proc that is called with the arguments <tt class=\"docutils literal\"><span class=\"pre\">args[0..]</span></tt>." },  { "module": "macros",  "name": "newCall",  "code": "proc newCall*(theProc: TNimrodIdent; args: varargs[PNimrodNode]): PNimrodNode {.\u000A    compileTime.}",  "desc": "produces a new call node. <cite>theProc</cite> is the proc that is called with the arguments <tt class=\"docutils literal\"><span class=\"pre\">args[0..]</span></tt>." },  { "module": "macros",  "name": "newCall",  "code": "proc newCall*(theProc: string; args: varargs[PNimrodNode]): PNimrodNode {.\u000A    compileTime.}",  "desc": "produces a new call node. <cite>theProc</cite> is the proc that is called with the arguments <tt class=\"docutils literal\"><span class=\"pre\">args[0..]</span></tt>." },  { "module": "macros",  "name": "newLit",  "code": "proc newLit*(c: char): PNimrodNode {.compileTime.}",  "desc": "produces a new character literal node." },  { "module": "macros",  "name": "newLit",  "code": "proc newLit*(i: BiggestInt): PNimrodNode {.compileTime.}",  "desc": "produces a new integer literal node." },  { "module": "macros",  "name": "newLit",  "code": "proc newLit*(f: BiggestFloat): PNimrodNode {.compileTime.}",  "desc": "produces a new float literal node." },  { "module": "macros",  "name": "newLit",  "code": "proc newLit*(s: string): PNimrodNode {.compileTime.}",  "desc": "produces a new string literal node." },  { "module": "macros",  "name": "nestList",  "code": "proc nestList*(theProc: TNimrodIdent; x: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "nests the list <cite>x</cite> into a tree of call expressions: <tt class=\"docutils literal\"><span class=\"pre\">[a, b, c]</span></tt> is transformed into <tt class=\"docutils literal\"><span class=\"pre\">theProc(a, theProc(c, d))</span></tt>." },  { "module": "macros",  "name": "treeRepr",  "code": "proc treeRepr*(n: PNimrodNode): string {.compileTime.}",  "desc": "<p>Convert the AST <cite>n</cite> to a human-readable tree-like string.</p>\u000A<p>See also <cite>repr</cite> and <cite>lispRepr</cite>.</p>\u000A" },  { "module": "macros",  "name": "lispRepr",  "code": "proc lispRepr*(n: PNimrodNode): string {.compileTime.}",  "desc": "<p>Convert the AST <cite>n</cite> to a human-readable lisp-like string,</p>\u000A<p>See also <cite>repr</cite> and <cite>treeRepr</cite>.</p>\u000A" },  { "module": "macros",  "name": "dumpTree",  "code": "macro dumpTree*(s: stmt): stmt {.immediate.}",  "desc": "<p>Accepts a block of nim code and prints the parsed abstract syntax tree using the <cite>toTree</cite> function. Printing is done <em>at compile time</em>.</p>\u000A<p>You can use this as a tool to explore the Nimrod's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</p>\u000A" },  { "module": "macros",  "name": "dumpLisp",  "code": "macro dumpLisp*(s: stmt): stmt {.immediate.}",  "desc": "<p>Accepts a block of nim code and prints the parsed abstract syntax tree using the <cite>toLisp</cite> function. Printing is done <em>at compile time</em>.</p>\u000A<p>See <cite>dumpTree</cite>.</p>\u000A" },  { "module": "macros",  "name": "dumpTreeImm",  "code": "macro dumpTreeImm*(s: stmt): stmt {.immediate, deprecated.}",  "desc": "The <tt class=\"docutils literal\"><span class=\"pre\">immediate</span></tt> version of <cite>dumpTree</cite>." },  { "module": "macros",  "name": "dumpLispImm",  "code": "macro dumpLispImm*(s: stmt): stmt {.immediate, deprecated.}",  "desc": "The <tt class=\"docutils literal\"><span class=\"pre\">immediate</span></tt> version of <cite>dumpLisp</cite>." },  { "module": "macros",  "name": "newEmptyNode",  "code": "proc newEmptyNode*(): PNimrodNode {.compileTime, noSideEffect.}",  "desc": "Create a new empty node " },  { "module": "macros",  "name": "newStmtList",  "code": "proc newStmtList*(stmts: varargs[PNimrodNode]): PNimrodNode {.compileTime.}",  "desc": "Create a new statement list" },  { "module": "macros",  "name": "newBlockStmt",  "code": "proc newBlockStmt*(label, body: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "Create a new block statement with label" },  { "module": "macros",  "name": "newBlockStmt",  "code": "proc newBlockStmt*(body: PNimrodNode): PNimrodNode {.compiletime.}",  "desc": "Create a new block: stmt" },  { "module": "macros",  "name": "newVarStmt",  "code": "proc newVarStmt*(name, value: PNimrodNode): PNimrodNode {.compiletime.}",  "desc": "Create a new var stmt " },  { "module": "macros",  "name": "newLetStmt",  "code": "proc newLetStmt*(name, value: PNimrodNode): PNimrodNode {.compiletime.}",  "desc": "Create a new let stmt " },  { "module": "macros",  "name": "newAssignment",  "code": "proc newAssignment*(lhs, rhs: PNimrodNode): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "newDotExpr",  "code": "proc newDotExpr*(a, b: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "Create new dot expression a.dot(b) -&gt;  <cite>a.b</cite>" },  { "module": "macros",  "name": "newIdentDefs",  "code": "proc newIdentDefs*(name, kind: PNimrodNode; default = newEmptyNode()): PNimrodNode {.\u000A    compileTime.}",  "desc": "<p>Creates a new <tt class=\"docutils literal\"><span class=\"pre\">nnkIdentDefs</span></tt> node of a specific kind and value.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">nnkIdentDefs</span></tt> need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the <tt class=\"docutils literal\"><span class=\"pre\">kind</span></tt> node and <tt class=\"docutils literal\"><span class=\"pre\">default</span></tt> (value) nodes may be empty depending on where the <tt class=\"docutils literal\"><span class=\"pre\">nnkIdentDefs</span></tt> appears: tuple or object definitions will have an empty <tt class=\"docutils literal\"><span class=\"pre\">default</span></tt> node, <tt class=\"docutils literal\"><span class=\"pre\">let</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> blocks may have an empty <tt class=\"docutils literal\"><span class=\"pre\">kind</span></tt> node if the identifier is being assigned a value. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">varSection</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newNimNode</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">nnkVarSection</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span>\u000A  <span class=\"Identifier\">newIdentDefs</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;string&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span>\u000A  <span class=\"Identifier\">newIdentDefs</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">newEmptyNode</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">newLit</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; var</span>\u000A<span class=\"Comment\">#       a: string</span>\u000A<span class=\"Comment\">#       b = 3</span></pre><p>If you need to create multiple identifiers you need to use the lower level <tt class=\"docutils literal\"><span class=\"pre\">newNimNode</span></tt>:</p>\u000A<pre><span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newNimNode</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">nnkIdentDefs</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span>\u000A  <span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ident</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;string&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span>\u000A    <span class=\"Identifier\">newStrLitNode</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Hello&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "macros",  "name": "newNilLit",  "code": "proc newNilLit*(): PNimrodNode {.compileTime.}",  "desc": "New nil literal shortcut" },  { "module": "macros",  "name": "high",  "code": "proc high*(node: PNimrodNode): int {.compileTime.}",  "desc": "Return the highest index available for a node" },  { "module": "macros",  "name": "last",  "code": "proc last*(node: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "Return the last item in nodes children. Same as <cite>node[node.high()]</cite> " },  { "module": "macros",  "name": "expectKind",  "code": "proc expectKind*(n: PNimrodNode; k: set[TNimrodNodeKind]) {.compileTime.}" },  { "module": "macros",  "name": "newProc",  "code": "proc newProc*(name = newEmptyNode(); \u000A              params: openArray[PNimrodNode] = [newEmptyNode()]; \u000A              body: PNimrodNode = newStmtList(); procType = nnkProcDef): PNimrodNode {.\u000A    compileTime.}",  "desc": "<p>shortcut for creating a new proc</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">params</span></tt> array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</p>\u000A" },  { "module": "macros",  "name": "newIfStmt",  "code": "proc newIfStmt*(branches: varargs[tuple[cond, body: PNimrodNode]]): PNimrodNode {.\u000A    compiletime.}",  "desc": "Constructor for <tt class=\"docutils literal\"><span class=\"pre\">if</span></tt> statements.<pre><span class=\"Identifier\">newIfStmt</span><span class=\"Punctuation\">(</span>\u000A  <span class=\"Punctuation\">(</span><span class=\"Identifier\">Ident</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">StmtList</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span>\u000A  <span class=\"Operator\">...</span>\u000A<span class=\"Punctuation\">)</span></pre>" },  { "module": "macros",  "name": "copyChildrenTo",  "code": "proc copyChildrenTo*(src, dest: PNimrodNode) {.compileTime.}",  "desc": "Copy all children from <cite>src</cite> to <cite>dest</cite>" },  { "module": "macros",  "name": "name",  "code": "proc name*(someProc: PNimrodNode): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "`name=`",  "code": "proc `name =`*(someProc: PNimrodNode; val: PNimrodNode) {.compileTime.}" },  { "module": "macros",  "name": "params",  "code": "proc params*(someProc: PNimrodNode): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "`params=`",  "code": "proc `params =`*(someProc: PNimrodNode; params: PNimrodNode) {.compileTime.}" },  { "module": "macros",  "name": "pragma",  "code": "proc pragma*(someProc: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "Get the pragma of a proc type These will be expanded" },  { "module": "macros",  "name": "`pragma=`",  "code": "proc `pragma =`*(someProc: PNimrodNode; val: PNimrodNode) {.compileTime.}",  "desc": "Set the pragma of a proc type" },  { "module": "macros",  "name": "body",  "code": "proc body*(someProc: PNimrodNode): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "`body=`",  "code": "proc `body =`*(someProc: PNimrodNode; val: PNimrodNode) {.compileTime.}" },  { "module": "macros",  "name": "basename",  "code": "proc basename*(a: PNimrodNode): PNimrodNode {.compiletime.}" },  { "module": "macros",  "name": "`$`",  "code": "proc `$`*(node: PNimrodNode): string {.compileTime.}",  "desc": "Get the string of an identifier node" },  { "module": "macros",  "name": "ident",  "code": "proc ident*(name: string): PNimrodNode {.compileTime, inline.}",  "desc": "Create a new ident node from a string" },  { "module": "macros",  "name": "children",  "code": "iterator children*(n: PNimrodNode): PNimrodNode {.inline.}" },  { "module": "macros",  "name": "findChild",  "code": "template findChild*(n: PNimrodNode; cond: expr): PNimrodNode {.immediate, dirty.}",  "desc": "Find the first child node matching condition (or nil).<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">res</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">findChild</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">n</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">it</span><span class=\"Operator\">.</span><span class=\"Identifier\">kind</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">nnkPostfix</span> <span class=\"Keyword\">and</span>\u000A                       <span class=\"Identifier\">it</span><span class=\"Operator\">.</span><span class=\"Identifier\">basename</span><span class=\"Operator\">.</span><span class=\"Identifier\">ident</span> <span class=\"Operator\">==</span> <span class=\"Operator\">!</span><span class=\"StringLit\">&quot;foo&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "macros",  "name": "insert",  "code": "proc insert*(a: PNimrodNode; pos: int; b: PNimrodNode) {.compileTime.}",  "desc": "Insert node B into A at pos" },  { "module": "macros",  "name": "basename",  "code": "proc basename*(a: PNimrodNode): PNimrodNode",  "desc": "Pull an identifier from prefix/postfix expressions" },  { "module": "macros",  "name": "`basename=`",  "code": "proc `basename =`*(a: PNimrodNode; val: string) {.compileTime.}" },  { "module": "macros",  "name": "postfix",  "code": "proc postfix*(node: PNimrodNode; op: string): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "prefix",  "code": "proc prefix*(node: PNimrodNode; op: string): PNimrodNode {.compileTime.}" },  { "module": "macros",  "name": "infix",  "code": "proc infix*(a: PNimrodNode; op: string; b: PNimrodNode): PNimrodNode {.\u000A    compileTime.}" },  { "module": "macros",  "name": "unpackPostfix",  "code": "proc unpackPostfix*(node: PNimrodNode): tuple[node: PNimrodNode, op: string] {.\u000A    compileTime.}" },  { "module": "macros",  "name": "unpackPrefix",  "code": "proc unpackPrefix*(node: PNimrodNode): tuple[node: PNimrodNode, op: string] {.\u000A    compileTime.}" },  { "module": "macros",  "name": "unpackInfix",  "code": "proc unpackInfix*(node: PNimrodNode): tuple[left: PNimrodNode, op: string, \u000A    right: PNimrodNode] {.compileTime.}" },  { "module": "macros",  "name": "copy",  "code": "proc copy*(node: PNimrodNode): PNimrodNode {.compileTime.}",  "desc": "An alias for copyNimTree()." },  { "module": "macros",  "name": "eqIdent",  "code": "proc eqIdent*(a, b: string): bool",  "desc": "Check if two idents are identical." },  { "module": "macros",  "name": "hasArgOfName",  "code": "proc hasArgOfName*(params: PNimrodNode; name: string): bool {.compiletime.}",  "desc": "Search nnkFormalParams for an argument." },  { "module": "macros",  "name": "addIdentIfAbsent",  "code": "proc addIdentIfAbsent*(dest: PNimrodNode; ident: string) {.compiletime.}",  "desc": "Add ident to dest if it is not present. This is intended for use with pragmas." },  { "module": "macros",  "name": "emit",  "code": "template emit*(e: static[string]): stmt",  "desc": "accepts a single string argument and treats it as nim code that should be inserted verbatim in the program Example:<pre><span class=\"Identifier\">emit</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;echo &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"CharLit\">'&quot;'</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;hello world&quot;</span><span class=\"Operator\">.</span><span class=\"Identifier\">toUpper</span> <span class=\"Operator\">&amp;</span> <span class=\"CharLit\">'&quot;'</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "marshal",  "name": "load",  "code": "proc load*[T](s: Stream; data: var T)",  "desc": "loads <cite>data</cite> from the stream <cite>s</cite>. Raises <cite>EIO</cite> in case of an error." },  { "module": "marshal",  "name": "store",  "code": "proc store*[T](s: Stream; data: T)",  "desc": "stores <cite>data</cite> into the stream <cite>s</cite>. Raises <cite>EIO</cite> in case of an error." },  { "module": "marshal",  "name": "`$$`",  "code": "proc `$$`*[T](x: T): string",  "desc": "returns a string representation of <cite>x</cite>." },  { "module": "marshal",  "name": "to",  "code": "proc to*[T](data: string): T",  "desc": "reads data and transforms it to a <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt>." },  { "module": "matchers",  "name": "validEmailAddress",  "code": "proc validEmailAddress*(s: string): bool {.noSideEffect, rtl, \u000A    extern: \"nsuValidEmailAddress\".}",  "desc": "returns true if <cite>s</cite> seems to be a valid e-mail address. The checking also uses a domain list." },  { "module": "matchers",  "name": "parseInt",  "code": "proc parseInt*(s: string; value: var int; validRange: Slice[int]) {.\u000A    noSideEffect, rtl, extern: \"nmatchParseInt\".}",  "desc": "parses <cite>s</cite> into an integer in the range <cite>validRange</cite>. If successful, <cite>value</cite> is modified to contain the result. Otherwise no exception is raised and <cite>value</cite> is not touched; this way a reasonable default value won't be overwritten." },  { "module": "math",  "name": "classify",  "code": "proc classify*(x: float): FloatClass",  "desc": "classifies a floating point value. Returns <cite>x</cite>'s class as specified by <cite>FloatClass</cite>." },  { "module": "math",  "name": "binom",  "code": "proc binom*(n, k: int): int {.noSideEffect.}",  "desc": "computes the binomial coefficient" },  { "module": "math",  "name": "fac",  "code": "proc fac*(n: int): int {.noSideEffect.}",  "desc": "computes the faculty/factorial function." },  { "module": "math",  "name": "isPowerOfTwo",  "code": "proc isPowerOfTwo*(x: int): bool {.noSideEffect.}",  "desc": "returns true, if <cite>x</cite> is a power of two, false otherwise. Zero and negative numbers are not a power of two." },  { "module": "math",  "name": "nextPowerOfTwo",  "code": "proc nextPowerOfTwo*(x: int): int {.noSideEffect.}",  "desc": "returns <cite>x</cite> rounded up to the nearest power of two. Zero and negative numbers get rounded up to 1." },  { "module": "math",  "name": "countBits32",  "code": "proc countBits32*(n: int32): int {.noSideEffect.}",  "desc": "counts the set bits in <cite>n</cite>." },  { "module": "math",  "name": "sum",  "code": "proc sum*[T](x: openArray[T]): T {.noSideEffect.}",  "desc": "computes the sum of the elements in <cite>x</cite>. If <cite>x</cite> is empty, 0 is returned." },  { "module": "math",  "name": "mean",  "code": "proc mean*(x: openArray[float]): float {.noSideEffect.}",  "desc": "computes the mean of the elements in <cite>x</cite>. If <cite>x</cite> is empty, NaN is returned." },  { "module": "math",  "name": "variance",  "code": "proc variance*(x: openArray[float]): float {.noSideEffect.}",  "desc": "computes the variance of the elements in <cite>x</cite>. If <cite>x</cite> is empty, NaN is returned." },  { "module": "math",  "name": "random",  "code": "proc random*(max: int): int {.gcsafe.}",  "desc": "returns a random number in the range 0..max-1. The sequence of random number is always the same, unless <cite>randomize</cite> is called which initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount." },  { "module": "math",  "name": "random",  "code": "proc random*(max: float): float {.gcsafe.}",  "desc": "returns a random number in the range 0..&lt;max. The sequence of random number is always the same, unless <cite>randomize</cite> is called which initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. This has a 16-bit resolution on windows and a 48-bit resolution on other platforms." },  { "module": "math",  "name": "randomize",  "code": "proc randomize*() {.gcsafe.}",  "desc": "initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. Note: Does nothing for the JavaScript target, as JavaScript does not support this." },  { "module": "math",  "name": "randomize",  "code": "proc randomize*(seed: int) {.gcsafe.}",  "desc": "initializes the random number generator with a specific seed. Note: Does nothing for the JavaScript target, as JavaScript does not support this." },  { "module": "math",  "name": "sqrt",  "code": "proc sqrt*(x: float): float {.importc: \"sqrt\", header: \"<math.h>\".}",  "desc": "computes the square root of <cite>x</cite>." },  { "module": "math",  "name": "ln",  "code": "proc ln*(x: float): float {.importc: \"log\", header: \"<math.h>\".}",  "desc": "computes ln(x)." },  { "module": "math",  "name": "log10",  "code": "proc log10*(x: float): float {.importc: \"log10\", header: \"<math.h>\".}" },  { "module": "math",  "name": "log2",  "code": "proc log2*(x: float): float" },  { "module": "math",  "name": "exp",  "code": "proc exp*(x: float): float {.importc: \"exp\", header: \"<math.h>\".}",  "desc": "computes e**x." },  { "module": "math",  "name": "frexp",  "code": "proc frexp*(x: float; exponent: var int): float {.importc: \"frexp\", \u000A    header: \"<math.h>\".}",  "desc": "Split a number into mantissa and exponent. <cite>frexp</cite> calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that <cite>x</cite> (the original float value) equals m * 2**n. frexp stores n in <cite>exponent</cite> and returns m." },  { "module": "math",  "name": "round",  "code": "proc round*(x: float): int {.importc: \"lrint\", header: \"<math.h>\".}",  "desc": "converts a float to an int by rounding.  " },  { "module": "math",  "name": "arccos",  "code": "proc arccos*(x: float): float {.importc: \"acos\", header: \"<math.h>\".}" },  { "module": "math",  "name": "arcsin",  "code": "proc arcsin*(x: float): float {.importc: \"asin\", header: \"<math.h>\".}" },  { "module": "math",  "name": "arctan",  "code": "proc arctan*(x: float): float {.importc: \"atan\", header: \"<math.h>\".}" },  { "module": "math",  "name": "arctan2",  "code": "proc arctan2*(y, x: float): float {.importc: \"atan2\", header: \"<math.h>\".}",  "desc": "Calculate the arc tangent of <cite>y</cite> / <cite>x</cite>. <cite>atan2</cite> returns the arc tangent of <cite>y</cite> / <cite>x</cite>; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (<cite>x</cite> near 0)." },  { "module": "math",  "name": "cos",  "code": "proc cos*(x: float): float {.importc: \"cos\", header: \"<math.h>\".}" },  { "module": "math",  "name": "cosh",  "code": "proc cosh*(x: float): float {.importc: \"cosh\", header: \"<math.h>\".}" },  { "module": "math",  "name": "hypot",  "code": "proc hypot*(x, y: float): float {.importc: \"hypot\", header: \"<math.h>\".}",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">sqrt(x*x + y*y)</span></tt>." },  { "module": "math",  "name": "sinh",  "code": "proc sinh*(x: float): float {.importc: \"sinh\", header: \"<math.h>\".}" },  { "module": "math",  "name": "sin",  "code": "proc sin*(x: float): float {.importc: \"sin\", header: \"<math.h>\".}" },  { "module": "math",  "name": "tan",  "code": "proc tan*(x: float): float {.importc: \"tan\", header: \"<math.h>\".}" },  { "module": "math",  "name": "tanh",  "code": "proc tanh*(x: float): float {.importc: \"tanh\", header: \"<math.h>\".}" },  { "module": "math",  "name": "pow",  "code": "proc pow*(x, y: float): float {.importc: \"pow\", header: \"<math.h>\".}",  "desc": "computes x to power raised of y." },  { "module": "math",  "name": "trunc",  "code": "proc trunc*(x: float): float {.importc: \"trunc\", header: \"<math.h>\".}" },  { "module": "math",  "name": "floor",  "code": "proc floor*(x: float): float {.importc: \"floor\", header: \"<math.h>\".}" },  { "module": "math",  "name": "ceil",  "code": "proc ceil*(x: float): float {.importc: \"ceil\", header: \"<math.h>\".}" },  { "module": "math",  "name": "fmod",  "code": "proc fmod*(x, y: float): float {.importc: \"fmod\", header: \"<math.h>\".}" },  { "module": "math",  "name": "`mod`",  "code": "proc `mod`*(x, y: float): float" },  { "module": "math",  "name": "random",  "code": "proc random*[T](x: Slice[T]): T",  "desc": "For a slice <cite>a .. b</cite> returns a value in the range <cite>a .. b-1</cite>." },  { "module": "math",  "name": "push",  "code": "proc push*(s: var RunningStat; x: float)",  "desc": "pushes a value <cite>x</cite> for processing" },  { "module": "math",  "name": "push",  "code": "proc push*(s: var RunningStat; x: int)",  "desc": "pushes a value <cite>x</cite> for processing. <cite>x</cite> is simply converted to <tt class=\"docutils literal\"><span class=\"pre\">float</span></tt> and the other push operation is called." },  { "module": "math",  "name": "variance",  "code": "proc variance*(s: RunningStat): float",  "desc": "computes the current variance of <cite>s</cite>" },  { "module": "math",  "name": "standardDeviation",  "code": "proc standardDeviation*(s: RunningStat): float",  "desc": "computes the current standard deviation of <cite>s</cite>" },  { "module": "md5",  "name": "md5Init",  "code": "proc md5Init*(c: var MD5Context)",  "desc": "initializes a MD5Context  " },  { "module": "md5",  "name": "md5Update",  "code": "proc md5Update*(c: var MD5Context; input: cstring; len: int)",  "desc": "updates the MD5Context with the <cite>input</cite> data of length <cite>len</cite>" },  { "module": "md5",  "name": "md5Final",  "code": "proc md5Final*(c: var MD5Context; digest: var MD5Digest)",  "desc": "finishes the MD5Context and stores the result in <cite>digest</cite>" },  { "module": "md5",  "name": "toMD5",  "code": "proc toMD5*(s: string): MD5Digest",  "desc": "computes the MD5Digest value for a string <cite>s</cite>" },  { "module": "md5",  "name": "`$`",  "code": "proc `$`*(D: MD5Digest): string",  "desc": "converts a MD5Digest value into its string representation" },  { "module": "md5",  "name": "getMD5",  "code": "proc getMD5*(s: string): string",  "desc": "computes an MD5 value of <cite>s</cite> and returns its string representation" },  { "module": "md5",  "name": "`==`",  "code": "proc `==`*(D1, D2: MD5Digest): bool",  "desc": "checks if two MD5Digest values are identical" },  { "module": "memfiles",  "name": "mapMem",  "code": "proc mapMem*(m: var MemFile; mode: FileMode = fmRead; mappedSize = - 1; \u000A             offset = 0): pointer" },  { "module": "memfiles",  "name": "unmapMem",  "code": "proc unmapMem*(f: var MemFile; p: pointer; size: int)",  "desc": "unmaps the memory region <tt class=\"docutils literal\"><span class=\"pre\">(p, &lt;p+size)</span></tt> of the mapped file <cite>f</cite>. All changes are written back to the file system, if <cite>f</cite> was opened with write access. <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> must be of exactly the size that was requested via <tt class=\"docutils literal\"><span class=\"pre\">mapMem</span></tt>." },  { "module": "memfiles",  "name": "open",  "code": "proc open*(filename: string; mode: FileMode = fmRead; mappedSize = - 1; \u000A           offset = 0; newFileSize = - 1): MemFile",  "desc": "opens a memory mapped file. If this fails, <tt class=\"docutils literal\"><span class=\"pre\">EOS</span></tt> is raised. <cite>newFileSize</cite> can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite). <cite>mappedSize</cite> and <cite>offset</cite> can be used to map only a slice of the file. Example:<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">mm</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mm_full</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mm_half</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">MemFile</span>\u000A\u000A<span class=\"Identifier\">mm</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">memfiles</span><span class=\"Operator\">.</span><span class=\"Identifier\">open</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/tmp/test.mmap&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mode</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">fmWrite</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">newFileSize</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">1024</span><span class=\"Punctuation\">)</span>    <span class=\"Comment\"># Create a new file</span>\u000A<span class=\"Identifier\">mm</span><span class=\"Operator\">.</span><span class=\"Identifier\">close</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Comment\"># Read the whole file, would fail if newFileSize was set</span>\u000A<span class=\"Identifier\">mm_full</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">memfiles</span><span class=\"Operator\">.</span><span class=\"Identifier\">open</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/tmp/test.mmap&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mode</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">fmReadWrite</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mappedSize</span> <span class=\"Operator\">=</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Comment\"># Read the first 512 bytes</span>\u000A<span class=\"Identifier\">mm_half</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">memfiles</span><span class=\"Operator\">.</span><span class=\"Identifier\">open</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/tmp/test.mmap&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mode</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">fmReadWrite</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">mappedSize</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">512</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "memfiles",  "name": "close",  "code": "proc close*(f: var MemFile)",  "desc": "closes the memory mapped file <cite>f</cite>. All changes are written back to the file system, if <cite>f</cite> was opened with write access." },  { "module": "mersenne",  "name": "newMersenneTwister",  "code": "proc newMersenneTwister*(seed: int): MersenneTwister" },  { "module": "mersenne",  "name": "getNum",  "code": "proc getNum*(m: var MersenneTwister): int" },  { "module": "mimetypes",  "name": "newMimetypes",  "code": "proc newMimetypes*(): MimeDB",  "desc": "Creates a new Mimetypes database. The database will contain the most common mimetypes." },  { "module": "mimetypes",  "name": "getMimetype",  "code": "proc getMimetype*(mimedb: MimeDB; ext: string; default = \"text/plain\"): string",  "desc": "Gets mimetype which corresponds to <tt class=\"docutils literal\"><span class=\"pre\">ext</span></tt>. Returns <tt class=\"docutils literal\"><span class=\"pre\">default</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">ext</span></tt> could not be found." },  { "module": "mimetypes",  "name": "getExt",  "code": "proc getExt*(mimedb: MimeDB; mimetype: string; default = \"txt\"): string",  "desc": "Gets extension which corresponds to <tt class=\"docutils literal\"><span class=\"pre\">mimetype</span></tt>. Returns <tt class=\"docutils literal\"><span class=\"pre\">default</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">mimetype</span></tt> could not be found. Extensions are returned without the leading dot." },  { "module": "mimetypes",  "name": "register",  "code": "proc register*(mimedb: var MimeDB; ext: string; mimetype: string)",  "desc": "Adds <tt class=\"docutils literal\"><span class=\"pre\">mimetype</span></tt> to the <tt class=\"docutils literal\"><span class=\"pre\">mimedb</span></tt>." },  { "module": "mmsystem",  "name": "sndPlaySoundA",  "code": "proc sndPlaySoundA*(Name: LPCSTR; flags: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"sndPlaySoundA\".}" },  { "module": "mmsystem",  "name": "sndPlaySoundW",  "code": "proc sndPlaySoundW*(Name: LPCWSTR; flags: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"sndPlaySoundW\".}" },  { "module": "mmsystem",  "name": "sndPlaySound",  "code": "proc sndPlaySound*(Name: cstring; flags: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"sndPlaySoundW\".}" },  { "module": "mmsystem",  "name": "MEVT_EVENTTYPE",  "code": "proc MEVT_EVENTTYPE*(x: int8): int8" },  { "module": "mmsystem",  "name": "MEVT_EVENTPARM",  "code": "proc MEVT_EVENTPARM*(x: DWORD): DWORD" },  { "module": "mmsystem",  "name": "MCI_MSF_MINUTE",  "code": "proc MCI_MSF_MINUTE*(msf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_MSF_SECOND",  "code": "proc MCI_MSF_SECOND*(msf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_MSF_FRAME",  "code": "proc MCI_MSF_FRAME*(msf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_MAKE_MSF",  "code": "proc MCI_MAKE_MSF*(m, s, f: int8): int32" },  { "module": "mmsystem",  "name": "MCI_TMSF_TRACK",  "code": "proc MCI_TMSF_TRACK*(tmsf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_TMSF_MINUTE",  "code": "proc MCI_TMSF_MINUTE*(tmsf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_TMSF_SECOND",  "code": "proc MCI_TMSF_SECOND*(tmsf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_TMSF_FRAME",  "code": "proc MCI_TMSF_FRAME*(tmsf: int32): int8" },  { "module": "mmsystem",  "name": "MCI_HMS_HOUR",  "code": "proc MCI_HMS_HOUR*(h: int32): int8" },  { "module": "mmsystem",  "name": "MCI_HMS_MINUTE",  "code": "proc MCI_HMS_MINUTE*(h: int32): int8" },  { "module": "mmsystem",  "name": "MCI_HMS_SECOND",  "code": "proc MCI_HMS_SECOND*(h: int32): int8" },  { "module": "mmsystem",  "name": "MCI_MAKE_HMS",  "code": "proc MCI_MAKE_HMS*(h, m, s: int8): int32" },  { "module": "mmsystem",  "name": "MCI_MAKE_TMSF",  "code": "proc MCI_MAKE_TMSF*(t, m, s, f: int8): int32" },  { "module": "mmsystem",  "name": "DIBINDEX",  "code": "proc DIBINDEX*(n: int32): int32" },  { "module": "mmsystem",  "name": "mixerGetNumDevs",  "code": "proc mixerGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                  importc: \"mixerGetNumDevs\".}" },  { "module": "mmsystem",  "name": "mmioStringToFOURCCA",  "code": "proc mmioStringToFOURCCA*(x1: LPCSTR; x2: uint32): FOURCC {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioStringToFOURCCA\".}" },  { "module": "mmsystem",  "name": "mmioStringToFOURCCW",  "code": "proc mmioStringToFOURCCW*(x1: LPCWSTR; x2: uint32): FOURCC {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioStringToFOURCCW\".}" },  { "module": "mmsystem",  "name": "mmioStringToFOURCC",  "code": "proc mmioStringToFOURCC*(x1: cstring; x2: uint32): FOURCC {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioStringToFOURCCA\".}" },  { "module": "mmsystem",  "name": "mmioInstallIOProcA",  "code": "proc mmioInstallIOProcA*(x1: FOURCC; x2: LPMMIOPROC; x3: DWORD): LPMMIOPROC {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioInstallIOProcA\".}" },  { "module": "mmsystem",  "name": "mmioInstallIOProcW",  "code": "proc mmioInstallIOProcW*(x1: FOURCC; x2: LPMMIOPROC; x3: DWORD): LPMMIOPROC {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioInstallIOProcW\".}" },  { "module": "mmsystem",  "name": "mmioInstallIOProc",  "code": "proc mmioInstallIOProc*(x1: FOURCC; x2: LPMMIOPROC; x3: DWORD): LPMMIOPROC {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioInstallIOProcA\".}" },  { "module": "mmsystem",  "name": "mmioOpenA",  "code": "proc mmioOpenA*(x1: LPSTR; x2: LPMMIOINFO; x3: DWORD): HMMIO {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioOpenA\".}" },  { "module": "mmsystem",  "name": "mmioOpenW",  "code": "proc mmioOpenW*(x1: LPWSTR; x2: LPMMIOINFO; x3: DWORD): HMMIO {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioOpenW\".}" },  { "module": "mmsystem",  "name": "mmioOpen",  "code": "proc mmioOpen*(x1: cstring; x2: LPMMIOINFO; x3: DWORD): HMMIO {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioOpenA\".}" },  { "module": "mmsystem",  "name": "mmioRenameA",  "code": "proc mmioRenameA*(x1: LPCSTR; x2: LPCSTR; x3: LPCMMIOINFO; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioRenameA\".}" },  { "module": "mmsystem",  "name": "mmioRenameW",  "code": "proc mmioRenameW*(x1: LPCWSTR; x2: LPCWSTR; x3: LPCMMIOINFO; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioRenameW\".}" },  { "module": "mmsystem",  "name": "mmioRename",  "code": "proc mmioRename*(x1: cstring; x2: cstring; x3: LPCMMIOINFO; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioRenameA\".}" },  { "module": "mmsystem",  "name": "mmioClose",  "code": "proc mmioClose*(x1: HMMIO; x2: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mmioClose\".}" },  { "module": "mmsystem",  "name": "mmioRead",  "code": "proc mmioRead*(x1: HMMIO; x2: HPSTR; x3: LONG): LONG {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioRead\".}" },  { "module": "mmsystem",  "name": "mmioWrite",  "code": "proc mmioWrite*(x1: HMMIO; x2: cstring; x3: LONG): LONG {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioWrite\".}" },  { "module": "mmsystem",  "name": "mmioSeek",  "code": "proc mmioSeek*(x1: HMMIO; x2: LONG; x3: WINT): LONG {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioSeek\".}" },  { "module": "mmsystem",  "name": "mmioGetInfo",  "code": "proc mmioGetInfo*(x1: HMMIO; x2: LPMMIOINFO; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioGetInfo\".}" },  { "module": "mmsystem",  "name": "mmioSetInfo",  "code": "proc mmioSetInfo*(x1: HMMIO; x2: LPCMMIOINFO; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioSetInfo\".}" },  { "module": "mmsystem",  "name": "mmioSetBuffer",  "code": "proc mmioSetBuffer*(x1: HMMIO; x2: LPSTR; x3: LONG; x4: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioSetBuffer\".}" },  { "module": "mmsystem",  "name": "mmioFlush",  "code": "proc mmioFlush*(x1: HMMIO; x2: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mmioFlush\".}" },  { "module": "mmsystem",  "name": "mmioAdvance",  "code": "proc mmioAdvance*(x1: HMMIO; x2: LPMMIOINFO; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioAdvance\".}" },  { "module": "mmsystem",  "name": "mmioSendMessage",  "code": "proc mmioSendMessage*(x1: HMMIO; x2: uint32; x3: LPARAM; x4: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioSendMessage\".}" },  { "module": "mmsystem",  "name": "mmioDescend",  "code": "proc mmioDescend*(x1: HMMIO; x2: LPMMCKINFO; x3: PMMCKINFO; x4: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioDescend\".}" },  { "module": "mmsystem",  "name": "mmioAscend",  "code": "proc mmioAscend*(x1: HMMIO; x2: LPMMCKINFO; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mmioAscend\".}" },  { "module": "mmsystem",  "name": "mmioCreateChunk",  "code": "proc mmioCreateChunk*(x1: HMMIO; x2: LPMMCKINFO; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mmioCreateChunk\".}" },  { "module": "mmsystem",  "name": "mciSendCommandA",  "code": "proc mciSendCommandA*(x1: MCIDEVICEID; x2: uint32; x3: DWORD; x4: DWORD): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendCommandA\".}" },  { "module": "mmsystem",  "name": "mciSendCommandW",  "code": "proc mciSendCommandW*(x1: MCIDEVICEID; x2: uint32; x3: DWORD; x4: DWORD): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendCommandW\".}" },  { "module": "mmsystem",  "name": "mciSendCommand",  "code": "proc mciSendCommand*(x1: MCIDEVICEID; x2: uint32; x3: DWORD; x4: DWORD): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendCommandA\".}" },  { "module": "mmsystem",  "name": "mciSendStringA",  "code": "proc mciSendStringA*(x1: LPCSTR; x2: LPSTR; x3: uint32; x4: HWND): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendStringA\".}" },  { "module": "mmsystem",  "name": "mciSendStringW",  "code": "proc mciSendStringW*(x1: LPCWSTR; x2: LPWSTR; x3: uint32; x4: HWND): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendStringW\".}" },  { "module": "mmsystem",  "name": "mciSendString",  "code": "proc mciSendString*(x1: cstring; x2: cstring; x3: uint32; x4: HWND): MCIERROR {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSendStringA\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceIDA",  "code": "proc mciGetDeviceIDA*(x1: LPCSTR): MCIDEVICEID {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mciGetDeviceIDA\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceIDW",  "code": "proc mciGetDeviceIDW*(x1: LPCWSTR): MCIDEVICEID {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mciGetDeviceIDW\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceID",  "code": "proc mciGetDeviceID*(x1: cstring): MCIDEVICEID {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mciGetDeviceIDA\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceIDFromElementIDA",  "code": "proc mciGetDeviceIDFromElementIDA*(x1: DWORD; x2: LPCSTR): MCIDEVICEID {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciGetDeviceIDFromElementIDA\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceIDFromElementIDW",  "code": "proc mciGetDeviceIDFromElementIDW*(x1: DWORD; x2: LPCWSTR): MCIDEVICEID {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciGetDeviceIDFromElementIDW\".}" },  { "module": "mmsystem",  "name": "mciGetDeviceIDFromElementID",  "code": "proc mciGetDeviceIDFromElementID*(x1: DWORD; x2: cstring): MCIDEVICEID {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciGetDeviceIDFromElementIDA\".}" },  { "module": "mmsystem",  "name": "mciGetErrorStringA",  "code": "proc mciGetErrorStringA*(x1: MCIERROR; x2: LPSTR; x3: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mciGetErrorStringA\".}" },  { "module": "mmsystem",  "name": "mciGetErrorStringW",  "code": "proc mciGetErrorStringW*(x1: MCIERROR; x2: LPWSTR; x3: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mciGetErrorStringW\".}" },  { "module": "mmsystem",  "name": "mciGetErrorString",  "code": "proc mciGetErrorString*(x1: MCIERROR; x2: cstring; x3: uint32): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mciGetErrorStringA\".}" },  { "module": "mmsystem",  "name": "mciSetYieldProc",  "code": "proc mciSetYieldProc*(x1: MCIDEVICEID; x2: YIELDPROC; x3: DWORD): bool {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mciSetYieldProc\".}" },  { "module": "mmsystem",  "name": "mciGetCreatorTask",  "code": "proc mciGetCreatorTask*(x1: MCIDEVICEID): HTASK {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mciGetCreatorTask\".}" },  { "module": "mmsystem",  "name": "mciGetYieldProc",  "code": "proc mciGetYieldProc*(x1: MCIDEVICEID; x2: LPDWORD): YIELDPROC {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mciGetYieldProc\".}" },  { "module": "mmsystem",  "name": "mciExecute",  "code": "proc mciExecute*(x1: LPCSTR): bool {.stdcall, dynlib: \"winmm.dll\", \u000A                                     importc: \"mciExecute\".}" },  { "module": "mmsystem",  "name": "joyGetPos",  "code": "proc joyGetPos*(x1: uint32; x2: LPJOYINFO): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"joyGetPos\".}" },  { "module": "mmsystem",  "name": "joyGetPosEx",  "code": "proc joyGetPosEx*(x1: uint32; x2: LPJOYINFOEX): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"joyGetPosEx\".}" },  { "module": "mmsystem",  "name": "joyGetThreshold",  "code": "proc joyGetThreshold*(x1: uint32; x2: LPUINT): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"joyGetThreshold\".}" },  { "module": "mmsystem",  "name": "joyReleaseCapture",  "code": "proc joyReleaseCapture*(x1: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"joyReleaseCapture\".}" },  { "module": "mmsystem",  "name": "joySetCapture",  "code": "proc joySetCapture*(x1: HWND; x2: uint32; x3: uint32; x4: bool): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"joySetCapture\".}" },  { "module": "mmsystem",  "name": "joySetThreshold",  "code": "proc joySetThreshold*(x1: uint32; x2: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"joySetThreshold\".}" },  { "module": "mmsystem",  "name": "waveOutGetNumDevs",  "code": "proc waveOutGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                    importc: \"waveOutGetNumDevs\".}" },  { "module": "mmsystem",  "name": "waveOutGetDevCapsA",  "code": "proc waveOutGetDevCapsA*(x1: uint32; x2: LPWAVEOUTCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "waveOutGetDevCapsW",  "code": "proc waveOutGetDevCapsW*(x1: uint32; x2: LPWAVEOUTCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "waveOutGetDevCaps",  "code": "proc waveOutGetDevCaps*(x1: uint32; x2: LPWAVEOUTCAPS; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "waveOutGetVolume",  "code": "proc waveOutGetVolume*(x1: HWAVEOUT; x2: LPDWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutGetVolume\".}" },  { "module": "mmsystem",  "name": "waveOutSetVolume",  "code": "proc waveOutSetVolume*(x1: HWAVEOUT; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutSetVolume\".}" },  { "module": "mmsystem",  "name": "waveOutGetErrorTextA",  "code": "proc waveOutGetErrorTextA*(x1: MMRESULT; x2: LPSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "waveOutGetErrorTextW",  "code": "proc waveOutGetErrorTextW*(x1: MMRESULT; x2: LPWSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetErrorTextW\".}" },  { "module": "mmsystem",  "name": "waveOutGetErrorText",  "code": "proc waveOutGetErrorText*(x1: MMRESULT; x2: cstring; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "waveOutOpen",  "code": "proc waveOutOpen*(x1: LPHWAVEOUT; x2: uint32; x3: LPCWAVEFORMATEX; x4: DWORD; \u000A                  x5: DWORD; x6: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutOpen\".}" },  { "module": "mmsystem",  "name": "waveOutClose",  "code": "proc waveOutClose*(x1: HWAVEOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveOutClose\".}" },  { "module": "mmsystem",  "name": "waveOutPrepareHeader",  "code": "proc waveOutPrepareHeader*(x1: HWAVEOUT; x2: LPWAVEHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutPrepareHeader\".}" },  { "module": "mmsystem",  "name": "waveOutUnprepareHeader",  "code": "proc waveOutUnprepareHeader*(x1: HWAVEOUT; x2: LPWAVEHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutUnprepareHeader\".}" },  { "module": "mmsystem",  "name": "waveOutWrite",  "code": "proc waveOutWrite*(x1: HWAVEOUT; x2: LPWAVEHDR; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutWrite\".}" },  { "module": "mmsystem",  "name": "waveOutPause",  "code": "proc waveOutPause*(x1: HWAVEOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveOutPause\".}" },  { "module": "mmsystem",  "name": "waveOutRestart",  "code": "proc waveOutRestart*(x1: HWAVEOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveOutRestart\".}" },  { "module": "mmsystem",  "name": "waveOutReset",  "code": "proc waveOutReset*(x1: HWAVEOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveOutReset\".}" },  { "module": "mmsystem",  "name": "waveOutBreakLoop",  "code": "proc waveOutBreakLoop*(x1: HWAVEOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveOutBreakLoop\".}" },  { "module": "mmsystem",  "name": "waveOutGetPosition",  "code": "proc waveOutGetPosition*(x1: HWAVEOUT; x2: LPMMTIME; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutGetPosition\".}" },  { "module": "mmsystem",  "name": "waveOutGetPitch",  "code": "proc waveOutGetPitch*(x1: HWAVEOUT; x2: LPDWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutGetPitch\".}" },  { "module": "mmsystem",  "name": "waveOutSetPitch",  "code": "proc waveOutSetPitch*(x1: HWAVEOUT; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutSetPitch\".}" },  { "module": "mmsystem",  "name": "waveOutGetPlaybackRate",  "code": "proc waveOutGetPlaybackRate*(x1: HWAVEOUT; x2: LPDWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutGetPlaybackRate\".}" },  { "module": "mmsystem",  "name": "waveOutSetPlaybackRate",  "code": "proc waveOutSetPlaybackRate*(x1: HWAVEOUT; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutSetPlaybackRate\".}" },  { "module": "mmsystem",  "name": "waveOutGetID",  "code": "proc waveOutGetID*(x1: HWAVEOUT; x2: LPUINT): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveOutGetID\".}" },  { "module": "mmsystem",  "name": "waveOutMessage",  "code": "proc waveOutMessage*(x1: HWAVEOUT; x2: uint32; x3: DWORD; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveOutMessage\".}" },  { "module": "mmsystem",  "name": "waveInGetNumDevs",  "code": "proc waveInGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                   importc: \"waveInGetNumDevs\".}" },  { "module": "mmsystem",  "name": "waveInGetDevCapsA",  "code": "proc waveInGetDevCapsA*(x1: uint32; x2: LPWAVEINCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "waveInGetDevCapsW",  "code": "proc waveInGetDevCapsW*(x1: uint32; x2: LPWAVEINCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "waveInGetDevCaps",  "code": "proc waveInGetDevCaps*(x1: uint32; x2: LPWAVEINCAPS; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "waveInGetErrorTextA",  "code": "proc waveInGetErrorTextA*(x1: MMRESULT; x2: LPSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "waveInGetErrorTextW",  "code": "proc waveInGetErrorTextW*(x1: MMRESULT; x2: LPWSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetErrorTextW\".}" },  { "module": "mmsystem",  "name": "waveInGetErrorText",  "code": "proc waveInGetErrorText*(x1: MMRESULT; x2: cstring; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "waveInOpen",  "code": "proc waveInOpen*(x1: LPHWAVEIN; x2: uint32; x3: LPCWAVEFORMATEX; x4: DWORD; \u000A                 x5: DWORD; x6: DWORD): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveInOpen\".}" },  { "module": "mmsystem",  "name": "waveInClose",  "code": "proc waveInClose*(x1: HWAVEIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveInClose\".}" },  { "module": "mmsystem",  "name": "waveInPrepareHeader",  "code": "proc waveInPrepareHeader*(x1: HWAVEIN; x2: LPWAVEHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInPrepareHeader\".}" },  { "module": "mmsystem",  "name": "waveInUnprepareHeader",  "code": "proc waveInUnprepareHeader*(x1: HWAVEIN; x2: LPWAVEHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInUnprepareHeader\".}" },  { "module": "mmsystem",  "name": "waveInAddBuffer",  "code": "proc waveInAddBuffer*(x1: HWAVEIN; x2: LPWAVEHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInAddBuffer\".}" },  { "module": "mmsystem",  "name": "waveInStart",  "code": "proc waveInStart*(x1: HWAVEIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveInStart\".}" },  { "module": "mmsystem",  "name": "waveInStop",  "code": "proc waveInStop*(x1: HWAVEIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveInStop\".}" },  { "module": "mmsystem",  "name": "waveInReset",  "code": "proc waveInReset*(x1: HWAVEIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"waveInReset\".}" },  { "module": "mmsystem",  "name": "waveInGetPosition",  "code": "proc waveInGetPosition*(x1: HWAVEIN; x2: LPMMTIME; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInGetPosition\".}" },  { "module": "mmsystem",  "name": "waveInGetID",  "code": "proc waveInGetID*(x1: HWAVEIN; x2: LPUINT): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"waveInGetID\".}" },  { "module": "mmsystem",  "name": "waveInMessage",  "code": "proc waveInMessage*(x1: HWAVEIN; x2: uint32; x3: DWORD; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"waveInMessage\".}" },  { "module": "mmsystem",  "name": "mixerGetLineControlsA",  "code": "proc mixerGetLineControlsA*(x1: HMIXEROBJ; x2: LPMIXERLINECONTROLSA; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineControlsA\".}" },  { "module": "mmsystem",  "name": "mixerGetLineControlsW",  "code": "proc mixerGetLineControlsW*(x1: HMIXEROBJ; x2: LPMIXERLINECONTROLSW; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineControlsW\".}" },  { "module": "mmsystem",  "name": "mixerGetLineControls",  "code": "proc mixerGetLineControls*(x1: HMIXEROBJ; x2: LPMIXERLINECONTROLS; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineControlsA\".}" },  { "module": "mmsystem",  "name": "joyGetNumDevs",  "code": "proc joyGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                importc: \"joyGetNumDevs\".}" },  { "module": "mmsystem",  "name": "joyGetDevCapsA",  "code": "proc joyGetDevCapsA*(x1: uint32; x2: LPJOYCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"joyGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "joyGetDevCapsW",  "code": "proc joyGetDevCapsW*(x1: uint32; x2: LPJOYCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"joyGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "joyGetDevCaps",  "code": "proc joyGetDevCaps*(x1: uint32; x2: LPJOYCAPS; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"joyGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "mixerGetControlDetailsA",  "code": "proc mixerGetControlDetailsA*(x1: HMIXEROBJ; x2: LPMIXERCONTROLDETAILS; \u000A                              x3: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mixerGetControlDetailsA\".}" },  { "module": "mmsystem",  "name": "mixerGetControlDetailsW",  "code": "proc mixerGetControlDetailsW*(x1: HMIXEROBJ; x2: LPMIXERCONTROLDETAILS; \u000A                              x3: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mixerGetControlDetailsW\".}" },  { "module": "mmsystem",  "name": "mixerGetControlDetails",  "code": "proc mixerGetControlDetails*(x1: HMIXEROBJ; x2: LPMIXERCONTROLDETAILS; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetControlDetailsA\".}" },  { "module": "mmsystem",  "name": "timeGetSystemTime",  "code": "proc timeGetSystemTime*(x1: LPMMTIME; x2: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"timeGetSystemTime\".}" },  { "module": "mmsystem",  "name": "timeGetTime",  "code": "proc timeGetTime*(): DWORD {.stdcall, dynlib: \"winmm.dll\", \u000A                             importc: \"timeGetTime\".}" },  { "module": "mmsystem",  "name": "timeSetEvent",  "code": "proc timeSetEvent*(x1: uint32; x2: uint32; x3: LPTIMECALLBACK; x4: DWORD; \u000A                   x5: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"timeSetEvent\".}" },  { "module": "mmsystem",  "name": "timeKillEvent",  "code": "proc timeKillEvent*(x1: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"timeKillEvent\".}" },  { "module": "mmsystem",  "name": "timeGetDevCaps",  "code": "proc timeGetDevCaps*(x1: LPTIMECAPS; x2: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"timeGetDevCaps\".}" },  { "module": "mmsystem",  "name": "timeBeginPeriod",  "code": "proc timeBeginPeriod*(x1: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"timeBeginPeriod\".}" },  { "module": "mmsystem",  "name": "timeEndPeriod",  "code": "proc timeEndPeriod*(x1: uint32): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"timeEndPeriod\".}" },  { "module": "mmsystem",  "name": "mixerGetDevCapsA",  "code": "proc mixerGetDevCapsA*(x1: uint32; x2: LPMIXERCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "mixerGetDevCapsW",  "code": "proc mixerGetDevCapsW*(x1: uint32; x2: LPMIXERCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "mixerGetDevCaps",  "code": "proc mixerGetDevCaps*(x1: uint32; x2: LPMIXERCAPS; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "mixerOpen",  "code": "proc mixerOpen*(x1: LPHMIXER; x2: uint32; x3: DWORD; x4: DWORD; x5: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerOpen\".}" },  { "module": "mmsystem",  "name": "mixerClose",  "code": "proc mixerClose*(x1: HMIXER): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"mixerClose\".}" },  { "module": "mmsystem",  "name": "mixerMessage",  "code": "proc mixerMessage*(x1: HMIXER; x2: uint32; x3: DWORD; x4: DWORD): DWORD {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerMessage\".}" },  { "module": "mmsystem",  "name": "auxGetNumDevs",  "code": "proc auxGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                importc: \"auxGetNumDevs\".}" },  { "module": "mmsystem",  "name": "auxGetDevCapsA",  "code": "proc auxGetDevCapsA*(x1: uint32; x2: LPAUXCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"auxGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "auxGetDevCapsW",  "code": "proc auxGetDevCapsW*(x1: uint32; x2: LPAUXCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"auxGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "auxGetDevCaps",  "code": "proc auxGetDevCaps*(x1: uint32; x2: LPAUXCAPS; x3: uint32): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"auxGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "auxSetVolume",  "code": "proc auxSetVolume*(x1: uint32; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"auxSetVolume\".}" },  { "module": "mmsystem",  "name": "auxGetVolume",  "code": "proc auxGetVolume*(x1: uint32; x2: LPDWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"auxGetVolume\".}" },  { "module": "mmsystem",  "name": "auxOutMessage",  "code": "proc auxOutMessage*(x1: uint32; x2: uint32; x3: DWORD; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"auxOutMessage\".}" },  { "module": "mmsystem",  "name": "midiOutGetNumDevs",  "code": "proc midiOutGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                    importc: \"midiOutGetNumDevs\".}" },  { "module": "mmsystem",  "name": "midiStreamOpen",  "code": "proc midiStreamOpen*(x1: LPHMIDISTRM; x2: LPUINT; x3: DWORD; x4: DWORD; \u000A                     x5: DWORD; x6: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiStreamOpen\".}" },  { "module": "mmsystem",  "name": "midiStreamClose",  "code": "proc midiStreamClose*(x1: HMIDISTRM): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiStreamClose\".}" },  { "module": "mmsystem",  "name": "midiStreamProperty",  "code": "proc midiStreamProperty*(x1: HMIDISTRM; x2: LPBYTE; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiStreamProperty\".}" },  { "module": "mmsystem",  "name": "midiStreamPosition",  "code": "proc midiStreamPosition*(x1: HMIDISTRM; x2: LPMMTIME; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiStreamPosition\".}" },  { "module": "mmsystem",  "name": "midiStreamOut",  "code": "proc midiStreamOut*(x1: HMIDISTRM; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiStreamOut\".}" },  { "module": "mmsystem",  "name": "midiStreamPause",  "code": "proc midiStreamPause*(x1: HMIDISTRM): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiStreamPause\".}" },  { "module": "mmsystem",  "name": "midiStreamRestart",  "code": "proc midiStreamRestart*(x1: HMIDISTRM): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiStreamRestart\".}" },  { "module": "mmsystem",  "name": "midiStreamStop",  "code": "proc midiStreamStop*(x1: HMIDISTRM): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiStreamStop\".}" },  { "module": "mmsystem",  "name": "midiConnect",  "code": "proc midiConnect*(x1: HMIDI; x2: HMIDIOUT; x3: pointer): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiConnect\".}" },  { "module": "mmsystem",  "name": "midiDisconnect",  "code": "proc midiDisconnect*(x1: HMIDI; x2: HMIDIOUT; x3: pointer): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiDisconnect\".}" },  { "module": "mmsystem",  "name": "midiOutGetDevCapsA",  "code": "proc midiOutGetDevCapsA*(x1: uint32; x2: LPMIDIOUTCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "midiOutGetDevCapsW",  "code": "proc midiOutGetDevCapsW*(x1: uint32; x2: LPMIDIOUTCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "midiOutGetDevCaps",  "code": "proc midiOutGetDevCaps*(x1: uint32; x2: LPMIDIOUTCAPS; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "midiOutGetVolume",  "code": "proc midiOutGetVolume*(x1: HMIDIOUT; x2: LPDWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiOutGetVolume\".}" },  { "module": "mmsystem",  "name": "midiOutSetVolume",  "code": "proc midiOutSetVolume*(x1: HMIDIOUT; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiOutSetVolume\".}" },  { "module": "mmsystem",  "name": "midiOutGetErrorTextA",  "code": "proc midiOutGetErrorTextA*(x1: MMRESULT; x2: LPSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "midiOutGetErrorTextW",  "code": "proc midiOutGetErrorTextW*(x1: MMRESULT; x2: LPWSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetErrorTextW\".}" },  { "module": "mmsystem",  "name": "midiOutGetErrorText",  "code": "proc midiOutGetErrorText*(x1: MMRESULT; x2: cstring; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "midiOutOpen",  "code": "proc midiOutOpen*(x1: LPHMIDIOUT; x2: uint32; x3: DWORD; x4: DWORD; x5: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutOpen\".}" },  { "module": "mmsystem",  "name": "midiOutClose",  "code": "proc midiOutClose*(x1: HMIDIOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiOutClose\".}" },  { "module": "mmsystem",  "name": "midiOutPrepareHeader",  "code": "proc midiOutPrepareHeader*(x1: HMIDIOUT; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutPrepareHeader\".}" },  { "module": "mmsystem",  "name": "midiOutUnprepareHeader",  "code": "proc midiOutUnprepareHeader*(x1: HMIDIOUT; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutUnprepareHeader\".}" },  { "module": "mmsystem",  "name": "midiOutShortMsg",  "code": "proc midiOutShortMsg*(x1: HMIDIOUT; x2: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiOutShortMsg\".}" },  { "module": "mmsystem",  "name": "midiOutLongMsg",  "code": "proc midiOutLongMsg*(x1: HMIDIOUT; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutLongMsg\".}" },  { "module": "mmsystem",  "name": "midiOutReset",  "code": "proc midiOutReset*(x1: HMIDIOUT): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiOutReset\".}" },  { "module": "mmsystem",  "name": "midiOutCachePatches",  "code": "proc midiOutCachePatches*(x1: HMIDIOUT; x2: uint32; x3: LPWORD; x4: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutCachePatches\".}" },  { "module": "mmsystem",  "name": "midiOutCacheDrumPatches",  "code": "proc midiOutCacheDrumPatches*(x1: HMIDIOUT; x2: uint32; x3: LPWORD; x4: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutCacheDrumPatches\".}" },  { "module": "mmsystem",  "name": "midiOutGetID",  "code": "proc midiOutGetID*(x1: HMIDIOUT; x2: LPUINT): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiOutGetID\".}" },  { "module": "mmsystem",  "name": "midiOutMessage",  "code": "proc midiOutMessage*(x1: HMIDIOUT; x2: uint32; x3: DWORD; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiOutMessage\".}" },  { "module": "mmsystem",  "name": "midiInGetNumDevs",  "code": "proc midiInGetNumDevs*(): uint32 {.stdcall, dynlib: \"winmm.dll\", \u000A                                   importc: \"midiInGetNumDevs\".}" },  { "module": "mmsystem",  "name": "midiInGetDevCapsA",  "code": "proc midiInGetDevCapsA*(x1: uint32; x2: LPMIDIINCAPSA; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "midiInGetDevCapsW",  "code": "proc midiInGetDevCapsW*(x1: uint32; x2: LPMIDIINCAPSW; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetDevCapsW\".}" },  { "module": "mmsystem",  "name": "midiInGetDevCaps",  "code": "proc midiInGetDevCaps*(x1: uint32; x2: LPMIDIINCAPS; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetDevCapsA\".}" },  { "module": "mmsystem",  "name": "midiInGetErrorTextA",  "code": "proc midiInGetErrorTextA*(x1: MMRESULT; x2: LPSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "midiInGetErrorTextW",  "code": "proc midiInGetErrorTextW*(x1: MMRESULT; x2: LPWSTR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetErrorTextW\".}" },  { "module": "mmsystem",  "name": "midiInGetErrorText",  "code": "proc midiInGetErrorText*(x1: MMRESULT; x2: cstring; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInGetErrorTextA\".}" },  { "module": "mmsystem",  "name": "midiInOpen",  "code": "proc midiInOpen*(x1: LPHMIDIIN; x2: uint32; x3: DWORD; x4: DWORD; x5: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInOpen\".}" },  { "module": "mmsystem",  "name": "midiInClose",  "code": "proc midiInClose*(x1: HMIDIIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiInClose\".}" },  { "module": "mmsystem",  "name": "midiInPrepareHeader",  "code": "proc midiInPrepareHeader*(x1: HMIDIIN; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInPrepareHeader\".}" },  { "module": "mmsystem",  "name": "midiInUnprepareHeader",  "code": "proc midiInUnprepareHeader*(x1: HMIDIIN; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInUnprepareHeader\".}" },  { "module": "mmsystem",  "name": "midiInAddBuffer",  "code": "proc midiInAddBuffer*(x1: HMIDIIN; x2: LPMIDIHDR; x3: uint32): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInAddBuffer\".}" },  { "module": "mmsystem",  "name": "midiInStart",  "code": "proc midiInStart*(x1: HMIDIIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiInStart\".}" },  { "module": "mmsystem",  "name": "midiInStop",  "code": "proc midiInStop*(x1: HMIDIIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiInStop\".}" },  { "module": "mmsystem",  "name": "midiInReset",  "code": "proc midiInReset*(x1: HMIDIIN): MMRESULT {.stdcall, dynlib: \"winmm.dll\", \u000A    importc: \"midiInReset\".}" },  { "module": "mmsystem",  "name": "midiInGetID",  "code": "proc midiInGetID*(x1: HMIDIIN; x2: LPUINT): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"midiInGetID\".}" },  { "module": "mmsystem",  "name": "midiInMessage",  "code": "proc midiInMessage*(x1: HMIDIIN; x2: uint32; x3: DWORD; x4: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"midiInMessage\".}" },  { "module": "mmsystem",  "name": "mixerGetLineInfoA",  "code": "proc mixerGetLineInfoA*(x1: HMIXEROBJ; x2: LPMIXERLINEA; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineInfoA\".}" },  { "module": "mmsystem",  "name": "mixerGetLineInfoW",  "code": "proc mixerGetLineInfoW*(x1: HMIXEROBJ; x2: LPMIXERLINEW; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineInfoW\".}" },  { "module": "mmsystem",  "name": "mixerGetLineInfo",  "code": "proc mixerGetLineInfo*(x1: HMIXEROBJ; x2: LPMIXERLINE; x3: DWORD): MMRESULT {.\u000A    stdcall, dynlib: \"winmm.dll\", importc: \"mixerGetLineInfoA\".}" },  { "module": "mmsystem",  "name": "mixerGetID",  "code": "proc mixerGetID*(x1: HMIXEROBJ; x2: var uint32; x3: DWORD): MMRESULT {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"mixerGetID\".}" },  { "module": "mmsystem",  "name": "PlaySoundA",  "code": "proc PlaySoundA*(x1: LPCSTR; x2: HMODULE; x3: DWORD): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"PlaySoundA\".}" },  { "module": "mmsystem",  "name": "PlaySoundW",  "code": "proc PlaySoundW*(x1: LPCWSTR; x2: HMODULE; x3: DWORD): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"PlaySoundW\".}" },  { "module": "mmsystem",  "name": "PlaySound",  "code": "proc PlaySound*(x1: cstring; x2: HMODULE; x3: DWORD): bool {.stdcall, \u000A    dynlib: \"winmm.dll\", importc: \"PlaySoundA\".}" },  { "module": "mysql",  "name": "my_net_init",  "code": "proc my_net_init*(net: PNET; vio: PVio): my_bool {.cdecl, dynlib: lib, \u000A    importc: \"my_net_init\".}" },  { "module": "mysql",  "name": "my_net_local_init",  "code": "proc my_net_local_init*(net: PNET) {.cdecl, dynlib: lib, \u000A                                     importc: \"my_net_local_init\".}" },  { "module": "mysql",  "name": "net_end",  "code": "proc net_end*(net: PNET) {.cdecl, dynlib: lib, importc: \"net_end\".}" },  { "module": "mysql",  "name": "net_clear",  "code": "proc net_clear*(net: PNET) {.cdecl, dynlib: lib, importc: \"net_clear\".}" },  { "module": "mysql",  "name": "net_realloc",  "code": "proc net_realloc*(net: PNET; len: int): my_bool {.cdecl, dynlib: lib, \u000A    importc: \"net_realloc\".}" },  { "module": "mysql",  "name": "net_flush",  "code": "proc net_flush*(net: PNET): my_bool {.cdecl, dynlib: lib, importc: \"net_flush\".}" },  { "module": "mysql",  "name": "my_net_write",  "code": "proc my_net_write*(net: PNET; packet: cstring; length: int): my_bool {.cdecl, \u000A    dynlib: lib, importc: \"my_net_write\".}" },  { "module": "mysql",  "name": "net_write_command",  "code": "proc net_write_command*(net: PNET; command: char; header: cstring; \u000A                        head_len: int; packet: cstring; length: int): my_bool {.\u000A    cdecl, dynlib: lib, importc: \"net_write_command\".}" },  { "module": "mysql",  "name": "net_real_write",  "code": "proc net_real_write*(net: PNET; packet: cstring; length: int): cint {.cdecl, \u000A    dynlib: lib, importc: \"net_real_write\".}" },  { "module": "mysql",  "name": "my_net_read",  "code": "proc my_net_read*(net: PNET): int {.cdecl, dynlib: lib, importc: \"my_net_read\".}" },  { "module": "mysql",  "name": "my_connect",  "code": "proc my_connect*(s: my_socket; name: Psockaddr; namelen: cuint; timeout: cuint): cint {.\u000A    cdecl, dynlib: lib, importc: \"my_connect\".}" },  { "module": "mysql",  "name": "randominit",  "code": "proc randominit*(para1: Prand_struct; seed1: int; seed2: int) {.cdecl, \u000A    dynlib: lib, importc: \"randominit\".}" },  { "module": "mysql",  "name": "my_rnd",  "code": "proc my_rnd*(para1: Prand_struct): cdouble {.cdecl, dynlib: lib, \u000A    importc: \"my_rnd\".}" },  { "module": "mysql",  "name": "create_random_string",  "code": "proc create_random_string*(fto: cstring; len: cuint; rand_st: Prand_struct) {.\u000A    cdecl, dynlib: lib, importc: \"create_random_string\".}" },  { "module": "mysql",  "name": "hash_password",  "code": "proc hash_password*(fto: int; password: cstring; password_len: cuint) {.cdecl, \u000A    dynlib: lib, importc: \"hash_password\".}" },  { "module": "mysql",  "name": "make_scrambled_password_323",  "code": "proc make_scrambled_password_323*(fto: cstring; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"make_scrambled_password_323\".}" },  { "module": "mysql",  "name": "scramble_323",  "code": "proc scramble_323*(fto: cstring; message: cstring; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"scramble_323\".}" },  { "module": "mysql",  "name": "check_scramble_323",  "code": "proc check_scramble_323*(para1: cstring; message: cstring; salt: int): my_bool {.\u000A    cdecl, dynlib: lib, importc: \"check_scramble_323\".}" },  { "module": "mysql",  "name": "get_salt_from_password_323",  "code": "proc get_salt_from_password_323*(res: ptr int; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"get_salt_from_password_323\".}" },  { "module": "mysql",  "name": "make_password_from_salt_323",  "code": "proc make_password_from_salt_323*(fto: cstring; salt: ptr int) {.cdecl, \u000A    dynlib: lib, importc: \"make_password_from_salt_323\".}" },  { "module": "mysql",  "name": "octet2hex",  "code": "proc octet2hex*(fto: cstring; str: cstring; length: cuint): cstring {.cdecl, \u000A    dynlib: lib, importc: \"octet2hex\".}" },  { "module": "mysql",  "name": "make_scrambled_password",  "code": "proc make_scrambled_password*(fto: cstring; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"make_scrambled_password\".}" },  { "module": "mysql",  "name": "scramble",  "code": "proc scramble*(fto: cstring; message: cstring; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"scramble\".}" },  { "module": "mysql",  "name": "check_scramble",  "code": "proc check_scramble*(reply: cstring; message: cstring; hash_stage2: pointer): my_bool {.\u000A    cdecl, dynlib: lib, importc: \"check_scramble\".}" },  { "module": "mysql",  "name": "get_salt_from_password",  "code": "proc get_salt_from_password*(res: pointer; password: cstring) {.cdecl, \u000A    dynlib: lib, importc: \"get_salt_from_password\".}" },  { "module": "mysql",  "name": "make_password_from_salt",  "code": "proc make_password_from_salt*(fto: cstring; hash_stage2: pointer) {.cdecl, \u000A    dynlib: lib, importc: \"make_password_from_salt\".}" },  { "module": "mysql",  "name": "get_tty_password",  "code": "proc get_tty_password*(opt_message: cstring): cstring {.cdecl, dynlib: lib, \u000A    importc: \"get_tty_password\".}" },  { "module": "mysql",  "name": "errno_to_sqlstate",  "code": "proc errno_to_sqlstate*(errno: cuint): cstring {.cdecl, dynlib: lib, \u000A    importc: \"mysql_errno_to_sqlstate\".}" },  { "module": "mysql",  "name": "modify_defaults_file",  "code": "proc modify_defaults_file*(file_location: cstring; option: cstring; \u000A                           option_value: cstring; section_name: cstring; \u000A                           remove_option: cint): cint {.cdecl, dynlib: lib, \u000A    importc: \"load_defaults\".}" },  { "module": "mysql",  "name": "load_defaults",  "code": "proc load_defaults*(conf_file: cstring; groups: cstringArray; argc: ptr cint; \u000A                    argv: ptr cstringArray): cint {.cdecl, dynlib: lib, \u000A    importc: \"load_defaults\".}" },  { "module": "mysql",  "name": "my_init",  "code": "proc my_init*(): my_bool {.cdecl, dynlib: lib, importc: \"my_init\".}" },  { "module": "mysql",  "name": "my_thread_init",  "code": "proc my_thread_init*(): my_bool {.cdecl, dynlib: lib, importc: \"my_thread_init\".}" },  { "module": "mysql",  "name": "my_thread_end",  "code": "proc my_thread_end*() {.cdecl, dynlib: lib, importc: \"my_thread_end\".}" },  { "module": "mysql",  "name": "IS_PRI_KEY",  "code": "proc IS_PRI_KEY*(n: int32): bool" },  { "module": "mysql",  "name": "IS_NOT_NULL",  "code": "proc IS_NOT_NULL*(n: int32): bool" },  { "module": "mysql",  "name": "IS_BLOB",  "code": "proc IS_BLOB*(n: int32): bool" },  { "module": "mysql",  "name": "IS_NUM",  "code": "proc IS_NUM*(t: Tenum_field_types): bool" },  { "module": "mysql",  "name": "INTERNAL_NUM_FIELD",  "code": "proc INTERNAL_NUM_FIELD*(f: Pst_mysql_field): bool" },  { "module": "mysql",  "name": "IS_NUM_FIELD",  "code": "proc IS_NUM_FIELD*(f: Pst_mysql_field): bool" },  { "module": "mysql",  "name": "server_init",  "code": "proc server_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.\u000A    cdecl, dynlib: lib, importc: \"mysql_server_init\".}" },  { "module": "mysql",  "name": "server_end",  "code": "proc server_end*() {.cdecl, dynlib: lib, importc: \"mysql_server_end\".}" },  { "module": "mysql",  "name": "library_init",  "code": "proc library_init*(argc: cint; argv: cstringArray; groups: cstringArray): cint {.\u000A    cdecl, dynlib: lib, importc: \"mysql_server_init\".}" },  { "module": "mysql",  "name": "library_end",  "code": "proc library_end*() {.cdecl, dynlib: lib, importc: \"mysql_server_end\".}" },  { "module": "mysql",  "name": "get_parameters",  "code": "proc get_parameters*(): PPARAMETERS {.stdcall, dynlib: lib, \u000A                                      importc: \"mysql_get_parameters\".}" },  { "module": "mysql",  "name": "thread_init",  "code": "proc thread_init*(): my_bool {.stdcall, dynlib: lib, \u000A                               importc: \"mysql_thread_init\".}" },  { "module": "mysql",  "name": "thread_end",  "code": "proc thread_end*() {.stdcall, dynlib: lib, importc: \"mysql_thread_end\".}" },  { "module": "mysql",  "name": "num_rows",  "code": "proc num_rows*(res: PRES): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_num_rows\".}" },  { "module": "mysql",  "name": "num_fields",  "code": "proc num_fields*(res: PRES): cuint {.stdcall, dynlib: lib, \u000A                                     importc: \"mysql_num_fields\".}" },  { "module": "mysql",  "name": "eof",  "code": "proc eof*(res: PRES): my_bool {.stdcall, dynlib: lib, importc: \"mysql_eof\".}" },  { "module": "mysql",  "name": "fetch_field_direct",  "code": "proc fetch_field_direct*(res: PRES; fieldnr: cuint): PFIELD {.stdcall, \u000A    dynlib: lib, importc: \"mysql_fetch_field_direct\".}" },  { "module": "mysql",  "name": "fetch_fields",  "code": "proc fetch_fields*(res: PRES): PFIELD {.stdcall, dynlib: lib, \u000A                                        importc: \"mysql_fetch_fields\".}" },  { "module": "mysql",  "name": "row_tell",  "code": "proc row_tell*(res: PRES): TROW_OFFSET {.stdcall, dynlib: lib, \u000A    importc: \"mysql_row_tell\".}" },  { "module": "mysql",  "name": "field_tell",  "code": "proc field_tell*(res: PRES): TFIELD_OFFSET {.stdcall, dynlib: lib, \u000A    importc: \"mysql_field_tell\".}" },  { "module": "mysql",  "name": "field_count",  "code": "proc field_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_field_count\".}" },  { "module": "mysql",  "name": "affected_rows",  "code": "proc affected_rows*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_affected_rows\".}" },  { "module": "mysql",  "name": "insert_id",  "code": "proc insert_id*(MySQL: PMySQL): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_insert_id\".}" },  { "module": "mysql",  "name": "errno",  "code": "proc errno*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, importc: \"mysql_errno\".}" },  { "module": "mysql",  "name": "error",  "code": "proc error*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, \u000A                                      importc: \"mysql_error\".}" },  { "module": "mysql",  "name": "sqlstate",  "code": "proc sqlstate*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_sqlstate\".}" },  { "module": "mysql",  "name": "warning_count",  "code": "proc warning_count*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_warning_count\".}" },  { "module": "mysql",  "name": "info",  "code": "proc info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: \"mysql_info\".}" },  { "module": "mysql",  "name": "thread_id",  "code": "proc thread_id*(MySQL: PMySQL): int {.stdcall, dynlib: lib, \u000A                                      importc: \"mysql_thread_id\".}" },  { "module": "mysql",  "name": "character_set_name",  "code": "proc character_set_name*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_character_set_name\".}" },  { "module": "mysql",  "name": "set_character_set",  "code": "proc set_character_set*(MySQL: PMySQL; csname: cstring): int32 {.stdcall, \u000A    dynlib: lib, importc: \"mysql_set_character_set\".}" },  { "module": "mysql",  "name": "init",  "code": "proc init*(MySQL: PMySQL): PMySQL {.stdcall, dynlib: lib, importc: \"mysql_init\".}" },  { "module": "mysql",  "name": "ssl_set",  "code": "proc ssl_set*(MySQL: PMySQL; key: cstring; cert: cstring; ca: cstring; \u000A              capath: cstring; cipher: cstring): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_ssl_set\".}" },  { "module": "mysql",  "name": "change_user",  "code": "proc change_user*(MySQL: PMySQL; user: cstring; passwd: cstring; db: cstring): my_bool {.\u000A    stdcall, dynlib: lib, importc: \"mysql_change_user\".}" },  { "module": "mysql",  "name": "real_connect",  "code": "proc real_connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring; \u000A                   db: cstring; port: cuint; unix_socket: cstring; \u000A                   clientflag: int): PMySQL {.stdcall, dynlib: lib, \u000A    importc: \"mysql_real_connect\".}" },  { "module": "mysql",  "name": "select_db",  "code": "proc select_db*(MySQL: PMySQL; db: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_select_db\".}" },  { "module": "mysql",  "name": "query",  "code": "proc query*(MySQL: PMySQL; q: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_query\".}" },  { "module": "mysql",  "name": "send_query",  "code": "proc send_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, \u000A    dynlib: lib, importc: \"mysql_send_query\".}" },  { "module": "mysql",  "name": "real_query",  "code": "proc real_query*(MySQL: PMySQL; q: cstring; len: int): cint {.stdcall, \u000A    dynlib: lib, importc: \"mysql_real_query\".}" },  { "module": "mysql",  "name": "store_result",  "code": "proc store_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_store_result\".}" },  { "module": "mysql",  "name": "use_result",  "code": "proc use_result*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib, \u000A                                        importc: \"mysql_use_result\".}" },  { "module": "mysql",  "name": "master_query",  "code": "proc master_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, \u000A    dynlib: lib, importc: \"mysql_master_query\".}" },  { "module": "mysql",  "name": "master_send_query",  "code": "proc master_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, \u000A    dynlib: lib, importc: \"mysql_master_send_query\".}" },  { "module": "mysql",  "name": "slave_query",  "code": "proc slave_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, \u000A    dynlib: lib, importc: \"mysql_slave_query\".}" },  { "module": "mysql",  "name": "slave_send_query",  "code": "proc slave_send_query*(MySQL: PMySQL; q: cstring; len: int): my_bool {.stdcall, \u000A    dynlib: lib, importc: \"mysql_slave_send_query\".}" },  { "module": "mysql",  "name": "get_character_set_info",  "code": "proc get_character_set_info*(MySQL: PMySQL; charset: PMY_CHARSET_INFO) {.\u000A    stdcall, dynlib: lib, importc: \"mysql_get_character_set_info\".}" },  { "module": "mysql",  "name": "set_local_infile_default",  "code": "proc set_local_infile_default*(MySQL: PMySQL) {.cdecl, dynlib: lib, \u000A    importc: \"mysql_set_local_infile_default\".}" },  { "module": "mysql",  "name": "enable_rpl_parse",  "code": "proc enable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib, \u000A                                        importc: \"mysql_enable_rpl_parse\".}" },  { "module": "mysql",  "name": "disable_rpl_parse",  "code": "proc disable_rpl_parse*(MySQL: PMySQL) {.stdcall, dynlib: lib, \u000A    importc: \"mysql_disable_rpl_parse\".}" },  { "module": "mysql",  "name": "rpl_parse_enabled",  "code": "proc rpl_parse_enabled*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_rpl_parse_enabled\".}" },  { "module": "mysql",  "name": "enable_reads_from_master",  "code": "proc enable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib, \u000A    importc: \"mysql_enable_reads_from_master\".}" },  { "module": "mysql",  "name": "disable_reads_from_master",  "code": "proc disable_reads_from_master*(MySQL: PMySQL) {.stdcall, dynlib: lib, \u000A    importc: \"mysql_disable_reads_from_master\".}" },  { "module": "mysql",  "name": "reads_from_master_enabled",  "code": "proc reads_from_master_enabled*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_reads_from_master_enabled\".}" },  { "module": "mysql",  "name": "rpl_query_type",  "code": "proc rpl_query_type*(q: cstring; length: cint): Trpl_type {.stdcall, \u000A    dynlib: lib, importc: \"mysql_rpl_query_type\".}" },  { "module": "mysql",  "name": "rpl_probe",  "code": "proc rpl_probe*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_rpl_probe\".}" },  { "module": "mysql",  "name": "set_master",  "code": "proc set_master*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring; \u000A                 passwd: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_set_master\".}" },  { "module": "mysql",  "name": "add_slave",  "code": "proc add_slave*(MySQL: PMySQL; host: cstring; port: cuint; user: cstring; \u000A                passwd: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_add_slave\".}" },  { "module": "mysql",  "name": "shutdown",  "code": "proc shutdown*(MySQL: PMySQL; shutdown_level: Tenum_shutdown_level): cint {.\u000A    stdcall, dynlib: lib, importc: \"mysql_shutdown\".}" },  { "module": "mysql",  "name": "dump_debug_info",  "code": "proc dump_debug_info*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_dump_debug_info\".}" },  { "module": "mysql",  "name": "refresh",  "code": "proc refresh*(sql: PMySQL; refresh_options: cuint): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_refresh\".}" },  { "module": "mysql",  "name": "kill",  "code": "proc kill*(MySQL: PMySQL; pid: int): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_kill\".}" },  { "module": "mysql",  "name": "set_server_option",  "code": "proc set_server_option*(MySQL: PMySQL; option: Tenum_mysql_set_option): cint {.\u000A    stdcall, dynlib: lib, importc: \"mysql_set_server_option\".}" },  { "module": "mysql",  "name": "ping",  "code": "proc ping*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, importc: \"mysql_ping\".}" },  { "module": "mysql",  "name": "stat",  "code": "proc stat*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, importc: \"mysql_stat\".}" },  { "module": "mysql",  "name": "get_server_info",  "code": "proc get_server_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_get_server_info\".}" },  { "module": "mysql",  "name": "get_client_info",  "code": "proc get_client_info*(): cstring {.stdcall, dynlib: lib, \u000A                                   importc: \"mysql_get_client_info\".}" },  { "module": "mysql",  "name": "get_client_version",  "code": "proc get_client_version*(): int {.stdcall, dynlib: lib, \u000A                                  importc: \"mysql_get_client_version\".}" },  { "module": "mysql",  "name": "get_host_info",  "code": "proc get_host_info*(MySQL: PMySQL): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_get_host_info\".}" },  { "module": "mysql",  "name": "get_server_version",  "code": "proc get_server_version*(MySQL: PMySQL): int {.stdcall, dynlib: lib, \u000A    importc: \"mysql_get_server_version\".}" },  { "module": "mysql",  "name": "get_proto_info",  "code": "proc get_proto_info*(MySQL: PMySQL): cuint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_get_proto_info\".}" },  { "module": "mysql",  "name": "list_dbs",  "code": "proc list_dbs*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_list_dbs\".}" },  { "module": "mysql",  "name": "list_tables",  "code": "proc list_tables*(MySQL: PMySQL; wild: cstring): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_list_tables\".}" },  { "module": "mysql",  "name": "list_processes",  "code": "proc list_processes*(MySQL: PMySQL): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_list_processes\".}" },  { "module": "mysql",  "name": "options",  "code": "proc options*(MySQL: PMySQL; option: Toption; arg: cstring): cint {.stdcall, \u000A    dynlib: lib, importc: \"mysql_options\".}" },  { "module": "mysql",  "name": "free_result",  "code": "proc free_result*(result: PRES) {.stdcall, dynlib: lib, \u000A                                  importc: \"mysql_free_result\".}" },  { "module": "mysql",  "name": "data_seek",  "code": "proc data_seek*(result: PRES; offset: my_ulonglong) {.stdcall, dynlib: lib, \u000A    importc: \"mysql_data_seek\".}" },  { "module": "mysql",  "name": "row_seek",  "code": "proc row_seek*(result: PRES; offset: TROW_OFFSET): TROW_OFFSET {.stdcall, \u000A    dynlib: lib, importc: \"mysql_row_seek\".}" },  { "module": "mysql",  "name": "field_seek",  "code": "proc field_seek*(result: PRES; offset: TFIELD_OFFSET): TFIELD_OFFSET {.stdcall, \u000A    dynlib: lib, importc: \"mysql_field_seek\".}" },  { "module": "mysql",  "name": "fetch_row",  "code": "proc fetch_row*(result: PRES): TROW {.stdcall, dynlib: lib, \u000A                                      importc: \"mysql_fetch_row\".}" },  { "module": "mysql",  "name": "fetch_lengths",  "code": "proc fetch_lengths*(result: PRES): ptr int {.stdcall, dynlib: lib, \u000A    importc: \"mysql_fetch_lengths\".}" },  { "module": "mysql",  "name": "fetch_field",  "code": "proc fetch_field*(result: PRES): PFIELD {.stdcall, dynlib: lib, \u000A    importc: \"mysql_fetch_field\".}" },  { "module": "mysql",  "name": "list_fields",  "code": "proc list_fields*(MySQL: PMySQL; table: cstring; wild: cstring): PRES {.stdcall, \u000A    dynlib: lib, importc: \"mysql_list_fields\".}" },  { "module": "mysql",  "name": "escape_string",  "code": "proc escape_string*(fto: cstring; `from`: cstring; from_length: int): int {.\u000A    stdcall, dynlib: lib, importc: \"mysql_escape_string\".}" },  { "module": "mysql",  "name": "hex_string",  "code": "proc hex_string*(fto: cstring; `from`: cstring; from_length: int): int {.\u000A    stdcall, dynlib: lib, importc: \"mysql_hex_string\".}" },  { "module": "mysql",  "name": "real_escape_string",  "code": "proc real_escape_string*(MySQL: PMySQL; fto: cstring; `from`: cstring; len: int): int {.\u000A    stdcall, dynlib: lib, importc: \"mysql_real_escape_string\".}" },  { "module": "mysql",  "name": "debug",  "code": "proc debug*(debug: cstring) {.stdcall, dynlib: lib, importc: \"mysql_debug\".}" },  { "module": "mysql",  "name": "myodbc_remove_escape",  "code": "proc myodbc_remove_escape*(MySQL: PMySQL; name: cstring) {.stdcall, dynlib: lib, \u000A    importc: \"myodbc_remove_escape\".}" },  { "module": "mysql",  "name": "thread_safe",  "code": "proc thread_safe*(): cuint {.stdcall, dynlib: lib, importc: \"mysql_thread_safe\".}" },  { "module": "mysql",  "name": "embedded",  "code": "proc embedded*(): my_bool {.stdcall, dynlib: lib, importc: \"mysql_embedded\".}" },  { "module": "mysql",  "name": "manager_init",  "code": "proc manager_init*(con: PMANAGER): PMANAGER {.stdcall, dynlib: lib, \u000A    importc: \"mysql_manager_init\".}" },  { "module": "mysql",  "name": "manager_connect",  "code": "proc manager_connect*(con: PMANAGER; host: cstring; user: cstring; \u000A                      passwd: cstring; port: cuint): PMANAGER {.stdcall, \u000A    dynlib: lib, importc: \"mysql_manager_connect\".}" },  { "module": "mysql",  "name": "manager_close",  "code": "proc manager_close*(con: PMANAGER) {.stdcall, dynlib: lib, \u000A                                     importc: \"mysql_manager_close\".}" },  { "module": "mysql",  "name": "manager_command",  "code": "proc manager_command*(con: PMANAGER; cmd: cstring; cmd_len: cint): cint {.\u000A    stdcall, dynlib: lib, importc: \"mysql_manager_command\".}" },  { "module": "mysql",  "name": "manager_fetch_line",  "code": "proc manager_fetch_line*(con: PMANAGER; res_buf: cstring; res_buf_size: cint): cint {.\u000A    stdcall, dynlib: lib, importc: \"mysql_manager_fetch_line\".}" },  { "module": "mysql",  "name": "read_query_result",  "code": "proc read_query_result*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_read_query_result\".}" },  { "module": "mysql",  "name": "stmt_init",  "code": "proc stmt_init*(MySQL: PMySQL): PSTMT {.stdcall, dynlib: lib, \u000A                                        importc: \"mysql_stmt_init\".}" },  { "module": "mysql",  "name": "stmt_prepare",  "code": "proc stmt_prepare*(stmt: PSTMT; query: cstring; len: int): cint {.stdcall, \u000A    dynlib: lib, importc: \"mysql_stmt_prepare\".}" },  { "module": "mysql",  "name": "stmt_execute",  "code": "proc stmt_execute*(stmt: PSTMT): cint {.stdcall, dynlib: lib, \u000A                                        importc: \"mysql_stmt_execute\".}" },  { "module": "mysql",  "name": "stmt_fetch",  "code": "proc stmt_fetch*(stmt: PSTMT): cint {.stdcall, dynlib: lib, \u000A                                      importc: \"mysql_stmt_fetch\".}" },  { "module": "mysql",  "name": "stmt_fetch_column",  "code": "proc stmt_fetch_column*(stmt: PSTMT; `bind`: PBIND; column: cuint; offset: int): cint {.\u000A    stdcall, dynlib: lib, importc: \"mysql_stmt_fetch_column\".}" },  { "module": "mysql",  "name": "stmt_store_result",  "code": "proc stmt_store_result*(stmt: PSTMT): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_store_result\".}" },  { "module": "mysql",  "name": "stmt_param_count",  "code": "proc stmt_param_count*(stmt: PSTMT): int {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_param_count\".}" },  { "module": "mysql",  "name": "stmt_attr_set",  "code": "proc stmt_attr_set*(stmt: PSTMT; attr_type: Tenum_stmt_attr_type; attr: pointer): my_bool {.\u000A    stdcall, dynlib: lib, importc: \"mysql_stmt_attr_set\".}" },  { "module": "mysql",  "name": "stmt_attr_get",  "code": "proc stmt_attr_get*(stmt: PSTMT; attr_type: Tenum_stmt_attr_type; attr: pointer): my_bool {.\u000A    stdcall, dynlib: lib, importc: \"mysql_stmt_attr_get\".}" },  { "module": "mysql",  "name": "stmt_bind_param",  "code": "proc stmt_bind_param*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_bind_param\".}" },  { "module": "mysql",  "name": "stmt_bind_result",  "code": "proc stmt_bind_result*(stmt: PSTMT; bnd: PBIND): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_bind_result\".}" },  { "module": "mysql",  "name": "stmt_close",  "code": "proc stmt_close*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_close\".}" },  { "module": "mysql",  "name": "stmt_reset",  "code": "proc stmt_reset*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_reset\".}" },  { "module": "mysql",  "name": "stmt_free_result",  "code": "proc stmt_free_result*(stmt: PSTMT): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_free_result\".}" },  { "module": "mysql",  "name": "stmt_send_long_data",  "code": "proc stmt_send_long_data*(stmt: PSTMT; param_number: cuint; data: cstring; \u000A                          len: int): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_send_long_data\".}" },  { "module": "mysql",  "name": "stmt_result_metadata",  "code": "proc stmt_result_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_result_metadata\".}" },  { "module": "mysql",  "name": "stmt_param_metadata",  "code": "proc stmt_param_metadata*(stmt: PSTMT): PRES {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_param_metadata\".}" },  { "module": "mysql",  "name": "stmt_errno",  "code": "proc stmt_errno*(stmt: PSTMT): cuint {.stdcall, dynlib: lib, \u000A                                       importc: \"mysql_stmt_errno\".}" },  { "module": "mysql",  "name": "stmt_error",  "code": "proc stmt_error*(stmt: PSTMT): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_error\".}" },  { "module": "mysql",  "name": "stmt_sqlstate",  "code": "proc stmt_sqlstate*(stmt: PSTMT): cstring {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_sqlstate\".}" },  { "module": "mysql",  "name": "stmt_row_seek",  "code": "proc stmt_row_seek*(stmt: PSTMT; offset: TROW_OFFSET): TROW_OFFSET {.stdcall, \u000A    dynlib: lib, importc: \"mysql_stmt_row_seek\".}" },  { "module": "mysql",  "name": "stmt_row_tell",  "code": "proc stmt_row_tell*(stmt: PSTMT): TROW_OFFSET {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_row_tell\".}" },  { "module": "mysql",  "name": "stmt_data_seek",  "code": "proc stmt_data_seek*(stmt: PSTMT; offset: my_ulonglong) {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_data_seek\".}" },  { "module": "mysql",  "name": "stmt_num_rows",  "code": "proc stmt_num_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_num_rows\".}" },  { "module": "mysql",  "name": "stmt_affected_rows",  "code": "proc stmt_affected_rows*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_affected_rows\".}" },  { "module": "mysql",  "name": "stmt_insert_id",  "code": "proc stmt_insert_id*(stmt: PSTMT): my_ulonglong {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_insert_id\".}" },  { "module": "mysql",  "name": "stmt_field_count",  "code": "proc stmt_field_count*(stmt: PSTMT): cuint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_stmt_field_count\".}" },  { "module": "mysql",  "name": "commit",  "code": "proc commit*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A                                       importc: \"mysql_commit\".}" },  { "module": "mysql",  "name": "rollback",  "code": "proc rollback*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_rollback\".}" },  { "module": "mysql",  "name": "autocommit",  "code": "proc autocommit*(MySQL: PMySQL; auto_mode: my_bool): my_bool {.stdcall, \u000A    dynlib: lib, importc: \"mysql_autocommit\".}" },  { "module": "mysql",  "name": "more_results",  "code": "proc more_results*(MySQL: PMySQL): my_bool {.stdcall, dynlib: lib, \u000A    importc: \"mysql_more_results\".}" },  { "module": "mysql",  "name": "next_result",  "code": "proc next_result*(MySQL: PMySQL): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_next_result\".}" },  { "module": "mysql",  "name": "close",  "code": "proc close*(sock: PMySQL) {.stdcall, dynlib: lib, importc: \"mysql_close\".}" },  { "module": "mysql",  "name": "reload",  "code": "proc reload*(x: PMySQL): cint" },  { "module": "mysql",  "name": "connect",  "code": "proc connect*(MySQL: PMySQL; host: cstring; user: cstring; passwd: cstring): PMySQL {.\u000A    stdcall, dynlib: lib, importc: \"mysql_connect\".}" },  { "module": "mysql",  "name": "create_db",  "code": "proc create_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_create_db\".}" },  { "module": "mysql",  "name": "drop_db",  "code": "proc drop_db*(MySQL: PMySQL; DB: cstring): cint {.stdcall, dynlib: lib, \u000A    importc: \"mysql_drop_db\".}" },  { "module": "mysql",  "name": "net_safe_read",  "code": "proc net_safe_read*(MySQL: PMySQL): cuint {.cdecl, dynlib: lib, \u000A    importc: \"net_safe_read\".}" },  { "module": "nb30",  "name": "Netbios",  "code": "proc Netbios*(P: PNCB): char {.stdcall, dynlib: \"netapi32.dll\", \u000A                               importc: \"Netbios\".}" },  { "module": "net",  "name": "isDisconnectionError",  "code": "proc isDisconnectionError*(flags: set[SocketFlag]; lastError: OSErrorCode): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">lastError</span></tt> is a disconnection error. Only does this if flags contains <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt>." },  { "module": "net",  "name": "toOSFlags",  "code": "proc toOSFlags*(socketFlags: set[SocketFlag]): cint",  "desc": "Converts the flags into the underlying OS representation." },  { "module": "net",  "name": "newSocket",  "code": "proc newSocket*(domain, typ, protocol: cint; buffered = true): Socket",  "desc": "<p>Creates a new socket.</p>\u000A<p>If an error occurs EOS will be raised.</p>\u000A" },  { "module": "net",  "name": "newSocket",  "code": "proc newSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A                protocol: Protocol = IPPROTO_TCP; buffered = true): Socket",  "desc": "<p>Creates a new socket.</p>\u000A<p>If an error occurs EOS will be raised.</p>\u000A" },  { "module": "net",  "name": "raiseSSLError",  "code": "proc raiseSSLError*(s = \"\")",  "desc": "Raises a new SSL error." },  { "module": "net",  "name": "newContext",  "code": "proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; \u000A                 certFile = \"\"; keyFile = \"\"): SSLContext",  "desc": "<p>Creates an SSL context.</p>\u000A<p>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of <tt class=\"docutils literal\"><span class=\"pre\">protSSLv23</span></tt> which allows for compatibility with all of them.</p>\u000A<p>There are currently only two options for verify mode; one is <tt class=\"docutils literal\"><span class=\"pre\">CVerifyNone</span></tt> and with it certificates will not be verified the other is <tt class=\"docutils literal\"><span class=\"pre\">CVerifyPeer</span></tt> and certificates will be verified for it, <tt class=\"docutils literal\"><span class=\"pre\">CVerifyPeer</span></tt> is the safest choice.</p>\u000A<p>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: <tt class=\"docutils literal\"><span class=\"pre\">openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</span></tt>.</p>\u000A" },  { "module": "net",  "name": "wrapSocket",  "code": "proc wrapSocket*(ctx: SSLContext; socket: Socket)",  "desc": "<p>Wraps a socket in an SSL context. This function effectively turns <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> into an SSL socket.</p>\u000A<p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p>\u000A" },  { "module": "net",  "name": "socketError",  "code": "proc socketError*(socket: Socket; err: int = - 1; async = false; \u000A                  lastError = (- 1).OSErrorCode)",  "desc": "<p>Raises an OSError based on the error code returned by <tt class=\"docutils literal\"><span class=\"pre\">SSLGetError</span></tt> (for SSL sockets) and <tt class=\"docutils literal\"><span class=\"pre\">osLastError</span></tt> otherwise.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> no error will be thrown in the case when the error was caused by no data being available to be read.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">err</span></tt> is not lower than 0 no exception will be raised.</p>\u000A" },  { "module": "net",  "name": "listen",  "code": "proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}",  "desc": "<p>Marks <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> as accepting connections. <tt class=\"docutils literal\"><span class=\"pre\">Backlog</span></tt> specifies the maximum length of the queue of pending connections.</p>\u000A<p>Raises an EOS error upon failure.</p>\u000A" },  { "module": "net",  "name": "bindAddr",  "code": "proc bindAddr*(socket: Socket; port = Port(0); address = \"\") {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Binds <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>:<tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> to the socket.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> is &quot;&quot; then ADDR_ANY will be bound.</p>\u000A" },  { "module": "net",  "name": "acceptAddr",  "code": "proc acceptAddr*(server: Socket; client: var Socket; address: var string; \u000A                 flags = {SocketFlag.SafeDisconn}) {.tags: [ReadIOEffect].}",  "desc": "<p>Blocks until a connection is being made from a client. When a connection is made sets <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> to the client socket and <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> to the address of the connecting client. This function will raise EOS if an error occurs.</p>\u000A<p>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> must be initialised (with <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt>), this function makes no effort to initialise the <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> variable.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt> call may result in an error if the connecting socket disconnects during the duration of the <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt>. If the <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt> flag is specified then this error will not be raised and instead accept will be called again.</p>\u000A" },  { "module": "net",  "name": "accept",  "code": "proc accept*(server: Socket; client: var Socket; \u000A             flags = {SocketFlag.SafeDisconn}) {.tags: [ReadIOEffect].}",  "desc": "<p>Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">acceptAddr</span></tt> but doesn't return the address, only the socket.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> must be initialised (with <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt>), this function makes no effort to initialise the <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> variable.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt> call may result in an error if the connecting socket disconnects during the duration of the <tt class=\"docutils literal\"><span class=\"pre\">accept</span></tt>. If the <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt> flag is specified then this error will not be raised and instead accept will be called again.</p>\u000A" },  { "module": "net",  "name": "close",  "code": "proc close*(socket: Socket)",  "desc": "Closes a socket." },  { "module": "net",  "name": "toCInt",  "code": "proc toCInt*(opt: SOBool): cint",  "desc": "Converts a <tt class=\"docutils literal\"><span class=\"pre\">SOBool</span></tt> into its Socket Option cint representation." },  { "module": "net",  "name": "getSockOpt",  "code": "proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.\u000A    tags: [ReadIOEffect].}",  "desc": "Retrieves option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> as a boolean value." },  { "module": "net",  "name": "setSockOpt",  "code": "proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.\u000A    tags: [WriteIOEffect].}",  "desc": "Sets option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> to a boolean value specified by <tt class=\"docutils literal\"><span class=\"pre\">value</span></tt>." },  { "module": "net",  "name": "connect",  "code": "proc connect*(socket: Socket; address: string; port = Port(0); \u000A              af: Domain = AF_INET) {.tags: [ReadIOEffect].}",  "desc": "<p>Connects socket to <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>:<tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">Address</span></tt> can be an IP address or a host name. If <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> is a host name, this function will try each IP of that host name. <tt class=\"docutils literal\"><span class=\"pre\">htons</span></tt> is already performed on <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> so you must not do it.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is an SSL socket a handshake will be automatically performed.</p>\u000A" },  { "module": "net",  "name": "handshake",  "code": "proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "<p>This proc needs to be called on a socket after it connects. This is only applicable when using <tt class=\"docutils literal\"><span class=\"pre\">connectAsync</span></tt>. This proc performs the SSL handshake.</p>\u000A<p>Returns <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt> whenever the socket is not yet ready for a handshake, <tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> whenever handshake completed successfully.</p>\u000A<p>A ESSL error is raised on any other errors.</p>\u000A" },  { "module": "net",  "name": "gotHandshake",  "code": "proc gotHandshake*(socket: Socket): bool",  "desc": "<p>Determines whether a handshake has occurred between a client (<tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>) and the server that <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is connected to.</p>\u000A<p>Throws ESSL if <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is not an SSL socket.</p>\u000A" },  { "module": "net",  "name": "hasDataBuffered",  "code": "proc hasDataBuffered*(s: Socket): bool",  "desc": "Determines whether a socket has data buffered." },  { "module": "net",  "name": "recv",  "code": "proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].}",  "desc": "<p>Receives data from a socket.</p>\u000A<p><strong>Note</strong>: This is a low-level function, you may be interested in the higher level versions of this function which are also named <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt>.</p>\u000A" },  { "module": "net",  "name": "recv",  "code": "proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {.\u000A    tags: [ReadIOEffect, TimeEffect].}",  "desc": "overload with a <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> parameter in miliseconds." },  { "module": "net",  "name": "recv",  "code": "proc recv*(socket: Socket; data: var string; size: int; timeout = - 1; \u000A           flags = {SocketFlag.SafeDisconn}): int",  "desc": "<p>Higher-level version of <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt>.</p>\u000A<p>When 0 is returned the socket's connection has been closed.</p>\u000A<p>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</p>\u000A<p>A timeout may be specified in miliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> must be initialised.</p>\u000A<p><strong>Warning</strong>: Only the <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt> flag is currently supported.</p>\u000A" },  { "module": "net",  "name": "readLine",  "code": "proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1; \u000A               flags = {SocketFlag.SafeDisconn}) {.\u000A    tags: [ReadIOEffect, TimeEffect].}",  "desc": "<p>Reads a line of data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>.</p>\u000A<p>If a full line is read <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is not added to <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt>, however if solely <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read then <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to it.</p>\u000A<p>If the socket is disconnected, <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p>An EOS exception will be raised in the case of a socket error.</p>\u000A<p>A timeout can be specified in miliseconds, if data is not received within the specified time an ETimeout exception will be raised.</p>\u000A<p><strong>Warning</strong>: Only the <tt class=\"docutils literal\"><span class=\"pre\">SafeDisconn</span></tt> flag is currently supported.</p>\u000A" },  { "module": "net",  "name": "recvFrom",  "code": "proc recvFrom*(socket: Socket; data: var string; length: int; \u000A               address: var string; port: var Port; flags = 0'i32): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Receives data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. This function should normally be used with connection-less sockets (UDP sockets).</p>\u000A<p>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</p>\u000A<p><strong>Warning:</strong> This function does not yet have a buffered implementation, so when <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is buffered the non-buffered implementation will be used. Therefore if <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> contains something in its buffer this function will make no effort to return it.</p>\u000A" },  { "module": "net",  "name": "skip",  "code": "proc skip*(socket: Socket; size: int; timeout = - 1)",  "desc": "<p>Skips <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> amount of bytes.</p>\u000A<p>An optional timeout can be specified in miliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</p>\u000A<p>Returns the number of skipped bytes.</p>\u000A" },  { "module": "net",  "name": "send",  "code": "proc send*(socket: Socket; data: pointer; size: int): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "<p>Sends data to a socket.</p>\u000A<p><strong>Note</strong>: This is a low-level version of <tt class=\"docutils literal\"><span class=\"pre\">send</span></tt>. You likely should use the version below.</p>\u000A" },  { "module": "net",  "name": "send",  "code": "proc send*(socket: Socket; data: string; flags = {SocketFlag.SafeDisconn}) {.\u000A    tags: [WriteIOEffect].}",  "desc": "sends data to a socket." },  { "module": "net",  "name": "trySend",  "code": "proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].}",  "desc": "Safe alternative to <tt class=\"docutils literal\"><span class=\"pre\">send</span></tt>. Does not raise an EOS when an error occurs, and instead returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> on failure." },  { "module": "net",  "name": "sendTo",  "code": "proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; \u000A             size: int; af: Domain = AF_INET; flags = 0'i32): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "<p>This proc sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to the specified <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</p>\u000A<p><strong>Note:</strong> You may wish to use the high-level version of this function which is defined below.</p>\u000A<p><strong>Note:</strong> This proc is not available for SSL sockets.</p>\u000A" },  { "module": "net",  "name": "sendTo",  "code": "proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "<p>This proc sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to the specified <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</p>\u000A<p>This is the high-level version of the above <tt class=\"docutils literal\"><span class=\"pre\">sendTo</span></tt> function.</p>\u000A" },  { "module": "net",  "name": "connect",  "code": "proc connect*(socket: Socket; address: string; port = Port(0); timeout: int; \u000A              af: Domain = AF_INET) {.tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "<p>Connects to server as specified by <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> on port specified by <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> paremeter specifies the time in miliseconds to allow for the connection to the server to be made.</p>\u000A" },  { "module": "net",  "name": "isSSL",  "code": "proc isSSL*(socket: Socket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is a SSL socket." },  { "module": "net",  "name": "getFD",  "code": "proc getFD*(socket: Socket): SocketHandle",  "desc": "Returns the socket's file descriptor" },  { "module": "net",  "name": "IPv4_any",  "code": "proc IPv4_any*(): TIpAddress",  "desc": "Returns the IPv4 any address, which can be used to listen on all available network adapters" },  { "module": "net",  "name": "IPv4_loopback",  "code": "proc IPv4_loopback*(): TIpAddress",  "desc": "Returns the IPv4 loopback address (127.0.0.1)" },  { "module": "net",  "name": "IPv4_broadcast",  "code": "proc IPv4_broadcast*(): TIpAddress",  "desc": "Returns the IPv4 broadcast address (255.255.255.255)" },  { "module": "net",  "name": "IPv6_any",  "code": "proc IPv6_any*(): TIpAddress",  "desc": "Returns the IPv6 any address (::0), which can be used to listen on all available network adapters " },  { "module": "net",  "name": "IPv6_loopback",  "code": "proc IPv6_loopback*(): TIpAddress",  "desc": "Returns the IPv6 loopback address (::1)" },  { "module": "net",  "name": "`==`",  "code": "proc `==`*(lhs, rhs: TIpAddress): bool",  "desc": "Compares two IpAddresses for Equality. Returns two if the addresses are equal" },  { "module": "net",  "name": "`$`",  "code": "proc `$`*(address: TIpAddress): string",  "desc": "Converts an TIpAddress into the textual representation" },  { "module": "net",  "name": "parseIpAddress",  "code": "proc parseIpAddress*(address_str: string): TIpAddress",  "desc": "Parses an IP address Raises EInvalidValue on error" },  { "module": "nimprof",  "name": "setSamplingFrequency",  "code": "proc setSamplingFrequency*(intervalInUs: int)",  "desc": "set this to change the sampling frequency. Default value is 5ms. Set it to 0 to disable time based profiling; it uses an imprecise instruction count measure instead then." },  { "module": "nimprof",  "name": "disableProfiling",  "code": "proc disableProfiling*()" },  { "module": "nimprof",  "name": "enableProfiling",  "code": "proc enableProfiling*()" },  { "module": "numeric",  "name": "brent",  "code": "proc brent*(xmin, xmax: float; function: OneVarFunction; tol: float; \u000A            maxiter = 1000): tuple[rootx, rooty: float, success: bool]",  "desc": "Searches <cite>function</cite> for a root between <cite>xmin</cite> and <cite>xmax</cite> using brents method. If the function value at <cite>xmin`and `xmax</cite> has the same sign, <cite>rootx</cite>/<cite>rooty</cite> is set too the extrema value closest to x-axis and succes is set to false. Otherwise there exists at least one root and success is set to true. This root is searched for at most <cite>maxiter</cite> iterations. If <cite>tol</cite> tolerance is reached within <cite>maxiter</cite> iterations the root refinement stops and success=true." },  { "module": "odbcsql",  "name": "SQLAllocHandle",  "code": "proc SQLAllocHandle*(HandleType: TSqlSmallInt; InputHandle: TSqlHandle; \u000A                     OutputHandlePtr: var TSqlHandle): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLSetEnvAttr",  "code": "proc SQLSetEnvAttr*(EnvironmentHandle: TSqlHEnv; Attribute: TSqlInteger; \u000A                    Value: TSqlPointer; StringLength: TSqlInteger): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetEnvAttr",  "code": "proc SQLGetEnvAttr*(EnvironmentHandle: TSqlHEnv; Attribute: TSqlInteger; \u000A                    Value: TSqlPointer; BufferLength: TSqlInteger; \u000A                    StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLFreeHandle",  "code": "proc SQLFreeHandle*(HandleType: TSqlSmallInt; Handle: TSqlHandle): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetDiagRec",  "code": "proc SQLGetDiagRec*(HandleType: TSqlSmallInt; Handle: TSqlHandle; \u000A                    RecNumber: TSqlSmallInt; Sqlstate: PSQLCHAR; \u000A                    NativeError: var TSqlInteger; MessageText: PSQLCHAR; \u000A                    BufferLength: TSqlSmallInt; TextLength: var TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetDiagField",  "code": "proc SQLGetDiagField*(HandleType: TSqlSmallInt; Handle: TSqlHandle; \u000A                      RecNumber: TSqlSmallInt; DiagIdentifier: TSqlSmallInt; \u000A                      DiagInfoPtr: TSqlPointer; BufferLength: TSqlSmallInt; \u000A                      StringLengthPtr: var TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLConnect",  "code": "proc SQLConnect*(ConnectionHandle: TSqlHDBC; ServerName: PSQLCHAR; \u000A                 NameLength1: TSqlSmallInt; UserName: PSQLCHAR; \u000A                 NameLength2: TSqlSmallInt; Authentication: PSQLCHAR; \u000A                 NameLength3: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLDisconnect",  "code": "proc SQLDisconnect*(ConnectionHandle: TSqlHDBC): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLDriverConnect",  "code": "proc SQLDriverConnect*(hdbc: TSqlHDBC; hwnd: TSqlHWND; szCsin: cstring; \u000A                       szCLen: TSqlSmallInt; szCsout: cstring; \u000A                       cbCSMax: TSqlSmallInt; cbCsOut: var TSqlSmallInt; \u000A                       f: TSqlUSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLBrowseConnect",  "code": "proc SQLBrowseConnect*(hdbc: TSqlHDBC; szConnStrIn: PSQLCHAR; \u000A                       cbConnStrIn: TSqlSmallInt; szConnStrOut: PSQLCHAR; \u000A                       cbConnStrOutMax: TSqlSmallInt; \u000A                       cbConnStrOut: var TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLExecDirect",  "code": "proc SQLExecDirect*(StatementHandle: TSqlHStmt; StatementText: PSQLCHAR; \u000A                    TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLPrepare",  "code": "proc SQLPrepare*(StatementHandle: TSqlHStmt; StatementText: PSQLCHAR; \u000A                 TextLength: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLCloseCursor",  "code": "proc SQLCloseCursor*(StatementHandle: TSqlHStmt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLExecute",  "code": "proc SQLExecute*(StatementHandle: TSqlHStmt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLFetch",  "code": "proc SQLFetch*(StatementHandle: TSqlHStmt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLNumResultCols",  "code": "proc SQLNumResultCols*(StatementHandle: TSqlHStmt; ColumnCount: var TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLDescribeCol",  "code": "proc SQLDescribeCol*(StatementHandle: TSqlHStmt; ColumnNumber: TSqlUSmallInt; \u000A                     ColumnName: PSQLCHAR; BufferLength: TSqlSmallInt; \u000A                     NameLength: var TSqlSmallInt; DataType: var TSqlSmallInt; \u000A                     ColumnSize: var TSqlUInteger; \u000A                     DecimalDigits: var TSqlSmallInt; Nullable: var TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLFetchScroll",  "code": "proc SQLFetchScroll*(StatementHandle: TSqlHStmt; FetchOrientation: TSqlSmallInt; \u000A                     FetchOffset: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLExtendedFetch",  "code": "proc SQLExtendedFetch*(hstmt: TSqlHStmt; fFetchType: TSqlUSmallInt; \u000A                       irow: TSqlInteger; pcrow: PSQLUINTEGER; \u000A                       rgfRowStatus: PSQLUSMALLINT): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetData",  "code": "proc SQLGetData*(StatementHandle: TSqlHStmt; ColumnNumber: TSqlUSmallInt; \u000A                 TargetType: TSqlSmallInt; TargetValue: TSqlPointer; \u000A                 BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLSetStmtAttr",  "code": "proc SQLSetStmtAttr*(StatementHandle: TSqlHStmt; Attribute: TSqlInteger; \u000A                     Value: TSqlPointer; StringLength: TSqlInteger): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetStmtAttr",  "code": "proc SQLGetStmtAttr*(StatementHandle: TSqlHStmt; Attribute: TSqlInteger; \u000A                     Value: TSqlPointer; BufferLength: TSqlInteger; \u000A                     StringLength: PSQLINTEGER): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLGetInfo",  "code": "proc SQLGetInfo*(ConnectionHandle: TSqlHDBC; InfoType: TSqlUSmallInt; \u000A                 InfoValue: TSqlPointer; BufferLength: TSqlSmallInt; \u000A                 StringLength: PSQLSMALLINT): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLBulkOperations",  "code": "proc SQLBulkOperations*(StatementHandle: TSqlHStmt; Operation: TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLPutData",  "code": "proc SQLPutData*(StatementHandle: TSqlHStmt; Data: TSqlPointer; \u000A                 StrLen_or_Ind: TSqlInteger): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLBindCol",  "code": "proc SQLBindCol*(StatementHandle: TSqlHStmt; ColumnNumber: TSqlUSmallInt; \u000A                 TargetType: TSqlSmallInt; TargetValue: TSqlPointer; \u000A                 BufferLength: TSqlInteger; StrLen_or_Ind: PSQLINTEGER): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLSetPos",  "code": "proc SQLSetPos*(hstmt: TSqlHStmt; irow: TSqlUSmallInt; fOption: TSqlUSmallInt; \u000A                fLock: TSqlUSmallInt): TSqlSmallInt {.dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLDataSources",  "code": "proc SQLDataSources*(EnvironmentHandle: TSqlHEnv; Direction: TSqlUSmallInt; \u000A                     ServerName: PSQLCHAR; BufferLength1: TSqlSmallInt; \u000A                     NameLength1: PSQLSMALLINT; Description: PSQLCHAR; \u000A                     BufferLength2: TSqlSmallInt; NameLength2: PSQLSMALLINT): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLDrivers",  "code": "proc SQLDrivers*(EnvironmentHandle: TSqlHEnv; Direction: TSqlUSmallInt; \u000A                 DriverDescription: PSQLCHAR; BufferLength1: TSqlSmallInt; \u000A                 DescriptionLength1: PSQLSMALLINT; DriverAttributes: PSQLCHAR; \u000A                 BufferLength2: TSqlSmallInt; AttributesLength2: PSQLSMALLINT): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLSetConnectAttr",  "code": "proc SQLSetConnectAttr*(ConnectionHandle: TSqlHDBC; Attribute: TSqlInteger; \u000A                        Value: TSqlPointer; StringLength: TSqlInteger): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLGetCursorName",  "code": "proc SQLGetCursorName*(StatementHandle: TSqlHStmt; CursorName: PSQLCHAR; \u000A                       BufferLength: TSqlSmallInt; NameLength: PSQLSMALLINT): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLSetCursorName",  "code": "proc SQLSetCursorName*(StatementHandle: TSqlHStmt; CursorName: PSQLCHAR; \u000A                       NameLength: TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLRowCount",  "code": "proc SQLRowCount*(StatementHandle: TSqlHStmt; RowCount: var TSqlInteger): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLBindParameter",  "code": "proc SQLBindParameter*(hstmt: TSqlHStmt; ipar: TSqlUSmallInt; \u000A                       fParamType: TSqlSmallInt; fCType: TSqlSmallInt; \u000A                       fSqlType: TSqlSmallInt; cbColDef: TSqlUInteger; \u000A                       ibScale: TSqlSmallInt; rgbValue: TSqlPointer; \u000A                       cbValueMax: TSqlInteger; pcbValue: PSQLINTEGER): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLFreeStmt",  "code": "proc SQLFreeStmt*(StatementHandle: TSqlHStmt; Option: TSqlUSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLColAttribute",  "code": "proc SQLColAttribute*(StatementHandle: TSqlHStmt; ColumnNumber: TSqlUSmallInt; \u000A                      FieldIdentifier: TSqlUSmallInt; \u000A                      CharacterAttribute: PSQLCHAR; BufferLength: TSqlSmallInt; \u000A                      StringLength: PSQLSMALLINT; NumericAttribute: TSqlPointer): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLEndTran",  "code": "proc SQLEndTran*(HandleType: TSqlSmallInt; Handle: TSqlHandle; \u000A                 CompletionType: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLTables",  "code": "proc SQLTables*(hstmt: TSqlHStmt; szTableQualifier: PSQLCHAR; \u000A                cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR; \u000A                cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR; \u000A                cbTableName: TSqlSmallInt; szTableType: PSQLCHAR; \u000A                cbTableType: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLColumns",  "code": "proc SQLColumns*(hstmt: TSqlHStmt; szTableQualifier: PSQLCHAR; \u000A                 cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR; \u000A                 cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR; \u000A                 cbTableName: TSqlSmallInt; szColumnName: PSQLCHAR; \u000A                 cbColumnName: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLSpecialColumns",  "code": "proc SQLSpecialColumns*(StatementHandle: TSqlHStmt; \u000A                        IdentifierType: TSqlUSmallInt; CatalogName: PSQLCHAR; \u000A                        NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR; \u000A                        NameLength2: TSqlSmallInt; TableName: PSQLCHAR; \u000A                        NameLength3: TSqlSmallInt; Scope: TSqlUSmallInt; \u000A                        Nullable: TSqlUSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLProcedures",  "code": "proc SQLProcedures*(hstmt: TSqlHStmt; szTableQualifier: PSQLCHAR; \u000A                    cbTableQualifier: TSqlSmallInt; szTableOwner: PSQLCHAR; \u000A                    cbTableOwner: TSqlSmallInt; szTableName: PSQLCHAR; \u000A                    cbTableName: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLPrimaryKeys",  "code": "proc SQLPrimaryKeys*(hstmt: TSqlHStmt; CatalogName: PSQLCHAR; \u000A                     NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR; \u000A                     NameLength2: TSqlSmallInt; TableName: PSQLCHAR; \u000A                     NameLength3: TSqlSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "odbcsql",  "name": "SQLProcedureColumns",  "code": "proc SQLProcedureColumns*(hstmt: TSqlHStmt; CatalogName: PSQLCHAR; \u000A                          NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR; \u000A                          NameLength2: TSqlSmallInt; ProcName: PSQLCHAR; \u000A                          NameLength3: TSqlSmallInt; ColumnName: PSQLCHAR; \u000A                          NameLength4: TSqlSmallInt): TSqlSmallInt {.\u000A    dynlib: odbclib, importc.}" },  { "module": "odbcsql",  "name": "SQLStatistics",  "code": "proc SQLStatistics*(hstmt: TSqlHStmt; CatalogName: PSQLCHAR; \u000A                    NameLength1: TSqlSmallInt; SchemaName: PSQLCHAR; \u000A                    NameLength2: TSqlSmallInt; TableName: PSQLCHAR; \u000A                    NameLength3: TSqlSmallInt; Unique: TSqlUSmallInt; \u000A                    Reserved: TSqlUSmallInt): TSqlSmallInt {.dynlib: odbclib, \u000A    importc.}" },  { "module": "oids",  "name": "hexbyte",  "code": "proc hexbyte*(hex: char): int" },  { "module": "oids",  "name": "parseOid",  "code": "proc parseOid*(str: cstring): Oid",  "desc": "parses an OID." },  { "module": "oids",  "name": "oidToString",  "code": "proc oidToString*(oid: Oid; str: cstring)" },  { "module": "oids",  "name": "`$`",  "code": "proc `$`*(oid: Oid): string" },  { "module": "oids",  "name": "genOid",  "code": "proc genOid*(): Oid",  "desc": "generates a new OID." },  { "module": "oids",  "name": "generatedTime",  "code": "proc generatedTime*(oid: Oid): Time",  "desc": "returns the generated timestamp of the OID." },  { "module": "openssl",  "name": "SSL_library_init",  "code": "proc SSL_library_init*(): cInt {.cdecl, dynlib: DLLSSLName, importc, discardable.}" },  { "module": "openssl",  "name": "SSL_load_error_strings",  "code": "proc SSL_load_error_strings*() {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "ERR_load_BIO_strings",  "code": "proc ERR_load_BIO_strings*() {.cdecl, dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "SSLv23_client_method",  "code": "proc SSLv23_client_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSLv23_method",  "code": "proc SSLv23_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSLv2_method",  "code": "proc SSLv2_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSLv3_method",  "code": "proc SSLv3_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "TLSv1_method",  "code": "proc TLSv1_method*(): PSSL_METHOD {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_new",  "code": "proc SSL_new*(context: SslCtx): SslPtr {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_free",  "code": "proc SSL_free*(ssl: SslPtr) {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_new",  "code": "proc SSL_CTX_new*(meth: PSSL_METHOD): SslCtx {.cdecl, dynlib: DLLSSLName, \u000A    importc.}" },  { "module": "openssl",  "name": "SSL_CTX_load_verify_locations",  "code": "proc SSL_CTX_load_verify_locations*(ctx: SslCtx; CAfile: cstring; \u000A                                    CApath: cstring): cInt {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_free",  "code": "proc SSL_CTX_free*(arg0: SslCtx) {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_set_verify",  "code": "proc SSL_CTX_set_verify*(s: SslCtx; mode: int; \u000A                         cb: proc (a: int; b: pointer): int {.cdecl.}) {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_get_verify_result",  "code": "proc SSL_get_verify_result*(ssl: SslPtr): int {.cdecl, dynlib: DLLSSLName, \u000A    importc.}" },  { "module": "openssl",  "name": "SSL_CTX_set_cipher_list",  "code": "proc SSL_CTX_set_cipher_list*(s: SslCtx; ciphers: cstring): cint {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_use_certificate_file",  "code": "proc SSL_CTX_use_certificate_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.\u000A    stdcall, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_use_certificate_chain_file",  "code": "proc SSL_CTX_use_certificate_chain_file*(ctx: SslCtx; filename: cstring): cInt {.\u000A    stdcall, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_use_PrivateKey_file",  "code": "proc SSL_CTX_use_PrivateKey_file*(ctx: SslCtx; filename: cstring; typ: cInt): cInt {.\u000A    cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_CTX_check_private_key",  "code": "proc SSL_CTX_check_private_key*(ctx: SslCtx): cInt {.cdecl, dynlib: DLLSSLName, \u000A    importc.}" },  { "module": "openssl",  "name": "SSL_set_fd",  "code": "proc SSL_set_fd*(ssl: SslPtr; fd: SocketHandle): cint {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_shutdown",  "code": "proc SSL_shutdown*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_set_shutdown",  "code": "proc SSL_set_shutdown*(ssl: SslPtr; mode: cint) {.cdecl, dynlib: DLLSSLName, \u000A    importc: \"SSL_set_shutdown\".}" },  { "module": "openssl",  "name": "SSL_get_shutdown",  "code": "proc SSL_get_shutdown*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, \u000A    importc: \"SSL_get_shutdown\".}" },  { "module": "openssl",  "name": "SSL_connect",  "code": "proc SSL_connect*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_read",  "code": "proc SSL_read*(ssl: SslPtr; buf: pointer; num: int): cint {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_write",  "code": "proc SSL_write*(ssl: SslPtr; buf: cstring; num: int): cint {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_get_error",  "code": "proc SSL_get_error*(s: SslPtr; ret_code: cInt): cInt {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_accept",  "code": "proc SSL_accept*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSL_pending",  "code": "proc SSL_pending*(ssl: SslPtr): cInt {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "BIO_new_ssl_connect",  "code": "proc BIO_new_ssl_connect*(ctx: SslCtx): BIO {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "BIO_ctrl",  "code": "proc BIO_ctrl*(bio: BIO; cmd: cint; larg: int; arg: cstring): int {.cdecl, \u000A    dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "BIO_get_ssl",  "code": "proc BIO_get_ssl*(bio: BIO; ssl: ptr SslPtr): int" },  { "module": "openssl",  "name": "BIO_set_conn_hostname",  "code": "proc BIO_set_conn_hostname*(bio: BIO; name: cstring): int" },  { "module": "openssl",  "name": "BIO_do_handshake",  "code": "proc BIO_do_handshake*(bio: BIO): int" },  { "module": "openssl",  "name": "BIO_do_connect",  "code": "proc BIO_do_connect*(bio: BIO): int" },  { "module": "openssl",  "name": "BIO_read",  "code": "proc BIO_read*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, \u000A    dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "BIO_write",  "code": "proc BIO_write*(b: BIO; data: cstring; length: cInt): cInt {.cdecl, \u000A    dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "BIO_free",  "code": "proc BIO_free*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "ERR_print_errors_fp",  "code": "proc ERR_print_errors_fp*(fp: File) {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "ERR_error_string",  "code": "proc ERR_error_string*(e: cInt; buf: cstring): cstring {.cdecl, \u000A    dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "ERR_get_error",  "code": "proc ERR_get_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "ERR_peek_last_error",  "code": "proc ERR_peek_last_error*(): cInt {.cdecl, dynlib: DLLUtilName, importc.}" },  { "module": "openssl",  "name": "OpenSSL_add_all_algorithms",  "code": "proc OpenSSL_add_all_algorithms*() {.cdecl, dynlib: DLLUtilName, \u000A                                     importc: \"OPENSSL_add_all_algorithms_conf\".}" },  { "module": "openssl",  "name": "OPENSSL_config",  "code": "proc OPENSSL_config*(configName: cstring) {.cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "CRYPTO_malloc_init",  "code": "proc CRYPTO_malloc_init*()" },  { "module": "openssl",  "name": "SSL_CTX_ctrl",  "code": "proc SSL_CTX_ctrl*(ctx: SslCtx; cmd: cInt; larg: int; parg: pointer): int {.\u000A    cdecl, dynlib: DLLSSLName, importc.}" },  { "module": "openssl",  "name": "SSLCTXSetMode",  "code": "proc SSLCTXSetMode*(ctx: SslCtx; mode: int): int" },  { "module": "openssl",  "name": "bioNew",  "code": "proc bioNew*(b: PBIO_METHOD): BIO {.cdecl, dynlib: DLLUtilName, \u000A                                    importc: \"BIO_new\".}" },  { "module": "openssl",  "name": "bioFreeAll",  "code": "proc bioFreeAll*(b: BIO) {.cdecl, dynlib: DLLUtilName, importc: \"BIO_free_all\".}" },  { "module": "openssl",  "name": "bioSMem",  "code": "proc bioSMem*(): PBIO_METHOD {.cdecl, dynlib: DLLUtilName, importc: \"BIO_s_mem\".}" },  { "module": "openssl",  "name": "bioCtrlPending",  "code": "proc bioCtrlPending*(b: BIO): cInt {.cdecl, dynlib: DLLUtilName, \u000A                                     importc: \"BIO_ctrl_pending\".}" },  { "module": "openssl",  "name": "bioRead",  "code": "proc bioRead*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, \u000A    dynlib: DLLUtilName, importc: \"BIO_read\".}" },  { "module": "openssl",  "name": "bioWrite",  "code": "proc bioWrite*(b: BIO; Buf: cstring; length: cInt): cInt {.cdecl, \u000A    dynlib: DLLUtilName, importc: \"BIO_write\".}" },  { "module": "openssl",  "name": "sslSetConnectState",  "code": "proc sslSetConnectState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName, \u000A                                      importc: \"SSL_set_connect_state\".}" },  { "module": "openssl",  "name": "sslSetAcceptState",  "code": "proc sslSetAcceptState*(s: SslPtr) {.cdecl, dynlib: DLLSSLName, \u000A                                     importc: \"SSL_set_accept_state\".}" },  { "module": "openssl",  "name": "sslRead",  "code": "proc sslRead*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, \u000A    dynlib: DLLSSLName, importc: \"SSL_read\".}" },  { "module": "openssl",  "name": "sslPeek",  "code": "proc sslPeek*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, \u000A    dynlib: DLLSSLName, importc: \"SSL_peek\".}" },  { "module": "openssl",  "name": "sslWrite",  "code": "proc sslWrite*(ssl: SslPtr; buf: cstring; num: cInt): cInt {.cdecl, \u000A    dynlib: DLLSSLName, importc: \"SSL_write\".}" },  { "module": "openssl",  "name": "sslSetBio",  "code": "proc sslSetBio*(ssl: SslPtr; rbio, wbio: BIO) {.cdecl, dynlib: DLLSSLName, \u000A    importc: \"SSL_set_bio\".}" },  { "module": "openssl",  "name": "sslDoHandshake",  "code": "proc sslDoHandshake*(ssl: SslPtr): cint {.cdecl, dynlib: DLLSSLName, \u000A    importc: \"SSL_do_handshake\".}" },  { "module": "openssl",  "name": "ErrClearError",  "code": "proc ErrClearError*() {.cdecl, dynlib: DLLUtilName, importc: \"ERR_clear_error\".}" },  { "module": "openssl",  "name": "ErrFreeStrings",  "code": "proc ErrFreeStrings*() {.cdecl, dynlib: DLLUtilName, importc: \"ERR_free_strings\".}" },  { "module": "openssl",  "name": "ErrRemoveState",  "code": "proc ErrRemoveState*(pid: cInt) {.cdecl, dynlib: DLLUtilName, \u000A                                  importc: \"ERR_remove_state\".}" },  { "module": "openssl",  "name": "md5_Init",  "code": "proc md5_Init*(c: var MD5_CTX): cint {.ic.}" },  { "module": "openssl",  "name": "md5_Update",  "code": "proc md5_Update*(c: var MD5_CTX; data: pointer; len: csize): cint {.ic.}" },  { "module": "openssl",  "name": "md5_Final",  "code": "proc md5_Final*(md: cstring; c: var MD5_CTX): cint {.ic.}" },  { "module": "openssl",  "name": "md5",  "code": "proc md5*(d: ptr cuchar; n: csize; md: ptr cuchar): ptr cuchar {.ic.}" },  { "module": "openssl",  "name": "md5_Transform",  "code": "proc md5_Transform*(c: var MD5_CTX; b: ptr cuchar) {.ic.}" },  { "module": "openssl",  "name": "md5_File",  "code": "proc md5_File*(file: string): string {.raises: [IOError, Exception].}",  "desc": "Generate MD5 hash for a file. Result is a 32 character" },  { "module": "openssl",  "name": "md5_Str",  "code": "proc md5_Str*(str: string): string {.raises: [IOError].}",  "desc": "Generate MD5 hash for a string. Result is a 32 character" },  { "module": "os",  "name": "osErrorMsg",  "code": "proc osErrorMsg*(): string {.rtl, extern: \"nos$1\", deprecated.}",  "desc": "<p>Retrieves the operating system's error flag, <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. On Windows <tt class=\"docutils literal\"><span class=\"pre\">GetLastError</span></tt> is checked before <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. Returns &quot;&quot; if no error occured.</p>\u000A<p><strong>Deprecated since version 0.9.4</strong>: use the other <tt class=\"docutils literal\"><span class=\"pre\">osErrorMsg</span></tt> proc.</p>\u000A" },  { "module": "os",  "name": "raiseOSError",  "code": "proc raiseOSError*(msg: string = \"\") {.noinline, rtl, extern: \"nos$1\", \u000A                                       deprecated.}",  "desc": "<p>raises an OSError exception with the given message <tt class=\"docutils literal\"><span class=\"pre\">msg</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">msg == &quot;&quot;</span></tt>, the operating system's error flag (<tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>) is converted to a readable error message. On Windows <tt class=\"docutils literal\"><span class=\"pre\">GetLastError</span></tt> is checked before <tt class=\"docutils literal\"><span class=\"pre\">errno</span></tt>. If no error flag is set, the message <tt class=\"docutils literal\"><span class=\"pre\">unknown OS error</span></tt> is used.</p>\u000A<p><strong>Deprecated since version 0.9.4</strong>: use the other <tt class=\"docutils literal\"><span class=\"pre\">raiseOSError</span></tt> proc.</p>\u000A" },  { "module": "os",  "name": "`==`",  "code": "proc `==`*(err1, err2: OSErrorCode): bool {.borrow.}" },  { "module": "os",  "name": "`$`",  "code": "proc `$`*(err: OSErrorCode): string {.borrow.}" },  { "module": "os",  "name": "osErrorMsg",  "code": "proc osErrorMsg*(errorCode: OSErrorCode): string",  "desc": "<p>Converts an OS error code into a human readable string.</p>\u000A<p>The error code can be retrieved using the <tt class=\"docutils literal\"><span class=\"pre\">osLastError</span></tt> proc.</p>\u000A<p>If conversion fails, or <tt class=\"docutils literal\"><span class=\"pre\">errorCode</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> then <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt> will be returned.</p>\u000A<p>On Windows, the <tt class=\"docutils literal\"><span class=\"pre\">-d:useWinAnsi</span></tt> compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</p>\u000A" },  { "module": "os",  "name": "raiseOSError",  "code": "proc raiseOSError*(errorCode: OSErrorCode)",  "desc": "<p>Raises an <tt class=\"docutils literal\"><span class=\"pre\">OSError</span></tt> exception. The <tt class=\"docutils literal\"><span class=\"pre\">errorCode</span></tt> will determine the message, <tt class=\"docutils literal\"><span class=\"pre\">osErrorMsg</span></tt> will be used to get this message.</p>\u000A<p>The error code can be retrieved using the <tt class=\"docutils literal\"><span class=\"pre\">osLastError</span></tt> proc.</p>\u000A<p>If the error code is <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> or an error message could not be retrieved, the message <tt class=\"docutils literal\"><span class=\"pre\">unknown OS error</span></tt> will be used.</p>\u000A" },  { "module": "os",  "name": "osLastError",  "code": "proc osLastError*(): OSErrorCode",  "desc": "<p>Retrieves the last operating system error code.</p>\u000A<p>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The <tt class=\"docutils literal\"><span class=\"pre\">OSErrorMsg</span></tt> procedure can then be used to convert this code into a string.</p>\u000A<p><strong>Warning</strong>: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> causing this procedure to return <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt>. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.</p>\u000A" },  { "module": "os",  "name": "unixToNativePath",  "code": "proc unixToNativePath*(path: string; drive = \"\"): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}",  "desc": "<p>Converts an UNIX-like path to a native one.</p>\u000A<p>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</p>\u000A<p>On systems with a concept of &quot;drives&quot;, <cite>drive</cite> is used to determine which drive label to use during absolute path conversion. <cite>drive</cite> defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</p>\u000A" },  { "module": "os",  "name": "existsFile",  "code": "proc existsFile*(filename: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}",  "desc": "Returns true if the file exists, false otherwise." },  { "module": "os",  "name": "existsDir",  "code": "proc existsDir*(dir: string): bool {.rtl, extern: \"nos$1\", tags: [ReadDirEffect].}",  "desc": "Returns true iff the directory <cite>dir</cite> exists. If <cite>dir</cite> is a file, false is returned." },  { "module": "os",  "name": "symlinkExists",  "code": "proc symlinkExists*(link: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}",  "desc": "Returns true iff the symlink <cite>link</cite> exists. Will return true regardless of whether the link points to a directory or file." },  { "module": "os",  "name": "fileExists",  "code": "proc fileExists*(filename: string): bool {.inline.}",  "desc": "Synonym for existsFile" },  { "module": "os",  "name": "dirExists",  "code": "proc dirExists*(dir: string): bool {.inline.}",  "desc": "Synonym for existsDir" },  { "module": "os",  "name": "getLastModificationTime",  "code": "proc getLastModificationTime*(file: string): Time {.rtl, extern: \"nos$1\".}",  "desc": "Returns the <cite>file</cite>'s last modification time." },  { "module": "os",  "name": "getLastAccessTime",  "code": "proc getLastAccessTime*(file: string): Time {.rtl, extern: \"nos$1\".}",  "desc": "Returns the <cite>file</cite>'s last read or write access time." },  { "module": "os",  "name": "getCreationTime",  "code": "proc getCreationTime*(file: string): Time {.rtl, extern: \"nos$1\".}",  "desc": "Returns the <cite>file</cite>'s creation time. Note that under posix OS's, the returned time may actually be the time at which the file's attribute's were last modified." },  { "module": "os",  "name": "fileNewer",  "code": "proc fileNewer*(a, b: string): bool {.rtl, extern: \"nos$1\".}",  "desc": "Returns true if the file <cite>a</cite> is newer than file <cite>b</cite>, i.e. if <cite>a</cite>'s modification time is later than <cite>b</cite>'s." },  { "module": "os",  "name": "getCurrentDir",  "code": "proc getCurrentDir*(): string {.rtl, extern: \"nos$1\", tags: [].}",  "desc": "Returns the <span id=\"current-working-directory_1\">current working directory</span>." },  { "module": "os",  "name": "setCurrentDir",  "code": "proc setCurrentDir*(newDir: string) {.inline, tags: [].}",  "desc": "Sets the <span id=\"current-working-directory_2\">current working directory</span>; <cite>OSError</cite> is raised if <cite>newDir</cite> cannot been set." },  { "module": "os",  "name": "joinPath",  "code": "proc joinPath*(head, tail: string): string {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "<p>Joins two directory names to one.</p>\u000A<p>For example on Unix:</p>\u000A<pre><span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;lib&quot;</span><span class=\"Punctuation\">)</span></pre><p>results in:</p>\u000A<pre><span class=\"StringLit\">&quot;usr/lib&quot;</span></pre><p>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</p>\u000A<pre><span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;/lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">joinPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;/lib&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/lib&quot;</span></pre>" },  { "module": "os",  "name": "joinPath",  "code": "proc joinPath*(parts: varargs[string]): string {.noSideEffect, rtl, \u000A    extern: \"nos$1OpenArray\".}",  "desc": "The same as <cite>joinPath(head, tail)</cite>, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds." },  { "module": "os",  "name": "`/`",  "code": "proc `/`*(head, tail: string): string {.noSideEffect.}",  "desc": "<p>The same as <tt class=\"docutils literal\"><span class=\"pre\">joinPath(head, tail)</span></tt></p>\u000A<p>Here are some examples for Unix:</p>\u000A<pre><span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;usr&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;/lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/lib&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"StringLit\">&quot;usr/&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;/lib&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/lib&quot;</span></pre>" },  { "module": "os",  "name": "splitPath",  "code": "proc splitPath*(path: string): tuple[head, tail: string] {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}",  "desc": "<p>Splits a directory into (head, tail), so that <tt class=\"docutils literal\"><span class=\"pre\">joinPath(head, tail) == path</span></tt>.</p>\u000A<p>Examples:</p>\u000A<pre><span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin/&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/bin&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/bin&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bin&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">splitPath</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "os",  "name": "parentDir",  "code": "proc parentDir*(path: string): string {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "<p>Returns the parent directory of <cite>path</cite>.</p>\u000A<p>This is often the same as the <tt class=\"docutils literal\"><span class=\"pre\">head</span></tt> result of <tt class=\"docutils literal\"><span class=\"pre\">splitPath</span></tt>. If there is no parent, &quot;&quot; is returned.<p>Example: <tt class=\"docutils literal\"><span class=\"pre\">parentDir(&quot;/usr/local/bin&quot;) == &quot;/usr/local&quot;</span></tt>.<br />Example: <tt class=\"docutils literal\"><span class=\"pre\">parentDir(&quot;/usr/local/bin/&quot;) == &quot;/usr/local&quot;</span></tt>.<br /></p></p>\u000A" },  { "module": "os",  "name": "isRootDir",  "code": "proc isRootDir*(path: string): bool {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "Checks whether a given <cite>path</cite> is a root directory" },  { "module": "os",  "name": "parentDirs",  "code": "iterator parentDirs*(path: string; fromRoot = false; inclusive = true): string",  "desc": "<p>Walks over all parent directories of a given <cite>path</cite></p>\u000A<p>If <cite>fromRoot</cite> is set, the traversal will start from the file system root diretory. If <cite>inclusive</cite> is set, the original argument will be included in the traversal.</p>\u000A<p>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</p>\u000A" },  { "module": "os",  "name": "`/../`",  "code": "proc `/../`*(head, tail: string): string {.noSideEffect.}",  "desc": "The same as <tt class=\"docutils literal\"><span class=\"pre\">parentDir(head) / tail</span></tt> unless there is no parent directory. Then <tt class=\"docutils literal\"><span class=\"pre\">head / tail</span></tt> is performed instead." },  { "module": "os",  "name": "splitFile",  "code": "proc splitFile*(path: string): tuple[dir, name, ext: string] {.noSideEffect, \u000A    rtl, extern: \"nos$1\".}",  "desc": "<p>Splits a filename into (dir, filename, extension). <cite>dir</cite> does not end in <cite>DirSep</cite>. <cite>extension</cite> includes the leading dot.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">dir</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">ext</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">splitFile</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;usr/local/nimc.html&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">dir</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;usr/local&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">name</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;nimc&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">ext</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;.html&quot;</span></pre><p>If <cite>path</cite> has no extension, <cite>ext</cite> is the empty string. If <cite>path</cite> has no directory component, <cite>dir</cite> is the empty string. If <cite>path</cite> has no filename component, <cite>name</cite> and <cite>ext</cite> are empty strings.</p>\u000A" },  { "module": "os",  "name": "extractFilename",  "code": "proc extractFilename*(path: string): string {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "Extracts the filename of a given <cite>path</cite>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">name &amp; ext</span></tt> from <tt class=\"docutils literal\"><span class=\"pre\">splitFile(path)</span></tt>." },  { "module": "os",  "name": "expandFilename",  "code": "proc expandFilename*(filename: string): string {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}",  "desc": "Returns the full path of <cite>filename</cite>, raises OSError in case of an error." },  { "module": "os",  "name": "changeFileExt",  "code": "proc changeFileExt*(filename, ext: string): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}",  "desc": "<p>Changes the file extension to <cite>ext</cite>.</p>\u000A<p>If the <cite>filename</cite> has no extension, <cite>ext</cite> will be added. If <cite>ext</cite> == &quot;&quot; then any extension is removed. <cite>Ext</cite> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>\u000A" },  { "module": "os",  "name": "addFileExt",  "code": "proc addFileExt*(filename, ext: string): string {.noSideEffect, rtl, \u000A    extern: \"nos$1\".}",  "desc": "<p>Adds the file extension <cite>ext</cite> to <cite>filename</cite>, unless <cite>filename</cite> already has an extension.</p>\u000A<p><cite>Ext</cite> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>\u000A" },  { "module": "os",  "name": "cmpPaths",  "code": "proc cmpPaths*(pathA, pathB: string): int {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "<p>Compares two paths.</p>\u000A<p>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</p>\u000A<p>0 iff pathA == pathB<br />&lt; 0 iff pathA &lt; pathB<br />&gt; 0 iff pathA &gt; pathB<br /></p>" },  { "module": "os",  "name": "isAbsolute",  "code": "proc isAbsolute*(path: string): bool {.rtl, noSideEffect, extern: \"nos$1\".}",  "desc": "<p>Checks whether a given <cite>path</cite> is absolute.</p>\u000A<p>On Windows, network paths are considered absolute too.</p>\u000A" },  { "module": "os",  "name": "sameFile",  "code": "proc sameFile*(path1, path2: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadDirEffect].}",  "desc": "<p>Returns True if both pathname arguments refer to the same physical file or directory. Raises an exception if any of the files does not exist or information about it can not be obtained.</p>\u000A<p>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</p>\u000A" },  { "module": "os",  "name": "sameFileContent",  "code": "proc sameFileContent*(path1, path2: string): bool {.rtl, extern: \"nos$1\", \u000A    tags: [ReadIOEffect].}",  "desc": "Returns True if both pathname arguments refer to files with identical binary content." },  { "module": "os",  "name": "getFilePermissions",  "code": "proc getFilePermissions*(filename: string): set[FilePermission] {.rtl, \u000A    extern: \"nos$1\", tags: [ReadDirEffect].}",  "desc": "retrieves file permissions for <cite>filename</cite>. <cite>OSError</cite> is raised in case of an error. On Windows, only the <tt class=\"docutils literal\"><span class=\"pre\">readonly</span></tt> flag is checked, every other permission is available in any case." },  { "module": "os",  "name": "setFilePermissions",  "code": "proc setFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [WriteDirEffect].}",  "desc": "sets the file permissions for <cite>filename</cite>. <cite>OSError</cite> is raised in case of an error. On Windows, only the <tt class=\"docutils literal\"><span class=\"pre\">readonly</span></tt> flag is changed, depending on <tt class=\"docutils literal\"><span class=\"pre\">fpUserWrite</span></tt>." },  { "module": "os",  "name": "copyFile",  "code": "proc copyFile*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                       tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "<p>Copies a file from <cite>source</cite> to <cite>dest</cite>.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use <a class=\"reference external\" href=\"#getFilePermissions\">getFilePermissions()</a> and <a class=\"reference external\" href=\"#setFilePermissions\">setFilePermissions()</a> to copy them by hand (or use the convenience <a class=\"reference external\" href=\"#copyFileWithPermissions\">copyFileWithPermissions()</a> proc), otherwise <cite>dest</cite> will inherit the default permissions of a newly created file for the user. If <cite>dest</cite> already exists, the file attributes will be preserved and the content overwritten.</p>\u000A" },  { "module": "os",  "name": "moveFile",  "code": "proc moveFile*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                       tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "Moves a file from <cite>source</cite> to <cite>dest</cite>. If this fails, <cite>OSError</cite> is raised." },  { "module": "os",  "name": "removeFile",  "code": "proc removeFile*(file: string) {.rtl, extern: \"nos$1\", tags: [WriteDirEffect].}",  "desc": "Removes the <cite>file</cite>. If this fails, <cite>OSError</cite> is raised. This does not fail if the file never existed in the first place. On Windows, ignores the read-only attribute." },  { "module": "os",  "name": "execShellCmd",  "code": "proc execShellCmd*(command: string): int {.rtl, extern: \"nos$1\", \u000A    tags: [ExecIOEffect].}",  "desc": "<p>Executes a <span id=\"shell-command_1\">shell command</span>.</p>\u000A<p>Command has the form 'program args' where args are the command line arguments given to program. The proc returns the error code of the shell when it has finished. The proc does not return until the process has finished. To execute a program without having a shell involved, use the <cite>execProcess</cite> proc of the <cite>osproc</cite> module.</p>\u000A" },  { "module": "os",  "name": "getEnv",  "code": "proc getEnv*(key: string): TaintedString {.tags: [ReadEnvEffect].}",  "desc": "<p>Returns the value of the <span id=\"environment-variable_1\">environment variable</span> named <cite>key</cite>.</p>\u000A<p>If the variable does not exist, &quot;&quot; is returned. To distinguish whether a variable exists or it's value is just &quot;&quot;, call <cite>existsEnv(key)</cite>.</p>\u000A" },  { "module": "os",  "name": "existsEnv",  "code": "proc existsEnv*(key: string): bool {.tags: [ReadEnvEffect].}",  "desc": "Checks whether the environment variable named <cite>key</cite> exists. Returns true if it exists, false otherwise." },  { "module": "os",  "name": "putEnv",  "code": "proc putEnv*(key, val: string) {.tags: [WriteEnvEffect].}",  "desc": "Sets the value of the <span id=\"environment-variable_2\">environment variable</span> named <cite>key</cite> to <cite>val</cite>. If an error occurs, <cite>EInvalidEnvVar</cite> is raised." },  { "module": "os",  "name": "envPairs",  "code": "iterator envPairs*(): tuple[key, value: TaintedString] {.tags: [ReadEnvEffect].}",  "desc": "Iterate over all <span id=\"environments-variables_1\">environments variables</span>. In the first component of the tuple is the name of the current variable stored, in the second its value." },  { "module": "os",  "name": "walkFiles",  "code": "iterator walkFiles*(pattern: string): string {.tags: [ReadDirEffect].}",  "desc": "<p>Iterate over all the files that match the <cite>pattern</cite>. On POSIX this uses the <span id=\"glob_1\">glob</span> call.</p>\u000A<p><cite>pattern</cite> is OS dependent, but at least the &quot;*.ext&quot; notation is supported.</p>\u000A" },  { "module": "os",  "name": "walkDir",  "code": "iterator walkDir*(dir: string): tuple[kind: PathComponent, path: string] {.\u000A    tags: [ReadDirEffect].}",  "desc": "<p>walks over the directory <cite>dir</cite> and yields for each directory or file in <cite>dir</cite>. The component type and full path for each item is returned. Walking is not recursive. Example: This directory structure:<pre>dirA / dirB / fileB1.txt\u000A     / dirC\u000A     / fileA1.txt\u000A     / fileA2.txt</pre>\u000A</p>\u000A<p>and this code:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">kind</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">path</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">walkDir</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;dirA&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">path</span><span class=\"Punctuation\">)</span></pre><p>produces this output (but not necessarily in this order!):<pre>dirA/dirB\u000AdirA/dirC\u000AdirA/fileA1.txt\u000AdirA/fileA2.txt</pre>\u000A</p>\u000A" },  { "module": "os",  "name": "walkDirRec",  "code": "iterator walkDirRec*(dir: string; filter = {pcFile, pcDir}): string {.\u000A    tags: [ReadDirEffect].}",  "desc": "<p>walks over the directory <cite>dir</cite> and yields for each file in <cite>dir</cite>. The full path for each file is returned. <strong>Warning</strong>: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</p>\u000A<p>Walking is recursive. <cite>filter</cite> controls the behaviour of the iterator:</p>\u000A<table border=\"1\" class=\"docutils\"><tr><th>filter</th><th>meaning</th></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcFile</span></tt></td><td>yield real files</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcLinkToFile</span></tt></td><td>yield symbolic links to files</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcDir</span></tt></td><td>follow real directories</td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">pcLinkToDir</span></tt></td><td>follow symbolic links to directories</td></tr>\u000A</table>" },  { "module": "os",  "name": "removeDir",  "code": "proc removeDir*(dir: string) {.rtl, extern: \"nos$1\", \u000A                               tags: [WriteDirEffect, ReadDirEffect].}",  "desc": "<p>Removes the directory <cite>dir</cite> including all subdirectories and files in <cite>dir</cite> (recursively).</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. This does not fail if the directory never existed in the first place.</p>\u000A" },  { "module": "os",  "name": "createDir",  "code": "proc createDir*(dir: string) {.rtl, extern: \"nos$1\", tags: [WriteDirEffect].}",  "desc": "<p>Creates the <span id=\"directory_1\">directory</span> <cite>dir</cite>.</p>\u000A<p>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, <cite>OSError</cite> is raised. It does <strong>not</strong> fail if the path already exists because for most usages this does not indicate an error.</p>\u000A" },  { "module": "os",  "name": "copyDir",  "code": "proc copyDir*(source, dest: string) {.rtl, extern: \"nos$1\", \u000A                                      tags: [WriteIOEffect, ReadIOEffect].}",  "desc": "<p>Copies a directory from <cite>source</cite> to <cite>dest</cite>.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. On the Windows platform this proc will copy the attributes from <cite>source</cite> into <cite>dest</cite>. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use <a class=\"reference external\" href=\"#copyDirWithPermissions\">copyDirWithPermissions()</a>.</p>\u000A" },  { "module": "os",  "name": "createSymlink",  "code": "proc createSymlink*(src, dest: string)",  "desc": "<p>Create a symbolic link at <cite>dest</cite> which points to the item specified by <cite>src</cite>. On most operating systems, will fail if a lonk</p>\u000A<p><strong>Warning</strong>: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</p>\u000A" },  { "module": "os",  "name": "createHardlink",  "code": "proc createHardlink*(src, dest: string)",  "desc": "<p>Create a hard link at <cite>dest</cite> which points to the item specified by <cite>src</cite>.</p>\u000A<p><strong>Warning</strong>: Most OS's restrict the creation of hard links to root users (administrators) .</p>\u000A" },  { "module": "os",  "name": "parseCmdLine",  "code": "proc parseCmdLine*(c: string): seq[string] {.noSideEffect, rtl, extern: \"nos$1\".}",  "desc": "<p>Splits a command line into several components; This proc is only occassionally useful, better use the <cite>parseopt</cite> module.</p>\u000A<p>On Windows, it uses the following parsing rules (see <a class=\"reference external\" href=\"http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\">http://msdn.microsoft.com/en-us/library/17w5ykft.aspx</a> ):</p>\u000A<ul class=\"simple\"><li>Arguments are delimited by white space, which is either a space or a tab.</li>\u000A<li>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</li>\u000A<li>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</li>\u000A<li>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</li>\u000A<li>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</li>\u000A<li>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</li>\u000A<li>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</li>\u000A</ul>\u000A<p>On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within <tt class=\"docutils literal\"><span class=\"pre\">&quot;</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">'</span></tt> quotes.</p>\u000A" },  { "module": "os",  "name": "copyFileWithPermissions",  "code": "proc copyFileWithPermissions*(source, dest: string; \u000A                              ignorePermissionErrors = true)",  "desc": "<p>Copies a file from <cite>source</cite> to <cite>dest</cite> preserving file permissions.</p>\u000A<p>This is a wrapper proc around <a class=\"reference external\" href=\"#copyFile\">copyFile()</a>, <a class=\"reference external\" href=\"#getFilePermissions\">getFilePermissions()</a> and <a class=\"reference external\" href=\"#setFilePermissions\">setFilePermissions()</a> on non Windows platform. On Windows this proc is just a wrapper for <a class=\"reference external\" href=\"#copyFile\">copyFile()</a> since that proc already copies attributes.</p>\u000A<p>On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If <cite>ignorePermissionErrors</cite> is true, errors while reading/setting file attributes will be ignored, otherwise will raise <cite>OSError</cite>.</p>\u000A" },  { "module": "os",  "name": "copyDirWithPermissions",  "code": "proc copyDirWithPermissions*(source, dest: string; ignorePermissionErrors = true) {.\u000A    rtl, extern: \"nos$1\", tags: [WriteIOEffect, ReadIOEffect].}",  "desc": "<p>Copies a directory from <cite>source</cite> to <cite>dest</cite> preserving file permissions.</p>\u000A<p>If this fails, <cite>OSError</cite> is raised. This is a wrapper proc around <a class=\"reference external\" href=\"#copyDir\">copyDir()</a> and <a class=\"reference external\" href=\"#copyFileWithPermissions\">copyFileWithPermissions()</a> on non Windows platforms. On Windows this proc is just a wrapper for <a class=\"reference external\" href=\"#copyDir\">copyDir()</a> since that proc already copies attributes.</p>\u000A<p>On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If <cite>ignorePermissionErrors</cite> is true, errors while reading/setting file attributes will be ignored, otherwise will raise <cite>OSError</cite>.</p>\u000A" },  { "module": "os",  "name": "inclFilePermissions",  "code": "proc inclFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [ReadDirEffect, WriteDirEffect].}",  "desc": "a convenience procedure for:<pre><span class=\"Identifier\">setFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">getFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">)</span><span class=\"Operator\">+</span><span class=\"Identifier\">permissions</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "os",  "name": "exclFilePermissions",  "code": "proc exclFilePermissions*(filename: string; permissions: set[FilePermission]) {.\u000A    rtl, extern: \"nos$1\", tags: [ReadDirEffect, WriteDirEffect].}",  "desc": "a convenience procedure for:<pre><span class=\"Identifier\">setFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">getFilePermissions</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">)</span><span class=\"Operator\">-</span><span class=\"Identifier\">permissions</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "os",  "name": "getHomeDir",  "code": "proc getHomeDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}",  "desc": "<p>Returns the home directory of the current user.</p>\u000A<p>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</p>\u000A" },  { "module": "os",  "name": "getConfigDir",  "code": "proc getConfigDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}",  "desc": "Returns the config directory of the current user for applications." },  { "module": "os",  "name": "getTempDir",  "code": "proc getTempDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadEnvEffect].}",  "desc": "Returns the temporary directory of the current user for applications to save temporary files in." },  { "module": "os",  "name": "paramCount",  "code": "proc paramCount*(): int {.tags: [ReadIOEffect].}",  "desc": "<p>Returns the number of <span id=\"command-line-arguments_1\">command line arguments</span> given to the application.</p>\u000A<p>If your binary was called without parameters this will return zero.  You can later query each individual paramater with <a class=\"reference external\" href=\"#paramStr\">paramStr()</a> or retrieve all of them in one go with <a class=\"reference external\" href=\"#commandLineParams\">commandLineParams()</a>.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">paramCount</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use paramCount() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>" },  { "module": "os",  "name": "paramStr",  "code": "proc paramStr*(i: int): TaintedString {.tags: [ReadIOEffect].}",  "desc": "<p>Returns the <cite>i</cite>-th <span id=\"command-line-argument_1\">command line argument</span> given to the application.</p>\u000A<p><cite>i</cite> should be in the range <cite>1..paramCount()</cite>, the <cite>EInvalidIndex</cite> exception will be raised for invalid values.  Instead of iterating over <a class=\"reference external\" href=\"#paramCount\">paramCount()</a> with this proc you can call the convenience <a class=\"reference external\" href=\"#commandLineParams\">commandLineParams()</a>.</p>\u000A<p>It is possible to call <tt class=\"docutils literal\"><span class=\"pre\">paramStr(0)</span></tt> but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call <a class=\"reference external\" href=\"#getAppFilename\">getAppFilename()</a> instead.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">paramStr</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use paramStr() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>" },  { "module": "os",  "name": "commandLineParams",  "code": "proc commandLineParams*(): seq[TaintedString]",  "desc": "<p>Convenience proc which returns the command line parameters.</p>\u000A<p>This returns <strong>only</strong> the parameters. If you want to get the application executable filename, call <a class=\"reference external\" href=\"#getAppFilename\">getAppFilename()</a>.</p>\u000A<p><strong>Availability</strong>: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with <a class=\"reference external\" href=\"system.html#declared\">declared()</a>. Example:</p>\u000A<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">declared</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">commandLineParams</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Use commandLineParams() here</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do something else!</span></pre>" },  { "module": "os",  "name": "getAppFilename",  "code": "proc getAppFilename*(): string {.rtl, extern: \"nos$1\", tags: [ReadIOEffect].}",  "desc": "<p>Returns the filename of the application's executable.</p>\u000A<p>This procedure will resolve symlinks.</p>\u000A<p><strong>Note</strong>: This does not work reliably on BSD.</p>\u000A" },  { "module": "os",  "name": "getApplicationFilename",  "code": "proc getApplicationFilename*(): string {.rtl, extern: \"nos$1\", deprecated.}",  "desc": "Returns the filename of the application's executable. <strong>Deprecated since version 0.8.12</strong>: use <tt class=\"docutils literal\"><span class=\"pre\">getAppFilename</span></tt> instead." },  { "module": "os",  "name": "getApplicationDir",  "code": "proc getApplicationDir*(): string {.rtl, extern: \"nos$1\", deprecated.}",  "desc": "Returns the directory of the application's executable. <strong>Deprecated since version 0.8.12</strong>: use <tt class=\"docutils literal\"><span class=\"pre\">getAppDir</span></tt> instead." },  { "module": "os",  "name": "getAppDir",  "code": "proc getAppDir*(): string {.rtl, extern: \"nos$1\", tags: [ReadIOEffect].}",  "desc": "Returns the directory of the application's executable. <strong>Note</strong>: This does not work reliably on BSD." },  { "module": "os",  "name": "sleep",  "code": "proc sleep*(milsecs: int) {.rtl, extern: \"nos$1\", tags: [TimeEffect].}",  "desc": "sleeps <cite>milsecs</cite> milliseconds." },  { "module": "os",  "name": "getFileSize",  "code": "proc getFileSize*(file: string): BiggestInt {.rtl, extern: \"nos$1\", \u000A    tags: [ReadIOEffect].}",  "desc": "returns the file size of <cite>file</cite>. Can raise <tt class=\"docutils literal\"><span class=\"pre\">OSError</span></tt>." },  { "module": "os",  "name": "findExe",  "code": "proc findExe*(exe: string): string {.tags: [ReadDirEffect, ReadEnvEffect].}",  "desc": "Searches for <cite>exe</cite> in the current working directory and then in directories listed in the <tt class=\"docutils literal\"><span class=\"pre\">PATH</span></tt> environment variable. Returns &quot;&quot; if the <cite>exe</cite> cannot be found. On DOS-like platforms, <cite>exe</cite> is added an <tt class=\"docutils literal\"><span class=\"pre\">.exe</span></tt> file extension if it has no extension." },  { "module": "os",  "name": "expandTilde",  "code": "proc expandTilde*(path: string): string",  "desc": "<p>Expands a path starting with <tt class=\"docutils literal\"><span class=\"pre\">~/</span></tt> to a full path.</p>\u000A<p>If <cite>path</cite> starts with the tilde character and is followed by <cite>/</cite> or <cite>\\</cite> this proc will return the reminder of the path appended to the result of the getHomeDir() proc, otherwise the input path will be returned without modification.</p>\u000A<p>The behaviour of this proc is the same on the Windows platform despite not having this convention. Example:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">configFile</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">expandTilde</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;~&quot;</span> <span class=\"Operator\">/</span> <span class=\"StringLit\">&quot;appname.cfg&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">configFile</span>\u000A<span class=\"Comment\"># --&gt; C:\\Users\\amber\\appname.cfg</span></pre>" },  { "module": "os",  "name": "getFileInfo",  "code": "proc getFileInfo*(handle: FileHandle): FileInfo",  "desc": "<p>Retrieves file information for the file object represented by the given handle.</p>\u000A<p>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</p>\u000A" },  { "module": "os",  "name": "getFileInfo",  "code": "proc getFileInfo*(file: File): FileInfo" },  { "module": "os",  "name": "getFileInfo",  "code": "proc getFileInfo*(path: string; followSymlink = true): FileInfo",  "desc": "<p>Retrieves file information for the file object pointed to by <cite>path</cite>.</p>\u000A<p>Due to intrinsic differences between operating systems, the information contained by the returned <cite>FileInfo</cite> structure will be slightly different across platforms, and in some cases, incomplete or inaccurate.</p>\u000A<p>When <cite>followSymlink</cite> is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</p>\u000A<p>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</p>\u000A" },  { "module": "os",  "name": "isHidden",  "code": "proc isHidden*(path: string): bool",  "desc": "<p>Determines whether a given path is hidden or not. Returns false if the file doesn't exist. The given path must be accessible from the current working directory of the program.</p>\u000A<p>On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not <em>just</em> '.' or '..' ' .&quot;</p>\u000A" },  { "module": "osinfo_posix",  "name": "getSystemVersion",  "code": "proc getSystemVersion*(): string" },  { "module": "osinfo_win",  "name": "globalMemoryStatusEx",  "code": "proc globalMemoryStatusEx*(lpBuffer: var TMEMORYSTATUSEX) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GlobalMemoryStatusEx\".}" },  { "module": "osinfo_win",  "name": "getMemoryInfo",  "code": "proc getMemoryInfo*(): TMemoryInfo",  "desc": "Retrieves memory info" },  { "module": "osinfo_win",  "name": "getVersionEx",  "code": "proc getVersionEx*(lpVersionInformation: var TOSVERSIONINFOEX): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetVersionExA\".}" },  { "module": "osinfo_win",  "name": "getProcAddress",  "code": "proc getProcAddress*(hModule: int; lpProcName: cstring): pointer {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcAddress\".}" },  { "module": "osinfo_win",  "name": "getModuleHandleA",  "code": "proc getModuleHandleA*(lpModuleName: cstring): int {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetModuleHandleA\".}" },  { "module": "osinfo_win",  "name": "getVersionInfo",  "code": "proc getVersionInfo*(): TVersionInfo",  "desc": "Retrieves operating system info" },  { "module": "osinfo_win",  "name": "getProductInfo",  "code": "proc getProductInfo*(majorVersion, minorVersion, SPMajorVersion, SPMinorVersion: int): int",  "desc": "Retrieves Windows' ProductInfo, this function only works in Vista and 7" },  { "module": "osinfo_win",  "name": "getSystemInfo",  "code": "proc getSystemInfo*(lpSystemInfo: LPSYSTEM_INFO) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemInfo\".}" },  { "module": "osinfo_win",  "name": "getSystemInfo",  "code": "proc getSystemInfo*(): TSYSTEM_INFO",  "desc": "Returns the SystemInfo" },  { "module": "osinfo_win",  "name": "getSystemMetrics",  "code": "proc getSystemMetrics*(nIndex: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetSystemMetrics\".}" },  { "module": "osinfo_win",  "name": "`$`",  "code": "proc `$`*(osvi: TVersionInfo): string",  "desc": "Turns a VersionInfo object, into a string" },  { "module": "osinfo_win",  "name": "getFileSize",  "code": "proc getFileSize*(file: string): BiggestInt" },  { "module": "osinfo_win",  "name": "getDiskFreeSpaceEx",  "code": "proc getDiskFreeSpaceEx*(lpDirectoryName: cstring; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes: var TFiletime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExA\".}" },  { "module": "osinfo_win",  "name": "getPartitionInfo",  "code": "proc getPartitionInfo*(partition: string): TPartitionInfo",  "desc": "Retrieves partition info, for example <tt class=\"docutils literal\"><span class=\"pre\">partition</span></tt> may be <tt class=\"docutils literal\"><span class=\"pre\">&quot;C:\\&quot;</span></tt>" },  { "module": "osproc",  "name": "quoteShellWindows",  "code": "proc quoteShellWindows*(s: string): string {.noSideEffect, rtl, extern: \"nosp$1\".}",  "desc": "Quote s, so it can be safely passed to Windows API. Based on Python's subprocess.list2cmdline See <a class=\"reference external\" href=\"http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\">http://msdn.microsoft.com/en-us/library/17w5ykft.aspx</a>" },  { "module": "osproc",  "name": "quoteShellPosix",  "code": "proc quoteShellPosix*(s: string): string {.noSideEffect, rtl, extern: \"nosp$1\".}",  "desc": "Quote s, so it can be safely passed to POSIX shell. Based on Python's pipes.quote" },  { "module": "osproc",  "name": "quoteShell",  "code": "proc quoteShell*(s: string): string {.noSideEffect, rtl, extern: \"nosp$1\".}",  "desc": "Quote s, so it can be safely passed to shell." },  { "module": "osproc",  "name": "execProcess",  "code": "proc execProcess*(command: string; args: openArray[string] = []; \u000A                  env: StringTableRef = nil; options: set[ProcessOption] = {\u000A    poStdErrToStdOut, poUsePath, poEvalCommand}): TaintedString {.rtl, \u000A    extern: \"nosp$1\", tags: [ExecIOEffect, ReadIOEffect].}",  "desc": "A convenience procedure that executes <tt class=\"docutils literal\"><span class=\"pre\">command</span></tt> with <tt class=\"docutils literal\"><span class=\"pre\">startProcess</span></tt> and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly." },  { "module": "osproc",  "name": "execCmd",  "code": "proc execCmd*(command: string): int {.rtl, extern: \"nosp$1\", \u000A                                      tags: [ExecIOEffect].}",  "desc": "Executes <tt class=\"docutils literal\"><span class=\"pre\">command</span></tt> and returns its error code. Standard input, output, error streams are inherited from the calling process. This operation is also often called <span id=\"system_1\">system</span>." },  { "module": "osproc",  "name": "startProcess",  "code": "proc startProcess*(command: string; workingDir: string = \"\"; \u000A                   args: openArray[string] = []; env: StringTableRef = nil; \u000A                   options: set[ProcessOption] = {poStdErrToStdOut}): Process {.\u000A    rtl, extern: \"nosp$1\", tags: [ExecIOEffect, ReadEnvEffect].}",  "desc": "<p>Starts a process. <cite>Command</cite> is the executable file, <cite>workingDir</cite> is the process's working directory. If <tt class=\"docutils literal\"><span class=\"pre\">workingDir == &quot;&quot;</span></tt> the current directory is used. <cite>args</cite> are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. <cite>args</cite> should not contain this argument! <cite>env</cite> is the environment that will be passed to the process. If <tt class=\"docutils literal\"><span class=\"pre\">env == nil</span></tt> the environment is inherited of the parent process. <cite>options</cite> are additional flags that may be passed to <cite>startProcess</cite>. See the documentation of <tt class=\"docutils literal\"><span class=\"pre\">TProcessOption</span></tt> for the meaning of these flags. You need to <cite>close</cite> the process when done.</p>\u000A<p>Note that you can't pass any <cite>args</cite> if you use the option <tt class=\"docutils literal\"><span class=\"pre\">poEvalCommand</span></tt>, which invokes the system shell to run the specified <cite>command</cite>. In this situation you have to concatenate manually the contents of <cite>args</cite> to <cite>command</cite> carefully escaping/quoting any special characters, since it will be passed <em>as is</em> to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invokation if possible as it leads to non portable software.</p>\u000A<p>Return value: The newly created process object. Nil is never returned, but <tt class=\"docutils literal\"><span class=\"pre\">EOS</span></tt> is raised in case of an error.</p>\u000A" },  { "module": "osproc",  "name": "startCmd",  "code": "proc startCmd*(command: string; \u000A               options: set[ProcessOption] = {poStdErrToStdOut, poUsePath}): Process {.\u000A    tags: [ExecIOEffect, ReadEnvEffect], deprecated.}",  "desc": "Deprecated - use <cite>startProcess</cite> directly." },  { "module": "osproc",  "name": "close",  "code": "proc close*(p: Process) {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "When the process has finished executing, cleanup related handles" },  { "module": "osproc",  "name": "suspend",  "code": "proc suspend*(p: Process) {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "Suspends the process <cite>p</cite>." },  { "module": "osproc",  "name": "resume",  "code": "proc resume*(p: Process) {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "Resumes the process <cite>p</cite>." },  { "module": "osproc",  "name": "terminate",  "code": "proc terminate*(p: Process) {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "Stop the process <cite>p</cite>. On Posix OSes the procedure sends <tt class=\"docutils literal\"><span class=\"pre\">SIGTERM</span></tt> to the process. On Windows the Win32 API function <tt class=\"docutils literal\"><span class=\"pre\">TerminateProcess()</span></tt> is called to stop the process." },  { "module": "osproc",  "name": "kill",  "code": "proc kill*(p: Process) {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "Kill the process <cite>p</cite>. On Posix OSes the procedure sends <tt class=\"docutils literal\"><span class=\"pre\">SIGKILL</span></tt> to the process. On Windows <tt class=\"docutils literal\"><span class=\"pre\">kill()</span></tt> is simply an alias for <tt class=\"docutils literal\"><span class=\"pre\">terminate()</span></tt>." },  { "module": "osproc",  "name": "running",  "code": "proc running*(p: Process): bool {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "Returns true iff the process <cite>p</cite> is still running. Returns immediately." },  { "module": "osproc",  "name": "processID",  "code": "proc processID*(p: Process): int {.rtl, extern: \"nosp$1\".}",  "desc": "returns <cite>p</cite>'s process ID." },  { "module": "osproc",  "name": "waitForExit",  "code": "proc waitForExit*(p: Process; timeout: int = - 1): int {.rtl, extern: \"nosp$1\", \u000A    tags: [].}",  "desc": "<p>waits for the process to finish and returns <cite>p</cite>'s error code.</p>\u000A<p><strong>Warning</strong>: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</p>\u000A" },  { "module": "osproc",  "name": "peekExitCode",  "code": "proc peekExitCode*(p: Process): int {.tags: [].}",  "desc": "return -1 if the process is still running. Otherwise the process' exit code" },  { "module": "osproc",  "name": "inputStream",  "code": "proc inputStream*(p: Process): Stream {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s input stream for writing to.</p>\u000A<p><strong>Warning</strong>: The returned <cite>PStream</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "outputStream",  "code": "proc outputStream*(p: Process): Stream {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s output stream for reading from.</p>\u000A<p><strong>Warning</strong>: The returned <cite>PStream</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "errorStream",  "code": "proc errorStream*(p: Process): Stream {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s error stream for reading from.</p>\u000A<p><strong>Warning</strong>: The returned <cite>PStream</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "inputHandle",  "code": "proc inputHandle*(p: Process): FileHandle {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s input file handle for writing to.</p>\u000A<p><strong>Warning</strong>: The returned <cite>TFileHandle</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "outputHandle",  "code": "proc outputHandle*(p: Process): FileHandle {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s output file handle for reading from.</p>\u000A<p><strong>Warning</strong>: The returned <cite>TFileHandle</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "errorHandle",  "code": "proc errorHandle*(p: Process): FileHandle {.rtl, extern: \"nosp$1\", tags: [].}",  "desc": "<p>returns <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>'s error file handle for reading from.</p>\u000A<p><strong>Warning</strong>: The returned <cite>TFileHandle</cite> should not be closed manually as it is closed when closing the PProcess <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt>.</p>\u000A" },  { "module": "osproc",  "name": "countProcessors",  "code": "proc countProcessors*(): int {.rtl, extern: \"nosp$1\".}",  "desc": "returns the numer of the processors/cores the machine has. Returns 0 if it cannot be detected." },  { "module": "osproc",  "name": "execProcesses",  "code": "proc execProcesses*(cmds: openArray[string]; \u000A                    options = {poStdErrToStdOut, poParentStreams}; \u000A                    n = countProcessors(); beforeRunEvent: proc (idx: int) = nil): int {.\u000A    rtl, extern: \"nosp$1\", \u000A    tags: [ExecIOEffect, TimeEffect, ReadEnvEffect, RootEffect].}",  "desc": "executes the commands <cite>cmds</cite> in parallel. Creates <cite>n</cite> processes that execute in parallel. The highest return value of all processes is returned. Runs <cite>beforeRunEvent</cite> before running each command." },  { "module": "osproc",  "name": "select",  "code": "proc select*(readfds: var seq[Process]; timeout = 500): int",  "desc": "<p><cite>select</cite> with a sensible Nim interface. <cite>timeout</cite> is in miliseconds. Specify -1 for no timeout. Returns the number of processes that are ready to read from. The processes that are ready to be read from are removed from <cite>readfds</cite>.</p>\u000A<p><strong>Warning</strong>: This function may give unexpected or completely wrong results on Windows.</p>\u000A" },  { "module": "osproc",  "name": "execCmdEx",  "code": "proc execCmdEx*(command: string; \u000A                options: set[ProcessOption] = {poStdErrToStdOut, poUsePath}): tuple[\u000A    output: TaintedString, exitCode: int] {.tags: [ExecIOEffect, ReadIOEffect], \u000A    gcsafe.}",  "desc": "a convenience proc that runs the <cite>command</cite>, grabs all its output and exit code and returns both." },  { "module": "parsecfg",  "name": "open",  "code": "proc open*(c: var CfgParser; input: Stream; filename: string; lineOffset = 0) {.\u000A    rtl, extern: \"npc$1\".}",  "desc": "initializes the parser with an input stream. <cite>Filename</cite> is only used for nice error messages. <cite>lineOffset</cite> can be used to influence the line number information in the generated error messages." },  { "module": "parsecfg",  "name": "close",  "code": "proc close*(c: var CfgParser) {.rtl, extern: \"npc$1\".}",  "desc": "closes the parser <cite>c</cite> and its associated input stream." },  { "module": "parsecfg",  "name": "getColumn",  "code": "proc getColumn*(c: CfgParser): int {.rtl, extern: \"npc$1\".}",  "desc": "get the current column the parser has arrived at." },  { "module": "parsecfg",  "name": "getLine",  "code": "proc getLine*(c: CfgParser): int {.rtl, extern: \"npc$1\".}",  "desc": "get the current line the parser has arrived at." },  { "module": "parsecfg",  "name": "getFilename",  "code": "proc getFilename*(c: CfgParser): string {.rtl, extern: \"npc$1\".}",  "desc": "get the filename of the file that the parser processes." },  { "module": "parsecfg",  "name": "errorStr",  "code": "proc errorStr*(c: CfgParser; msg: string): string {.rtl, extern: \"npc$1\".}",  "desc": "returns a properly formated error message containing current line and column information." },  { "module": "parsecfg",  "name": "warningStr",  "code": "proc warningStr*(c: CfgParser; msg: string): string {.rtl, extern: \"npc$1\".}",  "desc": "returns a properly formated warning message containing current line and column information." },  { "module": "parsecfg",  "name": "ignoreMsg",  "code": "proc ignoreMsg*(c: CfgParser; e: CfgEvent): string {.rtl, extern: \"npc$1\".}",  "desc": "returns a properly formated warning message containing that an entry is ignored." },  { "module": "parsecfg",  "name": "next",  "code": "proc next*(c: var CfgParser): CfgEvent {.rtl, extern: \"npc$1\".}",  "desc": "retrieves the first/next event. This controls the parser." },  { "module": "parsecsv",  "name": "open",  "code": "proc open*(my: var CsvParser; input: Stream; filename: string; separator = ','; \u000A           quote = '\\\"'; escape = '\\0'; skipInitialSpace = false)",  "desc": "initializes the parser with an input stream. <cite>Filename</cite> is only used for nice error messages. The parser's behaviour can be controlled by the diverse optional parameters:<ul class=\"simple\"><li><cite>separator</cite>: character used to separate fields</li>\u000A<li><cite>quote</cite>: Used to quote fields containing special characters like <cite>separator</cite>, <cite>quote</cite> or new-line characters. '0' disables the parsing of quotes.</li>\u000A<li><cite>escape</cite>: removes any special meaning from the following character; '0' disables escaping; if escaping is disabled and <cite>quote</cite> is not '0', two <cite>quote</cite> characters are parsed one literal <cite>quote</cite> character.</li>\u000A<li><cite>skipInitialSpace</cite>: If true, whitespace immediately following the <cite>separator</cite> is ignored.</li>\u000A</ul>\u000A" },  { "module": "parsecsv",  "name": "processedRows",  "code": "proc processedRows*(my: var CsvParser): int",  "desc": "returns number of the processed rows" },  { "module": "parsecsv",  "name": "readRow",  "code": "proc readRow*(my: var CsvParser; columns = 0): bool",  "desc": "reads the next row; if <cite>columns</cite> &gt; 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true." },  { "module": "parsecsv",  "name": "close",  "code": "proc close*(my: var CsvParser) {.inline.}",  "desc": "closes the parser <cite>my</cite> and its associated input stream." },  { "module": "parseopt",  "name": "initOptParser",  "code": "proc initOptParser*(cmdline = \"\"): OptParser",  "desc": "inits the option parser. If <tt class=\"docutils literal\"><span class=\"pre\">cmdline == &quot;&quot;</span></tt>, the real command line (as provided by the <tt class=\"docutils literal\"><span class=\"pre\">OS</span></tt> module) is taken." },  { "module": "parseopt",  "name": "next",  "code": "proc next*(p: var OptParser) {.rtl, extern: \"npo$1\".}",  "desc": "parses the first or next option; <tt class=\"docutils literal\"><span class=\"pre\">p.kind</span></tt> describes what token has been parsed. <tt class=\"docutils literal\"><span class=\"pre\">p.key</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">p.val</span></tt> are set accordingly." },  { "module": "parseopt",  "name": "cmdLineRest",  "code": "proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: \"npo$1\".}",  "desc": "retrieves the rest of the command line that has not been parsed yet." },  { "module": "parseopt",  "name": "getopt",  "code": "iterator getopt*(): tuple[kind: CmdLineKind, key, val: TaintedString]",  "desc": "This is an convenience iterator for iterating over the command line. This uses the TOptParser object. Example:<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">filename</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">kind</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">key</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">val</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">getopt</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Keyword\">case</span> <span class=\"Identifier\">kind</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdArgument</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">filename</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">key</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdLongOption</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">cmdShortOption</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">case</span> <span class=\"Identifier\">key</span>\u000A    <span class=\"Keyword\">of</span> <span class=\"StringLit\">&quot;help&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;h&quot;</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">writeHelp</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Keyword\">of</span> <span class=\"StringLit\">&quot;version&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;v&quot;</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">writeVersion</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdEnd</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span> <span class=\"Comment\"># cannot happen</span>\u000A<span class=\"Keyword\">if</span> <span class=\"Identifier\">filename</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># no filename has been given, so we show the help:</span>\u000A  <span class=\"Identifier\">writeHelp</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "parseopt2",  "name": "initOptParser",  "code": "proc initOptParser*(cmdline: seq[string]): OptParser {.rtl.}",  "desc": "Initalizes option parses with cmdline. cmdline should not contain argument 0 - program name. If cmdline == nil default to current command line arguments." },  { "module": "parseopt2",  "name": "initOptParser",  "code": "proc initOptParser*(cmdline: string): OptParser {.rtl, deprecated.}",  "desc": "Initalizes option parses with cmdline. Splits cmdline in on spaces and calls initOptParser(openarray[string]) Do not use." },  { "module": "parseopt2",  "name": "initOptParser",  "code": "proc initOptParser*(): OptParser",  "desc": "Initializes option parser from current command line arguments." },  { "module": "parseopt2",  "name": "next",  "code": "proc next*(p: var OptParser) {.rtl, extern: \"npo$1\".}" },  { "module": "parseopt2",  "name": "cmdLineRest",  "code": "proc cmdLineRest*(p: OptParser): TaintedString {.rtl, extern: \"npo$1\", \u000A    deprecated.}",  "desc": "Returns part of command line string that has not been parsed yet. Do not use - does not correctly handle whitespace." },  { "module": "parseopt2",  "name": "getopt",  "code": "iterator getopt*(): GetoptResult",  "desc": "This is an convenience iterator for iterating over the command line. This uses the OptParser object. Example:<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">filename</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">kind</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">key</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">val</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">getopt</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Keyword\">case</span> <span class=\"Identifier\">kind</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdArgument</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">filename</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">key</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdLongOption</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">cmdShortOption</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">case</span> <span class=\"Identifier\">key</span>\u000A    <span class=\"Keyword\">of</span> <span class=\"StringLit\">&quot;help&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;h&quot;</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">writeHelp</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Keyword\">of</span> <span class=\"StringLit\">&quot;version&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;v&quot;</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">writeVersion</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Keyword\">of</span> <span class=\"Identifier\">cmdEnd</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span> <span class=\"Comment\"># cannot happen</span>\u000A<span class=\"Keyword\">if</span> <span class=\"Identifier\">filename</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># no filename has been given, so we show the help:</span>\u000A  <span class=\"Identifier\">writeHelp</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "parsesql",  "name": "len",  "code": "proc len*(n: SqlNode): int" },  { "module": "parsesql",  "name": "add",  "code": "proc add*(father, n: SqlNode)" },  { "module": "parsesql",  "name": "parseSQL",  "code": "proc parseSQL*(input: Stream; filename: string): SqlNode",  "desc": "parses the SQL from <cite>input</cite> into an AST and returns the AST. <cite>filename</cite> is only used for error messages. Syntax errors raise an <cite>EInvalidSql</cite> exception." },  { "module": "parsesql",  "name": "renderSQL",  "code": "proc renderSQL*(n: SqlNode): string",  "desc": "Converts an SQL abstract syntax tree to its string representation." },  { "module": "parseurl",  "name": "parseUrl",  "code": "proc parseUrl*(url: string): Url {.deprecated.}" },  { "module": "parseurl",  "name": "`$`",  "code": "proc `$`*(u: Url): string {.deprecated.}",  "desc": "turns the URL <cite>u</cite> into its string representation." },  { "module": "parseutils",  "name": "parseHex",  "code": "proc parseHex*(s: string; number: var int; start = 0): int {.rtl, \u000A    extern: \"npuParseHex\", noSideEffect.}",  "desc": "<p>Parses a hexadecimal number and stores its value in <tt class=\"docutils literal\"><span class=\"pre\">number</span></tt>.</p>\u000A<p>Returns the number of the parsed characters or 0 in case of an error. This proc is sensitive to the already existing value of <tt class=\"docutils literal\"><span class=\"pre\">number</span></tt> and will likely not do what you want unless you make sure <tt class=\"docutils literal\"><span class=\"pre\">number</span></tt> is zero. You can use this feature to <em>chain</em> calls, though the result int will quickly overflow. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">value</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">0</span>\u000A<span class=\"Keyword\">discard</span> <span class=\"Identifier\">parseHex</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;0x38&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">value</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">56</span>\u000A<span class=\"Keyword\">discard</span> <span class=\"Identifier\">parseHex</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;0x34&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">value</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">56</span> <span class=\"Operator\">*</span> <span class=\"DecNumber\">256</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">52</span>\u000A<span class=\"Identifier\">value</span> <span class=\"Operator\">=</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">1</span>\u000A<span class=\"Keyword\">discard</span> <span class=\"Identifier\">parseHex</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;0x38&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">value</span> <span class=\"Operator\">==</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">200</span></pre>" },  { "module": "parseutils",  "name": "parseOct",  "code": "proc parseOct*(s: string; number: var int; start = 0): int {.rtl, \u000A    extern: \"npuParseOct\", noSideEffect.}",  "desc": "parses an octal number and stores its value in <tt class=\"docutils literal\"><span class=\"pre\">number</span></tt>. Returns the number of the parsed characters or 0 in case of an error." },  { "module": "parseutils",  "name": "parseIdent",  "code": "proc parseIdent*(s: string; ident: var string; start = 0): int",  "desc": "parses an identifier and stores it in <tt class=\"docutils literal\"><span class=\"pre\">ident</span></tt>. Returns the number of the parsed characters or 0 in case of an error." },  { "module": "parseutils",  "name": "parseIdent",  "code": "proc parseIdent*(s: string; start = 0): string",  "desc": "parses an identifier and stores it in <tt class=\"docutils literal\"><span class=\"pre\">ident</span></tt>. Returns the parsed identifier or an empty string in case of an error." },  { "module": "parseutils",  "name": "parseToken",  "code": "proc parseToken*(s: string; token: var string; validChars: set[char]; start = 0): int {.\u000A    inline, deprecated.}",  "desc": "<p>parses a token and stores it in <tt class=\"docutils literal\"><span class=\"pre\">token</span></tt>. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in <cite>validChars</cite>.</p>\u000A<p><strong>Deprecated since version 0.8.12</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">parseWhile</span></tt> instead.</p>\u000A" },  { "module": "parseutils",  "name": "skipWhitespace",  "code": "proc skipWhitespace*(s: string; start = 0): int {.inline.}",  "desc": "skips the whitespace starting at <tt class=\"docutils literal\"><span class=\"pre\">s[start]</span></tt>. Returns the number of skipped characters." },  { "module": "parseutils",  "name": "skip",  "code": "proc skip*(s, token: string; start = 0): int {.inline.}",  "desc": "skips the <cite>token</cite> starting at <tt class=\"docutils literal\"><span class=\"pre\">s[start]</span></tt>. Returns the length of <cite>token</cite> or 0 if there was no <cite>token</cite> at <tt class=\"docutils literal\"><span class=\"pre\">s[start]</span></tt>." },  { "module": "parseutils",  "name": "skipIgnoreCase",  "code": "proc skipIgnoreCase*(s, token: string; start = 0): int",  "desc": "same as <cite>skip</cite> but case is ignored for token matching." },  { "module": "parseutils",  "name": "skipUntil",  "code": "proc skipUntil*(s: string; until: set[char]; start = 0): int {.inline.}",  "desc": "Skips all characters until one char from the set <cite>until</cite> is found or the end is reached. Returns number of characters skipped." },  { "module": "parseutils",  "name": "skipUntil",  "code": "proc skipUntil*(s: string; until: char; start = 0): int {.inline.}",  "desc": "Skips all characters until the char <cite>until</cite> is found or the end is reached. Returns number of characters skipped." },  { "module": "parseutils",  "name": "skipWhile",  "code": "proc skipWhile*(s: string; toSkip: set[char]; start = 0): int {.inline.}",  "desc": "Skips all characters while one char from the set <cite>token</cite> is found. Returns number of characters skipped." },  { "module": "parseutils",  "name": "parseUntil",  "code": "proc parseUntil*(s: string; token: var string; until: set[char]; start = 0): int {.\u000A    inline.}",  "desc": "parses a token and stores it in <tt class=\"docutils literal\"><span class=\"pre\">token</span></tt>. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin <cite>until</cite>. " },  { "module": "parseutils",  "name": "parseUntil",  "code": "proc parseUntil*(s: string; token: var string; until: char; start = 0): int {.\u000A    inline.}",  "desc": "parses a token and stores it in <tt class=\"docutils literal\"><span class=\"pre\">token</span></tt>. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the <cite>until</cite> character." },  { "module": "parseutils",  "name": "parseWhile",  "code": "proc parseWhile*(s: string; token: var string; validChars: set[char]; start = 0): int {.\u000A    inline.}",  "desc": "parses a token and stores it in <tt class=\"docutils literal\"><span class=\"pre\">token</span></tt>. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in <cite>validChars</cite>. " },  { "module": "parseutils",  "name": "captureBetween",  "code": "proc captureBetween*(s: string; first: char; second = '\\0'; start = 0): string",  "desc": "Finds the first occurence of <tt class=\"docutils literal\"><span class=\"pre\">first</span></tt>, then returns everything from there up to <tt class=\"docutils literal\"><span class=\"pre\">second``(if ``second</span></tt> is '0', then <tt class=\"docutils literal\"><span class=\"pre\">first</span></tt> is used)." },  { "module": "parseutils",  "name": "parseBiggestInt",  "code": "proc parseBiggestInt*(s: string; number: var BiggestInt; start = 0): int {.rtl, \u000A    extern: \"npuParseBiggestInt\", noSideEffect.}",  "desc": "parses an integer starting at <cite>start</cite> and stores the value into <cite>number</cite>. Result is the number of processed chars or 0 if there is no integer. <cite>EOverflow</cite> is raised if an overflow occurs." },  { "module": "parseutils",  "name": "parseInt",  "code": "proc parseInt*(s: string; number: var int; start = 0): int {.rtl, \u000A    extern: \"npuParseInt\", noSideEffect.}",  "desc": "parses an integer starting at <cite>start</cite> and stores the value into <cite>number</cite>. Result is the number of processed chars or 0 if there is no integer. <cite>EOverflow</cite> is raised if an overflow occurs." },  { "module": "parseutils",  "name": "parseBiggestFloat",  "code": "proc parseBiggestFloat*(s: string; number: var BiggestFloat; start = 0): int {.\u000A    magic: \"ParseBiggestFloat\", importc: \"nimParseBiggestFloat\", noSideEffect.}",  "desc": "parses a float starting at <cite>start</cite> and stores the value into <cite>number</cite>. Result is the number of processed chars or 0 if a parsing error occurred." },  { "module": "parseutils",  "name": "parseFloat",  "code": "proc parseFloat*(s: string; number: var float; start = 0): int {.rtl, \u000A    extern: \"npuParseFloat\", noSideEffect.}",  "desc": "parses a float starting at <cite>start</cite> and stores the value into <cite>number</cite>. Result is the number of processed chars or 0 if there occured a parsing error." },  { "module": "parseutils",  "name": "interpolatedFragments",  "code": "iterator interpolatedFragments*(s: string): tuple[kind: InterpolatedKind, \u000A    value: string]",  "desc": "<p>Tokenizes the string <cite>s</cite> into substrings for interpolation purposes.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">k</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">v</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">interpolatedFragments</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  $this is ${an  example}  $$&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;(&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">k</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;, </span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\">&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">v</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\">)&quot;</span></pre><p>Results in:</p>\u000A<pre><span class=\"Punctuation\">(</span><span class=\"Identifier\">ikString</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;  &quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"Identifier\">ikExpr</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;this&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"Identifier\">ikString</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot; is &quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"Identifier\">ikExpr</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;an  example&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"Identifier\">ikString</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;  &quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"Identifier\">ikDollar</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;$&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "parsexml",  "name": "open",  "code": "proc open*(my: var XmlParser; input: Stream; filename: string; \u000A           options: set[XmlParseOption] = {})",  "desc": "initializes the parser with an input stream. <cite>Filename</cite> is only used for nice error messages. The parser's behaviour can be controlled by the <cite>options</cite> parameter: If <cite>options</cite> contains <tt class=\"docutils literal\"><span class=\"pre\">reportWhitespace</span></tt> a whitespace token is reported as an <tt class=\"docutils literal\"><span class=\"pre\">xmlWhitespace</span></tt> event. If <cite>options</cite> contains <tt class=\"docutils literal\"><span class=\"pre\">reportComments</span></tt> a comment token is reported as an <tt class=\"docutils literal\"><span class=\"pre\">xmlComment</span></tt> event. " },  { "module": "parsexml",  "name": "close",  "code": "proc close*(my: var XmlParser) {.inline.}",  "desc": "closes the parser <cite>my</cite> and its associated input stream." },  { "module": "parsexml",  "name": "kind",  "code": "proc kind*(my: XmlParser): XmlEventKind {.inline.}",  "desc": "returns the current event type for the XML parser" },  { "module": "parsexml",  "name": "charData",  "code": "proc charData*(my: XmlParser): string {.inline.}",  "desc": "returns the character data for the events: <tt class=\"docutils literal\"><span class=\"pre\">xmlCharData</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlWhitespace</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlComment</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlCData</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlSpecial</span></tt>" },  { "module": "parsexml",  "name": "elementName",  "code": "proc elementName*(my: XmlParser): string {.inline.}",  "desc": "returns the element name for the events: <tt class=\"docutils literal\"><span class=\"pre\">xmlElementStart</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlElementEnd</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">xmlElementOpen</span></tt>" },  { "module": "parsexml",  "name": "entityName",  "code": "proc entityName*(my: XmlParser): string {.inline.}",  "desc": "returns the entity name for the event: <tt class=\"docutils literal\"><span class=\"pre\">xmlEntity</span></tt>" },  { "module": "parsexml",  "name": "attrKey",  "code": "proc attrKey*(my: XmlParser): string {.inline.}",  "desc": "returns the attribute key for the event <tt class=\"docutils literal\"><span class=\"pre\">xmlAttribute</span></tt>" },  { "module": "parsexml",  "name": "attrValue",  "code": "proc attrValue*(my: XmlParser): string {.inline.}",  "desc": "returns the attribute value for the event <tt class=\"docutils literal\"><span class=\"pre\">xmlAttribute</span></tt>" },  { "module": "parsexml",  "name": "piName",  "code": "proc piName*(my: XmlParser): string {.inline.}",  "desc": "returns the processing instruction name for the event <tt class=\"docutils literal\"><span class=\"pre\">xmlPI</span></tt>" },  { "module": "parsexml",  "name": "piRest",  "code": "proc piRest*(my: XmlParser): string {.inline.}",  "desc": "returns the rest of the processing instruction for the event <tt class=\"docutils literal\"><span class=\"pre\">xmlPI</span></tt>" },  { "module": "parsexml",  "name": "rawData",  "code": "proc rawData*(my: XmlParser): string {.inline.}",  "desc": "returns the underlying 'data' string by reference. This is only used for speed hacks." },  { "module": "parsexml",  "name": "rawData2",  "code": "proc rawData2*(my: XmlParser): string {.inline.}",  "desc": "returns the underlying second 'data' string by reference. This is only used for speed hacks." },  { "module": "parsexml",  "name": "getColumn",  "code": "proc getColumn*(my: XmlParser): int {.inline.}",  "desc": "get the current column the parser has arrived at." },  { "module": "parsexml",  "name": "getLine",  "code": "proc getLine*(my: XmlParser): int {.inline.}",  "desc": "get the current line the parser has arrived at." },  { "module": "parsexml",  "name": "getFilename",  "code": "proc getFilename*(my: XmlParser): string {.inline.}",  "desc": "get the filename of the file that the parser processes." },  { "module": "parsexml",  "name": "errorMsg",  "code": "proc errorMsg*(my: XmlParser): string",  "desc": "returns a helpful error message for the event <tt class=\"docutils literal\"><span class=\"pre\">xmlError</span></tt>" },  { "module": "parsexml",  "name": "errorMsgExpected",  "code": "proc errorMsgExpected*(my: XmlParser; tag: string): string",  "desc": "returns an error message &quot;&lt;tag&gt; expected&quot; in the same format as the other error messages " },  { "module": "parsexml",  "name": "errorMsg",  "code": "proc errorMsg*(my: XmlParser; msg: string): string",  "desc": "returns an error message with text <cite>msg</cite> in the same format as the other error messages " },  { "module": "parsexml",  "name": "next",  "code": "proc next*(my: var XmlParser)",  "desc": "retrieves the first/next event. This controls the parser." },  { "module": "pcre",  "name": "compile",  "code": "proc compile*(a2: cstring; a3: cint; a4: ptr cstring; a5: ptr cint; a6: ptr char): ptr TPcre {.\u000A    cdecl, importc: \"pcre_compile\", pcreImport.}" },  { "module": "pcre",  "name": "compile2",  "code": "proc compile2*(a2: cstring; a3: cint; a4: ptr cint; a5: ptr cstring; \u000A               a6: ptr cint; a7: ptr char): ptr TPcre {.cdecl, \u000A    importc: \"pcre_compile2\", pcreImport.}" },  { "module": "pcre",  "name": "config",  "code": "proc config*(a2: cint; a3: pointer): cint {.cdecl, importc: \"pcre_config\", \u000A    pcreImport.}" },  { "module": "pcre",  "name": "copy_named_substring",  "code": "proc copy_named_substring*(a2: ptr TPcre; a3: cstring; a4: ptr cint; a5: cint; \u000A                           a6: cstring; a7: cstring; a8: cint): cint {.cdecl, \u000A    importc: \"pcre_copy_named_substring\", pcreImport.}" },  { "module": "pcre",  "name": "copy_substring",  "code": "proc copy_substring*(a2: cstring; a3: ptr cint; a4: cint; a5: cint; a6: cstring; \u000A                     a7: cint): cint {.cdecl, importc: \"pcre_copy_substring\", \u000A                                       pcreImport.}" },  { "module": "pcre",  "name": "dfa_exec",  "code": "proc dfa_exec*(a2: ptr TPcre; a3: ptr TExtra; a4: cstring; a5: cint; a6: cint; \u000A               a7: cint; a8: ptr cint; a9: cint; a10: ptr cint; a11: cint): cint {.\u000A    cdecl, importc: \"pcre_dfa_exec\", pcreImport.}" },  { "module": "pcre",  "name": "exec",  "code": "proc exec*(a2: ptr TPcre; a3: ptr TExtra; a4: cstring; a5: cint; a6: cint; \u000A           a7: cint; a8: ptr cint; a9: cint): cint {.cdecl, \u000A    importc: \"pcre_exec\", pcreImport.}" },  { "module": "pcre",  "name": "free_substring",  "code": "proc free_substring*(a2: cstring) {.cdecl, importc: \"pcre_free_substring\", \u000A                                    pcreImport.}" },  { "module": "pcre",  "name": "free_substring_list",  "code": "proc free_substring_list*(a2: cstringArray) {.cdecl, \u000A    importc: \"pcre_free_substring_list\", pcreImport.}" },  { "module": "pcre",  "name": "fullinfo",  "code": "proc fullinfo*(a2: ptr TPcre; a3: ptr TExtra; a4: cint; a5: pointer): cint {.\u000A    cdecl, importc: \"pcre_fullinfo\", pcreImport.}" },  { "module": "pcre",  "name": "get_named_substring",  "code": "proc get_named_substring*(a2: ptr TPcre; a3: cstring; a4: ptr cint; a5: cint; \u000A                          a6: cstring; a7: cstringArray): cint {.cdecl, \u000A    importc: \"pcre_get_named_substring\", pcreImport.}" },  { "module": "pcre",  "name": "get_stringnumber",  "code": "proc get_stringnumber*(a2: ptr TPcre; a3: cstring): cint {.cdecl, \u000A    importc: \"pcre_get_stringnumber\", pcreImport.}" },  { "module": "pcre",  "name": "get_stringtable_entries",  "code": "proc get_stringtable_entries*(a2: ptr TPcre; a3: cstring; a4: cstringArray; \u000A                              a5: cstringArray): cint {.cdecl, \u000A    importc: \"pcre_get_stringtable_entries\", pcreImport.}" },  { "module": "pcre",  "name": "get_substring",  "code": "proc get_substring*(a2: cstring; a3: ptr cint; a4: cint; a5: cint; \u000A                    a6: cstringArray): cint {.cdecl, \u000A    importc: \"pcre_get_substring\", pcreImport.}" },  { "module": "pcre",  "name": "get_substring_list",  "code": "proc get_substring_list*(a2: cstring; a3: ptr cint; a4: cint; \u000A                         a5: ptr cstringArray): cint {.cdecl, \u000A    importc: \"pcre_get_substring_list\", pcreImport.}" },  { "module": "pcre",  "name": "maketables",  "code": "proc maketables*(): ptr char {.cdecl, importc: \"pcre_maketables\", pcreImport.}" },  { "module": "pcre",  "name": "refcount",  "code": "proc refcount*(a2: ptr TPcre; a3: cint): cint {.cdecl, importc: \"pcre_refcount\", \u000A    pcreImport.}" },  { "module": "pcre",  "name": "study",  "code": "proc study*(a2: ptr TPcre; a3: cint; a4: var cstring): ptr TExtra {.cdecl, \u000A    importc: \"pcre_study\", pcreImport.}" },  { "module": "pcre",  "name": "version",  "code": "proc version*(): cstring {.cdecl, importc: \"pcre_version\", pcreImport.}" },  { "module": "pcre",  "name": "pattern_to_host_byte_order",  "code": "proc pattern_to_host_byte_order*(a2: ptr TPcre; a3: ptr TExtra; a4: ptr char): cint {.\u000A    cdecl, importc: \"pcre_pattern_to_host_byte_order\", pcreImport.}" },  { "module": "pcre",  "name": "jit_stack_alloc",  "code": "proc jit_stack_alloc*(a2: cint; a3: cint): ptr Tjit_stack {.cdecl, \u000A    importc: \"pcre_jit_stack_alloc\", pcreImport.}" },  { "module": "pcre",  "name": "jit_stack_free",  "code": "proc jit_stack_free*(a2: ptr Tjit_stack) {.cdecl, \u000A    importc: \"pcre_jit_stack_free\", pcreImport.}" },  { "module": "pcre",  "name": "assign_jit_stack",  "code": "proc assign_jit_stack*(a2: ptr TExtra; a3: TJitCallback; a4: pointer) {.cdecl, \u000A    importc: \"pcre_assign_jit_stack\", pcreImport.}" },  { "module": "pdcurses",  "name": "BUTTON_CHANGED",  "code": "template BUTTON_CHANGED*(x: expr): expr" },  { "module": "pdcurses",  "name": "BUTTON_STATUS",  "code": "template BUTTON_STATUS*(x: expr): expr" },  { "module": "pdcurses",  "name": "ACS_PICK",  "code": "template ACS_PICK*(w, n: expr): expr" },  { "module": "pdcurses",  "name": "KEY_F",  "code": "template KEY_F*(n: expr): expr" },  { "module": "pdcurses",  "name": "COLOR_PAIR",  "code": "template COLOR_PAIR*(n: expr): expr" },  { "module": "pdcurses",  "name": "PAIR_NUMBER",  "code": "template PAIR_NUMBER*(n: expr): expr" },  { "module": "pdcurses",  "name": "addch",  "code": "proc addch*(a2: cunsignedlong): cint {.extdecl, importc: \"addch\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addchnstr",  "code": "proc addchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"addchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addchstr",  "code": "proc addchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"addchstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addnstr",  "code": "proc addnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"addnstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addstr",  "code": "proc addstr*(a2: cstring): cint {.extdecl, importc: \"addstr\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attroff",  "code": "proc attroff*(a2: cunsignedlong): cint {.extdecl, importc: \"attroff\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attron",  "code": "proc attron*(a2: cunsignedlong): cint {.extdecl, importc: \"attron\", \u000A                                        dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attrset",  "code": "proc attrset*(a2: cunsignedlong): cint {.extdecl, importc: \"attrset\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attr_get",  "code": "proc attr_get*(a2: ptr cunsignedlong; a3: ptr cshort; a4: pointer): cint {.\u000A    extdecl, importc: \"attr_get\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attr_off",  "code": "proc attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl, \u000A    importc: \"attr_off\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attr_on",  "code": "proc attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl, \u000A    importc: \"attr_on\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "attr_set",  "code": "proc attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl, \u000A    importc: \"attr_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "baudrate",  "code": "proc baudrate*(): cint {.extdecl, importc: \"baudrate\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "beep",  "code": "proc beep*(): cint {.extdecl, importc: \"beep\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "bkgd",  "code": "proc bkgd*(a2: cunsignedlong): cint {.extdecl, importc: \"bkgd\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "bkgdset",  "code": "proc bkgdset*(a2: cunsignedlong) {.extdecl, importc: \"bkgdset\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "border",  "code": "proc border*(a2: cunsignedlong; a3: cunsignedlong; a4: cunsignedlong; \u000A             a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong; \u000A             a8: cunsignedlong; a9: cunsignedlong): cint {.extdecl, \u000A    importc: \"border\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "box",  "code": "proc box*(a2: ptr TWINDOW; a3: cunsignedlong; a4: cunsignedlong): cint {.\u000A    extdecl, importc: \"box\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "can_change_color",  "code": "proc can_change_color*(): cunsignedchar {.extdecl, importc: \"can_change_color\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "cbreak",  "code": "proc cbreak*(): cint {.extdecl, importc: \"cbreak\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "chgat",  "code": "proc chgat*(a2: cint; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.\u000A    extdecl, importc: \"chgat\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "clearok",  "code": "proc clearok*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"clearok\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "clear",  "code": "proc clear*(): cint {.extdecl, importc: \"clear\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "clrtobot",  "code": "proc clrtobot*(): cint {.extdecl, importc: \"clrtobot\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "clrtoeol",  "code": "proc clrtoeol*(): cint {.extdecl, importc: \"clrtoeol\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "color_content",  "code": "proc color_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort; a5: ptr cshort): cint {.\u000A    extdecl, importc: \"color_content\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "color_set",  "code": "proc color_set*(a2: cshort; a3: pointer): cint {.extdecl, importc: \"color_set\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "copywin",  "code": "proc copywin*(a2: ptr TWINDOW; a3: ptr TWINDOW; a4: cint; a5: cint; a6: cint; \u000A              a7: cint; a8: cint; a9: cint; a10: cint): cint {.extdecl, \u000A    importc: \"copywin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "curs_set",  "code": "proc curs_set*(a2: cint): cint {.extdecl, importc: \"curs_set\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "def_prog_mode",  "code": "proc def_prog_mode*(): cint {.extdecl, importc: \"def_prog_mode\", \u000A                              dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "def_shell_mode",  "code": "proc def_shell_mode*(): cint {.extdecl, importc: \"def_shell_mode\", \u000A                               dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "delay_output",  "code": "proc delay_output*(a2: cint): cint {.extdecl, importc: \"delay_output\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "delch",  "code": "proc delch*(): cint {.extdecl, importc: \"delch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "deleteln",  "code": "proc deleteln*(): cint {.extdecl, importc: \"deleteln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "delscreen",  "code": "proc delscreen*(a2: ptr TSCREEN) {.extdecl, importc: \"delscreen\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "delwin",  "code": "proc delwin*(a2: ptr TWINDOW): cint {.extdecl, importc: \"delwin\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "derwin",  "code": "proc derwin*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr TWINDOW {.\u000A    extdecl, importc: \"derwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "doupdate",  "code": "proc doupdate*(): cint {.extdecl, importc: \"doupdate\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "dupwin",  "code": "proc dupwin*(a2: ptr TWINDOW): ptr TWINDOW {.extdecl, importc: \"dupwin\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "echochar",  "code": "proc echochar*(a2: cunsignedlong): cint {.extdecl, importc: \"echochar\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "echo",  "code": "proc echo*(): cint {.extdecl, importc: \"echo\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "endwin",  "code": "proc endwin*(): cint {.extdecl, importc: \"endwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "erasechar",  "code": "proc erasechar*(): char {.extdecl, importc: \"erasechar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "erase",  "code": "proc erase*(): cint {.extdecl, importc: \"erase\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "filter",  "code": "proc filter*() {.extdecl, importc: \"filter\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "flash",  "code": "proc flash*(): cint {.extdecl, importc: \"flash\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "flushinp",  "code": "proc flushinp*(): cint {.extdecl, importc: \"flushinp\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getbkgd",  "code": "proc getbkgd*(a2: ptr TWINDOW): cunsignedlong {.extdecl, importc: \"getbkgd\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getnstr",  "code": "proc getnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"getnstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getstr",  "code": "proc getstr*(a2: cstring): cint {.extdecl, importc: \"getstr\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getwin",  "code": "proc getwin*(a2: File): ptr TWINDOW {.extdecl, importc: \"getwin\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "halfdelay",  "code": "proc halfdelay*(a2: cint): cint {.extdecl, importc: \"halfdelay\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "has_colors",  "code": "proc has_colors*(): cunsignedchar {.extdecl, importc: \"has_colors\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "has_ic",  "code": "proc has_ic*(): cunsignedchar {.extdecl, importc: \"has_ic\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "has_il",  "code": "proc has_il*(): cunsignedchar {.extdecl, importc: \"has_il\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "hline",  "code": "proc hline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: \"hline\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "idcok",  "code": "proc idcok*(a2: ptr TWINDOW; a3: cunsignedchar) {.extdecl, importc: \"idcok\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "idlok",  "code": "proc idlok*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"idlok\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "immedok",  "code": "proc immedok*(a2: ptr TWINDOW; a3: cunsignedchar) {.extdecl, importc: \"immedok\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "inchnstr",  "code": "proc inchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"inchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "inchstr",  "code": "proc inchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"inchstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "inch",  "code": "proc inch*(): cunsignedlong {.extdecl, importc: \"inch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "init_color",  "code": "proc init_color*(a2: cshort; a3: cshort; a4: cshort; a5: cshort): cint {.\u000A    extdecl, importc: \"init_color\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "init_pair",  "code": "proc init_pair*(a2: cshort; a3: cshort; a4: cshort): cint {.extdecl, \u000A    importc: \"init_pair\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "initscr",  "code": "proc initscr*(): ptr TWINDOW {.extdecl, importc: \"initscr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "innstr",  "code": "proc innstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"innstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insch",  "code": "proc insch*(a2: cunsignedlong): cint {.extdecl, importc: \"insch\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insdelln",  "code": "proc insdelln*(a2: cint): cint {.extdecl, importc: \"insdelln\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insertln",  "code": "proc insertln*(): cint {.extdecl, importc: \"insertln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insnstr",  "code": "proc insnstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"insnstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insstr",  "code": "proc insstr*(a2: cstring): cint {.extdecl, importc: \"insstr\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "instr",  "code": "proc instr*(a2: cstring): cint {.extdecl, importc: \"instr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "intrflush",  "code": "proc intrflush*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"intrflush\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "isendwin",  "code": "proc isendwin*(): cunsignedchar {.extdecl, importc: \"isendwin\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "is_linetouched",  "code": "proc is_linetouched*(a2: ptr TWINDOW; a3: cint): cunsignedchar {.extdecl, \u000A    importc: \"is_linetouched\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "is_wintouched",  "code": "proc is_wintouched*(a2: ptr TWINDOW): cunsignedchar {.extdecl, \u000A    importc: \"is_wintouched\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "keyname",  "code": "proc keyname*(a2: cint): cstring {.extdecl, importc: \"keyname\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "keypad",  "code": "proc keypad*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"keypad\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "killchar",  "code": "proc killchar*(): char {.extdecl, importc: \"killchar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "leaveok",  "code": "proc leaveok*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"leaveok\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "longname",  "code": "proc longname*(): cstring {.extdecl, importc: \"longname\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "meta",  "code": "proc meta*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, importc: \"meta\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "move",  "code": "proc move*(a2: cint; a3: cint): cint {.extdecl, importc: \"move\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddch",  "code": "proc mvaddch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, \u000A    importc: \"mvaddch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddchnstr",  "code": "proc mvaddchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvaddchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddchstr",  "code": "proc mvaddchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvaddchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddnstr",  "code": "proc mvaddnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvaddnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddstr",  "code": "proc mvaddstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvaddstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvchgat",  "code": "proc mvchgat*(a2: cint; a3: cint; a4: cint; a5: cunsignedlong; a6: cshort; \u000A              a7: pointer): cint {.extdecl, importc: \"mvchgat\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvcur",  "code": "proc mvcur*(a2: cint; a3: cint; a4: cint; a5: cint): cint {.extdecl, \u000A    importc: \"mvcur\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvdelch",  "code": "proc mvdelch*(a2: cint; a3: cint): cint {.extdecl, importc: \"mvdelch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvderwin",  "code": "proc mvderwin*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvderwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvgetch",  "code": "proc mvgetch*(a2: cint; a3: cint): cint {.extdecl, importc: \"mvgetch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvgetnstr",  "code": "proc mvgetnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvgetnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvgetstr",  "code": "proc mvgetstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvgetstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvhline",  "code": "proc mvhline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl, \u000A    importc: \"mvhline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinch",  "code": "proc mvinch*(a2: cint; a3: cint): cunsignedlong {.extdecl, importc: \"mvinch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinchnstr",  "code": "proc mvinchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvinchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinchstr",  "code": "proc mvinchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvinchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinnstr",  "code": "proc mvinnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvinnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinsch",  "code": "proc mvinsch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, \u000A    importc: \"mvinsch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinsnstr",  "code": "proc mvinsnstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvinsnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinsstr",  "code": "proc mvinsstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvinsstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinstr",  "code": "proc mvinstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvinstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvprintw",  "code": "proc mvprintw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl, \u000A    importc: \"mvprintw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvscanw",  "code": "proc mvscanw*(a2: cint; a3: cint; a4: cstring): cint {.varargs, extdecl, \u000A    importc: \"mvscanw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvvline",  "code": "proc mvvline*(a2: cint; a3: cint; a4: cunsignedlong; a5: cint): cint {.extdecl, \u000A    importc: \"mvvline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddchnstr",  "code": "proc mvwaddchnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                   a6: cint): cint {.extdecl, importc: \"mvwaddchnstr\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddchstr",  "code": "proc mvwaddchstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwaddchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddch",  "code": "proc mvwaddch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwaddch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddnstr",  "code": "proc mvwaddnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwaddnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddstr",  "code": "proc mvwaddstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwaddstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwchgat",  "code": "proc mvwchgat*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cunsignedlong; \u000A               a7: cshort; a8: pointer): cint {.extdecl, importc: \"mvwchgat\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwdelch",  "code": "proc mvwdelch*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvwdelch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwgetch",  "code": "proc mvwgetch*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvwgetch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwgetnstr",  "code": "proc mvwgetnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwgetnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwgetstr",  "code": "proc mvwgetstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwgetstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwhline",  "code": "proc mvwhline*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.\u000A    extdecl, importc: \"mvwhline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinchnstr",  "code": "proc mvwinchnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                  a6: cint): cint {.extdecl, importc: \"mvwinchnstr\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinchstr",  "code": "proc mvwinchstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwinchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinch",  "code": "proc mvwinch*(a2: ptr TWINDOW; a3: cint; a4: cint): cunsignedlong {.extdecl, \u000A    importc: \"mvwinch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinnstr",  "code": "proc mvwinnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwinnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinsch",  "code": "proc mvwinsch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwinsch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinsnstr",  "code": "proc mvwinsnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwinsnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinsstr",  "code": "proc mvwinsstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwinsstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinstr",  "code": "proc mvwinstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwinstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwin",  "code": "proc mvwin*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwprintw",  "code": "proc mvwprintw*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    varargs, extdecl, importc: \"mvwprintw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwscanw",  "code": "proc mvwscanw*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    varargs, extdecl, importc: \"mvwscanw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwvline",  "code": "proc mvwvline*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong; a6: cint): cint {.\u000A    extdecl, importc: \"mvwvline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "napms",  "code": "proc napms*(a2: cint): cint {.extdecl, importc: \"napms\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "newpad",  "code": "proc newpad*(a2: cint; a3: cint): ptr TWINDOW {.extdecl, importc: \"newpad\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "newterm",  "code": "proc newterm*(a2: cstring; a3: File; a4: File): ptr TSCREEN {.extdecl, \u000A    importc: \"newterm\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "newwin",  "code": "proc newwin*(a2: cint; a3: cint; a4: cint; a5: cint): ptr TWINDOW {.extdecl, \u000A    importc: \"newwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nl",  "code": "proc nl*(): cint {.extdecl, importc: \"nl\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nocbreak",  "code": "proc nocbreak*(): cint {.extdecl, importc: \"nocbreak\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nodelay",  "code": "proc nodelay*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"nodelay\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "noecho",  "code": "proc noecho*(): cint {.extdecl, importc: \"noecho\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nonl",  "code": "proc nonl*(): cint {.extdecl, importc: \"nonl\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "noqiflush",  "code": "proc noqiflush*() {.extdecl, importc: \"noqiflush\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "noraw",  "code": "proc noraw*(): cint {.extdecl, importc: \"noraw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "notimeout",  "code": "proc notimeout*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"notimeout\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "overlay",  "code": "proc overlay*(a2: ptr TWINDOW; a3: ptr TWINDOW): cint {.extdecl, \u000A    importc: \"overlay\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "overwrite",  "code": "proc overwrite*(a2: ptr TWINDOW; a3: ptr TWINDOW): cint {.extdecl, \u000A    importc: \"overwrite\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "pair_content",  "code": "proc pair_content*(a2: cshort; a3: ptr cshort; a4: ptr cshort): cint {.extdecl, \u000A    importc: \"pair_content\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "pechochar",  "code": "proc pechochar*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"pechochar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "pnoutrefresh",  "code": "proc pnoutrefresh*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cint; \u000A                   a7: cint; a8: cint): cint {.extdecl, importc: \"pnoutrefresh\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "prefresh",  "code": "proc prefresh*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cint; \u000A               a7: cint; a8: cint): cint {.extdecl, importc: \"prefresh\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "printw",  "code": "proc printw*(a2: cstring): cint {.varargs, extdecl, importc: \"printw\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "putwin",  "code": "proc putwin*(a2: ptr TWINDOW; a3: File): cint {.extdecl, importc: \"putwin\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "qiflush",  "code": "proc qiflush*() {.extdecl, importc: \"qiflush\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "raw",  "code": "proc raw*(): cint {.extdecl, importc: \"raw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "redrawwin",  "code": "proc redrawwin*(a2: ptr TWINDOW): cint {.extdecl, importc: \"redrawwin\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "refresh",  "code": "proc refresh*(): cint {.extdecl, importc: \"refresh\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "reset_prog_mode",  "code": "proc reset_prog_mode*(): cint {.extdecl, importc: \"reset_prog_mode\", \u000A                                dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "reset_shell_mode",  "code": "proc reset_shell_mode*(): cint {.extdecl, importc: \"reset_shell_mode\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "resetty",  "code": "proc resetty*(): cint {.extdecl, importc: \"resetty\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "savetty",  "code": "proc savetty*(): cint {.extdecl, importc: \"savetty\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scanw",  "code": "proc scanw*(a2: cstring): cint {.varargs, extdecl, importc: \"scanw\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scr_dump",  "code": "proc scr_dump*(a2: cstring): cint {.extdecl, importc: \"scr_dump\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scr_init",  "code": "proc scr_init*(a2: cstring): cint {.extdecl, importc: \"scr_init\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scr_restore",  "code": "proc scr_restore*(a2: cstring): cint {.extdecl, importc: \"scr_restore\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scr_set",  "code": "proc scr_set*(a2: cstring): cint {.extdecl, importc: \"scr_set\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scrl",  "code": "proc scrl*(a2: cint): cint {.extdecl, importc: \"scrl\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scroll",  "code": "proc scroll*(a2: ptr TWINDOW): cint {.extdecl, importc: \"scroll\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "scrollok",  "code": "proc scrollok*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"scrollok\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "set_term",  "code": "proc set_term*(a2: ptr TSCREEN): ptr TSCREEN {.extdecl, importc: \"set_term\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "setscrreg",  "code": "proc setscrreg*(a2: cint; a3: cint): cint {.extdecl, importc: \"setscrreg\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attroff",  "code": "proc slk_attroff*(a2: cunsignedlong): cint {.extdecl, importc: \"slk_attroff\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attr_off",  "code": "proc slk_attr_off*(a2: cunsignedlong; a3: pointer): cint {.extdecl, \u000A    importc: \"slk_attr_off\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attron",  "code": "proc slk_attron*(a2: cunsignedlong): cint {.extdecl, importc: \"slk_attron\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attr_on",  "code": "proc slk_attr_on*(a2: cunsignedlong; a3: pointer): cint {.extdecl, \u000A    importc: \"slk_attr_on\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attrset",  "code": "proc slk_attrset*(a2: cunsignedlong): cint {.extdecl, importc: \"slk_attrset\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_attr_set",  "code": "proc slk_attr_set*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl, \u000A    importc: \"slk_attr_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_clear",  "code": "proc slk_clear*(): cint {.extdecl, importc: \"slk_clear\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_color",  "code": "proc slk_color*(a2: cshort): cint {.extdecl, importc: \"slk_color\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_init",  "code": "proc slk_init*(a2: cint): cint {.extdecl, importc: \"slk_init\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_label",  "code": "proc slk_label*(a2: cint): cstring {.extdecl, importc: \"slk_label\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_noutrefresh",  "code": "proc slk_noutrefresh*(): cint {.extdecl, importc: \"slk_noutrefresh\", \u000A                                dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_refresh",  "code": "proc slk_refresh*(): cint {.extdecl, importc: \"slk_refresh\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_restore",  "code": "proc slk_restore*(): cint {.extdecl, importc: \"slk_restore\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_set",  "code": "proc slk_set*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"slk_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_touch",  "code": "proc slk_touch*(): cint {.extdecl, importc: \"slk_touch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "standend",  "code": "proc standend*(): cint {.extdecl, importc: \"standend\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "standout",  "code": "proc standout*(): cint {.extdecl, importc: \"standout\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "start_color",  "code": "proc start_color*(): cint {.extdecl, importc: \"start_color\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "subpad",  "code": "proc subpad*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr TWINDOW {.\u000A    extdecl, importc: \"subpad\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "subwin",  "code": "proc subwin*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint; a6: cint): ptr TWINDOW {.\u000A    extdecl, importc: \"subwin\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "syncok",  "code": "proc syncok*(a2: ptr TWINDOW; a3: cunsignedchar): cint {.extdecl, \u000A    importc: \"syncok\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "termattrs",  "code": "proc termattrs*(): cunsignedlong {.extdecl, importc: \"termattrs\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "termattrs2",  "code": "proc termattrs2*(): cunsignedlong {.extdecl, importc: \"term_attrs\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "termname",  "code": "proc termname*(): cstring {.extdecl, importc: \"termname\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "timeout",  "code": "proc timeout*(a2: cint) {.extdecl, importc: \"timeout\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "touchline",  "code": "proc touchline*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"touchline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "touchwin",  "code": "proc touchwin*(a2: ptr TWINDOW): cint {.extdecl, importc: \"touchwin\", \u000A                                        dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "typeahead",  "code": "proc typeahead*(a2: cint): cint {.extdecl, importc: \"typeahead\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "untouchwin",  "code": "proc untouchwin*(a2: ptr TWINDOW): cint {.extdecl, importc: \"untouchwin\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "use_env",  "code": "proc use_env*(a2: cunsignedchar) {.extdecl, importc: \"use_env\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vidattr",  "code": "proc vidattr*(a2: cunsignedlong): cint {.extdecl, importc: \"vidattr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vid_attr",  "code": "proc vid_attr*(a2: cunsignedlong; a3: cshort; a4: pointer): cint {.extdecl, \u000A    importc: \"vid_attr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vline",  "code": "proc vline*(a2: cunsignedlong; a3: cint): cint {.extdecl, importc: \"vline\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vwprintw",  "code": "proc vwprintw*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, varargs, \u000A    importc: \"vw_printw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vwprintw2",  "code": "proc vwprintw2*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, varargs, \u000A    importc: \"vwprintw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vwscanw",  "code": "proc vwscanw*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, varargs, \u000A    importc: \"vw_scanw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vwscanw2",  "code": "proc vwscanw2*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, varargs, \u000A    importc: \"vwscanw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddchnstr",  "code": "proc waddchnstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"waddchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddchstr",  "code": "proc waddchstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"waddchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddch",  "code": "proc waddch*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"waddch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddnstr",  "code": "proc waddnstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"waddnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddstr",  "code": "proc waddstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, importc: \"waddstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattroff",  "code": "proc wattroff*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"wattroff\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattron",  "code": "proc wattron*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"wattron\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattrset",  "code": "proc wattrset*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"wattrset\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattr_get",  "code": "proc wattr_get*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: ptr cshort; \u000A                a5: pointer): cint {.extdecl, importc: \"wattr_get\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattr_off",  "code": "proc wattr_off*(a2: ptr TWINDOW; a3: cunsignedlong; a4: pointer): cint {.\u000A    extdecl, importc: \"wattr_off\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattr_on",  "code": "proc wattr_on*(a2: ptr TWINDOW; a3: cunsignedlong; a4: pointer): cint {.extdecl, \u000A    importc: \"wattr_on\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wattr_set",  "code": "proc wattr_set*(a2: ptr TWINDOW; a3: cunsignedlong; a4: cshort; a5: pointer): cint {.\u000A    extdecl, importc: \"wattr_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wbkgdset",  "code": "proc wbkgdset*(a2: ptr TWINDOW; a3: cunsignedlong) {.extdecl, \u000A    importc: \"wbkgdset\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wbkgd",  "code": "proc wbkgd*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"wbkgd\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wborder",  "code": "proc wborder*(a2: ptr TWINDOW; a3: cunsignedlong; a4: cunsignedlong; \u000A              a5: cunsignedlong; a6: cunsignedlong; a7: cunsignedlong; \u000A              a8: cunsignedlong; a9: cunsignedlong; a10: cunsignedlong): cint {.\u000A    extdecl, importc: \"wborder\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wchgat",  "code": "proc wchgat*(a2: ptr TWINDOW; a3: cint; a4: cunsignedlong; a5: cshort; \u000A             a6: pointer): cint {.extdecl, importc: \"wchgat\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wclear",  "code": "proc wclear*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wclear\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wclrtobot",  "code": "proc wclrtobot*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wclrtobot\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wclrtoeol",  "code": "proc wclrtoeol*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wclrtoeol\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wcolor_set",  "code": "proc wcolor_set*(a2: ptr TWINDOW; a3: cshort; a4: pointer): cint {.extdecl, \u000A    importc: \"wcolor_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wcursyncup",  "code": "proc wcursyncup*(a2: ptr TWINDOW) {.extdecl, importc: \"wcursyncup\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wdelch",  "code": "proc wdelch*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wdelch\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wdeleteln",  "code": "proc wdeleteln*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wdeleteln\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wechochar",  "code": "proc wechochar*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"wechochar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "werase",  "code": "proc werase*(a2: ptr TWINDOW): cint {.extdecl, importc: \"werase\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wgetch",  "code": "proc wgetch*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wgetch\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wgetnstr",  "code": "proc wgetnstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"wgetnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wgetstr",  "code": "proc wgetstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, importc: \"wgetstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "whline",  "code": "proc whline*(a2: ptr TWINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl, \u000A    importc: \"whline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winchnstr",  "code": "proc winchnstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"winchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winchstr",  "code": "proc winchstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"winchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winch",  "code": "proc winch*(a2: ptr TWINDOW): cunsignedlong {.extdecl, importc: \"winch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winnstr",  "code": "proc winnstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"winnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsch",  "code": "proc winsch*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"winsch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsdelln",  "code": "proc winsdelln*(a2: ptr TWINDOW; a3: cint): cint {.extdecl, \u000A    importc: \"winsdelln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsertln",  "code": "proc winsertln*(a2: ptr TWINDOW): cint {.extdecl, importc: \"winsertln\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsnstr",  "code": "proc winsnstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"winsnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsstr",  "code": "proc winsstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, importc: \"winsstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winstr",  "code": "proc winstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, importc: \"winstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wmove",  "code": "proc wmove*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"wmove\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wnoutrefresh",  "code": "proc wnoutrefresh*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wnoutrefresh\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wprintw",  "code": "proc wprintw*(a2: ptr TWINDOW; a3: cstring): cint {.varargs, extdecl, \u000A    importc: \"wprintw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wredrawln",  "code": "proc wredrawln*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"wredrawln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wrefresh",  "code": "proc wrefresh*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wrefresh\", \u000A                                        dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wscanw",  "code": "proc wscanw*(a2: ptr TWINDOW; a3: cstring): cint {.varargs, extdecl, \u000A    importc: \"wscanw\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wscrl",  "code": "proc wscrl*(a2: ptr TWINDOW; a3: cint): cint {.extdecl, importc: \"wscrl\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wsetscrreg",  "code": "proc wsetscrreg*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"wsetscrreg\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wstandend",  "code": "proc wstandend*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wstandend\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wstandout",  "code": "proc wstandout*(a2: ptr TWINDOW): cint {.extdecl, importc: \"wstandout\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wsyncdown",  "code": "proc wsyncdown*(a2: ptr TWINDOW) {.extdecl, importc: \"wsyncdown\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wsyncup",  "code": "proc wsyncup*(a2: ptr TWINDOW) {.extdecl, importc: \"wsyncup\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wtimeout",  "code": "proc wtimeout*(a2: ptr TWINDOW; a3: cint) {.extdecl, importc: \"wtimeout\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wtouchln",  "code": "proc wtouchln*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cint): cint {.extdecl, \u000A    importc: \"wtouchln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wvline",  "code": "proc wvline*(a2: ptr TWINDOW; a3: cunsignedlong; a4: cint): cint {.extdecl, \u000A    importc: \"wvline\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addnwstr",  "code": "proc addnwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"addnwstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addwstr",  "code": "proc addwstr*(a2: cstring): cint {.extdecl, importc: \"addwstr\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "add_wch",  "code": "proc add_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"add_wch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "add_wchnstr",  "code": "proc add_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"add_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "add_wchstr",  "code": "proc add_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"add_wchstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "border_set",  "code": "proc border_set*(a2: ptr cunsignedlong; a3: ptr cunsignedlong; \u000A                 a4: ptr cunsignedlong; a5: ptr cunsignedlong; \u000A                 a6: ptr cunsignedlong; a7: ptr cunsignedlong; \u000A                 a8: ptr cunsignedlong; a9: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"border_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "box_set",  "code": "proc box_set*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"box_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "echo_wchar",  "code": "proc echo_wchar*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"echo_wchar\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "erasewchar",  "code": "proc erasewchar*(a2: cstring): cint {.extdecl, importc: \"erasewchar\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getbkgrnd",  "code": "proc getbkgrnd*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"getbkgrnd\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getcchar",  "code": "proc getcchar*(a2: ptr cunsignedlong; a3: cstring; a4: ptr cunsignedlong; \u000A               a5: ptr cshort; a6: pointer): cint {.extdecl, \u000A    importc: \"getcchar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getn_wstr",  "code": "proc getn_wstr*(a2: ptr cint; a3: cint): cint {.extdecl, importc: \"getn_wstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "get_wch",  "code": "proc get_wch*(a2: ptr cint): cint {.extdecl, importc: \"get_wch\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "get_wstr",  "code": "proc get_wstr*(a2: ptr cint): cint {.extdecl, importc: \"get_wstr\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "hline_set",  "code": "proc hline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"hline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "innwstr",  "code": "proc innwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"innwstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "ins_nwstr",  "code": "proc ins_nwstr*(a2: cstring; a3: cint): cint {.extdecl, importc: \"ins_nwstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "ins_wch",  "code": "proc ins_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"ins_wch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "ins_wstr",  "code": "proc ins_wstr*(a2: cstring): cint {.extdecl, importc: \"ins_wstr\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "inwstr",  "code": "proc inwstr*(a2: cstring): cint {.extdecl, importc: \"inwstr\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "in_wch",  "code": "proc in_wch*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"in_wch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "in_wchnstr",  "code": "proc in_wchnstr*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"in_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "in_wchstr",  "code": "proc in_wchstr*(a2: ptr cunsignedlong): cint {.extdecl, importc: \"in_wchstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "key_name",  "code": "proc key_name*(a2: char): cstring {.extdecl, importc: \"key_name\", \u000A                                    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "killwchar",  "code": "proc killwchar*(a2: cstring): cint {.extdecl, importc: \"killwchar\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddnwstr",  "code": "proc mvaddnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvaddnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddwstr",  "code": "proc mvaddwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvaddwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvadd_wch",  "code": "proc mvadd_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvadd_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvadd_wchnstr",  "code": "proc mvadd_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvadd_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvadd_wchstr",  "code": "proc mvadd_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvadd_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvgetn_wstr",  "code": "proc mvgetn_wstr*(a2: cint; a3: cint; a4: ptr cint; a5: cint): cint {.extdecl, \u000A    importc: \"mvgetn_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvget_wch",  "code": "proc mvget_wch*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, \u000A    importc: \"mvget_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvget_wstr",  "code": "proc mvget_wstr*(a2: cint; a3: cint; a4: ptr cint): cint {.extdecl, \u000A    importc: \"mvget_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvhline_set",  "code": "proc mvhline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvhline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinnwstr",  "code": "proc mvinnwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvinnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvins_nwstr",  "code": "proc mvins_nwstr*(a2: cint; a3: cint; a4: cstring; a5: cint): cint {.extdecl, \u000A    importc: \"mvins_nwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvins_wch",  "code": "proc mvins_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvins_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvins_wstr",  "code": "proc mvins_wstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvins_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinwstr",  "code": "proc mvinwstr*(a2: cint; a3: cint; a4: cstring): cint {.extdecl, \u000A    importc: \"mvinwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvin_wch",  "code": "proc mvin_wch*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvin_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvin_wchnstr",  "code": "proc mvin_wchnstr*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvin_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvin_wchstr",  "code": "proc mvin_wchstr*(a2: cint; a3: cint; a4: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"mvin_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvvline_set",  "code": "proc mvvline_set*(a2: cint; a3: cint; a4: ptr cunsignedlong; a5: cint): cint {.\u000A    extdecl, importc: \"mvvline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddnwstr",  "code": "proc mvwaddnwstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwaddnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddwstr",  "code": "proc mvwaddwstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwaddwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwadd_wch",  "code": "proc mvwadd_wch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwadd_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwadd_wchnstr",  "code": "proc mvwadd_wchnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                     a6: cint): cint {.extdecl, importc: \"mvwadd_wchnstr\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwadd_wchstr",  "code": "proc mvwadd_wchstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwadd_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwgetn_wstr",  "code": "proc mvwgetn_wstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cint; a6: cint): cint {.\u000A    extdecl, importc: \"mvwgetn_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwget_wch",  "code": "proc mvwget_wch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.\u000A    extdecl, importc: \"mvwget_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwget_wstr",  "code": "proc mvwget_wstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cint): cint {.\u000A    extdecl, importc: \"mvwget_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwhline_set",  "code": "proc mvwhline_set*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                   a6: cint): cint {.extdecl, importc: \"mvwhline_set\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinnwstr",  "code": "proc mvwinnwstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwinnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwins_nwstr",  "code": "proc mvwins_nwstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring; a6: cint): cint {.\u000A    extdecl, importc: \"mvwins_nwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwins_wch",  "code": "proc mvwins_wch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwins_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwins_wstr",  "code": "proc mvwins_wstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwins_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwin_wch",  "code": "proc mvwin_wch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwin_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwin_wchnstr",  "code": "proc mvwin_wchnstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                    a6: cint): cint {.extdecl, importc: \"mvwin_wchnstr\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwin_wchstr",  "code": "proc mvwin_wchstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwin_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinwstr",  "code": "proc mvwinwstr*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cstring): cint {.\u000A    extdecl, importc: \"mvwinwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwvline_set",  "code": "proc mvwvline_set*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: ptr cunsignedlong; \u000A                   a6: cint): cint {.extdecl, importc: \"mvwvline_set\", \u000A                                     dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "pecho_wchar",  "code": "proc pecho_wchar*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"pecho_wchar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "setcchar",  "code": "proc setcchar*(a2: ptr cunsignedlong; a3: cstring; a4: cunsignedlong; \u000A               a5: cshort; a6: pointer): cint {.extdecl, importc: \"setcchar\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_wset",  "code": "proc slk_wset*(a2: cint; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"slk_wset\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "unget_wch",  "code": "proc unget_wch*(a2: char): cint {.extdecl, importc: \"unget_wch\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "vline_set",  "code": "proc vline_set*(a2: ptr cunsignedlong; a3: cint): cint {.extdecl, \u000A    importc: \"vline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddnwstr",  "code": "proc waddnwstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"waddnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddwstr",  "code": "proc waddwstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, \u000A    importc: \"waddwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wadd_wch",  "code": "proc wadd_wch*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wadd_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wadd_wchnstr",  "code": "proc wadd_wchnstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"wadd_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wadd_wchstr",  "code": "proc wadd_wchstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wadd_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wbkgrnd",  "code": "proc wbkgrnd*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wbkgrnd\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wbkgrndset",  "code": "proc wbkgrndset*(a2: ptr TWINDOW; a3: ptr cunsignedlong) {.extdecl, \u000A    importc: \"wbkgrndset\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wborder_set",  "code": "proc wborder_set*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: ptr cunsignedlong; \u000A                  a5: ptr cunsignedlong; a6: ptr cunsignedlong; \u000A                  a7: ptr cunsignedlong; a8: ptr cunsignedlong; \u000A                  a9: ptr cunsignedlong; a10: ptr cunsignedlong): cint {.\u000A    extdecl, importc: \"wborder_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wecho_wchar",  "code": "proc wecho_wchar*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wecho_wchar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wgetbkgrnd",  "code": "proc wgetbkgrnd*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wgetbkgrnd\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wgetn_wstr",  "code": "proc wgetn_wstr*(a2: ptr TWINDOW; a3: ptr cint; a4: cint): cint {.extdecl, \u000A    importc: \"wgetn_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wget_wch",  "code": "proc wget_wch*(a2: ptr TWINDOW; a3: ptr cint): cint {.extdecl, \u000A    importc: \"wget_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wget_wstr",  "code": "proc wget_wstr*(a2: ptr TWINDOW; a3: ptr cint): cint {.extdecl, \u000A    importc: \"wget_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "whline_set",  "code": "proc whline_set*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"whline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winnwstr",  "code": "proc winnwstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"winnwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wins_nwstr",  "code": "proc wins_nwstr*(a2: ptr TWINDOW; a3: cstring; a4: cint): cint {.extdecl, \u000A    importc: \"wins_nwstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wins_wch",  "code": "proc wins_wch*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"wins_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wins_wstr",  "code": "proc wins_wstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, \u000A    importc: \"wins_wstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winwstr",  "code": "proc winwstr*(a2: ptr TWINDOW; a3: cstring): cint {.extdecl, importc: \"winwstr\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "win_wch",  "code": "proc win_wch*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"win_wch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "win_wchnstr",  "code": "proc win_wchnstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"win_wchnstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "win_wchstr",  "code": "proc win_wchstr*(a2: ptr TWINDOW; a3: ptr cunsignedlong): cint {.extdecl, \u000A    importc: \"win_wchstr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wunctrl",  "code": "proc wunctrl*(a2: ptr cunsignedlong): cstring {.extdecl, importc: \"wunctrl\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wvline_set",  "code": "proc wvline_set*(a2: ptr TWINDOW; a3: ptr cunsignedlong; a4: cint): cint {.\u000A    extdecl, importc: \"wvline_set\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getattrs",  "code": "proc getattrs*(a2: ptr TWINDOW): cunsignedlong {.extdecl, importc: \"getattrs\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getbegx",  "code": "proc getbegx*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getbegx\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getbegy",  "code": "proc getbegy*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getbegy\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getmaxx",  "code": "proc getmaxx*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getmaxx\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getmaxy",  "code": "proc getmaxy*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getmaxy\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getparx",  "code": "proc getparx*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getparx\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getpary",  "code": "proc getpary*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getpary\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getcurx",  "code": "proc getcurx*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getcurx\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getcury",  "code": "proc getcury*(a2: ptr TWINDOW): cint {.extdecl, importc: \"getcury\", \u000A                                       dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "traceoff",  "code": "proc traceoff*() {.extdecl, importc: \"traceoff\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "traceon",  "code": "proc traceon*() {.extdecl, importc: \"traceon\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "unctrl",  "code": "proc unctrl*(a2: cunsignedlong): cstring {.extdecl, importc: \"unctrl\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "crmode",  "code": "proc crmode*(): cint {.extdecl, importc: \"crmode\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nocrmode",  "code": "proc nocrmode*(): cint {.extdecl, importc: \"nocrmode\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "draino",  "code": "proc draino*(a2: cint): cint {.extdecl, importc: \"draino\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "resetterm",  "code": "proc resetterm*(): cint {.extdecl, importc: \"resetterm\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "fixterm",  "code": "proc fixterm*(): cint {.extdecl, importc: \"fixterm\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "saveterm",  "code": "proc saveterm*(): cint {.extdecl, importc: \"saveterm\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "setsyx",  "code": "proc setsyx*(a2: cint; a3: cint): cint {.extdecl, importc: \"setsyx\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mouse_set",  "code": "proc mouse_set*(a2: cunsignedlong): cint {.extdecl, importc: \"mouse_set\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mouse_on",  "code": "proc mouse_on*(a2: cunsignedlong): cint {.extdecl, importc: \"mouse_on\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mouse_off",  "code": "proc mouse_off*(a2: cunsignedlong): cint {.extdecl, importc: \"mouse_off\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "request_mouse_pos",  "code": "proc request_mouse_pos*(): cint {.extdecl, importc: \"request_mouse_pos\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "map_button",  "code": "proc map_button*(a2: cunsignedlong): cint {.extdecl, importc: \"map_button\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wmouse_position",  "code": "proc wmouse_position*(a2: ptr TWINDOW; a3: ptr cint; a4: ptr cint) {.extdecl, \u000A    importc: \"wmouse_position\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getmouse",  "code": "proc getmouse*(): cunsignedlong {.extdecl, importc: \"getmouse\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getbmap",  "code": "proc getbmap*(): cunsignedlong {.extdecl, importc: \"getbmap\", \u000A                                 dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "assume_default_colors",  "code": "proc assume_default_colors*(a2: cint; a3: cint): cint {.extdecl, \u000A    importc: \"assume_default_colors\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "curses_version",  "code": "proc curses_version*(): cstring {.extdecl, importc: \"curses_version\", \u000A                                  dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "has_key",  "code": "proc has_key*(a2: cint): cunsignedchar {.extdecl, importc: \"has_key\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "use_default_colors",  "code": "proc use_default_colors*(): cint {.extdecl, importc: \"use_default_colors\", \u000A                                   dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wresize",  "code": "proc wresize*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"wresize\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mouseinterval",  "code": "proc mouseinterval*(a2: cint): cint {.extdecl, importc: \"mouseinterval\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mousemask",  "code": "proc mousemask*(a2: cunsignedlong; a3: ptr cunsignedlong): cunsignedlong {.\u000A    extdecl, importc: \"mousemask\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mouse_trafo",  "code": "proc mouse_trafo*(a2: ptr cint; a3: ptr cint; a4: cunsignedchar): cunsignedchar {.\u000A    extdecl, importc: \"mouse_trafo\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "nc_getmouse",  "code": "proc nc_getmouse*(a2: ptr TMEVENT): cint {.extdecl, importc: \"nc_getmouse\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "ungetmouse",  "code": "proc ungetmouse*(a2: ptr TMEVENT): cint {.extdecl, importc: \"ungetmouse\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wenclose",  "code": "proc wenclose*(a2: ptr TWINDOW; a3: cint; a4: cint): cunsignedchar {.extdecl, \u000A    importc: \"wenclose\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wmouse_trafo",  "code": "proc wmouse_trafo*(a2: ptr TWINDOW; a3: ptr cint; a4: ptr cint; \u000A                   a5: cunsignedchar): cunsignedchar {.extdecl, \u000A    importc: \"wmouse_trafo\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "addrawch",  "code": "proc addrawch*(a2: cunsignedlong): cint {.extdecl, importc: \"addrawch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "insrawch",  "code": "proc insrawch*(a2: cunsignedlong): cint {.extdecl, importc: \"insrawch\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "is_termresized",  "code": "proc is_termresized*(): cunsignedchar {.extdecl, importc: \"is_termresized\", \u000A                                        dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvaddrawch",  "code": "proc mvaddrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, \u000A    importc: \"mvaddrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvdeleteln",  "code": "proc mvdeleteln*(a2: cint; a3: cint): cint {.extdecl, importc: \"mvdeleteln\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinsertln",  "code": "proc mvinsertln*(a2: cint; a3: cint): cint {.extdecl, importc: \"mvinsertln\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvinsrawch",  "code": "proc mvinsrawch*(a2: cint; a3: cint; a4: cunsignedlong): cint {.extdecl, \u000A    importc: \"mvinsrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwaddrawch",  "code": "proc mvwaddrawch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwaddrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwdeleteln",  "code": "proc mvwdeleteln*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvwdeleteln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinsertln",  "code": "proc mvwinsertln*(a2: ptr TWINDOW; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"mvwinsertln\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "mvwinsrawch",  "code": "proc mvwinsrawch*(a2: ptr TWINDOW; a3: cint; a4: cint; a5: cunsignedlong): cint {.\u000A    extdecl, importc: \"mvwinsrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "raw_output",  "code": "proc raw_output*(a2: cunsignedchar): cint {.extdecl, importc: \"raw_output\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "resize_term",  "code": "proc resize_term*(a2: cint; a3: cint): cint {.extdecl, importc: \"resize_term\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "resize_window",  "code": "proc resize_window*(a2: ptr TWINDOW; a3: cint; a4: cint): ptr TWINDOW {.extdecl, \u000A    importc: \"resize_window\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "waddrawch",  "code": "proc waddrawch*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"waddrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "winsrawch",  "code": "proc winsrawch*(a2: ptr TWINDOW; a3: cunsignedlong): cint {.extdecl, \u000A    importc: \"winsrawch\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "wordchar",  "code": "proc wordchar*(): char {.extdecl, importc: \"wordchar\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "slk_wlabel",  "code": "proc slk_wlabel*(a2: cint): cstring {.extdecl, importc: \"slk_wlabel\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "debug",  "code": "proc debug*(a2: cstring) {.varargs, extdecl, importc: \"PDC_debug\", \u000A                           dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "ungetch",  "code": "proc ungetch*(a2: cint): cint {.extdecl, importc: \"PDC_ungetch\", \u000A                                dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "set_blink",  "code": "proc set_blink*(a2: cunsignedchar): cint {.extdecl, importc: \"PDC_set_blink\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "set_line_color",  "code": "proc set_line_color*(a2: cshort): cint {.extdecl, importc: \"PDC_set_line_color\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "set_title",  "code": "proc set_title*(a2: cstring) {.extdecl, importc: \"PDC_set_title\", \u000A                               dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "clearclipboard",  "code": "proc clearclipboard*(): cint {.extdecl, importc: \"PDC_clearclipboard\", \u000A                               dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "freeclipboard",  "code": "proc freeclipboard*(a2: cstring): cint {.extdecl, importc: \"PDC_freeclipboard\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getclipboard",  "code": "proc getclipboard*(a2: cstringArray; a3: ptr clong): cint {.extdecl, \u000A    importc: \"PDC_getclipboard\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "setclipboard",  "code": "proc setclipboard*(a2: cstring; a3: clong): cint {.extdecl, \u000A    importc: \"PDC_setclipboard\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "get_input_fd",  "code": "proc get_input_fd*(): cunsignedlong {.extdecl, importc: \"PDC_get_input_fd\", \u000A                                      dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "get_key_modifiers",  "code": "proc get_key_modifiers*(): cunsignedlong {.extdecl, \u000A    importc: \"PDC_get_key_modifiers\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "return_key_modifiers",  "code": "proc return_key_modifiers*(a2: cunsignedchar): cint {.extdecl, \u000A    importc: \"PDC_return_key_modifiers\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "save_key_modifiers",  "code": "proc save_key_modifiers*(a2: cunsignedchar): cint {.extdecl, \u000A    importc: \"PDC_save_key_modifiers\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "bottom_panel",  "code": "proc bottom_panel*(pan: ptr TPANEL): cint {.extdecl, importc: \"bottom_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "del_panel",  "code": "proc del_panel*(pan: ptr TPANEL): cint {.extdecl, importc: \"del_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "hide_panel",  "code": "proc hide_panel*(pan: ptr TPANEL): cint {.extdecl, importc: \"hide_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "move_panel",  "code": "proc move_panel*(pan: ptr TPANEL; starty: cint; startx: cint): cint {.extdecl, \u000A    importc: \"move_panel\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "new_panel",  "code": "proc new_panel*(win: ptr TWINDOW): ptr TPANEL {.extdecl, importc: \"new_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "panel_above",  "code": "proc panel_above*(pan: ptr TPANEL): ptr TPANEL {.extdecl, \u000A    importc: \"panel_above\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "panel_below",  "code": "proc panel_below*(pan: ptr TPANEL): ptr TPANEL {.extdecl, \u000A    importc: \"panel_below\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "panel_hidden",  "code": "proc panel_hidden*(pan: ptr TPANEL): cint {.extdecl, importc: \"panel_hidden\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "panel_userptr",  "code": "proc panel_userptr*(pan: ptr TPANEL): pointer {.extdecl, \u000A    importc: \"panel_userptr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "panel_window",  "code": "proc panel_window*(pan: ptr TPANEL): ptr TWINDOW {.extdecl, \u000A    importc: \"panel_window\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "replace_panel",  "code": "proc replace_panel*(pan: ptr TPANEL; win: ptr TWINDOW): cint {.extdecl, \u000A    importc: \"replace_panel\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "set_panel_userptr",  "code": "proc set_panel_userptr*(pan: ptr TPANEL; uptr: pointer): cint {.extdecl, \u000A    importc: \"set_panel_userptr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "show_panel",  "code": "proc show_panel*(pan: ptr TPANEL): cint {.extdecl, importc: \"show_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "top_panel",  "code": "proc top_panel*(pan: ptr TPANEL): cint {.extdecl, importc: \"top_panel\", \u000A    dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "update_panels",  "code": "proc update_panels*() {.extdecl, importc: \"update_panels\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "Xinitscr",  "code": "proc Xinitscr*(a2: cint; a3: cstringArray): ptr TWINDOW {.extdecl, \u000A    importc: \"Xinitscr\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "XCursesExit",  "code": "proc XCursesExit*() {.extdecl, importc: \"XCursesExit\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_init",  "code": "proc sb_init*(): cint {.extdecl, importc: \"sb_init\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_set_horz",  "code": "proc sb_set_horz*(a2: cint; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"sb_set_horz\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_set_vert",  "code": "proc sb_set_vert*(a2: cint; a3: cint; a4: cint): cint {.extdecl, \u000A    importc: \"sb_set_vert\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_get_horz",  "code": "proc sb_get_horz*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl, \u000A    importc: \"sb_get_horz\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_get_vert",  "code": "proc sb_get_vert*(a2: ptr cint; a3: ptr cint; a4: ptr cint): cint {.extdecl, \u000A    importc: \"sb_get_vert\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "sb_refresh",  "code": "proc sb_refresh*(): cint {.extdecl, importc: \"sb_refresh\", dynlib: pdcursesdll.}" },  { "module": "pdcurses",  "name": "getch",  "code": "template getch*(): expr" },  { "module": "pdcurses",  "name": "ungetch",  "code": "template ungetch*(ch: expr): expr" },  { "module": "pdcurses",  "name": "getbegyx",  "code": "template getbegyx*(w, y, x: expr): expr" },  { "module": "pdcurses",  "name": "getmaxyx",  "code": "template getmaxyx*(w, y, x: expr): expr" },  { "module": "pdcurses",  "name": "getparyx",  "code": "template getparyx*(w, y, x: expr): expr" },  { "module": "pdcurses",  "name": "getyx",  "code": "template getyx*(w, y, x: expr): expr" },  { "module": "pdcurses",  "name": "getsyx",  "code": "template getsyx*(y, x: expr): stmt" },  { "module": "pdcurses",  "name": "getmouse",  "code": "template getmouse*(x: expr): expr" },  { "module": "pdcurses",  "name": "get_buffer_rows",  "code": "proc get_buffer_rows*(): cint {.extdecl, importc: \"PDC_get_buffer_rows\", \u000A                                dynlib: pdcursesdll.}" },  { "module": "pegs",  "name": "term",  "code": "proc term*(t: string): Peg {.nosideEffect, rtl, extern: \"npegs$1Str\".}",  "desc": "constructs a PEG from a terminal string" },  { "module": "pegs",  "name": "termIgnoreCase",  "code": "proc termIgnoreCase*(t: string): Peg {.nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a PEG from a terminal string; ignore case for matching" },  { "module": "pegs",  "name": "termIgnoreStyle",  "code": "proc termIgnoreStyle*(t: string): Peg {.nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a PEG from a terminal string; ignore style for matching" },  { "module": "pegs",  "name": "term",  "code": "proc term*(t: char): Peg {.nosideEffect, rtl, extern: \"npegs$1Char\".}",  "desc": "constructs a PEG from a terminal char" },  { "module": "pegs",  "name": "charSet",  "code": "proc charSet*(s: set[char]): Peg {.nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a PEG from a character set <cite>s</cite>" },  { "module": "pegs",  "name": "`/`",  "code": "proc `/`*(a: varargs[Peg]): Peg {.nosideEffect, rtl, \u000A                                  extern: \"npegsOrderedChoice\".}",  "desc": "constructs an ordered choice with the PEGs in <cite>a</cite>" },  { "module": "pegs",  "name": "sequence",  "code": "proc sequence*(a: varargs[Peg]): Peg {.nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a sequence with all the PEGs from <cite>a</cite>" },  { "module": "pegs",  "name": "`?`",  "code": "proc `?`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsOptional\".}",  "desc": "constructs an optional for the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`*`",  "code": "proc `*`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsGreedyRep\".}",  "desc": "constructs a &quot;greedy repetition&quot; for the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`!*`",  "code": "proc `!*`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsSearch\".}",  "desc": "constructs a &quot;search&quot; for the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`!*\\`",  "code": "proc `!*\\`*(a: Peg): Peg {.noSideEffect, rtl, extern: \"npgegsCapturedSearch\".}",  "desc": "constructs a &quot;captured search&quot; for the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`+`",  "code": "proc `+`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsGreedyPosRep\".}",  "desc": "constructs a &quot;greedy positive repetition&quot; with the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`&amp;`",  "code": "proc `&`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsAndPredicate\".}",  "desc": "constructs an &quot;and predicate&quot; with the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "`!`",  "code": "proc `!`*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsNotPredicate\".}",  "desc": "constructs a &quot;not predicate&quot; with the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "any",  "code": "proc any*(): Peg {.inline.}",  "desc": "constructs the PEG <span id=\"any-character_1\">any character</span> (<tt class=\"docutils literal\"><span class=\"pre\">.</span></tt>)" },  { "module": "pegs",  "name": "anyRune",  "code": "proc anyRune*(): Peg {.inline.}",  "desc": "constructs the PEG <span id=\"any-rune_1\">any rune</span> (<tt class=\"docutils literal\"><span class=\"pre\">_</span></tt>)" },  { "module": "pegs",  "name": "newLine",  "code": "proc newLine*(): Peg {.inline.}",  "desc": "constructs the PEG <span id=\"newline_1\">newline</span> (<tt class=\"docutils literal\"><span class=\"pre\">\\n</span></tt>)" },  { "module": "pegs",  "name": "unicodeLetter",  "code": "proc unicodeLetter*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">\\letter</span></tt> which matches any Unicode letter." },  { "module": "pegs",  "name": "unicodeLower",  "code": "proc unicodeLower*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">\\lower</span></tt> which matches any Unicode lowercase letter." },  { "module": "pegs",  "name": "unicodeUpper",  "code": "proc unicodeUpper*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">\\upper</span></tt> which matches any Unicode uppercase letter." },  { "module": "pegs",  "name": "unicodeTitle",  "code": "proc unicodeTitle*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">\\title</span></tt> which matches any Unicode title letter." },  { "module": "pegs",  "name": "unicodeWhitespace",  "code": "proc unicodeWhitespace*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">\\white</span></tt> which matches any Unicode whitespace character." },  { "module": "pegs",  "name": "startAnchor",  "code": "proc startAnchor*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">^</span></tt> which matches the start of the input.  " },  { "module": "pegs",  "name": "endAnchor",  "code": "proc endAnchor*(): Peg {.inline.}",  "desc": "constructs the PEG <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> which matches the end of the input.  " },  { "module": "pegs",  "name": "capture",  "code": "proc capture*(a: Peg): Peg {.nosideEffect, rtl, extern: \"npegsCapture\".}",  "desc": "constructs a capture with the PEG <cite>a</cite>" },  { "module": "pegs",  "name": "backref",  "code": "proc backref*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "constructs a back reference of the given <cite>index</cite>. <cite>index</cite> starts counting from 1." },  { "module": "pegs",  "name": "backrefIgnoreCase",  "code": "proc backrefIgnoreCase*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, \u000A    rtl, extern: \"npegs$1\".}",  "desc": "constructs a back reference of the given <cite>index</cite>. <cite>index</cite> starts counting from 1. Ignores case for matching." },  { "module": "pegs",  "name": "backrefIgnoreStyle",  "code": "proc backrefIgnoreStyle*(index: range[1 .. MaxSubpatterns]): Peg {.nosideEffect, \u000A    rtl, extern: \"npegs$1\".}",  "desc": "constructs a back reference of the given <cite>index</cite>. <cite>index</cite> starts counting from 1. Ignores style for matching." },  { "module": "pegs",  "name": "nonterminal",  "code": "proc nonterminal*(n: NonTerminal): Peg {.nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a PEG that consists of the nonterminal symbol" },  { "module": "pegs",  "name": "newNonTerminal",  "code": "proc newNonTerminal*(name: string; line, column: int): NonTerminal {.\u000A    nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "constructs a nonterminal symbol" },  { "module": "pegs",  "name": "letters",  "code": "template letters*(): expr",  "desc": "expands to <tt class=\"docutils literal\"><span class=\"pre\">charset({'A'..'Z', 'a'..'z'})</span></tt>" },  { "module": "pegs",  "name": "digits",  "code": "template digits*(): expr",  "desc": "expands to <tt class=\"docutils literal\"><span class=\"pre\">charset({'0'..'9'})</span></tt>" },  { "module": "pegs",  "name": "whitespace",  "code": "template whitespace*(): expr",  "desc": "expands to <tt class=\"docutils literal\"><span class=\"pre\">charset({' ', '\\9'..'\\13'})</span></tt>" },  { "module": "pegs",  "name": "identChars",  "code": "template identChars*(): expr",  "desc": "expands to <tt class=\"docutils literal\"><span class=\"pre\">charset({'a'..'z', 'A'..'Z', '0'..'9', '_'})</span></tt>" },  { "module": "pegs",  "name": "identStartChars",  "code": "template identStartChars*(): expr",  "desc": "expands to <tt class=\"docutils literal\"><span class=\"pre\">charset({'A'..'Z', 'a'..'z', '_'})</span></tt>" },  { "module": "pegs",  "name": "ident",  "code": "template ident*(): expr",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">[a-zA-Z_][a-zA-z_0-9]*</span></tt>; standard identifier" },  { "module": "pegs",  "name": "natural",  "code": "template natural*(): expr",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">\\d+</span></tt>" },  { "module": "pegs",  "name": "`$`",  "code": "proc `$`*(r: Peg): string {.nosideEffect, rtl, extern: \"npegsToString\".}",  "desc": "converts a PEG to its string representation" },  { "module": "pegs",  "name": "bounds",  "code": "proc bounds*(c: Captures; i: range[0 .. MaxSubpatterns - 1]): tuple[\u000A    first, last: int]",  "desc": "returns the bounds <tt class=\"docutils literal\"><span class=\"pre\">[first..last]</span></tt> of the <cite>i</cite>'th capture." },  { "module": "pegs",  "name": "rawMatch",  "code": "proc rawMatch*(s: string; p: Peg; start: int; c: var Captures): int {.\u000A    nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "low-level matching proc that implements the PEG interpreter. Use this for maximum efficiency (every other PEG operation ends up calling this proc). Returns -1 if it does not match, else the length of the match" },  { "module": "pegs",  "name": "match",  "code": "proc match*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {.\u000A    nosideEffect, rtl, extern: \"npegs$1Capture\".}",  "desc": "returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">s[start..]</span></tt> matches the <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> and the captured substrings in the array <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt>. If it does not match, nothing is written into <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned." },  { "module": "pegs",  "name": "match",  "code": "proc match*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> matches the <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> beginning from <tt class=\"docutils literal\"><span class=\"pre\">start</span></tt>." },  { "module": "pegs",  "name": "matchLen",  "code": "proc matchLen*(s: string; pattern: Peg; matches: var openArray[string]; \u000A               start = 0): int {.nosideEffect, rtl, extern: \"npegs$1Capture\".}",  "desc": "the same as <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of <cite>s</cite> remains that does not belong to the match." },  { "module": "pegs",  "name": "matchLen",  "code": "proc matchLen*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "the same as <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of <cite>s</cite> remains that does not belong to the match." },  { "module": "pegs",  "name": "find",  "code": "proc find*(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {.\u000A    nosideEffect, rtl, extern: \"npegs$1Capture\".}",  "desc": "returns the starting position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> and the captured substrings in the array <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt>. If it does not match, nothing is written into <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> and -1 is returned." },  { "module": "pegs",  "name": "findBounds",  "code": "proc findBounds*(s: string; pattern: Peg; matches: var openArray[string]; \u000A                 start = 0): tuple[first, last: int] {.nosideEffect, rtl, \u000A    extern: \"npegs$1Capture\".}",  "desc": "returns the starting position and end position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> and the captured substrings in the array <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt>. If it does not match, nothing is written into <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> and (-1,0) is returned." },  { "module": "pegs",  "name": "find",  "code": "proc find*(s: string; pattern: Peg; start = 0): int {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "returns the starting position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt>. If it does not match, -1 is returned." },  { "module": "pegs",  "name": "findAll",  "code": "iterator findAll*(s: string; pattern: Peg; start = 0): string",  "desc": "yields all matching <em>substrings</em> of <cite>s</cite> that match <cite>pattern</cite>." },  { "module": "pegs",  "name": "findAll",  "code": "proc findAll*(s: string; pattern: Peg; start = 0): seq[string] {.nosideEffect, \u000A    rtl, extern: \"npegs$1\".}",  "desc": "returns all matching <em>substrings</em> of <cite>s</cite> that match <cite>pattern</cite>. If it does not match, @[] is returned." },  { "module": "pegs",  "name": "`=~`",  "code": "template `=~`*(s: string; pattern: Peg): bool",  "desc": "This calls <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt> with an implicit declared <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> array that can be used in the scope of the <tt class=\"docutils literal\"><span class=\"pre\">=~</span></tt> call:<pre><span class=\"Keyword\">if</span> <span class=\"Identifier\">line</span> <span class=\"Operator\">=~</span> <span class=\"RawData\">peg&quot;\\s* {\\w+} \\s* '=' \\s* {\\w+}&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># matches a key=value pair:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Key: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Value: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">elif</span> <span class=\"Identifier\">line</span> <span class=\"Operator\">=~</span> <span class=\"RawData\">peg&quot;\\s*{'#'.*}&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># matches a comment</span>\u000A  <span class=\"Comment\"># note that the implicit ``matches`` array is different from the</span>\u000A  <span class=\"Comment\"># ``matches`` array of the first branch</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;comment: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;syntax error&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "pegs",  "name": "contains",  "code": "proc contains*(s: string; pattern: Peg; start = 0): bool {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, pattern, start) &gt;= 0</span></tt>" },  { "module": "pegs",  "name": "contains",  "code": "proc contains*(s: string; pattern: Peg; matches: var openArray[string]; \u000A               start = 0): bool {.nosideEffect, rtl, extern: \"npegs$1Capture\".}",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, pattern, matches, start) &gt;= 0</span></tt>" },  { "module": "pegs",  "name": "startsWith",  "code": "proc startsWith*(s: string; prefix: Peg; start = 0): bool {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "returns true if <cite>s</cite> starts with the pattern <cite>prefix</cite>" },  { "module": "pegs",  "name": "endsWith",  "code": "proc endsWith*(s: string; suffix: Peg; start = 0): bool {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "returns true if <cite>s</cite> ends with the pattern <cite>prefix</cite>" },  { "module": "pegs",  "name": "replacef",  "code": "proc replacef*(s: string; sub: Peg; by: string): string {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>. Captures can be accessed in <cite>by</cite> with the notation <tt class=\"docutils literal\"><span class=\"pre\">$i</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">$#</span></tt> (see strutils.`%`). Examples:<pre><span class=\"StringLit\">&quot;var1=key; var2=key2&quot;</span><span class=\"Operator\">.</span><span class=\"Identifier\">replace</span><span class=\"Punctuation\">(</span><span class=\"RawData\">peg&quot;{\\ident}'='{\\ident}&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;$1&lt;-$2$2&quot;</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;var1&lt;-keykey; val2&lt;-key2key2&quot;</span></pre>" },  { "module": "pegs",  "name": "replace",  "code": "proc replace*(s: string; sub: Peg; by = \"\"): string {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>. Captures cannot be accessed in <cite>by</cite>." },  { "module": "pegs",  "name": "parallelReplace",  "code": "proc parallelReplace*(s: string; \u000A                      subs: varargs[tuple[pattern: Peg, repl: string]]): string {.\u000A    nosideEffect, rtl, extern: \"npegs$1\".}",  "desc": "Returns a modified copy of <cite>s</cite> with the substitutions in <cite>subs</cite> applied in parallel." },  { "module": "pegs",  "name": "transformFile",  "code": "proc transformFile*(infile, outfile: string; \u000A                    subs: varargs[tuple[pattern: Peg, repl: string]]) {.rtl, \u000A    extern: \"npegs$1\".}",  "desc": "reads in the file <cite>infile</cite>, performs a parallel replacement (calls <cite>parallelReplace</cite>) and writes back to <cite>outfile</cite>. Raises <tt class=\"docutils literal\"><span class=\"pre\">EIO</span></tt> if an error occurs. This is supposed to be used for quick scripting." },  { "module": "pegs",  "name": "split",  "code": "iterator split*(s: string; sep: Peg): string",  "desc": "<p>Splits the string <cite>s</cite> into substrings.</p>\u000A<p>Substrings are separated by the PEG <cite>sep</cite>. Examples:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;00232this02939is39an22example111&quot;</span><span class=\"Punctuation\">,</span> <span class=\"RawData\">peg&quot;\\d+&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;this&quot;</span>\u000A<span class=\"StringLit\">&quot;is&quot;</span>\u000A<span class=\"StringLit\">&quot;an&quot;</span>\u000A<span class=\"StringLit\">&quot;example&quot;</span></pre>" },  { "module": "pegs",  "name": "split",  "code": "proc split*(s: string; sep: Peg): seq[string] {.nosideEffect, rtl, \u000A    extern: \"npegs$1\".}",  "desc": "Splits the string <cite>s</cite> into substrings." },  { "module": "pegs",  "name": "parsePeg",  "code": "proc parsePeg*(pattern: string; filename = \"pattern\"; line = 1; col = 0): Peg",  "desc": "constructs a Peg object from <cite>pattern</cite>. <cite>filename</cite>, <cite>line</cite>, <cite>col</cite> are used for error messages, but they only provide start offsets. <cite>parsePeg</cite> keeps track of line and column numbers within <cite>pattern</cite>." },  { "module": "pegs",  "name": "peg",  "code": "proc peg*(pattern: string): Peg",  "desc": "constructs a Peg object from the <cite>pattern</cite>. The short name has been chosen to encourage its use as a raw string modifier:<pre>\u000Apeg&quot;{\\ident} \\s* '=' \\s* {.*}&quot;</pre>\u000A" },  { "module": "pegs",  "name": "escapePeg",  "code": "proc escapePeg*(s: string): string",  "desc": "escapes <cite>s</cite> so that it is matched verbatim when used as a peg." },  { "module": "poly",  "name": "degree",  "code": "proc degree*(p: Poly): int",  "desc": "Returns the degree of the polynomial, that is the number of coefficients-1" },  { "module": "poly",  "name": "eval",  "code": "proc eval*(p: Poly; x: float): float",  "desc": "Evaluates a polynomial function value for <cite>x</cite> quickly using Horners method" },  { "module": "poly",  "name": "`[]`",  "code": "proc `[]`*(p: Poly; idx: int): float",  "desc": "Gets a coefficient of the polynomial. p[2] will returns the quadric term, p[3] the cubic etc. Out of bounds index will return 0.0." },  { "module": "poly",  "name": "`[]=`",  "code": "proc `[]=`*(p: var Poly; idx: int; v: float)",  "desc": "Sets an coefficient of the polynomial by index. p[2] set the quadric term, p[3] the cubic etc. If index is out of range for the coefficients, the polynomial grows to the smallest needed degree." },  { "module": "poly",  "name": "items",  "code": "iterator items*(p: Poly): float",  "desc": "Iterates through the corfficients of the polynomial." },  { "module": "poly",  "name": "clean",  "code": "proc clean*(p: var Poly; zerotol = 0.0)",  "desc": "Removes leading zero coefficients of the polynomial. An optional tolerance can be given for what's considered zero." },  { "module": "poly",  "name": "`$`",  "code": "proc `$`*(p: Poly): string",  "desc": "Gets a somewhat reasonable string representation of the polynomial The format should be compatible with most online function plotters, for example directly in google search" },  { "module": "poly",  "name": "derivative",  "code": "proc derivative*(p: Poly): Poly",  "desc": "Returns a new polynomial, which is the derivative of <cite>p</cite>" },  { "module": "poly",  "name": "diff",  "code": "proc diff*(p: Poly; x: float): float",  "desc": "Evaluates the differentiation of a polynomial with respect to <cite>x</cite> quickly using a modifed Horners method" },  { "module": "poly",  "name": "integral",  "code": "proc integral*(p: Poly): Poly",  "desc": "Returns a new polynomial which is the indefinite integral of <cite>p</cite>. The constant term is set to 0.0" },  { "module": "poly",  "name": "integrate",  "code": "proc integrate*(p: Poly; xmin, xmax: float): float",  "desc": "Computes the definite integral of <cite>p</cite> between <cite>xmin</cite> and <cite>xmax</cite> quickly using a modified version of Horners method" },  { "module": "poly",  "name": "initPoly",  "code": "proc initPoly*(cofs: varargs[float]): Poly",  "desc": "Initializes a polynomial with given coefficients. The most significant coefficient is first, so to create x^2-2x+3: intiPoly(1.0,-2.0,3.0)" },  { "module": "poly",  "name": "divMod",  "code": "proc divMod*(p, d: Poly; q, r: var Poly)",  "desc": "Divides <cite>p</cite> with <cite>d</cite>, and stores the quotinent in <cite>q</cite> and the remainder in <cite>d</cite>" },  { "module": "poly",  "name": "`+`",  "code": "proc `+`*(p1: Poly; p2: Poly): Poly",  "desc": "Adds two polynomials" },  { "module": "poly",  "name": "`*`",  "code": "proc `*`*(p1: Poly; p2: Poly): Poly",  "desc": "Multiplies the polynomial <cite>p1</cite> with <cite>p2</cite>" },  { "module": "poly",  "name": "`*`",  "code": "proc `*`*(p: Poly; f: float): Poly",  "desc": "Multiplies the polynomial <cite>p</cite> with a real number" },  { "module": "poly",  "name": "`*`",  "code": "proc `*`*(f: float; p: Poly): Poly",  "desc": "Multiplies a real number with a polynomial" },  { "module": "poly",  "name": "`-`",  "code": "proc `-`*(p: Poly): Poly",  "desc": "Negates a polynomial" },  { "module": "poly",  "name": "`-`",  "code": "proc `-`*(p1: Poly; p2: Poly): Poly",  "desc": "Subtract <cite>p1</cite> with <cite>p2</cite>" },  { "module": "poly",  "name": "`/`",  "code": "proc `/`*(p: Poly; f: float): Poly",  "desc": "Divides polynomial <cite>p</cite> with a real number <cite>f</cite>" },  { "module": "poly",  "name": "`/`",  "code": "proc `/`*(p, q: Poly): Poly",  "desc": "Divides polynomial <cite>p</cite> with polynomial <cite>q</cite>" },  { "module": "poly",  "name": "`mod`",  "code": "proc `mod`*(p, q: Poly): Poly",  "desc": "Computes the polynomial modulo operation, that is the remainder of <cite>p</cite>/<cite>q</cite>" },  { "module": "poly",  "name": "normalize",  "code": "proc normalize*(p: var Poly)",  "desc": "Multiplies the polynomial inplace by a term so that the leading term is 1.0. This might lead to an unstable polynomial if the leading term is zero." },  { "module": "poly",  "name": "solveQuadric",  "code": "proc solveQuadric*(a, b, c: float; zerotol = 0.0): seq[float]",  "desc": "Solves the quadric equation <cite>ax^2+bx+c</cite>, with a possible tolerance <cite>zerotol</cite> to find roots of curves just 'touching' the x axis. Returns sequence with 0,1 or 2 solutions." },  { "module": "poly",  "name": "roots",  "code": "proc roots*(p: Poly; tol = 1e-09; zerotol = 1e-06; mergetol = 1e-12; \u000A            maxiter = 1000): seq[float]",  "desc": "Computes the real roots of the polynomial <cite>p</cite> <cite>tol</cite> is the tolerance used to break searching for each root when reached. <cite>zerotol</cite> is the tolerance, which is 'close enough' to zero to be considered a root and is used to find roots for curves that only 'touch' the x-axis. <cite>mergetol</cite> is the tolerance, of which two x-values are considered beeing the same root. <cite>maxiter</cite> can be used to limit the number of iterations for each root. Returns a (possibly empty) sorted sequence with the solutions." },  { "module": "posix",  "name": "aio_cancel",  "code": "proc aio_cancel*(a1: cint; a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_error",  "code": "proc aio_error*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_fsync",  "code": "proc aio_fsync*(a1: cint; a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_read",  "code": "proc aio_read*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_return",  "code": "proc aio_return*(a1: ptr Taiocb): int {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_suspend",  "code": "proc aio_suspend*(a1: ptr ptr Taiocb; a2: cint; a3: ptr Ttimespec): cint {.\u000A    importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "aio_write",  "code": "proc aio_write*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "lio_listio",  "code": "proc lio_listio*(a1: cint; a2: ptr ptr Taiocb; a3: cint; a4: ptr TsigEvent): cint {.\u000A    importc, header: \"<aio.h>\".}" },  { "module": "posix",  "name": "htonl",  "code": "proc htonl*(a1: int32): int32 {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "htons",  "code": "proc htons*(a1: int16): int16 {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "ntohl",  "code": "proc ntohl*(a1: int32): int32 {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "ntohs",  "code": "proc ntohs*(a1: int16): int16 {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "inet_addr",  "code": "proc inet_addr*(a1: cstring): TInAddrT {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "inet_ntoa",  "code": "proc inet_ntoa*(a1: InAddr): cstring {.importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "inet_ntop",  "code": "proc inet_ntop*(a1: cint; a2: pointer; a3: cstring; a4: int32): cstring {.\u000A    importc, header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "inet_pton",  "code": "proc inet_pton*(a1: cint; a2: cstring; a3: pointer): cint {.importc, \u000A    header: \"<arpa/inet.h>\".}" },  { "module": "posix",  "name": "IN6ADDR_ANY_INIT",  "code": "proc IN6ADDR_ANY_INIT*(): TIn6Addr {.importc, header: \"<netinet/in.h>\".}" },  { "module": "posix",  "name": "IN6ADDR_LOOPBACK_INIT",  "code": "proc IN6ADDR_LOOPBACK_INIT*(): TIn6Addr {.importc, header: \"<netinet/in.h>\".}" },  { "module": "posix",  "name": "closedir",  "code": "proc closedir*(a1: ptr TDIR): cint {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "opendir",  "code": "proc opendir*(a1: cstring): ptr TDIR {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "readdir",  "code": "proc readdir*(a1: ptr TDIR): ptr Tdirent {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "readdir_r",  "code": "proc readdir_r*(a1: ptr TDIR; a2: ptr Tdirent; a3: ptr ptr Tdirent): cint {.\u000A    importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "rewinddir",  "code": "proc rewinddir*(a1: ptr TDIR) {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "seekdir",  "code": "proc seekdir*(a1: ptr TDIR; a2: int) {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "telldir",  "code": "proc telldir*(a1: ptr TDIR): int {.importc, header: \"<dirent.h>\".}" },  { "module": "posix",  "name": "dlclose",  "code": "proc dlclose*(a1: pointer): cint {.importc, header: \"<dlfcn.h>\".}" },  { "module": "posix",  "name": "dlerror",  "code": "proc dlerror*(): cstring {.importc, header: \"<dlfcn.h>\".}" },  { "module": "posix",  "name": "dlopen",  "code": "proc dlopen*(a1: cstring; a2: cint): pointer {.importc, header: \"<dlfcn.h>\".}" },  { "module": "posix",  "name": "dlsym",  "code": "proc dlsym*(a1: pointer; a2: cstring): pointer {.importc, header: \"<dlfcn.h>\".}" },  { "module": "posix",  "name": "creat",  "code": "proc creat*(a1: cstring; a2: TMode): cint {.importc, header: \"<fcntl.h>\".}" },  { "module": "posix",  "name": "fcntl",  "code": "proc fcntl*(a1: cint | SocketHandle; a2: cint): cint {.varargs, importc, \u000A    header: \"<fcntl.h>\".}" },  { "module": "posix",  "name": "open",  "code": "proc open*(a1: cstring; a2: cint): cint {.varargs, importc, header: \"<fcntl.h>\".}" },  { "module": "posix",  "name": "posix_fadvise",  "code": "proc posix_fadvise*(a1: cint; a2, a3: TOff; a4: cint): cint {.importc, \u000A    header: \"<fcntl.h>\".}" },  { "module": "posix",  "name": "posix_fallocate",  "code": "proc posix_fallocate*(a1: cint; a2, a3: TOff): cint {.importc, \u000A    header: \"<fcntl.h>\".}" },  { "module": "posix",  "name": "fmtmsg",  "code": "proc fmtmsg*(a1: int; a2: cstring; a3: cint; a4, a5, a6: cstring): cint {.\u000A    importc, header: \"<fmtmsg.h>\".}" },  { "module": "posix",  "name": "fnmatch",  "code": "proc fnmatch*(a1, a2: cstring; a3: cint): cint {.importc, header: \"<fnmatch.h>\".}" },  { "module": "posix",  "name": "ftw",  "code": "proc ftw*(a1: cstring; \u000A          a2: proc (x1: cstring; x2: ptr TStat; x3: cint): cint {.noconv.}; \u000A          a3: cint): cint {.importc, header: \"<ftw.h>\".}" },  { "module": "posix",  "name": "nftw",  "code": "proc nftw*(a1: cstring; a2: proc (x1: cstring; x2: ptr TStat; x3: cint; \u000A                                  x4: ptr TFTW): cint {.noconv.}; a3: cint; \u000A           a4: cint): cint {.importc, header: \"<ftw.h>\".}" },  { "module": "posix",  "name": "glob",  "code": "proc glob*(a1: cstring; a2: cint; \u000A           a3: proc (x1: cstring; x2: cint): cint {.noconv.}; a4: ptr TGlob): cint {.\u000A    importc, header: \"<glob.h>\".}" },  { "module": "posix",  "name": "globfree",  "code": "proc globfree*(a1: ptr TGlob) {.importc, header: \"<glob.h>\".}" },  { "module": "posix",  "name": "getgrgid",  "code": "proc getgrgid*(a1: TGid): ptr TGroup {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "getgrnam",  "code": "proc getgrnam*(a1: cstring): ptr TGroup {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "getgrgid_r",  "code": "proc getgrgid_r*(a1: TGid; a2: ptr TGroup; a3: cstring; a4: int; \u000A                 a5: ptr ptr TGroup): cint {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "getgrnam_r",  "code": "proc getgrnam_r*(a1: cstring; a2: ptr TGroup; a3: cstring; a4: int; \u000A                 a5: ptr ptr TGroup): cint {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "getgrent",  "code": "proc getgrent*(): ptr TGroup {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "endgrent",  "code": "proc endgrent*() {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "setgrent",  "code": "proc setgrent*() {.importc, header: \"<grp.h>\".}" },  { "module": "posix",  "name": "iconv_open",  "code": "proc iconv_open*(a1, a2: cstring): Ticonv {.importc, header: \"<iconv.h>\".}" },  { "module": "posix",  "name": "iconv",  "code": "proc iconv*(a1: Ticonv; a2: var cstring; a3: var int; a4: var cstring; \u000A            a5: var int): int {.importc, header: \"<iconv.h>\".}" },  { "module": "posix",  "name": "iconv_close",  "code": "proc iconv_close*(a1: Ticonv): cint {.importc, header: \"<iconv.h>\".}" },  { "module": "posix",  "name": "nl_langinfo",  "code": "proc nl_langinfo*(a1: Tnl_item): cstring {.importc, header: \"<langinfo.h>\".}" },  { "module": "posix",  "name": "basename",  "code": "proc basename*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}" },  { "module": "posix",  "name": "dirname",  "code": "proc dirname*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}" },  { "module": "posix",  "name": "localeconv",  "code": "proc localeconv*(): ptr Tlconv {.importc, header: \"<locale.h>\".}" },  { "module": "posix",  "name": "setlocale",  "code": "proc setlocale*(a1: cint; a2: cstring): cstring {.importc, header: \"<locale.h>\".}" },  { "module": "posix",  "name": "strfmon",  "code": "proc strfmon*(a1: cstring; a2: int; a3: cstring): int {.varargs, importc, \u000A    header: \"<monetary.h>\".}" },  { "module": "posix",  "name": "mq_close",  "code": "proc mq_close*(a1: TMqd): cint {.importc, header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_getattr",  "code": "proc mq_getattr*(a1: TMqd; a2: ptr TMqAttr): cint {.importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_notify",  "code": "proc mq_notify*(a1: TMqd; a2: ptr TsigEvent): cint {.importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_open",  "code": "proc mq_open*(a1: cstring; a2: cint): TMqd {.varargs, importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_receive",  "code": "proc mq_receive*(a1: TMqd; a2: cstring; a3: int; a4: var int): int {.importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_send",  "code": "proc mq_send*(a1: TMqd; a2: cstring; a3: int; a4: int): cint {.importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_setattr",  "code": "proc mq_setattr*(a1: TMqd; a2, a3: ptr TMqAttr): cint {.importc, \u000A    header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_timedreceive",  "code": "proc mq_timedreceive*(a1: TMqd; a2: cstring; a3: int; a4: int; a5: ptr Ttimespec): int {.\u000A    importc, header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_timedsend",  "code": "proc mq_timedsend*(a1: TMqd; a2: cstring; a3: int; a4: int; a5: ptr Ttimespec): cint {.\u000A    importc, header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "mq_unlink",  "code": "proc mq_unlink*(a1: cstring): cint {.importc, header: \"<mqueue.h>\".}" },  { "module": "posix",  "name": "getpwnam",  "code": "proc getpwnam*(a1: cstring): ptr TPasswd {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "getpwuid",  "code": "proc getpwuid*(a1: Tuid): ptr TPasswd {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "getpwnam_r",  "code": "proc getpwnam_r*(a1: cstring; a2: ptr TPasswd; a3: cstring; a4: int; \u000A                 a5: ptr ptr TPasswd): cint {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "getpwuid_r",  "code": "proc getpwuid_r*(a1: Tuid; a2: ptr TPasswd; a3: cstring; a4: int; \u000A                 a5: ptr ptr TPasswd): cint {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "endpwent",  "code": "proc endpwent*() {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "getpwent",  "code": "proc getpwent*(): ptr TPasswd {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "setpwent",  "code": "proc setpwent*() {.importc, header: \"<pwd.h>\".}" },  { "module": "posix",  "name": "uname",  "code": "proc uname*(a1: var Tutsname): cint {.importc, header: \"<sys/utsname.h>\".}" },  { "module": "posix",  "name": "pthread_atfork",  "code": "proc pthread_atfork*(a1, a2, a3: proc () {.noconv.}): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_destroy",  "code": "proc pthread_attr_destroy*(a1: ptr Tpthread_attr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getdetachstate",  "code": "proc pthread_attr_getdetachstate*(a1: ptr Tpthread_attr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getguardsize",  "code": "proc pthread_attr_getguardsize*(a1: ptr Tpthread_attr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getinheritsched",  "code": "proc pthread_attr_getinheritsched*(a1: ptr Tpthread_attr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getschedparam",  "code": "proc pthread_attr_getschedparam*(a1: ptr Tpthread_attr; a2: ptr Tsched_param): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getschedpolicy",  "code": "proc pthread_attr_getschedpolicy*(a1: ptr Tpthread_attr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getscope",  "code": "proc pthread_attr_getscope*(a1: ptr Tpthread_attr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getstack",  "code": "proc pthread_attr_getstack*(a1: ptr Tpthread_attr; a2: var pointer; a3: var int): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getstackaddr",  "code": "proc pthread_attr_getstackaddr*(a1: ptr Tpthread_attr; a2: var pointer): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_getstacksize",  "code": "proc pthread_attr_getstacksize*(a1: ptr Tpthread_attr; a2: var int): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_init",  "code": "proc pthread_attr_init*(a1: ptr Tpthread_attr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setdetachstate",  "code": "proc pthread_attr_setdetachstate*(a1: ptr Tpthread_attr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setguardsize",  "code": "proc pthread_attr_setguardsize*(a1: ptr Tpthread_attr; a2: int): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setinheritsched",  "code": "proc pthread_attr_setinheritsched*(a1: ptr Tpthread_attr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setschedparam",  "code": "proc pthread_attr_setschedparam*(a1: ptr Tpthread_attr; a2: ptr Tsched_param): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setschedpolicy",  "code": "proc pthread_attr_setschedpolicy*(a1: ptr Tpthread_attr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setscope",  "code": "proc pthread_attr_setscope*(a1: ptr Tpthread_attr; a2: cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setstack",  "code": "proc pthread_attr_setstack*(a1: ptr Tpthread_attr; a2: pointer; a3: int): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setstackaddr",  "code": "proc pthread_attr_setstackaddr*(a1: ptr Tpthread_attr; a2: pointer): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_attr_setstacksize",  "code": "proc pthread_attr_setstacksize*(a1: ptr Tpthread_attr; a2: int): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrier_destroy",  "code": "proc pthread_barrier_destroy*(a1: ptr Tpthread_barrier): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrier_init",  "code": "proc pthread_barrier_init*(a1: ptr Tpthread_barrier; \u000A                           a2: ptr Tpthread_barrierattr; a3: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrier_wait",  "code": "proc pthread_barrier_wait*(a1: ptr Tpthread_barrier): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrierattr_destroy",  "code": "proc pthread_barrierattr_destroy*(a1: ptr Tpthread_barrierattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrierattr_getpshared",  "code": "proc pthread_barrierattr_getpshared*(a1: ptr Tpthread_barrierattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrierattr_init",  "code": "proc pthread_barrierattr_init*(a1: ptr Tpthread_barrierattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_barrierattr_setpshared",  "code": "proc pthread_barrierattr_setpshared*(a1: ptr Tpthread_barrierattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cancel",  "code": "proc pthread_cancel*(a1: Tpthread): cint {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cleanup_push",  "code": "proc pthread_cleanup_push*(a1: proc (x: pointer) {.noconv.}; a2: pointer) {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cleanup_pop",  "code": "proc pthread_cleanup_pop*(a1: cint) {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_broadcast",  "code": "proc pthread_cond_broadcast*(a1: ptr Tpthread_cond): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_destroy",  "code": "proc pthread_cond_destroy*(a1: ptr Tpthread_cond): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_init",  "code": "proc pthread_cond_init*(a1: ptr Tpthread_cond; a2: ptr Tpthread_condattr): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_signal",  "code": "proc pthread_cond_signal*(a1: ptr Tpthread_cond): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_timedwait",  "code": "proc pthread_cond_timedwait*(a1: ptr Tpthread_cond; a2: ptr Tpthread_mutex; \u000A                             a3: ptr Ttimespec): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_cond_wait",  "code": "proc pthread_cond_wait*(a1: ptr Tpthread_cond; a2: ptr Tpthread_mutex): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_destroy",  "code": "proc pthread_condattr_destroy*(a1: ptr Tpthread_condattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_getclock",  "code": "proc pthread_condattr_getclock*(a1: ptr Tpthread_condattr; a2: var TClockId): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_getpshared",  "code": "proc pthread_condattr_getpshared*(a1: ptr Tpthread_condattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_init",  "code": "proc pthread_condattr_init*(a1: ptr Tpthread_condattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_setclock",  "code": "proc pthread_condattr_setclock*(a1: ptr Tpthread_condattr; a2: TClockId): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_condattr_setpshared",  "code": "proc pthread_condattr_setpshared*(a1: ptr Tpthread_condattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_create",  "code": "proc pthread_create*(a1: ptr Tpthread; a2: ptr Tpthread_attr; \u000A                     a3: proc (x: pointer): pointer {.noconv.}; a4: pointer): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_detach",  "code": "proc pthread_detach*(a1: Tpthread): cint {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_equal",  "code": "proc pthread_equal*(a1, a2: Tpthread): cint {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_exit",  "code": "proc pthread_exit*(a1: pointer) {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_getconcurrency",  "code": "proc pthread_getconcurrency*(): cint {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_getcpuclockid",  "code": "proc pthread_getcpuclockid*(a1: Tpthread; a2: var TClockId): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_getschedparam",  "code": "proc pthread_getschedparam*(a1: Tpthread; a2: var cint; a3: ptr Tsched_param): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_getspecific",  "code": "proc pthread_getspecific*(a1: Tpthread_key): pointer {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_join",  "code": "proc pthread_join*(a1: Tpthread; a2: ptr pointer): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_key_create",  "code": "proc pthread_key_create*(a1: ptr Tpthread_key; a2: proc (x: pointer) {.noconv.}): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_key_delete",  "code": "proc pthread_key_delete*(a1: Tpthread_key): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_destroy",  "code": "proc pthread_mutex_destroy*(a1: ptr Tpthread_mutex): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_getprioceiling",  "code": "proc pthread_mutex_getprioceiling*(a1: ptr Tpthread_mutex; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_init",  "code": "proc pthread_mutex_init*(a1: ptr Tpthread_mutex; a2: ptr Tpthread_mutexattr): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_lock",  "code": "proc pthread_mutex_lock*(a1: ptr Tpthread_mutex): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_setprioceiling",  "code": "proc pthread_mutex_setprioceiling*(a1: ptr Tpthread_mutex; a2: cint; \u000A                                   a3: var cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_timedlock",  "code": "proc pthread_mutex_timedlock*(a1: ptr Tpthread_mutex; a2: ptr Ttimespec): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_trylock",  "code": "proc pthread_mutex_trylock*(a1: ptr Tpthread_mutex): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutex_unlock",  "code": "proc pthread_mutex_unlock*(a1: ptr Tpthread_mutex): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_destroy",  "code": "proc pthread_mutexattr_destroy*(a1: ptr Tpthread_mutexattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_getprioceiling",  "code": "proc pthread_mutexattr_getprioceiling*(a1: ptr Tpthread_mutexattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_getprotocol",  "code": "proc pthread_mutexattr_getprotocol*(a1: ptr Tpthread_mutexattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_getpshared",  "code": "proc pthread_mutexattr_getpshared*(a1: ptr Tpthread_mutexattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_gettype",  "code": "proc pthread_mutexattr_gettype*(a1: ptr Tpthread_mutexattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_init",  "code": "proc pthread_mutexattr_init*(a1: ptr Tpthread_mutexattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_setprioceiling",  "code": "proc pthread_mutexattr_setprioceiling*(a1: ptr Tpthread_mutexattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_setprotocol",  "code": "proc pthread_mutexattr_setprotocol*(a1: ptr Tpthread_mutexattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_setpshared",  "code": "proc pthread_mutexattr_setpshared*(a1: ptr Tpthread_mutexattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_mutexattr_settype",  "code": "proc pthread_mutexattr_settype*(a1: ptr Tpthread_mutexattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_once",  "code": "proc pthread_once*(a1: ptr Tpthread_once; a2: proc () {.noconv.}): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_destroy",  "code": "proc pthread_rwlock_destroy*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_init",  "code": "proc pthread_rwlock_init*(a1: ptr Tpthread_rwlock; a2: ptr Tpthread_rwlockattr): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_rdlock",  "code": "proc pthread_rwlock_rdlock*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_timedrdlock",  "code": "proc pthread_rwlock_timedrdlock*(a1: ptr Tpthread_rwlock; a2: ptr Ttimespec): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_timedwrlock",  "code": "proc pthread_rwlock_timedwrlock*(a1: ptr Tpthread_rwlock; a2: ptr Ttimespec): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_tryrdlock",  "code": "proc pthread_rwlock_tryrdlock*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_trywrlock",  "code": "proc pthread_rwlock_trywrlock*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_unlock",  "code": "proc pthread_rwlock_unlock*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlock_wrlock",  "code": "proc pthread_rwlock_wrlock*(a1: ptr Tpthread_rwlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlockattr_destroy",  "code": "proc pthread_rwlockattr_destroy*(a1: ptr Tpthread_rwlockattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlockattr_getpshared",  "code": "proc pthread_rwlockattr_getpshared*(a1: ptr Tpthread_rwlockattr; a2: var cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlockattr_init",  "code": "proc pthread_rwlockattr_init*(a1: ptr Tpthread_rwlockattr): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_rwlockattr_setpshared",  "code": "proc pthread_rwlockattr_setpshared*(a1: ptr Tpthread_rwlockattr; a2: cint): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_self",  "code": "proc pthread_self*(): Tpthread {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setcancelstate",  "code": "proc pthread_setcancelstate*(a1: cint; a2: var cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setcanceltype",  "code": "proc pthread_setcanceltype*(a1: cint; a2: var cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setconcurrency",  "code": "proc pthread_setconcurrency*(a1: cint): cint {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setschedparam",  "code": "proc pthread_setschedparam*(a1: Tpthread; a2: cint; a3: ptr Tsched_param): cint {.\u000A    importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setschedprio",  "code": "proc pthread_setschedprio*(a1: Tpthread; a2: cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_setspecific",  "code": "proc pthread_setspecific*(a1: Tpthread_key; a2: pointer): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_spin_destroy",  "code": "proc pthread_spin_destroy*(a1: ptr Tpthread_spinlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_spin_init",  "code": "proc pthread_spin_init*(a1: ptr Tpthread_spinlock; a2: cint): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_spin_lock",  "code": "proc pthread_spin_lock*(a1: ptr Tpthread_spinlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_spin_trylock",  "code": "proc pthread_spin_trylock*(a1: ptr Tpthread_spinlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_spin_unlock",  "code": "proc pthread_spin_unlock*(a1: ptr Tpthread_spinlock): cint {.importc, \u000A    header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "pthread_testcancel",  "code": "proc pthread_testcancel*() {.importc, header: \"<pthread.h>\".}" },  { "module": "posix",  "name": "exitnow",  "code": "proc exitnow*(code: int): void {.importc: \"_exit\", header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "access",  "code": "proc access*(a1: cstring; a2: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "alarm",  "code": "proc alarm*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "chdir",  "code": "proc chdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "chown",  "code": "proc chown*(a1: cstring; a2: Tuid; a3: TGid): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "close",  "code": "proc close*(a1: cint | SocketHandle): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "confstr",  "code": "proc confstr*(a1: cint; a2: cstring; a3: int): int {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "crypt",  "code": "proc crypt*(a1, a2: cstring): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "ctermid",  "code": "proc ctermid*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "dup",  "code": "proc dup*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "dup2",  "code": "proc dup2*(a1, a2: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "encrypt",  "code": "proc encrypt*(a1: array[0 .. 63, char]; a2: cint) {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execl",  "code": "proc execl*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execle",  "code": "proc execle*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execlp",  "code": "proc execlp*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execv",  "code": "proc execv*(a1: cstring; a2: cstringArray): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execve",  "code": "proc execve*(a1: cstring; a2, a3: cstringArray): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execvp",  "code": "proc execvp*(a1: cstring; a2: cstringArray): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "execvpe",  "code": "proc execvpe*(a1: cstring; a2: cstringArray; a3: cstringArray): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fchown",  "code": "proc fchown*(a1: cint; a2: Tuid; a3: TGid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fchdir",  "code": "proc fchdir*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fdatasync",  "code": "proc fdatasync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fork",  "code": "proc fork*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fpathconf",  "code": "proc fpathconf*(a1, a2: cint): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "fsync",  "code": "proc fsync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "ftruncate",  "code": "proc ftruncate*(a1: cint; a2: TOff): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getcwd",  "code": "proc getcwd*(a1: cstring; a2: int): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getegid",  "code": "proc getegid*(): TGid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "geteuid",  "code": "proc geteuid*(): Tuid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getgid",  "code": "proc getgid*(): TGid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getgroups",  "code": "proc getgroups*(a1: cint; a2: ptr array[0 .. 255, TGid]): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "gethostid",  "code": "proc gethostid*(): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "gethostname",  "code": "proc gethostname*(a1: cstring; a2: int): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getlogin",  "code": "proc getlogin*(): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getlogin_r",  "code": "proc getlogin_r*(a1: cstring; a2: int): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getopt",  "code": "proc getopt*(a1: cint; a2: cstringArray; a3: cstring): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getpgid",  "code": "proc getpgid*(a1: TPid): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getpgrp",  "code": "proc getpgrp*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getpid",  "code": "proc getpid*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getppid",  "code": "proc getppid*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getsid",  "code": "proc getsid*(a1: TPid): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getuid",  "code": "proc getuid*(): Tuid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "getwd",  "code": "proc getwd*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "isatty",  "code": "proc isatty*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "lchown",  "code": "proc lchown*(a1: cstring; a2: Tuid; a3: TGid): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "link",  "code": "proc link*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "lockf",  "code": "proc lockf*(a1, a2: cint; a3: TOff): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "lseek",  "code": "proc lseek*(a1: cint; a2: TOff; a3: cint): TOff {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "nice",  "code": "proc nice*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "pathconf",  "code": "proc pathconf*(a1: cstring; a2: cint): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "pause",  "code": "proc pause*(): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "pipe",  "code": "proc pipe*(a: array[0 .. 1, cint]): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "pread",  "code": "proc pread*(a1: cint; a2: pointer; a3: int; a4: TOff): int {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "pwrite",  "code": "proc pwrite*(a1: cint; a2: pointer; a3: int; a4: TOff): int {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "read",  "code": "proc read*(a1: cint; a2: pointer; a3: int): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "readlink",  "code": "proc readlink*(a1, a2: cstring; a3: int): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "rmdir",  "code": "proc rmdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setegid",  "code": "proc setegid*(a1: TGid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "seteuid",  "code": "proc seteuid*(a1: Tuid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setgid",  "code": "proc setgid*(a1: TGid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setpgid",  "code": "proc setpgid*(a1, a2: TPid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setpgrp",  "code": "proc setpgrp*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setregid",  "code": "proc setregid*(a1, a2: TGid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setreuid",  "code": "proc setreuid*(a1, a2: Tuid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setsid",  "code": "proc setsid*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "setuid",  "code": "proc setuid*(a1: Tuid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "sleep",  "code": "proc sleep*(a1: cint): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "swab",  "code": "proc swab*(a1, a2: pointer; a3: int) {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "symlink",  "code": "proc symlink*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "sync",  "code": "proc sync*() {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "sysconf",  "code": "proc sysconf*(a1: cint): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "tcgetpgrp",  "code": "proc tcgetpgrp*(a1: cint): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "tcsetpgrp",  "code": "proc tcsetpgrp*(a1: cint; a2: TPid): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "truncate",  "code": "proc truncate*(a1: cstring; a2: TOff): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "ttyname",  "code": "proc ttyname*(a1: cint): cstring {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "ttyname_r",  "code": "proc ttyname_r*(a1: cint; a2: cstring; a3: int): cint {.importc, \u000A    header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "ualarm",  "code": "proc ualarm*(a1, a2: Tuseconds): Tuseconds {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "unlink",  "code": "proc unlink*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "usleep",  "code": "proc usleep*(a1: Tuseconds): cint {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "vfork",  "code": "proc vfork*(): TPid {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "write",  "code": "proc write*(a1: cint; a2: pointer; a3: int): int {.importc, header: \"<unistd.h>\".}" },  { "module": "posix",  "name": "sem_close",  "code": "proc sem_close*(a1: ptr TSem): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_destroy",  "code": "proc sem_destroy*(a1: ptr TSem): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_getvalue",  "code": "proc sem_getvalue*(a1: ptr TSem; a2: var cint): cint {.importc, \u000A    header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_init",  "code": "proc sem_init*(a1: ptr TSem; a2: cint; a3: cint): cint {.importc, \u000A    header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_open",  "code": "proc sem_open*(a1: cstring; a2: cint): ptr TSem {.varargs, importc, \u000A    header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_post",  "code": "proc sem_post*(a1: ptr TSem): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_timedwait",  "code": "proc sem_timedwait*(a1: ptr TSem; a2: ptr Ttimespec): cint {.importc, \u000A    header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_trywait",  "code": "proc sem_trywait*(a1: ptr TSem): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_unlink",  "code": "proc sem_unlink*(a1: cstring): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "sem_wait",  "code": "proc sem_wait*(a1: ptr TSem): cint {.importc, header: \"<semaphore.h>\".}" },  { "module": "posix",  "name": "ftok",  "code": "proc ftok*(a1: cstring; a2: cint): TKey {.importc, header: \"<sys/ipc.h>\".}" },  { "module": "posix",  "name": "statvfs",  "code": "proc statvfs*(a1: cstring; a2: var TStatvfs): cint {.importc, \u000A    header: \"<sys/statvfs.h>\".}" },  { "module": "posix",  "name": "fstatvfs",  "code": "proc fstatvfs*(a1: cint; a2: var TStatvfs): cint {.importc, \u000A    header: \"<sys/statvfs.h>\".}" },  { "module": "posix",  "name": "chmod",  "code": "proc chmod*(a1: cstring; a2: TMode): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "fchmod",  "code": "proc fchmod*(a1: cint; a2: TMode): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "fstat",  "code": "proc fstat*(a1: cint; a2: var TStat): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "lstat",  "code": "proc lstat*(a1: cstring; a2: var TStat): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "mkdir",  "code": "proc mkdir*(a1: cstring; a2: TMode): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "mkfifo",  "code": "proc mkfifo*(a1: cstring; a2: TMode): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "mknod",  "code": "proc mknod*(a1: cstring; a2: TMode; a3: TDev): cint {.importc, \u000A    header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "stat",  "code": "proc stat*(a1: cstring; a2: var TStat): cint {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "umask",  "code": "proc umask*(a1: TMode): TMode {.importc, header: \"<sys/stat.h>\".}" },  { "module": "posix",  "name": "S_ISBLK",  "code": "proc S_ISBLK*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a block special file." },  { "module": "posix",  "name": "S_ISCHR",  "code": "proc S_ISCHR*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a character special file." },  { "module": "posix",  "name": "S_ISDIR",  "code": "proc S_ISDIR*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a directory." },  { "module": "posix",  "name": "S_ISFIFO",  "code": "proc S_ISFIFO*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a pipe or FIFO special file." },  { "module": "posix",  "name": "S_ISREG",  "code": "proc S_ISREG*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a regular file." },  { "module": "posix",  "name": "S_ISLNK",  "code": "proc S_ISLNK*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a symbolic link." },  { "module": "posix",  "name": "S_ISSOCK",  "code": "proc S_ISSOCK*(m: TMode): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a socket." },  { "module": "posix",  "name": "S_TYPEISMQ",  "code": "proc S_TYPEISMQ*(buf: var TStat): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a message queue." },  { "module": "posix",  "name": "S_TYPEISSEM",  "code": "proc S_TYPEISSEM*(buf: var TStat): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a semaphore." },  { "module": "posix",  "name": "S_TYPEISSHM",  "code": "proc S_TYPEISSHM*(buf: var TStat): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test for a shared memory object." },  { "module": "posix",  "name": "S_TYPEISTMO",  "code": "proc S_TYPEISTMO*(buf: var TStat): bool {.importc, header: \"<sys/stat.h>\".}",  "desc": "Test macro for a typed memory object." },  { "module": "posix",  "name": "mlock",  "code": "proc mlock*(a1: pointer; a2: int): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "mlockall",  "code": "proc mlockall*(a1: cint): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "mmap",  "code": "proc mmap*(a1: pointer; a2: int; a3, a4, a5: cint; a6: TOff): pointer {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "mprotect",  "code": "proc mprotect*(a1: pointer; a2: int; a3: cint): cint {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "msync",  "code": "proc msync*(a1: pointer; a2: int; a3: cint): cint {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "munlock",  "code": "proc munlock*(a1: pointer; a2: int): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "munlockall",  "code": "proc munlockall*(): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "munmap",  "code": "proc munmap*(a1: pointer; a2: int): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "posix_madvise",  "code": "proc posix_madvise*(a1: pointer; a2: int; a3: cint): cint {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "posix_mem_offset",  "code": "proc posix_mem_offset*(a1: pointer; a2: int; a3: var TOff; a4: var int; \u000A                       a5: var cint): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "posix_typed_mem_get_info",  "code": "proc posix_typed_mem_get_info*(a1: cint; a2: var Tposix_typed_mem_info): cint {.\u000A    importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "posix_typed_mem_open",  "code": "proc posix_typed_mem_open*(a1: cstring; a2, a3: cint): cint {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "shm_open",  "code": "proc shm_open*(a1: cstring; a2: cint; a3: TMode): cint {.importc, \u000A    header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "shm_unlink",  "code": "proc shm_unlink*(a1: cstring): cint {.importc, header: \"<sys/mman.h>\".}" },  { "module": "posix",  "name": "asctime",  "code": "proc asctime*(a1: var Ttm): cstring {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "asctime_r",  "code": "proc asctime_r*(a1: var Ttm; a2: cstring): cstring {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock",  "code": "proc clock*(): TClock {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock_getcpuclockid",  "code": "proc clock_getcpuclockid*(a1: TPid; a2: var TClockId): cint {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock_getres",  "code": "proc clock_getres*(a1: TClockId; a2: var Ttimespec): cint {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock_gettime",  "code": "proc clock_gettime*(a1: TClockId; a2: var Ttimespec): cint {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock_nanosleep",  "code": "proc clock_nanosleep*(a1: TClockId; a2: cint; a3: var Ttimespec; \u000A                      a4: var Ttimespec): cint {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "clock_settime",  "code": "proc clock_settime*(a1: TClockId; a2: var Ttimespec): cint {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "ctime",  "code": "proc ctime*(a1: var Time): cstring {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "ctime_r",  "code": "proc ctime_r*(a1: var Time; a2: cstring): cstring {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "difftime",  "code": "proc difftime*(a1, a2: Time): cdouble {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "getdate",  "code": "proc getdate*(a1: cstring): ptr Ttm {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "gmtime",  "code": "proc gmtime*(a1: var Time): ptr Ttm {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "gmtime_r",  "code": "proc gmtime_r*(a1: var Time; a2: var Ttm): ptr Ttm {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "localtime",  "code": "proc localtime*(a1: var Time): ptr Ttm {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "localtime_r",  "code": "proc localtime_r*(a1: var Time; a2: var Ttm): ptr Ttm {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "mktime",  "code": "proc mktime*(a1: var Ttm): Time {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "timegm",  "code": "proc timegm*(a1: var Ttm): Time {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "nanosleep",  "code": "proc nanosleep*(a1, a2: var Ttimespec): cint {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "strftime",  "code": "proc strftime*(a1: cstring; a2: int; a3: cstring; a4: var Ttm): int {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "strptime",  "code": "proc strptime*(a1, a2: cstring; a3: var Ttm): cstring {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "time",  "code": "proc time*(a1: var Time): Time {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "timer_create",  "code": "proc timer_create*(a1: var TClockId; a2: var TsigEvent; a3: var Ttimer): cint {.\u000A    importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "timer_delete",  "code": "proc timer_delete*(a1: var Ttimer): cint {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "timer_gettime",  "code": "proc timer_gettime*(a1: Ttimer; a2: var titimerspec): cint {.importc, \u000A    header: \"<time.h>\".}" },  { "module": "posix",  "name": "timer_getoverrun",  "code": "proc timer_getoverrun*(a1: Ttimer): cint {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "timer_settime",  "code": "proc timer_settime*(a1: Ttimer; a2: cint; a3: var titimerspec; \u000A                    a4: var titimerspec): cint {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "tzset",  "code": "proc tzset*() {.importc, header: \"<time.h>\".}" },  { "module": "posix",  "name": "wait",  "code": "proc wait*(a1: var cint): TPid {.importc, header: \"<sys/wait.h>\".}" },  { "module": "posix",  "name": "waitid",  "code": "proc waitid*(a1: cint; a2: Tid; a3: var TsigInfo; a4: cint): cint {.importc, \u000A    header: \"<sys/wait.h>\".}" },  { "module": "posix",  "name": "waitpid",  "code": "proc waitpid*(a1: TPid; a2: var cint; a3: cint): TPid {.importc, \u000A    header: \"<sys/wait.h>\".}" },  { "module": "posix",  "name": "bsd_signal",  "code": "proc bsd_signal*(a1: cint; a2: proc (x: pointer) {.noconv.}) {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "kill",  "code": "proc kill*(a1: TPid; a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "killpg",  "code": "proc killpg*(a1: TPid; a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "pthread_kill",  "code": "proc pthread_kill*(a1: Tpthread; a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "pthread_sigmask",  "code": "proc pthread_sigmask*(a1: cint; a2, a3: var Tsigset): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "`raise`",  "code": "proc `raise`*(a1: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigaction",  "code": "proc sigaction*(a1: cint; a2, a3: var TSigaction): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigaddset",  "code": "proc sigaddset*(a1: var Tsigset; a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigaltstack",  "code": "proc sigaltstack*(a1, a2: var TStack): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigdelset",  "code": "proc sigdelset*(a1: var Tsigset; a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigemptyset",  "code": "proc sigemptyset*(a1: var Tsigset): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigfillset",  "code": "proc sigfillset*(a1: var Tsigset): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sighold",  "code": "proc sighold*(a1: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigignore",  "code": "proc sigignore*(a1: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "siginterrupt",  "code": "proc siginterrupt*(a1, a2: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigismember",  "code": "proc sigismember*(a1: var Tsigset; a2: cint): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "signal",  "code": "proc signal*(a1: cint; a2: proc (x: cint) {.noconv.}) {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigpause",  "code": "proc sigpause*(a1: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigpending",  "code": "proc sigpending*(a1: var Tsigset): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigprocmask",  "code": "proc sigprocmask*(a1: cint; a2, a3: var Tsigset): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigqueue",  "code": "proc sigqueue*(a1: TPid; a2: cint; a3: TsigVal): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigrelse",  "code": "proc sigrelse*(a1: cint): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigset",  "code": "proc sigset*(a1: int; a2: proc (x: cint) {.noconv.}) {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigsuspend",  "code": "proc sigsuspend*(a1: var Tsigset): cint {.importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigtimedwait",  "code": "proc sigtimedwait*(a1: var Tsigset; a2: var TsigInfo; a3: var Ttimespec): cint {.\u000A    importc, header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigwait",  "code": "proc sigwait*(a1: var Tsigset; a2: var cint): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "sigwaitinfo",  "code": "proc sigwaitinfo*(a1: var Tsigset; a2: var TsigInfo): cint {.importc, \u000A    header: \"<signal.h>\".}" },  { "module": "posix",  "name": "catclose",  "code": "proc catclose*(a1: Tnl_catd): cint {.importc, header: \"<nl_types.h>\".}" },  { "module": "posix",  "name": "catgets",  "code": "proc catgets*(a1: Tnl_catd; a2, a3: cint; a4: cstring): cstring {.importc, \u000A    header: \"<nl_types.h>\".}" },  { "module": "posix",  "name": "catopen",  "code": "proc catopen*(a1: cstring; a2: cint): Tnl_catd {.importc, header: \"<nl_types.h>\".}" },  { "module": "posix",  "name": "sched_get_priority_max",  "code": "proc sched_get_priority_max*(a1: cint): cint {.importc, header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_get_priority_min",  "code": "proc sched_get_priority_min*(a1: cint): cint {.importc, header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_getparam",  "code": "proc sched_getparam*(a1: TPid; a2: var Tsched_param): cint {.importc, \u000A    header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_getscheduler",  "code": "proc sched_getscheduler*(a1: TPid): cint {.importc, header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_rr_get_interval",  "code": "proc sched_rr_get_interval*(a1: TPid; a2: var Ttimespec): cint {.importc, \u000A    header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_setparam",  "code": "proc sched_setparam*(a1: TPid; a2: var Tsched_param): cint {.importc, \u000A    header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_setscheduler",  "code": "proc sched_setscheduler*(a1: TPid; a2: cint; a3: var Tsched_param): cint {.\u000A    importc, header: \"<sched.h>\".}" },  { "module": "posix",  "name": "sched_yield",  "code": "proc sched_yield*(): cint {.importc, header: \"<sched.h>\".}" },  { "module": "posix",  "name": "strerror",  "code": "proc strerror*(errnum: cint): cstring {.importc, header: \"<string.h>\".}" },  { "module": "posix",  "name": "hstrerror",  "code": "proc hstrerror*(herrnum: cint): cstring {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "FD_CLR",  "code": "proc FD_CLR*(a1: cint; a2: var TFdSet) {.importc, header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "FD_ISSET",  "code": "proc FD_ISSET*(a1: cint | SocketHandle; a2: var TFdSet): cint {.importc, \u000A    header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "FD_SET",  "code": "proc FD_SET*(a1: cint | SocketHandle; a2: var TFdSet) {.importc: \"FD_SET\", \u000A    header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "FD_ZERO",  "code": "proc FD_ZERO*(a1: var TFdSet) {.importc, header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "pselect",  "code": "proc pselect*(a1: cint; a2, a3, a4: ptr TFdSet; a5: ptr Ttimespec; \u000A              a6: var Tsigset): cint {.importc, header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "select",  "code": "proc select*(a1: cint | SocketHandle; a2, a3, a4: ptr TFdSet; a5: ptr Timeval): cint {.\u000A    importc, header: \"<sys/select.h>\".}" },  { "module": "posix",  "name": "posix_spawn",  "code": "proc posix_spawn*(a1: var TPid; a2: cstring; a3: var Tposix_spawn_file_actions; \u000A                  a4: var Tposix_spawnattr; a5, a6: cstringArray): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawn_file_actions_addclose",  "code": "proc posix_spawn_file_actions_addclose*(a1: var Tposix_spawn_file_actions; \u000A                                        a2: cint): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawn_file_actions_adddup2",  "code": "proc posix_spawn_file_actions_adddup2*(a1: var Tposix_spawn_file_actions; \u000A                                       a2, a3: cint): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawn_file_actions_addopen",  "code": "proc posix_spawn_file_actions_addopen*(a1: var Tposix_spawn_file_actions; \u000A                                       a2: cint; a3: cstring; a4: cint; \u000A                                       a5: TMode): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawn_file_actions_destroy",  "code": "proc posix_spawn_file_actions_destroy*(a1: var Tposix_spawn_file_actions): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawn_file_actions_init",  "code": "proc posix_spawn_file_actions_init*(a1: var Tposix_spawn_file_actions): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_destroy",  "code": "proc posix_spawnattr_destroy*(a1: var Tposix_spawnattr): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getsigdefault",  "code": "proc posix_spawnattr_getsigdefault*(a1: var Tposix_spawnattr; a2: var Tsigset): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getflags",  "code": "proc posix_spawnattr_getflags*(a1: var Tposix_spawnattr; a2: var cshort): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getpgroup",  "code": "proc posix_spawnattr_getpgroup*(a1: var Tposix_spawnattr; a2: var TPid): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getschedparam",  "code": "proc posix_spawnattr_getschedparam*(a1: var Tposix_spawnattr; \u000A                                    a2: var Tsched_param): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getschedpolicy",  "code": "proc posix_spawnattr_getschedpolicy*(a1: var Tposix_spawnattr; a2: var cint): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_getsigmask",  "code": "proc posix_spawnattr_getsigmask*(a1: var Tposix_spawnattr; a2: var Tsigset): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_init",  "code": "proc posix_spawnattr_init*(a1: var Tposix_spawnattr): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setsigdefault",  "code": "proc posix_spawnattr_setsigdefault*(a1: var Tposix_spawnattr; a2: var Tsigset): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setflags",  "code": "proc posix_spawnattr_setflags*(a1: var Tposix_spawnattr; a2: cint): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setpgroup",  "code": "proc posix_spawnattr_setpgroup*(a1: var Tposix_spawnattr; a2: TPid): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setschedparam",  "code": "proc posix_spawnattr_setschedparam*(a1: var Tposix_spawnattr; \u000A                                    a2: var Tsched_param): cint {.importc, \u000A    header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setschedpolicy",  "code": "proc posix_spawnattr_setschedpolicy*(a1: var Tposix_spawnattr; a2: cint): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnattr_setsigmask",  "code": "proc posix_spawnattr_setsigmask*(a1: var Tposix_spawnattr; a2: var Tsigset): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "posix_spawnp",  "code": "proc posix_spawnp*(a1: var TPid; a2: cstring; a3: var Tposix_spawn_file_actions; \u000A                   a4: var Tposix_spawnattr; a5, a6: cstringArray): cint {.\u000A    importc, header: \"<spawn.h>\".}" },  { "module": "posix",  "name": "getcontext",  "code": "proc getcontext*(a1: var Tucontext): cint {.importc, header: \"<ucontext.h>\".}" },  { "module": "posix",  "name": "makecontext",  "code": "proc makecontext*(a1: var Tucontext; a4: proc () {.noconv.}; a3: cint) {.\u000A    varargs, importc, header: \"<ucontext.h>\".}" },  { "module": "posix",  "name": "setcontext",  "code": "proc setcontext*(a1: var Tucontext): cint {.importc, header: \"<ucontext.h>\".}" },  { "module": "posix",  "name": "swapcontext",  "code": "proc swapcontext*(a1, a2: var Tucontext): cint {.importc, header: \"<ucontext.h>\".}" },  { "module": "posix",  "name": "readv",  "code": "proc readv*(a1: cint; a2: ptr TIOVec; a3: cint): int {.importc, \u000A    header: \"<sys/uio.h>\".}" },  { "module": "posix",  "name": "writev",  "code": "proc writev*(a1: cint; a2: ptr TIOVec; a3: cint): int {.importc, \u000A    header: \"<sys/uio.h>\".}" },  { "module": "posix",  "name": "CMSG_DATA",  "code": "proc CMSG_DATA*(cmsg: ptr Tcmsghdr): cstring {.importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "CMSG_NXTHDR",  "code": "proc CMSG_NXTHDR*(mhdr: ptr Tmsghdr; cmsg: ptr Tcmsghdr): ptr Tcmsghdr {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "CMSG_FIRSTHDR",  "code": "proc CMSG_FIRSTHDR*(mhdr: ptr Tmsghdr): ptr Tcmsghdr {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "`==`",  "code": "proc `==`*(x, y: SocketHandle): bool {.borrow.}" },  { "module": "posix",  "name": "accept",  "code": "proc accept*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): SocketHandle {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "bindSocket",  "code": "proc bindSocket*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.\u000A    importc: \"bind\", header: \"<sys/socket.h>\".}",  "desc": "is Posix's <tt class=\"docutils literal\"><span class=\"pre\">bind</span></tt>, because <tt class=\"docutils literal\"><span class=\"pre\">bind</span></tt> is a reserved word" },  { "module": "posix",  "name": "connect",  "code": "proc connect*(a1: SocketHandle; a2: ptr SockAddr; a3: Socklen): cint {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "getpeername",  "code": "proc getpeername*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "getsockname",  "code": "proc getsockname*(a1: SocketHandle; a2: ptr SockAddr; a3: ptr Socklen): cint {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "getsockopt",  "code": "proc getsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: ptr Socklen): cint {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "listen",  "code": "proc listen*(a1: SocketHandle; a2: cint): cint {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "recv",  "code": "proc recv*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "recvfrom",  "code": "proc recvfrom*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; \u000A               a5: ptr SockAddr; a6: ptr Socklen): int {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "recvmsg",  "code": "proc recvmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "send",  "code": "proc send*(a1: SocketHandle; a2: pointer; a3: int; a4: cint): int {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "sendmsg",  "code": "proc sendmsg*(a1: SocketHandle; a2: ptr Tmsghdr; a3: cint): int {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "sendto",  "code": "proc sendto*(a1: SocketHandle; a2: pointer; a3: int; a4: cint; a5: ptr SockAddr; \u000A             a6: Socklen): int {.importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "setsockopt",  "code": "proc setsockopt*(a1: SocketHandle; a2, a3: cint; a4: pointer; a5: Socklen): cint {.\u000A    importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "shutdown",  "code": "proc shutdown*(a1: SocketHandle; a2: cint): cint {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "socket",  "code": "proc socket*(a1, a2, a3: cint): SocketHandle {.importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "sockatmark",  "code": "proc sockatmark*(a1: cint): cint {.importc, header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "socketpair",  "code": "proc socketpair*(a1, a2, a3: cint; a4: var array[0 .. 1, cint]): cint {.importc, \u000A    header: \"<sys/socket.h>\".}" },  { "module": "posix",  "name": "if_nametoindex",  "code": "proc if_nametoindex*(a1: cstring): cint {.importc, header: \"<net/if.h>\".}" },  { "module": "posix",  "name": "if_indextoname",  "code": "proc if_indextoname*(a1: cint; a2: cstring): cstring {.importc, \u000A    header: \"<net/if.h>\".}" },  { "module": "posix",  "name": "if_nameindex",  "code": "proc if_nameindex*(): ptr Tif_nameindex {.importc, header: \"<net/if.h>\".}" },  { "module": "posix",  "name": "if_freenameindex",  "code": "proc if_freenameindex*(a1: ptr Tif_nameindex) {.importc, header: \"<net/if.h>\".}" },  { "module": "posix",  "name": "IN6_IS_ADDR_UNSPECIFIED",  "code": "proc IN6_IS_ADDR_UNSPECIFIED*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Unspecified address." },  { "module": "posix",  "name": "IN6_IS_ADDR_LOOPBACK",  "code": "proc IN6_IS_ADDR_LOOPBACK*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Loopback address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MULTICAST",  "code": "proc IN6_IS_ADDR_MULTICAST*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast address." },  { "module": "posix",  "name": "IN6_IS_ADDR_LINKLOCAL",  "code": "proc IN6_IS_ADDR_LINKLOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Unicast link-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_SITELOCAL",  "code": "proc IN6_IS_ADDR_SITELOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Unicast site-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_V4MAPPED",  "code": "proc IN6_IS_ADDR_V4MAPPED*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "IPv4 mapped address." },  { "module": "posix",  "name": "IN6_IS_ADDR_V4COMPAT",  "code": "proc IN6_IS_ADDR_V4COMPAT*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "IPv4-compatible address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MC_NODELOCAL",  "code": "proc IN6_IS_ADDR_MC_NODELOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast node-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MC_LINKLOCAL",  "code": "proc IN6_IS_ADDR_MC_LINKLOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast link-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MC_SITELOCAL",  "code": "proc IN6_IS_ADDR_MC_SITELOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast site-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MC_ORGLOCAL",  "code": "proc IN6_IS_ADDR_MC_ORGLOCAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast organization-local address." },  { "module": "posix",  "name": "IN6_IS_ADDR_MC_GLOBAL",  "code": "proc IN6_IS_ADDR_MC_GLOBAL*(a1: ptr TIn6Addr): cint {.importc, \u000A    header: \"<netinet/in.h>\".}",  "desc": "Multicast global address." },  { "module": "posix",  "name": "endhostent",  "code": "proc endhostent*() {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "endnetent",  "code": "proc endnetent*() {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "endprotoent",  "code": "proc endprotoent*() {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "endservent",  "code": "proc endservent*() {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "freeaddrinfo",  "code": "proc freeaddrinfo*(a1: ptr AddrInfo) {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "gai_strerror",  "code": "proc gai_strerror*(a1: cint): cstring {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getaddrinfo",  "code": "proc getaddrinfo*(a1, a2: cstring; a3: ptr AddrInfo; a4: var ptr AddrInfo): cint {.\u000A    importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "gethostbyaddr",  "code": "proc gethostbyaddr*(a1: pointer; a2: Socklen; a3: cint): ptr Hostent {.importc, \u000A    header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "gethostbyname",  "code": "proc gethostbyname*(a1: cstring): ptr Hostent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "gethostent",  "code": "proc gethostent*(): ptr Hostent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getnameinfo",  "code": "proc getnameinfo*(a1: ptr SockAddr; a2: Socklen; a3: cstring; a4: Socklen; \u000A                  a5: cstring; a6: Socklen; a7: cint): cint {.importc, \u000A    header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getnetbyaddr",  "code": "proc getnetbyaddr*(a1: int32; a2: cint): ptr Tnetent {.importc, \u000A    header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getnetbyname",  "code": "proc getnetbyname*(a1: cstring): ptr Tnetent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getnetent",  "code": "proc getnetent*(): ptr Tnetent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getprotobyname",  "code": "proc getprotobyname*(a1: cstring): ptr TProtoent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getprotobynumber",  "code": "proc getprotobynumber*(a1: cint): ptr TProtoent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getprotoent",  "code": "proc getprotoent*(): ptr TProtoent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getservbyname",  "code": "proc getservbyname*(a1, a2: cstring): ptr Servent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getservbyport",  "code": "proc getservbyport*(a1: cint; a2: cstring): ptr Servent {.importc, \u000A    header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "getservent",  "code": "proc getservent*(): ptr Servent {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "sethostent",  "code": "proc sethostent*(a1: cint) {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "setnetent",  "code": "proc setnetent*(a1: cint) {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "setprotoent",  "code": "proc setprotoent*(a1: cint) {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "setservent",  "code": "proc setservent*(a1: cint) {.importc, header: \"<netdb.h>\".}" },  { "module": "posix",  "name": "poll",  "code": "proc poll*(a1: ptr TPollfd; a2: Tnfds; a3: int): cint {.importc, \u000A    header: \"<poll.h>\".}" },  { "module": "posix",  "name": "realpath",  "code": "proc realpath*(name, resolved: cstring): cstring {.importc: \"realpath\", \u000A    header: \"<stdlib.h>\".}" },  { "module": "posix",  "name": "utimes",  "code": "proc utimes*(path: cstring; times: ptr array[2, Timeval]): int {.\u000A    importc: \"utimes\", header: \"<sys/time.h>\".}",  "desc": "<p>Sets file access and modification times.</p>\u000A<p>Pass the filename and an array of times to set the access and modification times respectively. If you pass nil as the array both attributes will be set to the current time.</p>\u000A<p>Returns zero on success.</p>\u000A<p>For more information read <a class=\"reference external\" href=\"http://www.unix.com/man-page/posix/3/utimes/\">http://www.unix.com/man-page/posix/3/utimes/</a>.</p>\u000A" },  { "module": "postgres",  "name": "pqconnectStart",  "code": "proc pqconnectStart*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName, \u000A    importc: \"PQconnectStart\".}" },  { "module": "postgres",  "name": "pqconnectPoll",  "code": "proc pqconnectPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl, \u000A    dynlib: dllName, importc: \"PQconnectPoll\".}" },  { "module": "postgres",  "name": "pqconnectdb",  "code": "proc pqconnectdb*(conninfo: cstring): PPGconn {.cdecl, dynlib: dllName, \u000A    importc: \"PQconnectdb\".}" },  { "module": "postgres",  "name": "pqsetdbLogin",  "code": "proc pqsetdbLogin*(pghost: cstring; pgport: cstring; pgoptions: cstring; \u000A                   pgtty: cstring; dbName: cstring; login: cstring; pwd: cstring): PPGconn {.\u000A    cdecl, dynlib: dllName, importc: \"PQsetdbLogin\".}" },  { "module": "postgres",  "name": "pqsetdb",  "code": "proc pqsetdb*(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME: cstring): Ppgconn" },  { "module": "postgres",  "name": "pqfinish",  "code": "proc pqfinish*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: \"PQfinish\".}" },  { "module": "postgres",  "name": "pqconndefaults",  "code": "proc pqconndefaults*(): PPQconninfoOption {.cdecl, dynlib: dllName, \u000A    importc: \"PQconndefaults\".}" },  { "module": "postgres",  "name": "pqconninfoFree",  "code": "proc pqconninfoFree*(connOptions: PPQconninfoOption) {.cdecl, dynlib: dllName, \u000A    importc: \"PQconninfoFree\".}" },  { "module": "postgres",  "name": "pqresetStart",  "code": "proc pqresetStart*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQresetStart\".}" },  { "module": "postgres",  "name": "pqresetPoll",  "code": "proc pqresetPoll*(conn: PPGconn): PostgresPollingStatusType {.cdecl, \u000A    dynlib: dllName, importc: \"PQresetPoll\".}" },  { "module": "postgres",  "name": "pqreset",  "code": "proc pqreset*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: \"PQreset\".}" },  { "module": "postgres",  "name": "pqrequestCancel",  "code": "proc pqrequestCancel*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQrequestCancel\".}" },  { "module": "postgres",  "name": "pqdb",  "code": "proc pqdb*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQdb\".}" },  { "module": "postgres",  "name": "pquser",  "code": "proc pquser*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQuser\".}" },  { "module": "postgres",  "name": "pqpass",  "code": "proc pqpass*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQpass\".}" },  { "module": "postgres",  "name": "pqhost",  "code": "proc pqhost*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQhost\".}" },  { "module": "postgres",  "name": "pqport",  "code": "proc pqport*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQport\".}" },  { "module": "postgres",  "name": "pqtty",  "code": "proc pqtty*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, importc: \"PQtty\".}" },  { "module": "postgres",  "name": "pqoptions",  "code": "proc pqoptions*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQoptions\".}" },  { "module": "postgres",  "name": "pqstatus",  "code": "proc pqstatus*(conn: PPGconn): TConnStatusType {.cdecl, dynlib: dllName, \u000A    importc: \"PQstatus\".}" },  { "module": "postgres",  "name": "pqtransactionStatus",  "code": "proc pqtransactionStatus*(conn: PPGconn): PGTransactionStatusType {.cdecl, \u000A    dynlib: dllName, importc: \"PQtransactionStatus\".}" },  { "module": "postgres",  "name": "pqparameterStatus",  "code": "proc pqparameterStatus*(conn: PPGconn; paramName: cstring): cstring {.cdecl, \u000A    dynlib: dllName, importc: \"PQparameterStatus\".}" },  { "module": "postgres",  "name": "pqprotocolVersion",  "code": "proc pqprotocolVersion*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQprotocolVersion\".}" },  { "module": "postgres",  "name": "pqerrorMessage",  "code": "proc pqerrorMessage*(conn: PPGconn): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQerrorMessage\".}" },  { "module": "postgres",  "name": "pqsocket",  "code": "proc pqsocket*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A                                       importc: \"PQsocket\".}" },  { "module": "postgres",  "name": "pqbackendPID",  "code": "proc pqbackendPID*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQbackendPID\".}" },  { "module": "postgres",  "name": "pqclientEncoding",  "code": "proc pqclientEncoding*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQclientEncoding\".}" },  { "module": "postgres",  "name": "pqsetClientEncoding",  "code": "proc pqsetClientEncoding*(conn: PPGconn; encoding: cstring): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQsetClientEncoding\".}" },  { "module": "postgres",  "name": "pqgetssl",  "code": "proc pqgetssl*(conn: PPGconn): PSSL {.cdecl, dynlib: dllName, \u000A                                      importc: \"PQgetssl\".}" },  { "module": "postgres",  "name": "pqsetErrorVerbosity",  "code": "proc pqsetErrorVerbosity*(conn: PPGconn; verbosity: PGVerbosity): PGVerbosity {.\u000A    cdecl, dynlib: dllName, importc: \"PQsetErrorVerbosity\".}" },  { "module": "postgres",  "name": "pqtrace",  "code": "proc pqtrace*(conn: PPGconn; debug_port: File) {.cdecl, dynlib: dllName, \u000A    importc: \"PQtrace\".}" },  { "module": "postgres",  "name": "pquntrace",  "code": "proc pquntrace*(conn: PPGconn) {.cdecl, dynlib: dllName, importc: \"PQuntrace\".}" },  { "module": "postgres",  "name": "pqsetNoticeReceiver",  "code": "proc pqsetNoticeReceiver*(conn: PPGconn; theProc: PQnoticeReceiver; arg: pointer): PQnoticeReceiver {.\u000A    cdecl, dynlib: dllName, importc: \"PQsetNoticeReceiver\".}" },  { "module": "postgres",  "name": "pqsetNoticeProcessor",  "code": "proc pqsetNoticeProcessor*(conn: PPGconn; theProc: PQnoticeProcessor; \u000A                           arg: pointer): PQnoticeProcessor {.cdecl, \u000A    dynlib: dllName, importc: \"PQsetNoticeProcessor\".}" },  { "module": "postgres",  "name": "pqexec",  "code": "proc pqexec*(conn: PPGconn; query: cstring): PPGresult {.cdecl, dynlib: dllName, \u000A    importc: \"PQexec\".}" },  { "module": "postgres",  "name": "pqexecParams",  "code": "proc pqexecParams*(conn: PPGconn; command: cstring; nParams: int32; \u000A                   paramTypes: POid; paramValues: cstringArray; \u000A                   paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult {.\u000A    cdecl, dynlib: dllName, importc: \"PQexecParams\".}" },  { "module": "postgres",  "name": "pqprepare",  "code": "proc pqprepare*(conn: PPGconn; stmtName, query: cstring; nParams: int32; \u000A                paramTypes: POid): PPGresult {.cdecl, dynlib: dllName, \u000A    importc: \"PQprepare\".}" },  { "module": "postgres",  "name": "pqexecPrepared",  "code": "proc pqexecPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32; \u000A                     paramValues: cstringArray; \u000A                     paramLengths, paramFormats: ptr int32; resultFormat: int32): PPGresult {.\u000A    cdecl, dynlib: dllName, importc: \"PQexecPrepared\".}" },  { "module": "postgres",  "name": "pqsendQuery",  "code": "proc pqsendQuery*(conn: PPGconn; query: cstring): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQsendQuery\".}" },  { "module": "postgres",  "name": "pqsendQueryParams",  "code": "proc pqsendQueryParams*(conn: PPGconn; command: cstring; nParams: int32; \u000A                        paramTypes: POid; paramValues: cstringArray; \u000A                        paramLengths, paramFormats: ptr int32; \u000A                        resultFormat: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQsendQueryParams\".}" },  { "module": "postgres",  "name": "pqsendQueryPrepared",  "code": "proc pqsendQueryPrepared*(conn: PPGconn; stmtName: cstring; nParams: int32; \u000A                          paramValues: cstringArray; \u000A                          paramLengths, paramFormats: ptr int32; \u000A                          resultFormat: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQsendQueryPrepared\".}" },  { "module": "postgres",  "name": "pqgetResult",  "code": "proc pqgetResult*(conn: PPGconn): PPGresult {.cdecl, dynlib: dllName, \u000A    importc: \"PQgetResult\".}" },  { "module": "postgres",  "name": "pqisBusy",  "code": "proc pqisBusy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A                                       importc: \"PQisBusy\".}" },  { "module": "postgres",  "name": "pqconsumeInput",  "code": "proc pqconsumeInput*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQconsumeInput\".}" },  { "module": "postgres",  "name": "pqnotifies",  "code": "proc pqnotifies*(conn: PPGconn): PPGnotify {.cdecl, dynlib: dllName, \u000A    importc: \"PQnotifies\".}" },  { "module": "postgres",  "name": "pqputCopyData",  "code": "proc pqputCopyData*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"PQputCopyData\".}" },  { "module": "postgres",  "name": "pqputCopyEnd",  "code": "proc pqputCopyEnd*(conn: PPGconn; errormsg: cstring): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQputCopyEnd\".}" },  { "module": "postgres",  "name": "pqgetCopyData",  "code": "proc pqgetCopyData*(conn: PPGconn; buffer: cstringArray; async: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"PQgetCopyData\".}" },  { "module": "postgres",  "name": "pqgetline",  "code": "proc pqgetline*(conn: PPGconn; str: cstring; len: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQgetline\".}" },  { "module": "postgres",  "name": "pqputline",  "code": "proc pqputline*(conn: PPGconn; str: cstring): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQputline\".}" },  { "module": "postgres",  "name": "pqgetlineAsync",  "code": "proc pqgetlineAsync*(conn: PPGconn; buffer: cstring; bufsize: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"PQgetlineAsync\".}" },  { "module": "postgres",  "name": "pqputnbytes",  "code": "proc pqputnbytes*(conn: PPGconn; buffer: cstring; nbytes: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQputnbytes\".}" },  { "module": "postgres",  "name": "pqendcopy",  "code": "proc pqendcopy*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A                                        importc: \"PQendcopy\".}" },  { "module": "postgres",  "name": "pqsetnonblocking",  "code": "proc pqsetnonblocking*(conn: PPGconn; arg: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQsetnonblocking\".}" },  { "module": "postgres",  "name": "pqisnonblocking",  "code": "proc pqisnonblocking*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQisnonblocking\".}" },  { "module": "postgres",  "name": "pqflush",  "code": "proc pqflush*(conn: PPGconn): int32 {.cdecl, dynlib: dllName, importc: \"PQflush\".}" },  { "module": "postgres",  "name": "pqfn",  "code": "proc pqfn*(conn: PPGconn; fnid: int32; result_buf, result_len: ptr int32; \u000A           result_is_int: int32; args: PPQArgBlock; nargs: int32): PPGresult {.\u000A    cdecl, dynlib: dllName, importc: \"PQfn\".}" },  { "module": "postgres",  "name": "pqresultStatus",  "code": "proc pqresultStatus*(res: PPGresult): TExecStatusType {.cdecl, dynlib: dllName, \u000A    importc: \"PQresultStatus\".}" },  { "module": "postgres",  "name": "pqresStatus",  "code": "proc pqresStatus*(status: TExecStatusType): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQresStatus\".}" },  { "module": "postgres",  "name": "pqresultErrorMessage",  "code": "proc pqresultErrorMessage*(res: PPGresult): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQresultErrorMessage\".}" },  { "module": "postgres",  "name": "pqresultErrorField",  "code": "proc pqresultErrorField*(res: PPGresult; fieldcode: int32): cstring {.cdecl, \u000A    dynlib: dllName, importc: \"PQresultErrorField\".}" },  { "module": "postgres",  "name": "pqntuples",  "code": "proc pqntuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQntuples\".}" },  { "module": "postgres",  "name": "pqnfields",  "code": "proc pqnfields*(res: PPGresult): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQnfields\".}" },  { "module": "postgres",  "name": "pqbinaryTuples",  "code": "proc pqbinaryTuples*(res: PPGresult): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQbinaryTuples\".}" },  { "module": "postgres",  "name": "pqfname",  "code": "proc pqfname*(res: PPGresult; field_num: int32): cstring {.cdecl, \u000A    dynlib: dllName, importc: \"PQfname\".}" },  { "module": "postgres",  "name": "pqfnumber",  "code": "proc pqfnumber*(res: PPGresult; field_name: cstring): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQfnumber\".}" },  { "module": "postgres",  "name": "pqftable",  "code": "proc pqftable*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName, \u000A    importc: \"PQftable\".}" },  { "module": "postgres",  "name": "pqftablecol",  "code": "proc pqftablecol*(res: PPGresult; field_num: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQftablecol\".}" },  { "module": "postgres",  "name": "pqfformat",  "code": "proc pqfformat*(res: PPGresult; field_num: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"PQfformat\".}" },  { "module": "postgres",  "name": "pqftype",  "code": "proc pqftype*(res: PPGresult; field_num: int32): Oid {.cdecl, dynlib: dllName, \u000A    importc: \"PQftype\".}" },  { "module": "postgres",  "name": "pqfsize",  "code": "proc pqfsize*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQfsize\".}" },  { "module": "postgres",  "name": "pqfmod",  "code": "proc pqfmod*(res: PPGresult; field_num: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQfmod\".}" },  { "module": "postgres",  "name": "pqcmdStatus",  "code": "proc pqcmdStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQcmdStatus\".}" },  { "module": "postgres",  "name": "pqoidStatus",  "code": "proc pqoidStatus*(res: PPGresult): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQoidStatus\".}" },  { "module": "postgres",  "name": "pqoidValue",  "code": "proc pqoidValue*(res: PPGresult): Oid {.cdecl, dynlib: dllName, \u000A                                        importc: \"PQoidValue\".}" },  { "module": "postgres",  "name": "pqcmdTuples",  "code": "proc pqcmdTuples*(res: PPGresult): cstring {.cdecl, dynlib: dllName, \u000A    importc: \"PQcmdTuples\".}" },  { "module": "postgres",  "name": "pqgetvalue",  "code": "proc pqgetvalue*(res: PPGresult; tup_num: int32; field_num: int32): cstring {.\u000A    cdecl, dynlib: dllName, importc: \"PQgetvalue\".}" },  { "module": "postgres",  "name": "pqgetlength",  "code": "proc pqgetlength*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"PQgetlength\".}" },  { "module": "postgres",  "name": "pqgetisnull",  "code": "proc pqgetisnull*(res: PPGresult; tup_num: int32; field_num: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"PQgetisnull\".}" },  { "module": "postgres",  "name": "pqclear",  "code": "proc pqclear*(res: PPGresult) {.cdecl, dynlib: dllName, importc: \"PQclear\".}" },  { "module": "postgres",  "name": "pqfreemem",  "code": "proc pqfreemem*(p: pointer) {.cdecl, dynlib: dllName, importc: \"PQfreemem\".}" },  { "module": "postgres",  "name": "pqmakeEmptyPGresult",  "code": "proc pqmakeEmptyPGresult*(conn: PPGconn; status: TExecStatusType): PPGresult {.\u000A    cdecl, dynlib: dllName, importc: \"PQmakeEmptyPGresult\".}" },  { "module": "postgres",  "name": "pqescapeString",  "code": "proc pqescapeString*(till, `from`: cstring; len: int): int {.cdecl, \u000A    dynlib: dllName, importc: \"PQescapeString\".}" },  { "module": "postgres",  "name": "pqescapeBytea",  "code": "proc pqescapeBytea*(bintext: cstring; binlen: int; bytealen: var int): cstring {.\u000A    cdecl, dynlib: dllName, importc: \"PQescapeBytea\".}" },  { "module": "postgres",  "name": "pqunescapeBytea",  "code": "proc pqunescapeBytea*(strtext: cstring; retbuflen: var int): cstring {.cdecl, \u000A    dynlib: dllName, importc: \"PQunescapeBytea\".}" },  { "module": "postgres",  "name": "pqprint",  "code": "proc pqprint*(fout: File; res: PPGresult; ps: PPQprintOpt) {.cdecl, \u000A    dynlib: dllName, importc: \"PQprint\".}" },  { "module": "postgres",  "name": "pqdisplayTuples",  "code": "proc pqdisplayTuples*(res: PPGresult; fp: File; fillAlign: int32; \u000A                      fieldSep: cstring; printHeader: int32; quiet: int32) {.\u000A    cdecl, dynlib: dllName, importc: \"PQdisplayTuples\".}" },  { "module": "postgres",  "name": "pqprintTuples",  "code": "proc pqprintTuples*(res: PPGresult; fout: File; printAttName: int32; \u000A                    terseOutput: int32; width: int32) {.cdecl, dynlib: dllName, \u000A    importc: \"PQprintTuples\".}" },  { "module": "postgres",  "name": "lo_open",  "code": "proc lo_open*(conn: PPGconn; lobjId: Oid; mode: int32): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"lo_open\".}" },  { "module": "postgres",  "name": "lo_close",  "code": "proc lo_close*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"lo_close\".}" },  { "module": "postgres",  "name": "lo_read",  "code": "proc lo_read*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"lo_read\".}" },  { "module": "postgres",  "name": "lo_write",  "code": "proc lo_write*(conn: PPGconn; fd: int32; buf: cstring; length: int): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"lo_write\".}" },  { "module": "postgres",  "name": "lo_lseek",  "code": "proc lo_lseek*(conn: PPGconn; fd: int32; offset: int32; whence: int32): int32 {.\u000A    cdecl, dynlib: dllName, importc: \"lo_lseek\".}" },  { "module": "postgres",  "name": "lo_creat",  "code": "proc lo_creat*(conn: PPGconn; mode: int32): Oid {.cdecl, dynlib: dllName, \u000A    importc: \"lo_creat\".}" },  { "module": "postgres",  "name": "lo_tell",  "code": "proc lo_tell*(conn: PPGconn; fd: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"lo_tell\".}" },  { "module": "postgres",  "name": "lo_unlink",  "code": "proc lo_unlink*(conn: PPGconn; lobjId: Oid): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"lo_unlink\".}" },  { "module": "postgres",  "name": "lo_import",  "code": "proc lo_import*(conn: PPGconn; filename: cstring): Oid {.cdecl, dynlib: dllName, \u000A    importc: \"lo_import\".}" },  { "module": "postgres",  "name": "lo_export",  "code": "proc lo_export*(conn: PPGconn; lobjId: Oid; filename: cstring): int32 {.cdecl, \u000A    dynlib: dllName, importc: \"lo_export\".}" },  { "module": "postgres",  "name": "pqmblen",  "code": "proc pqmblen*(s: cstring; encoding: int32): int32 {.cdecl, dynlib: dllName, \u000A    importc: \"PQmblen\".}" },  { "module": "postgres",  "name": "pqenv2encoding",  "code": "proc pqenv2encoding*(): int32 {.cdecl, dynlib: dllName, \u000A                                importc: \"PQenv2encoding\".}" },  { "module": "psapi",  "name": "EnumProcesses",  "code": "proc EnumProcesses*(lpidProcess: ptr DWORD; cb: DWORD; cbNeeded: ptr DWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"EnumProcesses\".}" },  { "module": "psapi",  "name": "EnumProcessModules",  "code": "proc EnumProcessModules*(hProcess: HANDLE; lphModule: ptr HMODULE; cb: DWORD; \u000A                         lpcbNeeded: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: psapiDll, importc: \"EnumProcessModules\".}" },  { "module": "psapi",  "name": "GetModuleBaseNameA",  "code": "proc GetModuleBaseNameA*(hProcess: HANDLE; hModule: HMODULE; lpBaseName: LPSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetModuleBaseNameA\".}" },  { "module": "psapi",  "name": "GetModuleBaseNameW",  "code": "proc GetModuleBaseNameW*(hProcess: HANDLE; hModule: HMODULE; lpBaseName: LPWSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetModuleBaseNameW\".}" },  { "module": "psapi",  "name": "GetModuleBaseName",  "code": "proc GetModuleBaseName*(hProcess: HANDLE; hModule: HMODULE; lpBaseName: LPWSTR; \u000A                        nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetModuleBaseNameW\".}" },  { "module": "psapi",  "name": "GetModuleFileNameExA",  "code": "proc GetModuleFileNameExA*(hProcess: HANDLE; hModule: HMODULE; \u000A                           lpFileNameEx: LPSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: psapiDll, importc: \"GetModuleFileNameExA\".}" },  { "module": "psapi",  "name": "GetModuleFileNameExW",  "code": "proc GetModuleFileNameExW*(hProcess: HANDLE; hModule: HMODULE; \u000A                           lpFileNameEx: LPWSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: psapiDll, importc: \"GetModuleFileNameExW\".}" },  { "module": "psapi",  "name": "GetModuleFileNameEx",  "code": "proc GetModuleFileNameEx*(hProcess: HANDLE; hModule: HMODULE; \u000A                          lpFileNameEx: LPWSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: psapiDll, importc: \"GetModuleFileNameExW\".}" },  { "module": "psapi",  "name": "GetModuleInformation",  "code": "proc GetModuleInformation*(hProcess: HANDLE; hModule: HMODULE; \u000A                           lpmodinfo: LPMODULEINFO; cb: DWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"GetModuleInformation\".}" },  { "module": "psapi",  "name": "EmptyWorkingSet",  "code": "proc EmptyWorkingSet*(hProcess: HANDLE): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"EmptyWorkingSet\".}" },  { "module": "psapi",  "name": "QueryWorkingSet",  "code": "proc QueryWorkingSet*(hProcess: HANDLE; pv: PVOID; cb: DWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"QueryWorkingSet\".}" },  { "module": "psapi",  "name": "QueryWorkingSetEx",  "code": "proc QueryWorkingSetEx*(hProcess: HANDLE; pv: PVOID; cb: DWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"QueryWorkingSetEx\".}" },  { "module": "psapi",  "name": "InitializeProcessForWsWatch",  "code": "proc InitializeProcessForWsWatch*(hProcess: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: psapiDll, importc: \"InitializeProcessForWsWatch\".}" },  { "module": "psapi",  "name": "GetWsChanges",  "code": "proc GetWsChanges*(hProcess: HANDLE; lpWatchInfo: PPSAPI_WS_WATCH_INFORMATION; \u000A                   cb: DWORD): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetWsChanges\".}" },  { "module": "psapi",  "name": "GetMappedFileNameA",  "code": "proc GetMappedFileNameA*(hProcess: HANDLE; lpv: LPVOID; lpFilename: LPSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetMappedFileNameA\".}" },  { "module": "psapi",  "name": "GetMappedFileNameW",  "code": "proc GetMappedFileNameW*(hProcess: HANDLE; lpv: LPVOID; lpFilename: LPWSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetMappedFileNameW\".}" },  { "module": "psapi",  "name": "GetMappedFileName",  "code": "proc GetMappedFileName*(hProcess: HANDLE; lpv: LPVOID; lpFilename: LPWSTR; \u000A                        nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetMappedFileNameW\".}" },  { "module": "psapi",  "name": "EnumDeviceDrivers",  "code": "proc EnumDeviceDrivers*(lpImageBase: LPVOID; cb: DWORD; lpcbNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"EnumDeviceDrivers\".}" },  { "module": "psapi",  "name": "GetDeviceDriverBaseNameA",  "code": "proc GetDeviceDriverBaseNameA*(ImageBase: LPVOID; lpBaseName: LPSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverBaseNameA\".}" },  { "module": "psapi",  "name": "GetDeviceDriverBaseNameW",  "code": "proc GetDeviceDriverBaseNameW*(ImageBase: LPVOID; lpBaseName: LPWSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverBaseNameW\".}" },  { "module": "psapi",  "name": "GetDeviceDriverBaseName",  "code": "proc GetDeviceDriverBaseName*(ImageBase: LPVOID; lpBaseName: LPWSTR; \u000A                              nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverBaseNameW\".}" },  { "module": "psapi",  "name": "GetDeviceDriverFileNameA",  "code": "proc GetDeviceDriverFileNameA*(ImageBase: LPVOID; lpFileName: LPSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverFileNameA\".}" },  { "module": "psapi",  "name": "GetDeviceDriverFileNameW",  "code": "proc GetDeviceDriverFileNameW*(ImageBase: LPVOID; lpFileName: LPWSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverFileNameW\".}" },  { "module": "psapi",  "name": "GetDeviceDriverFileName",  "code": "proc GetDeviceDriverFileName*(ImageBase: LPVOID; lpFileName: LPWSTR; \u000A                              nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetDeviceDriverFileNameW\".}" },  { "module": "psapi",  "name": "GetProcessMemoryInfo",  "code": "proc GetProcessMemoryInfo*(hProcess: HANDLE; \u000A                           ppsmemCounters: PPROCESS_MEMORY_COUNTERS; cb: DWORD): WINBOOL {.\u000A    stdcall, dynlib: psapiDll, importc: \"GetProcessMemoryInfo\".}" },  { "module": "psapi",  "name": "GetPerformanceInfo",  "code": "proc GetPerformanceInfo*(pPerformanceInformation: PPERFORMANCE_INFORMATION; \u000A                         cb: DWORD): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetPerformanceInfo\".}" },  { "module": "psapi",  "name": "EnumPageFilesA",  "code": "proc EnumPageFilesA*(pCallBackRoutine: PENUM_PAGE_FILE_CALLBACKA; \u000A                     pContext: LPVOID): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"EnumPageFilesA\".}" },  { "module": "psapi",  "name": "EnumPageFilesW",  "code": "proc EnumPageFilesW*(pCallBackRoutine: PENUM_PAGE_FILE_CALLBACKW; \u000A                     pContext: LPVOID): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"EnumPageFilesW\".}" },  { "module": "psapi",  "name": "EnumPageFiles",  "code": "proc EnumPageFiles*(pCallBackRoutine: PENUM_PAGE_FILE_CALLBACKW; \u000A                    pContext: LPVOID): WINBOOL {.stdcall, dynlib: psapiDll, \u000A    importc: \"EnumPageFilesW\".}" },  { "module": "psapi",  "name": "GetProcessImageFileNameA",  "code": "proc GetProcessImageFileNameA*(hProcess: HANDLE; lpImageFileName: LPSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetProcessImageFileNameA\".}" },  { "module": "psapi",  "name": "GetProcessImageFileNameW",  "code": "proc GetProcessImageFileNameW*(hProcess: HANDLE; lpImageFileName: LPWSTR; \u000A                               nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetProcessImageFileNameW\".}" },  { "module": "psapi",  "name": "GetProcessImageFileName",  "code": "proc GetProcessImageFileName*(hProcess: HANDLE; lpImageFileName: LPWSTR; \u000A                              nSize: DWORD): DWORD {.stdcall, dynlib: psapiDll, \u000A    importc: \"GetProcessImageFileNameW\".}" },  { "module": "queues",  "name": "initQueue",  "code": "proc initQueue*[T](initialSize = 4): Queue[T]",  "desc": "creates a new queue. <cite>initialSize</cite> needs to be a power of 2." },  { "module": "queues",  "name": "len",  "code": "proc len*[T](q: Queue[T]): int",  "desc": "returns the number of elements of <cite>q</cite>." },  { "module": "queues",  "name": "items",  "code": "iterator items*[T](q: Queue[T]): T",  "desc": "yields every element of <cite>q</cite>." },  { "module": "queues",  "name": "add",  "code": "proc add*[T](q: var Queue[T]; item: T)",  "desc": "adds an <cite>item</cite> to the end of the queue <cite>q</cite>." },  { "module": "queues",  "name": "enqueue",  "code": "proc enqueue*[T](q: var Queue[T]; item: T)",  "desc": "alias for the <tt class=\"docutils literal\"><span class=\"pre\">add</span></tt> operation." },  { "module": "queues",  "name": "dequeue",  "code": "proc dequeue*[T](q: var Queue[T]): T",  "desc": "removes and returns the first element of the queue <cite>q</cite>." },  { "module": "queues",  "name": "`$`",  "code": "proc `$`*[T](q: Queue[T]): string",  "desc": "turns a queue into its string representation." },  { "module": "rawsockets",  "name": "ioctlsocket",  "code": "proc ioctlsocket*(s: SocketHandle; cmd: clong; argptr: ptr clong): cint {.\u000A    stdcall, importc: \"ioctlsocket\", dynlib: \"ws2_32.dll\".}" },  { "module": "rawsockets",  "name": "`==`",  "code": "proc `==`*(a, b: Port): bool {.borrow.}",  "desc": "<tt class=\"docutils literal\"><span class=\"pre\">==</span></tt> for ports." },  { "module": "rawsockets",  "name": "`$`",  "code": "proc `$`*(p: Port): string {.borrow.}",  "desc": "returns the port number as a string" },  { "module": "rawsockets",  "name": "toInt",  "code": "proc toInt*(domain: Domain): cint",  "desc": "Converts the TDomain enum to a platform-dependent <tt class=\"docutils literal\"><span class=\"pre\">cint</span></tt>." },  { "module": "rawsockets",  "name": "toInt",  "code": "proc toInt*(typ: SockType): cint",  "desc": "Converts the TType enum to a platform-dependent <tt class=\"docutils literal\"><span class=\"pre\">cint</span></tt>." },  { "module": "rawsockets",  "name": "toInt",  "code": "proc toInt*(p: Protocol): cint",  "desc": "Converts the TProtocol enum to a platform-dependent <tt class=\"docutils literal\"><span class=\"pre\">cint</span></tt>." },  { "module": "rawsockets",  "name": "newRawSocket",  "code": "proc newRawSocket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A                   protocol: Protocol = IPPROTO_TCP): SocketHandle",  "desc": "Creates a new socket; returns <cite>InvalidSocket</cite> if an error occurs." },  { "module": "rawsockets",  "name": "newRawSocket",  "code": "proc newRawSocket*(domain: cint; typ: cint; protocol: cint): SocketHandle",  "desc": "<p>Creates a new socket; returns <cite>InvalidSocket</cite> if an error occurs.</p>\u000A<p>Use this overload if one of the enums specified above does not contain what you need.</p>\u000A" },  { "module": "rawsockets",  "name": "close",  "code": "proc close*(socket: SocketHandle)",  "desc": "closes a socket." },  { "module": "rawsockets",  "name": "bindAddr",  "code": "proc bindAddr*(socket: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint" },  { "module": "rawsockets",  "name": "listen",  "code": "proc listen*(socket: SocketHandle; backlog = SOMAXCONN): cint {.\u000A    tags: [ReadIOEffect].}",  "desc": "Marks <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> as accepting connections. <tt class=\"docutils literal\"><span class=\"pre\">Backlog</span></tt> specifies the maximum length of the queue of pending connections." },  { "module": "rawsockets",  "name": "getAddrInfo",  "code": "proc getAddrInfo*(address: string; port: Port; af: Domain = AF_INET; \u000A                  typ: SockType = SOCK_STREAM; prot: Protocol = IPPROTO_TCP): ptr AddrInfo",  "desc": "<blockquote><p><strong>Warning</strong>: The resulting <tt class=\"docutils literal\"><span class=\"pre\">ptr TAddrInfo</span></tt> must be freed using <tt class=\"docutils literal\"><span class=\"pre\">dealloc</span></tt>!</p></blockquote>\u000A" },  { "module": "rawsockets",  "name": "dealloc",  "code": "proc dealloc*(ai: ptr AddrInfo)" },  { "module": "rawsockets",  "name": "ntohl",  "code": "proc ntohl*(x: int32): int32",  "desc": "Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation." },  { "module": "rawsockets",  "name": "ntohs",  "code": "proc ntohs*(x: int16): int16",  "desc": "Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation." },  { "module": "rawsockets",  "name": "htonl",  "code": "proc htonl*(x: int32): int32",  "desc": "Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation." },  { "module": "rawsockets",  "name": "htons",  "code": "proc htons*(x: int16): int16",  "desc": "Converts 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation." },  { "module": "rawsockets",  "name": "getServByName",  "code": "proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].}",  "desc": "<p>Searches the database from the beginning and finds the first entry for which the service name specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> matches the s_name member and the protocol name specified by <tt class=\"docutils literal\"><span class=\"pre\">proto</span></tt> matches the s_proto member.</p>\u000A<p>On posix this will search through the <tt class=\"docutils literal\"><span class=\"pre\">/etc/services</span></tt> file.</p>\u000A" },  { "module": "rawsockets",  "name": "getServByPort",  "code": "proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].}",  "desc": "<p>Searches the database from the beginning and finds the first entry for which the port specified by <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> matches the s_port member and the protocol name specified by <tt class=\"docutils literal\"><span class=\"pre\">proto</span></tt> matches the s_proto member.</p>\u000A<p>On posix this will search through the <tt class=\"docutils literal\"><span class=\"pre\">/etc/services</span></tt> file.</p>\u000A" },  { "module": "rawsockets",  "name": "getHostByAddr",  "code": "proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].}",  "desc": "This function will lookup the hostname of an IP Address." },  { "module": "rawsockets",  "name": "getHostByName",  "code": "proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].}",  "desc": "This function will lookup the IP address of a hostname." },  { "module": "rawsockets",  "name": "getSockName",  "code": "proc getSockName*(socket: SocketHandle): Port",  "desc": "returns the socket's associated port number." },  { "module": "rawsockets",  "name": "getSockOptInt",  "code": "proc getSockOptInt*(socket: SocketHandle; level, optname: int): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "getsockopt for integer options." },  { "module": "rawsockets",  "name": "setSockOptInt",  "code": "proc setSockOptInt*(socket: SocketHandle; level, optname, optval: int) {.\u000A    tags: [WriteIOEffect].}",  "desc": "setsockopt for integer options." },  { "module": "rawsockets",  "name": "setBlocking",  "code": "proc setBlocking*(s: SocketHandle; blocking: bool)",  "desc": "<p>Sets blocking mode on socket.</p>\u000A<p>Raises EOS on error.</p>\u000A" },  { "module": "rawsockets",  "name": "select",  "code": "proc select*(readfds: var seq[SocketHandle]; timeout = 500): int",  "desc": "<p>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. <tt class=\"docutils literal\"><span class=\"pre\">Timeout</span></tt> is in miliseconds and -1 can be specified for no timeout.</p>\u000A<p>A socket is removed from the specific <tt class=\"docutils literal\"><span class=\"pre\">seq</span></tt> when it has data waiting to be read/written to or has errors (<tt class=\"docutils literal\"><span class=\"pre\">exceptfds</span></tt>).</p>\u000A" },  { "module": "rawsockets",  "name": "selectWrite",  "code": "proc selectWrite*(writefds: var seq[SocketHandle]; timeout = 500): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>When a socket in <tt class=\"docutils literal\"><span class=\"pre\">writefds</span></tt> is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from <tt class=\"docutils literal\"><span class=\"pre\">writefds</span></tt>.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> is specified in miliseconds and <tt class=\"docutils literal\"><span class=\"pre\">-1</span></tt> can be specified for an unlimited time.</p>\u000A" },  { "module": "rdstdin",  "name": "readLineFromStdin",  "code": "proc readLineFromStdin*(prompt: string): TaintedString {.\u000A    tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "Reads a line from stdin." },  { "module": "rdstdin",  "name": "readLineFromStdin",  "code": "proc readLineFromStdin*(prompt: string; line: var TaintedString): bool {.\u000A    tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "Reads a <cite>line</cite> from stdin. <cite>line</cite> must not be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>! May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string. Returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> if the end of the file has been reached, <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> otherwise. If <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned <cite>line</cite> contains no new data." },  { "module": "re",  "name": "re",  "code": "proc re*(s: string; flags = {reExtended, reStudy}): Regex",  "desc": "Constructor of regular expressions. Note that Nim's extended raw string literals support this syntax <tt class=\"docutils literal\"><span class=\"pre\">re&quot;[abc]&quot;</span></tt> as a short form for <tt class=\"docutils literal\"><span class=\"pre\">re(r&quot;[abc]&quot;)</span></tt>." },  { "module": "re",  "name": "findBounds",  "code": "proc findBounds*(s: string; pattern: Regex; matches: var openArray[string]; \u000A                 start = 0): tuple[first, last: int]",  "desc": "returns the starting position and end position of <cite>pattern</cite> in <cite>s</cite> and the captured substrings in the array <cite>matches</cite>. If it does not match, nothing is written into <cite>matches</cite> and <tt class=\"docutils literal\"><span class=\"pre\">(-1,0)</span></tt> is returned." },  { "module": "re",  "name": "findBounds",  "code": "proc findBounds*(s: string; pattern: Regex; \u000A                 matches: var openArray[tuple[first, last: int]]; start = 0): tuple[\u000A    first, last: int]",  "desc": "returns the starting position and end position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> and the captured substrings in the array <cite>matches</cite>. If it does not match, nothing is written into <cite>matches</cite> and <tt class=\"docutils literal\"><span class=\"pre\">(-1,0)</span></tt> is returned." },  { "module": "re",  "name": "findBounds",  "code": "proc findBounds*(s: string; pattern: Regex; start = 0): tuple[first, last: int]",  "desc": "returns the starting position of <cite>pattern</cite> in <cite>s</cite>. If it does not match, <tt class=\"docutils literal\"><span class=\"pre\">(-1,0)</span></tt> is returned." },  { "module": "re",  "name": "match",  "code": "proc match*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool",  "desc": "returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">s[start..]</span></tt> matches the <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> and the captured substrings in the array <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt>. If it does not match, nothing is written into <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned." },  { "module": "re",  "name": "match",  "code": "proc match*(s: string; pattern: Regex; start = 0): bool",  "desc": "returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> if <tt class=\"docutils literal\"><span class=\"pre\">s[start..]</span></tt> matches the <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt>." },  { "module": "re",  "name": "matchLen",  "code": "proc matchLen*(s: string; pattern: Regex; matches: var openArray[string]; \u000A               start = 0): int",  "desc": "the same as <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen." },  { "module": "re",  "name": "matchLen",  "code": "proc matchLen*(s: string; pattern: Regex; start = 0): int",  "desc": "the same as <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. " },  { "module": "re",  "name": "find",  "code": "proc find*(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int",  "desc": "returns the starting position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> and the captured substrings in the array <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt>. If it does not match, nothing is written into <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> and -1 is returned." },  { "module": "re",  "name": "find",  "code": "proc find*(s: string; pattern: Regex; start = 0): int",  "desc": "returns the starting position of <tt class=\"docutils literal\"><span class=\"pre\">pattern</span></tt> in <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt>. If it does not match, -1 is returned." },  { "module": "re",  "name": "findAll",  "code": "iterator findAll*(s: string; pattern: Regex; start = 0): string",  "desc": "<p>Yields all matching <em>substrings</em> of <cite>s</cite> that match <cite>pattern</cite>.</p>\u000A<p>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</p>\u000A" },  { "module": "re",  "name": "findAll",  "code": "proc findAll*(s: string; pattern: Regex; start = 0): seq[string]",  "desc": "returns all matching <em>substrings</em> of <cite>s</cite> that match <cite>pattern</cite>. If it does not match, @[] is returned." },  { "module": "re",  "name": "`=~`",  "code": "template `=~`*(s: string; pattern: Regex): expr",  "desc": "This calls <tt class=\"docutils literal\"><span class=\"pre\">match</span></tt> with an implicit declared <tt class=\"docutils literal\"><span class=\"pre\">matches</span></tt> array that can be used in the scope of the <tt class=\"docutils literal\"><span class=\"pre\">=~</span></tt> call:<pre><span class=\"Keyword\">if</span> <span class=\"Identifier\">line</span> <span class=\"Operator\">=~</span> <span class=\"RawData\">re&quot;\\s*(\\w+)\\s*\\=\\s*(\\w+)&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># matches a key=value pair:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Key: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Value: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">elif</span> <span class=\"Identifier\">line</span> <span class=\"Operator\">=~</span> <span class=\"RawData\">re&quot;\\s*(\\#.*)&quot;</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># matches a comment</span>\u000A  <span class=\"Comment\"># note that the implicit ``matches`` array is different from the</span>\u000A  <span class=\"Comment\"># ``matches`` array of the first branch</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;comment: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">matches</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;syntax error&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "re",  "name": "contains",  "code": "proc contains*(s: string; pattern: Regex; start = 0): bool",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, pattern, start) &gt;= 0</span></tt>" },  { "module": "re",  "name": "contains",  "code": "proc contains*(s: string; pattern: Regex; matches: var openArray[string]; \u000A               start = 0): bool",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, pattern, matches, start) &gt;= 0</span></tt>" },  { "module": "re",  "name": "startsWith",  "code": "proc startsWith*(s: string; prefix: Regex): bool",  "desc": "returns true if <cite>s</cite> starts with the pattern <cite>prefix</cite>" },  { "module": "re",  "name": "endsWith",  "code": "proc endsWith*(s: string; suffix: Regex): bool",  "desc": "returns true if <cite>s</cite> ends with the pattern <cite>prefix</cite>" },  { "module": "re",  "name": "replace",  "code": "proc replace*(s: string; sub: Regex; by = \"\"): string",  "desc": "Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>. Captures cannot be accessed in <cite>by</cite>. Examples:<pre><span class=\"StringLit\">&quot;var1=key; var2=key2&quot;</span><span class=\"Operator\">.</span><span class=\"Identifier\">replace</span><span class=\"Punctuation\">(</span><span class=\"RawData\">re&quot;(\\w+)'='(\\w+)&quot;</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;; &quot;</span></pre>" },  { "module": "re",  "name": "replacef",  "code": "proc replacef*(s: string; sub: Regex; by: string): string",  "desc": "Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>. Captures can be accessed in <cite>by</cite> with the notation <tt class=\"docutils literal\"><span class=\"pre\">$i</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">$#</span></tt> (see strutils.`%`). Examples:<p>&quot;var1=key; var2=key2&quot;.replacef(re&quot;(w+)'='(w+)&quot;, &quot;$1&lt;-$2$2&quot;)</p>\u000A<p>Results in:</p>\u000A<p>&quot;var1&lt;-keykey; val2&lt;-key2key2&quot;</p>\u000A" },  { "module": "re",  "name": "parallelReplace",  "code": "proc parallelReplace*(s: string; \u000A                      subs: openArray[tuple[pattern: Regex, repl: string]]): string",  "desc": "Returns a modified copy of <cite>s</cite> with the substitutions in <cite>subs</cite> applied in parallel." },  { "module": "re",  "name": "transformFile",  "code": "proc transformFile*(infile, outfile: string; \u000A                    subs: openArray[tuple[pattern: Regex, repl: string]])",  "desc": "reads in the file <cite>infile</cite>, performs a parallel replacement (calls <cite>parallelReplace</cite>) and writes back to <cite>outfile</cite>. Raises <tt class=\"docutils literal\"><span class=\"pre\">EIO</span></tt> if an error occurs. This is supposed to be used for quick scripting." },  { "module": "re",  "name": "split",  "code": "iterator split*(s: string; sep: Regex): string",  "desc": "<p>Splits the string <cite>s</cite> into substrings.</p>\u000A<p>Substrings are separated by the regular expression <cite>sep</cite>. Examples:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;00232this02939is39an22example111&quot;</span><span class=\"Punctuation\">,</span> <span class=\"RawData\">re&quot;\\d+&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;this&quot;</span>\u000A<span class=\"StringLit\">&quot;is&quot;</span>\u000A<span class=\"StringLit\">&quot;an&quot;</span>\u000A<span class=\"StringLit\">&quot;example&quot;</span></pre>" },  { "module": "re",  "name": "split",  "code": "proc split*(s: string; sep: Regex): seq[string]",  "desc": "Splits the string <cite>s</cite> into substrings." },  { "module": "re",  "name": "escapeRe",  "code": "proc escapeRe*(s: string): string",  "desc": "escapes <cite>s</cite> so that it is matched verbatim when used as a regular expression." },  { "module": "readline",  "name": "CTRL_CHAR",  "code": "template CTRL_CHAR*(c: expr): expr" },  { "module": "readline",  "name": "META_CHAR",  "code": "template META_CHAR*(c: expr): expr" },  { "module": "readline",  "name": "CTRL",  "code": "template CTRL*(c: expr): expr" },  { "module": "readline",  "name": "META",  "code": "template META*(c: expr): expr" },  { "module": "readline",  "name": "UNMETA",  "code": "template UNMETA*(c: expr): expr" },  { "module": "readline",  "name": "UNCTRL",  "code": "template UNCTRL*(c: expr): expr" },  { "module": "readline",  "name": "make_bare_keymap",  "code": "proc make_bare_keymap*(): PKeymap {.cdecl, importc: \"rl_make_bare_keymap\", \u000A                                    dynlib: readlineDll.}" },  { "module": "readline",  "name": "copy_keymap",  "code": "proc copy_keymap*(a2: PKeymap): PKeymap {.cdecl, importc: \"rl_copy_keymap\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "make_keymap",  "code": "proc make_keymap*(): PKeymap {.cdecl, importc: \"rl_make_keymap\", \u000A                               dynlib: readlineDll.}" },  { "module": "readline",  "name": "discard_keymap",  "code": "proc discard_keymap*(a2: PKeymap) {.cdecl, importc: \"rl_discard_keymap\", \u000A                                    dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_keymap_by_name",  "code": "proc get_keymap_by_name*(a2: cstring): PKeymap {.cdecl, \u000A    importc: \"rl_get_keymap_by_name\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_keymap",  "code": "proc get_keymap*(): PKeymap {.cdecl, importc: \"rl_get_keymap\", \u000A                              dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_keymap",  "code": "proc set_keymap*(a2: PKeymap) {.cdecl, importc: \"rl_set_keymap\", \u000A                                dynlib: readlineDll.}" },  { "module": "readline",  "name": "expand",  "code": "proc expand*(a2: cstring): cstring {.cdecl, importc: \"tilde_expand\", \u000A                                     dynlib: tildeDll.}" },  { "module": "readline",  "name": "expand_word",  "code": "proc expand_word*(a2: cstring): cstring {.cdecl, importc: \"tilde_expand_word\", \u000A    dynlib: tildeDll.}" },  { "module": "readline",  "name": "find_word",  "code": "proc find_word*(a2: cstring; a3: cint; a4: ptr cint): cstring {.cdecl, \u000A    importc: \"tilde_find_word\", dynlib: tildeDll.}" },  { "module": "readline",  "name": "digit_argument",  "code": "proc digit_argument*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_digit_argument\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "universal_argument",  "code": "proc universal_argument*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_universal_argument\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "forward_byte",  "code": "proc forward_byte*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_forward_byte\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "forward_char",  "code": "proc forward_char*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_forward_char\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "forward",  "code": "proc forward*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_forward\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_byte",  "code": "proc backward_byte*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_byte\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_char",  "code": "proc backward_char*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_char\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward",  "code": "proc backward*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_backward\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "beg_of_line",  "code": "proc beg_of_line*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_beg_of_line\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "end_of_line",  "code": "proc end_of_line*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_end_of_line\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "forward_word",  "code": "proc forward_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_forward_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_word",  "code": "proc backward_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "refresh_line",  "code": "proc refresh_line*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_refresh_line\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "clear_screen",  "code": "proc clear_screen*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_clear_screen\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "skip_csi_sequence",  "code": "proc skip_csi_sequence*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_skip_csi_sequence\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "arrow_keys",  "code": "proc arrow_keys*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_arrow_keys\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "insert",  "code": "proc insert*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_insert\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "quoted_insert",  "code": "proc quoted_insert*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_quoted_insert\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "tab_insert",  "code": "proc tab_insert*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_tab_insert\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "newline",  "code": "proc newline*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_newline\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "do_lowercase_version",  "code": "proc do_lowercase_version*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_do_lowercase_version\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "rubout",  "code": "proc rubout*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_rubout\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "delete",  "code": "proc delete*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_delete\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "rubout_or_delete",  "code": "proc rubout_or_delete*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_rubout_or_delete\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "delete_horizontal_space",  "code": "proc delete_horizontal_space*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_delete_horizontal_space\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "delete_or_show_completions",  "code": "proc delete_or_show_completions*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_delete_or_show_completions\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "insert_comment",  "code": "proc insert_comment*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_insert_comment\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "upcase_word",  "code": "proc upcase_word*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_upcase_word\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "downcase_word",  "code": "proc downcase_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_downcase_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "capitalize_word",  "code": "proc capitalize_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_capitalize_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "transpose_words",  "code": "proc transpose_words*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_transpose_words\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "transpose_chars",  "code": "proc transpose_chars*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_transpose_chars\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "char_search",  "code": "proc char_search*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_char_search\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_char_search",  "code": "proc backward_char_search*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_char_search\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "beginning_of_history",  "code": "proc beginning_of_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_beginning_of_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "end_of_history",  "code": "proc end_of_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_end_of_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_next_history",  "code": "proc get_next_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_get_next_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_previous_history",  "code": "proc get_previous_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_get_previous_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_mark",  "code": "proc set_mark*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_set_mark\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "exchange_point_and_mark",  "code": "proc exchange_point_and_mark*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_exchange_point_and_mark\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_editing_mode",  "code": "proc vi_editing_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_editing_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "emacs_editing_mode",  "code": "proc emacs_editing_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_emacs_editing_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "overwrite_mode",  "code": "proc overwrite_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_overwrite_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "re_read_init_file",  "code": "proc re_read_init_file*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_re_read_init_file\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "dump_functions",  "code": "proc dump_functions*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_dump_functions\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "dump_macros",  "code": "proc dump_macros*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_dump_macros\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "dump_variables",  "code": "proc dump_variables*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_dump_variables\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "complete",  "code": "proc complete*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_complete\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "possible_completions",  "code": "proc possible_completions*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_possible_completions\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "insert_completions",  "code": "proc insert_completions*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_insert_completions\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "old_menu_complete",  "code": "proc old_menu_complete*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_old_menu_complete\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "menu_complete",  "code": "proc menu_complete*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_menu_complete\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_menu_complete",  "code": "proc backward_menu_complete*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_menu_complete\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "kill_word",  "code": "proc kill_word*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_kill_word\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_kill_word",  "code": "proc backward_kill_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_kill_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "kill_line",  "code": "proc kill_line*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_kill_line\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "backward_kill_line",  "code": "proc backward_kill_line*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_backward_kill_line\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "kill_full_line",  "code": "proc kill_full_line*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_kill_full_line\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unix_word_rubout",  "code": "proc unix_word_rubout*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_unix_word_rubout\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unix_filename_rubout",  "code": "proc unix_filename_rubout*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_unix_filename_rubout\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unix_line_discard",  "code": "proc unix_line_discard*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_unix_line_discard\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "copy_region_to_kill",  "code": "proc copy_region_to_kill*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_copy_region_to_kill\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "kill_region",  "code": "proc kill_region*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_kill_region\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "copy_forward_word",  "code": "proc copy_forward_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_copy_forward_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "copy_backward_word",  "code": "proc copy_backward_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_copy_backward_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "yank",  "code": "proc yank*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_yank\", \u000A                                       dynlib: readlineDll.}" },  { "module": "readline",  "name": "yank_pop",  "code": "proc yank_pop*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_yank_pop\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "yank_nth_arg",  "code": "proc yank_nth_arg*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_yank_nth_arg\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "yank_last_arg",  "code": "proc yank_last_arg*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_yank_last_arg\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "paste_from_clipboard",  "code": "proc paste_from_clipboard*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_paste_from_clipboard\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "reverse_search_history",  "code": "proc reverse_search_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_reverse_search_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "forward_search_history",  "code": "proc forward_search_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_forward_search_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "start_kbd_macro",  "code": "proc start_kbd_macro*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_start_kbd_macro\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "end_kbd_macro",  "code": "proc end_kbd_macro*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_end_kbd_macro\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "call_last_kbd_macro",  "code": "proc call_last_kbd_macro*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_call_last_kbd_macro\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "revert_line",  "code": "proc revert_line*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_revert_line\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "undo_command",  "code": "proc undo_command*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_undo_command\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "tilde_expand",  "code": "proc tilde_expand*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_tilde_expand\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "restart_output",  "code": "proc restart_output*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_restart_output\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "stop_output",  "code": "proc stop_output*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_stop_output\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "abort",  "code": "proc abort*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_abort\", \u000A                                        dynlib: readlineDll.}" },  { "module": "readline",  "name": "tty_status",  "code": "proc tty_status*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_tty_status\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "history_search_forward",  "code": "proc history_search_forward*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_history_search_forward\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "history_search_backward",  "code": "proc history_search_backward*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_history_search_backward\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "noninc_forward_search",  "code": "proc noninc_forward_search*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_noninc_forward_search\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "noninc_reverse_search",  "code": "proc noninc_reverse_search*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_noninc_reverse_search\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "noninc_forward_search_again",  "code": "proc noninc_forward_search_again*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_noninc_forward_search_again\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "noninc_reverse_search_again",  "code": "proc noninc_reverse_search_again*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_noninc_reverse_search_again\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "insert_close",  "code": "proc insert_close*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_insert_close\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "callback_handler_install",  "code": "proc callback_handler_install*(a2: cstring; a3: TvcpFunc) {.cdecl, \u000A    importc: \"rl_callback_handler_install\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "callback_read_char",  "code": "proc callback_read_char*() {.cdecl, importc: \"rl_callback_read_char\", \u000A                             dynlib: readlineDll.}" },  { "module": "readline",  "name": "callback_handler_remove",  "code": "proc callback_handler_remove*() {.cdecl, importc: \"rl_callback_handler_remove\", \u000A                                  dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_redo",  "code": "proc vi_redo*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_redo\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_undo",  "code": "proc vi_undo*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_undo\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_yank_arg",  "code": "proc vi_yank_arg*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_yank_arg\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_fetch_history",  "code": "proc vi_fetch_history*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_fetch_history\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_search_again",  "code": "proc vi_search_again*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_search_again\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_search",  "code": "proc vi_search*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_search\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_complete",  "code": "proc vi_complete*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_complete\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_tilde_expand",  "code": "proc vi_tilde_expand*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_tilde_expand\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_prev_word",  "code": "proc vi_prev_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_prev_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_next_word",  "code": "proc vi_next_word*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_next_word\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_end_word",  "code": "proc vi_end_word*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_end_word\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_insert_beg",  "code": "proc vi_insert_beg*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_insert_beg\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_append_mode",  "code": "proc vi_append_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_append_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_append_eol",  "code": "proc vi_append_eol*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_append_eol\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_eof_maybe",  "code": "proc vi_eof_maybe*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_eof_maybe\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_insertion_mode",  "code": "proc vi_insertion_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_insertion_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_insert_mode",  "code": "proc vi_insert_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_insert_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_movement_mode",  "code": "proc vi_movement_mode*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_movement_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_arg_digit",  "code": "proc vi_arg_digit*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_arg_digit\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_change_case",  "code": "proc vi_change_case*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_change_case\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_put",  "code": "proc vi_put*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_put\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_column",  "code": "proc vi_column*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_column\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_delete_to",  "code": "proc vi_delete_to*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_delete_to\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_change_to",  "code": "proc vi_change_to*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_change_to\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_yank_to",  "code": "proc vi_yank_to*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_yank_to\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_rubout",  "code": "proc vi_rubout*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_rubout\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_delete",  "code": "proc vi_delete*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_delete\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_back_to_indent",  "code": "proc vi_back_to_indent*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_back_to_indent\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_first_print",  "code": "proc vi_first_print*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_first_print\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_char_search",  "code": "proc vi_char_search*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_char_search\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_match",  "code": "proc vi_match*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_match\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_change_char",  "code": "proc vi_change_char*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_change_char\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_subst",  "code": "proc vi_subst*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_subst\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_overstrike",  "code": "proc vi_overstrike*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_overstrike\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_overstrike_delete",  "code": "proc vi_overstrike_delete*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_overstrike_delete\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_replace",  "code": "proc vi_replace*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_replace\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_set_mark",  "code": "proc vi_set_mark*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_set_mark\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_goto_mark",  "code": "proc vi_goto_mark*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_vi_goto_mark\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_check",  "code": "proc vi_check*(): cint {.cdecl, importc: \"rl_vi_check\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_domove",  "code": "proc vi_domove*(a2: cint; a3: ptr cint): cint {.cdecl, importc: \"rl_vi_domove\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_bracktype",  "code": "proc vi_bracktype*(a2: cint): cint {.cdecl, importc: \"rl_vi_bracktype\", \u000A                                     dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_start_inserting",  "code": "proc vi_start_inserting*(a2: cint; a3: cint; a4: cint) {.cdecl, \u000A    importc: \"rl_vi_start_inserting\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_fXWord",  "code": "proc vi_fXWord*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_fWord\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_bXWord",  "code": "proc vi_bXWord*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_bWord\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_eXWord",  "code": "proc vi_eXWord*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_eWord\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_fword",  "code": "proc vi_fword*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_fword\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_bword",  "code": "proc vi_bword*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_bword\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "vi_eword",  "code": "proc vi_eword*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_vi_eword\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "readline",  "code": "proc readline*(a2: cstring): cstring {.cdecl, importc: \"readline\", \u000A                                       dynlib: readlineDll.}" },  { "module": "readline",  "name": "free",  "code": "proc free*(mem: cstring) {.importc: \"free\", nodecl.}",  "desc": "free the buffer that <cite>readline</cite> returned." },  { "module": "readline",  "name": "set_prompt",  "code": "proc set_prompt*(a2: cstring): cint {.cdecl, importc: \"rl_set_prompt\", \u000A                                      dynlib: readlineDll.}" },  { "module": "readline",  "name": "expand_prompt",  "code": "proc expand_prompt*(a2: cstring): cint {.cdecl, importc: \"rl_expand_prompt\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "initialize",  "code": "proc initialize*(): cint {.cdecl, importc: \"rl_initialize\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "discard_argument",  "code": "proc discard_argument*(): cint {.cdecl, importc: \"rl_discard_argument\", \u000A                                 dynlib: readlineDll.}" },  { "module": "readline",  "name": "add_defun",  "code": "proc add_defun*(a2: cstring; a3: TCommandFunc; a4: cint): cint {.cdecl, \u000A    importc: \"rl_add_defun\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_key",  "code": "proc bind_key*(a2: cint; a3: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_bind_key\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_key_in_map",  "code": "proc bind_key_in_map*(a2: cint; a3: TCommandFunc; a4: PKeymap): cint {.cdecl, \u000A    importc: \"rl_bind_key_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unbind_key",  "code": "proc unbind_key*(a2: cint): cint {.cdecl, importc: \"rl_unbind_key\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "unbind_key_in_map",  "code": "proc unbind_key_in_map*(a2: cint; a3: PKeymap): cint {.cdecl, \u000A    importc: \"rl_unbind_key_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_key_if_unbound",  "code": "proc bind_key_if_unbound*(a2: cint; a3: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_bind_key_if_unbound\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_key_if_unbound_in_map",  "code": "proc bind_key_if_unbound_in_map*(a2: cint; a3: TCommandFunc; a4: PKeymap): cint {.\u000A    cdecl, importc: \"rl_bind_key_if_unbound_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unbind_function_in_map",  "code": "proc unbind_function_in_map*(a2: TCommandFunc; a3: PKeymap): cint {.cdecl, \u000A    importc: \"rl_unbind_function_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "unbind_command_in_map",  "code": "proc unbind_command_in_map*(a2: cstring; a3: PKeymap): cint {.cdecl, \u000A    importc: \"rl_unbind_command_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_keyseq",  "code": "proc bind_keyseq*(a2: cstring; a3: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_bind_keyseq\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_keyseq_in_map",  "code": "proc bind_keyseq_in_map*(a2: cstring; a3: TCommandFunc; a4: PKeymap): cint {.\u000A    cdecl, importc: \"rl_bind_keyseq_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_keyseq_if_unbound",  "code": "proc bind_keyseq_if_unbound*(a2: cstring; a3: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_bind_keyseq_if_unbound\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "bind_keyseq_if_unbound_in_map",  "code": "proc bind_keyseq_if_unbound_in_map*(a2: cstring; a3: TCommandFunc; a4: PKeymap): cint {.\u000A    cdecl, importc: \"rl_bind_keyseq_if_unbound_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "generic_bind",  "code": "proc generic_bind*(a2: cint; a3: cstring; a4: cstring; a5: PKeymap): cint {.\u000A    cdecl, importc: \"rl_generic_bind\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "variable_value",  "code": "proc variable_value*(a2: cstring): cstring {.cdecl, \u000A    importc: \"rl_variable_value\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "variable_bind",  "code": "proc variable_bind*(a2: cstring; a3: cstring): cint {.cdecl, \u000A    importc: \"rl_variable_bind\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_key",  "code": "proc set_key*(a2: cstring; a3: TCommandFunc; a4: PKeymap): cint {.cdecl, \u000A    importc: \"rl_set_key\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "macro_bind",  "code": "proc macro_bind*(a2: cstring; a3: cstring; a4: PKeymap): cint {.cdecl, \u000A    importc: \"rl_macro_bind\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "translate_keyseq",  "code": "proc translate_keyseq*(a2: cstring; a3: cstring; a4: ptr cint): cint {.cdecl, \u000A    importc: \"rl_translate_keyseq\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "untranslate_keyseq",  "code": "proc untranslate_keyseq*(a2: cint): cstring {.cdecl, \u000A    importc: \"rl_untranslate_keyseq\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "named_function",  "code": "proc named_function*(a2: cstring): TCommandFunc {.cdecl, \u000A    importc: \"rl_named_function\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "function_of_keyseq",  "code": "proc function_of_keyseq*(a2: cstring; a3: PKeymap; a4: ptr cint): TCommandFunc {.\u000A    cdecl, importc: \"rl_function_of_keyseq\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "list_funmap_names",  "code": "proc list_funmap_names*() {.cdecl, importc: \"rl_list_funmap_names\", \u000A                            dynlib: readlineDll.}" },  { "module": "readline",  "name": "invoking_keyseqs_in_map",  "code": "proc invoking_keyseqs_in_map*(a2: TCommandFunc; a3: PKeymap): cstringArray {.\u000A    cdecl, importc: \"rl_invoking_keyseqs_in_map\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "invoking_keyseqs",  "code": "proc invoking_keyseqs*(a2: TCommandFunc): cstringArray {.cdecl, \u000A    importc: \"rl_invoking_keyseqs\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "function_dumper",  "code": "proc function_dumper*(a2: cint) {.cdecl, importc: \"rl_function_dumper\", \u000A                                  dynlib: readlineDll.}" },  { "module": "readline",  "name": "macro_dumper",  "code": "proc macro_dumper*(a2: cint) {.cdecl, importc: \"rl_macro_dumper\", \u000A                               dynlib: readlineDll.}" },  { "module": "readline",  "name": "variable_dumper",  "code": "proc variable_dumper*(a2: cint) {.cdecl, importc: \"rl_variable_dumper\", \u000A                                  dynlib: readlineDll.}" },  { "module": "readline",  "name": "read_init_file",  "code": "proc read_init_file*(a2: cstring): cint {.cdecl, importc: \"rl_read_init_file\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "parse_and_bind",  "code": "proc parse_and_bind*(a2: cstring): cint {.cdecl, importc: \"rl_parse_and_bind\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_keymap_name",  "code": "proc get_keymap_name*(a2: PKeymap): cstring {.cdecl, \u000A    importc: \"rl_get_keymap_name\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_keymap_from_edit_mode",  "code": "proc set_keymap_from_edit_mode*() {.cdecl, \u000A                                    importc: \"rl_set_keymap_from_edit_mode\", \u000A                                    dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_keymap_name_from_edit_mode",  "code": "proc get_keymap_name_from_edit_mode*(): cstring {.cdecl, \u000A    importc: \"rl_get_keymap_name_from_edit_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "add_funmap_entry",  "code": "proc add_funmap_entry*(a2: cstring; a3: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_add_funmap_entry\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "funmap_names",  "code": "proc funmap_names*(): cstringArray {.cdecl, importc: \"rl_funmap_names\", \u000A                                     dynlib: readlineDll.}" },  { "module": "readline",  "name": "initialize_funmap",  "code": "proc initialize_funmap*() {.cdecl, importc: \"rl_initialize_funmap\", \u000A                            dynlib: readlineDll.}" },  { "module": "readline",  "name": "push_macro_input",  "code": "proc push_macro_input*(a2: cstring) {.cdecl, importc: \"rl_push_macro_input\", \u000A                                      dynlib: readlineDll.}" },  { "module": "readline",  "name": "add_undo",  "code": "proc add_undo*(a2: Tundo_code; a3: cint; a4: cint; a5: cstring) {.cdecl, \u000A    importc: \"rl_add_undo\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "free_undo_list",  "code": "proc free_undo_list*() {.cdecl, importc: \"rl_free_undo_list\", \u000A                         dynlib: readlineDll.}" },  { "module": "readline",  "name": "do_undo",  "code": "proc do_undo*(): cint {.cdecl, importc: \"rl_do_undo\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "begin_undo_group",  "code": "proc begin_undo_group*(): cint {.cdecl, importc: \"rl_begin_undo_group\", \u000A                                 dynlib: readlineDll.}" },  { "module": "readline",  "name": "end_undo_group",  "code": "proc end_undo_group*(): cint {.cdecl, importc: \"rl_end_undo_group\", \u000A                               dynlib: readlineDll.}" },  { "module": "readline",  "name": "modifying",  "code": "proc modifying*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_modifying\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "redisplay",  "code": "proc redisplay*() {.cdecl, importc: \"rl_redisplay\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "on_new_line",  "code": "proc on_new_line*(): cint {.cdecl, importc: \"rl_on_new_line\", \u000A                            dynlib: readlineDll.}" },  { "module": "readline",  "name": "on_new_line_with_prompt",  "code": "proc on_new_line_with_prompt*(): cint {.cdecl, \u000A                                        importc: \"rl_on_new_line_with_prompt\", \u000A                                        dynlib: readlineDll.}" },  { "module": "readline",  "name": "forced_update_display",  "code": "proc forced_update_display*(): cint {.cdecl, \u000A                                      importc: \"rl_forced_update_display\", \u000A                                      dynlib: readlineDll.}" },  { "module": "readline",  "name": "clear_message",  "code": "proc clear_message*(): cint {.cdecl, importc: \"rl_clear_message\", \u000A                              dynlib: readlineDll.}" },  { "module": "readline",  "name": "reset_line_state",  "code": "proc reset_line_state*(): cint {.cdecl, importc: \"rl_reset_line_state\", \u000A                                 dynlib: readlineDll.}" },  { "module": "readline",  "name": "crlf",  "code": "proc crlf*(): cint {.cdecl, importc: \"rl_crlf\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "message",  "code": "proc message*(a2: cstring): cint {.varargs, cdecl, importc: \"rl_message\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "show_char",  "code": "proc show_char*(a2: cint): cint {.cdecl, importc: \"rl_show_char\", \u000A                                  dynlib: readlineDll.}" },  { "module": "readline",  "name": "character_len",  "code": "proc character_len*(a2: cint; a3: cint): cint {.cdecl, \u000A    importc: \"rl_character_len\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "save_prompt",  "code": "proc save_prompt*() {.cdecl, importc: \"rl_save_prompt\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "restore_prompt",  "code": "proc restore_prompt*() {.cdecl, importc: \"rl_restore_prompt\", \u000A                         dynlib: readlineDll.}" },  { "module": "readline",  "name": "replace_line",  "code": "proc replace_line*(a2: cstring; a3: cint) {.cdecl, importc: \"rl_replace_line\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "insert_text",  "code": "proc insert_text*(a2: cstring): cint {.cdecl, importc: \"rl_insert_text\", \u000A                                       dynlib: readlineDll.}" },  { "module": "readline",  "name": "delete_text",  "code": "proc delete_text*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_delete_text\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "kill_text",  "code": "proc kill_text*(a2: cint; a3: cint): cint {.cdecl, importc: \"rl_kill_text\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "copy_text",  "code": "proc copy_text*(a2: cint; a3: cint): cstring {.cdecl, importc: \"rl_copy_text\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "prep_terminal",  "code": "proc prep_terminal*(a2: cint) {.cdecl, importc: \"rl_prep_terminal\", \u000A                                dynlib: readlineDll.}" },  { "module": "readline",  "name": "deprep_terminal",  "code": "proc deprep_terminal*() {.cdecl, importc: \"rl_deprep_terminal\", \u000A                          dynlib: readlineDll.}" },  { "module": "readline",  "name": "tty_set_default_bindings",  "code": "proc tty_set_default_bindings*(a2: PKeymap) {.cdecl, \u000A    importc: \"rl_tty_set_default_bindings\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "tty_unset_default_bindings",  "code": "proc tty_unset_default_bindings*(a2: PKeymap) {.cdecl, \u000A    importc: \"rl_tty_unset_default_bindings\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "reset_terminal",  "code": "proc reset_terminal*(a2: cstring): cint {.cdecl, importc: \"rl_reset_terminal\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "resize_terminal",  "code": "proc resize_terminal*() {.cdecl, importc: \"rl_resize_terminal\", \u000A                          dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_screen_size",  "code": "proc set_screen_size*(a2: cint; a3: cint) {.cdecl, \u000A    importc: \"rl_set_screen_size\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_screen_size",  "code": "proc get_screen_size*(a2: ptr cint; a3: ptr cint) {.cdecl, \u000A    importc: \"rl_get_screen_size\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "reset_screen_size",  "code": "proc reset_screen_size*() {.cdecl, importc: \"rl_reset_screen_size\", \u000A                            dynlib: readlineDll.}" },  { "module": "readline",  "name": "get_termcap",  "code": "proc get_termcap*(a2: cstring): cstring {.cdecl, importc: \"rl_get_termcap\", \u000A    dynlib: readlineDll.}" },  { "module": "readline",  "name": "stuff_char",  "code": "proc stuff_char*(a2: cint): cint {.cdecl, importc: \"rl_stuff_char\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "execute_next",  "code": "proc execute_next*(a2: cint): cint {.cdecl, importc: \"rl_execute_next\", \u000A                                     dynlib: readlineDll.}" },  { "module": "readline",  "name": "clear_pending_input",  "code": "proc clear_pending_input*(): cint {.cdecl, importc: \"rl_clear_pending_input\", \u000A                                    dynlib: readlineDll.}" },  { "module": "readline",  "name": "read_key",  "code": "proc read_key*(): cint {.cdecl, importc: \"rl_read_key\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "getc",  "code": "proc getc*(a2: File): cint {.cdecl, importc: \"rl_getc\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_keyboard_input_timeout",  "code": "proc set_keyboard_input_timeout*(a2: cint): cint {.cdecl, \u000A    importc: \"rl_set_keyboard_input_timeout\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "extend_line_buffer",  "code": "proc extend_line_buffer*(a2: cint) {.cdecl, importc: \"rl_extend_line_buffer\", \u000A                                     dynlib: readlineDll.}" },  { "module": "readline",  "name": "ding",  "code": "proc ding*(): cint {.cdecl, importc: \"rl_ding\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "alphabetic",  "code": "proc alphabetic*(a2: cint): cint {.cdecl, importc: \"rl_alphabetic\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "free",  "code": "proc free*(a2: pointer) {.cdecl, importc: \"rl_free\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_signals",  "code": "proc set_signals*(): cint {.cdecl, importc: \"rl_set_signals\", \u000A                            dynlib: readlineDll.}" },  { "module": "readline",  "name": "clear_signals",  "code": "proc clear_signals*(): cint {.cdecl, importc: \"rl_clear_signals\", \u000A                              dynlib: readlineDll.}" },  { "module": "readline",  "name": "cleanup_after_signal",  "code": "proc cleanup_after_signal*() {.cdecl, importc: \"rl_cleanup_after_signal\", \u000A                               dynlib: readlineDll.}" },  { "module": "readline",  "name": "reset_after_signal",  "code": "proc reset_after_signal*() {.cdecl, importc: \"rl_reset_after_signal\", \u000A                             dynlib: readlineDll.}" },  { "module": "readline",  "name": "free_line_state",  "code": "proc free_line_state*() {.cdecl, importc: \"rl_free_line_state\", \u000A                          dynlib: readlineDll.}" },  { "module": "readline",  "name": "echo_signal_char",  "code": "proc echo_signal_char*(a2: cint) {.cdecl, importc: \"rl_echo_signal_char\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "set_paren_blink_timeout",  "code": "proc set_paren_blink_timeout*(a2: cint): cint {.cdecl, \u000A    importc: \"rl_set_paren_blink_timeout\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "maybe_save_line",  "code": "proc maybe_save_line*(): cint {.cdecl, importc: \"rl_maybe_save_line\", \u000A                                dynlib: readlineDll.}" },  { "module": "readline",  "name": "maybe_unsave_line",  "code": "proc maybe_unsave_line*(): cint {.cdecl, importc: \"rl_maybe_unsave_line\", \u000A                                  dynlib: readlineDll.}" },  { "module": "readline",  "name": "maybe_replace_line",  "code": "proc maybe_replace_line*(): cint {.cdecl, importc: \"rl_maybe_replace_line\", \u000A                                   dynlib: readlineDll.}" },  { "module": "readline",  "name": "complete_internal",  "code": "proc complete_internal*(a2: cint): cint {.cdecl, \u000A    importc: \"rl_complete_internal\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "display_match_list",  "code": "proc display_match_list*(a2: cstringArray; a3: cint; a4: cint) {.cdecl, \u000A    importc: \"rl_display_match_list\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "completion_matches",  "code": "proc completion_matches*(a2: cstring; a3: Tcompentry_func): cstringArray {.\u000A    cdecl, importc: \"rl_completion_matches\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "username_completion_function",  "code": "proc username_completion_function*(a2: cstring; a3: cint): cstring {.cdecl, \u000A    importc: \"rl_username_completion_function\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "filename_completion_function",  "code": "proc filename_completion_function*(a2: cstring; a3: cint): cstring {.cdecl, \u000A    importc: \"rl_filename_completion_function\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "completion_mode",  "code": "proc completion_mode*(a2: TCommandFunc): cint {.cdecl, \u000A    importc: \"rl_completion_mode\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "SETSTATE",  "code": "template SETSTATE*(x: expr): stmt" },  { "module": "readline",  "name": "UNSETSTATE",  "code": "template UNSETSTATE*(x: expr): stmt" },  { "module": "readline",  "name": "ISSTATE",  "code": "template ISSTATE*(x: expr): expr" },  { "module": "readline",  "name": "save_state",  "code": "proc save_state*(a2: ptr Treadline_state): cint {.cdecl, \u000A    importc: \"rl_save_state\", dynlib: readlineDll.}" },  { "module": "readline",  "name": "restore_state",  "code": "proc restore_state*(a2: ptr Treadline_state): cint {.cdecl, \u000A    importc: \"rl_restore_state\", dynlib: readlineDll.}" },  { "module": "redis",  "name": "open",  "code": "proc open*(host = \"localhost\"; port = 6379.Port): Redis",  "desc": "Opens a connection to the redis server." },  { "module": "redis",  "name": "flushPipeline",  "code": "proc flushPipeline*(r: Redis; wasMulti = false): RedisList",  "desc": "Send buffered commands, clear buffer, return results" },  { "module": "redis",  "name": "startPipelining",  "code": "proc startPipelining*(r: Redis)",  "desc": "Enable command pipelining (reduces network roundtrips). Note that when enabled, you must call flushPipeline to actually send commands, except for multi/exec() which enable and flush the pipeline automatically. Commands return immediately with dummy values; actual results returned from flushPipeline() or exec()" },  { "module": "redis",  "name": "del",  "code": "proc del*(r: Redis; keys: varargs[string]): RedisInteger",  "desc": "Delete a key or multiple keys" },  { "module": "redis",  "name": "exists",  "code": "proc exists*(r: Redis; key: string): bool",  "desc": "Determine if a key exists" },  { "module": "redis",  "name": "expire",  "code": "proc expire*(r: Redis; key: string; seconds: int): bool",  "desc": "Set a key's time to live in seconds. Returns <cite>false</cite> if the key could not be found or the timeout could not be set." },  { "module": "redis",  "name": "expireAt",  "code": "proc expireAt*(r: Redis; key: string; timestamp: int): bool",  "desc": "Set the expiration for a key as a UNIX timestamp. Returns <cite>false</cite> if the key could not be found or the timeout could not be set." },  { "module": "redis",  "name": "keys",  "code": "proc keys*(r: Redis; pattern: string): RedisList",  "desc": "Find all keys matching the given pattern" },  { "module": "redis",  "name": "move",  "code": "proc move*(r: Redis; key: string; db: int): bool",  "desc": "Move a key to another database. Returns <cite>true</cite> on a successful move." },  { "module": "redis",  "name": "persist",  "code": "proc persist*(r: Redis; key: string): bool",  "desc": "Remove the expiration from a key. Returns <cite>true</cite> when the timeout was removed." },  { "module": "redis",  "name": "randomKey",  "code": "proc randomKey*(r: Redis): RedisString",  "desc": "Return a random key from the keyspace" },  { "module": "redis",  "name": "rename",  "code": "proc rename*(r: Redis; key, newkey: string): RedisStatus",  "desc": "<p>Rename a key.</p>\u000A<p><strong>WARNING:</strong> Overwrites <cite>newkey</cite> if it exists!</p>\u000A" },  { "module": "redis",  "name": "renameNX",  "code": "proc renameNX*(r: Redis; key, newkey: string): bool",  "desc": "Same as <tt class=\"docutils literal\"><span class=\"pre\">rename</span></tt> but doesn't continue if <cite>newkey</cite> exists. Returns <cite>true</cite> if key was renamed." },  { "module": "redis",  "name": "ttl",  "code": "proc ttl*(r: Redis; key: string): RedisInteger",  "desc": "Get the time to live for a key" },  { "module": "redis",  "name": "keyType",  "code": "proc keyType*(r: Redis; key: string): RedisStatus",  "desc": "Determine the type stored at key" },  { "module": "redis",  "name": "append",  "code": "proc append*(r: Redis; key, value: string): RedisInteger",  "desc": "Append a value to a key" },  { "module": "redis",  "name": "decr",  "code": "proc decr*(r: Redis; key: string): RedisInteger",  "desc": "Decrement the integer value of a key by one" },  { "module": "redis",  "name": "decrBy",  "code": "proc decrBy*(r: Redis; key: string; decrement: int): RedisInteger",  "desc": "Decrement the integer value of a key by the given number" },  { "module": "redis",  "name": "get",  "code": "proc get*(r: Redis; key: string): RedisString",  "desc": "Get the value of a key. Returns <cite>redisNil</cite> when <cite>key</cite> doesn't exist." },  { "module": "redis",  "name": "getBit",  "code": "proc getBit*(r: Redis; key: string; offset: int): RedisInteger",  "desc": "Returns the bit value at offset in the string value stored at key" },  { "module": "redis",  "name": "getRange",  "code": "proc getRange*(r: Redis; key: string; start, stop: int): RedisString",  "desc": "Get a substring of the string stored at a key" },  { "module": "redis",  "name": "getSet",  "code": "proc getSet*(r: Redis; key: string; value: string): RedisString",  "desc": "Set the string value of a key and return its old value. Returns <cite>redisNil</cite> when key doesn't exist." },  { "module": "redis",  "name": "incr",  "code": "proc incr*(r: Redis; key: string): RedisInteger",  "desc": "Increment the integer value of a key by one." },  { "module": "redis",  "name": "incrBy",  "code": "proc incrBy*(r: Redis; key: string; increment: int): RedisInteger",  "desc": "Increment the integer value of a key by the given number" },  { "module": "redis",  "name": "setk",  "code": "proc setk*(r: Redis; key, value: string)",  "desc": "<p>Set the string value of a key.</p>\u000A<p>NOTE: This function had to be renamed due to a clash with the <cite>set</cite> type.</p>\u000A" },  { "module": "redis",  "name": "setNX",  "code": "proc setNX*(r: Redis; key, value: string): bool",  "desc": "Set the value of a key, only if the key does not exist. Returns <cite>true</cite> if the key was set." },  { "module": "redis",  "name": "setBit",  "code": "proc setBit*(r: Redis; key: string; offset: int; value: string): RedisInteger",  "desc": "Sets or clears the bit at offset in the string value stored at key" },  { "module": "redis",  "name": "setEx",  "code": "proc setEx*(r: Redis; key: string; seconds: int; value: string): RedisStatus",  "desc": "Set the value and expiration of a key" },  { "module": "redis",  "name": "setRange",  "code": "proc setRange*(r: Redis; key: string; offset: int; value: string): RedisInteger",  "desc": "Overwrite part of a string at key starting at the specified offset" },  { "module": "redis",  "name": "strlen",  "code": "proc strlen*(r: Redis; key: string): RedisInteger",  "desc": "Get the length of the value stored in a key. Returns 0 when key doesn't exist." },  { "module": "redis",  "name": "hDel",  "code": "proc hDel*(r: Redis; key, field: string): bool",  "desc": "Delete a hash field at <cite>key</cite>. Returns <cite>true</cite> if the field was removed." },  { "module": "redis",  "name": "hExists",  "code": "proc hExists*(r: Redis; key, field: string): bool",  "desc": "Determine if a hash field exists." },  { "module": "redis",  "name": "hGet",  "code": "proc hGet*(r: Redis; key, field: string): RedisString",  "desc": "Get the value of a hash field" },  { "module": "redis",  "name": "hGetAll",  "code": "proc hGetAll*(r: Redis; key: string): RedisList",  "desc": "Get all the fields and values in a hash" },  { "module": "redis",  "name": "hIncrBy",  "code": "proc hIncrBy*(r: Redis; key, field: string; incr: int): RedisInteger",  "desc": "Increment the integer value of a hash field by the given number" },  { "module": "redis",  "name": "hKeys",  "code": "proc hKeys*(r: Redis; key: string): RedisList",  "desc": "Get all the fields in a hash" },  { "module": "redis",  "name": "hLen",  "code": "proc hLen*(r: Redis; key: string): RedisInteger",  "desc": "Get the number of fields in a hash" },  { "module": "redis",  "name": "hMGet",  "code": "proc hMGet*(r: Redis; key: string; fields: varargs[string]): RedisList",  "desc": "Get the values of all the given hash fields" },  { "module": "redis",  "name": "hMSet",  "code": "proc hMSet*(r: Redis; key: string; \u000A            fieldValues: openArray[tuple[field, value: string]])",  "desc": "Set multiple hash fields to multiple values" },  { "module": "redis",  "name": "hSet",  "code": "proc hSet*(r: Redis; key, field, value: string): RedisInteger",  "desc": "Set the string value of a hash field" },  { "module": "redis",  "name": "hSetNX",  "code": "proc hSetNX*(r: Redis; key, field, value: string): RedisInteger",  "desc": "Set the value of a hash field, only if the field does <strong>not</strong> exist" },  { "module": "redis",  "name": "hVals",  "code": "proc hVals*(r: Redis; key: string): RedisList",  "desc": "Get all the values in a hash" },  { "module": "redis",  "name": "bLPop",  "code": "proc bLPop*(r: Redis; keys: varargs[string]; timeout: int): RedisList",  "desc": "Remove and get the <em>first</em> element in a list, or block until one is available" },  { "module": "redis",  "name": "bRPop",  "code": "proc bRPop*(r: Redis; keys: varargs[string]; timeout: int): RedisList",  "desc": "Remove and get the <em>last</em> element in a list, or block until one is available." },  { "module": "redis",  "name": "bRPopLPush",  "code": "proc bRPopLPush*(r: Redis; source, destination: string; timeout: int): RedisString",  "desc": "<p>Pop a value from a list, push it to another list and return it; or block until one is available.</p>\u000A<p><a class=\"reference external\" href=\"http://redis.io/commands/brpoplpush\">http://redis.io/commands/brpoplpush</a></p>\u000A" },  { "module": "redis",  "name": "lIndex",  "code": "proc lIndex*(r: Redis; key: string; index: int): RedisString",  "desc": "Get an element from a list by its index" },  { "module": "redis",  "name": "lInsert",  "code": "proc lInsert*(r: Redis; key: string; before: bool; pivot, value: string): RedisInteger",  "desc": "Insert an element before or after another element in a list" },  { "module": "redis",  "name": "lLen",  "code": "proc lLen*(r: Redis; key: string): RedisInteger",  "desc": "Get the length of a list" },  { "module": "redis",  "name": "lPop",  "code": "proc lPop*(r: Redis; key: string): RedisString",  "desc": "Remove and get the first element in a list" },  { "module": "redis",  "name": "lPush",  "code": "proc lPush*(r: Redis; key, value: string; create: bool = true): RedisInteger",  "desc": "Prepend a value to a list. Returns the length of the list after the push. The <tt class=\"docutils literal\"><span class=\"pre\">create</span></tt> param specifies whether a list should be created if it doesn't exist at <tt class=\"docutils literal\"><span class=\"pre\">key</span></tt>. More specifically if <tt class=\"docutils literal\"><span class=\"pre\">create</span></tt> is true, <cite>LPUSH</cite> will be used, otherwise <cite>LPUSHX</cite>." },  { "module": "redis",  "name": "lRange",  "code": "proc lRange*(r: Redis; key: string; start, stop: int): RedisList",  "desc": "Get a range of elements from a list. Returns <cite>nil</cite> when <cite>key</cite> doesn't exist." },  { "module": "redis",  "name": "lRem",  "code": "proc lRem*(r: Redis; key: string; value: string; count: int = 0): RedisInteger",  "desc": "Remove elements from a list. Returns the number of elements that have been removed." },  { "module": "redis",  "name": "lSet",  "code": "proc lSet*(r: Redis; key: string; index: int; value: string)",  "desc": "Set the value of an element in a list by its index" },  { "module": "redis",  "name": "lTrim",  "code": "proc lTrim*(r: Redis; key: string; start, stop: int)",  "desc": "Trim a list to the specified range" },  { "module": "redis",  "name": "rPop",  "code": "proc rPop*(r: Redis; key: string): RedisString",  "desc": "Remove and get the last element in a list" },  { "module": "redis",  "name": "rPopLPush",  "code": "proc rPopLPush*(r: Redis; source, destination: string): RedisString",  "desc": "Remove the last element in a list, append it to another list and return it" },  { "module": "redis",  "name": "rPush",  "code": "proc rPush*(r: Redis; key, value: string; create: bool = true): RedisInteger",  "desc": "Append a value to a list. Returns the length of the list after the push. The <tt class=\"docutils literal\"><span class=\"pre\">create</span></tt> param specifies whether a list should be created if it doesn't exist at <tt class=\"docutils literal\"><span class=\"pre\">key</span></tt>. More specifically if <tt class=\"docutils literal\"><span class=\"pre\">create</span></tt> is true, <cite>RPUSH</cite> will be used, otherwise <cite>RPUSHX</cite>." },  { "module": "redis",  "name": "sadd",  "code": "proc sadd*(r: Redis; key: string; member: string): RedisInteger",  "desc": "Add a member to a set" },  { "module": "redis",  "name": "scard",  "code": "proc scard*(r: Redis; key: string): RedisInteger",  "desc": "Get the number of members in a set" },  { "module": "redis",  "name": "sdiff",  "code": "proc sdiff*(r: Redis; keys: varargs[string]): RedisList",  "desc": "Subtract multiple sets" },  { "module": "redis",  "name": "sdiffstore",  "code": "proc sdiffstore*(r: Redis; destination: string; keys: varargs[string]): RedisInteger",  "desc": "Subtract multiple sets and store the resulting set in a key" },  { "module": "redis",  "name": "sinter",  "code": "proc sinter*(r: Redis; keys: varargs[string]): RedisList",  "desc": "Intersect multiple sets" },  { "module": "redis",  "name": "sinterstore",  "code": "proc sinterstore*(r: Redis; destination: string; keys: varargs[string]): RedisInteger",  "desc": "Intersect multiple sets and store the resulting set in a key" },  { "module": "redis",  "name": "sismember",  "code": "proc sismember*(r: Redis; key: string; member: string): RedisInteger",  "desc": "Determine if a given value is a member of a set" },  { "module": "redis",  "name": "smembers",  "code": "proc smembers*(r: Redis; key: string): RedisList",  "desc": "Get all the members in a set" },  { "module": "redis",  "name": "smove",  "code": "proc smove*(r: Redis; source: string; destination: string; member: string): RedisInteger",  "desc": "Move a member from one set to another" },  { "module": "redis",  "name": "spop",  "code": "proc spop*(r: Redis; key: string): RedisString",  "desc": "Remove and return a random member from a set" },  { "module": "redis",  "name": "srandmember",  "code": "proc srandmember*(r: Redis; key: string): RedisString",  "desc": "Get a random member from a set" },  { "module": "redis",  "name": "srem",  "code": "proc srem*(r: Redis; key: string; member: string): RedisInteger",  "desc": "Remove a member from a set" },  { "module": "redis",  "name": "sunion",  "code": "proc sunion*(r: Redis; keys: varargs[string]): RedisList",  "desc": "Add multiple sets" },  { "module": "redis",  "name": "sunionstore",  "code": "proc sunionstore*(r: Redis; destination: string; key: varargs[string]): RedisInteger",  "desc": "Add multiple sets and store the resulting set in a key " },  { "module": "redis",  "name": "zadd",  "code": "proc zadd*(r: Redis; key: string; score: int; member: string): RedisInteger",  "desc": "Add a member to a sorted set, or update its score if it already exists" },  { "module": "redis",  "name": "zcard",  "code": "proc zcard*(r: Redis; key: string): RedisInteger",  "desc": "Get the number of members in a sorted set" },  { "module": "redis",  "name": "zcount",  "code": "proc zcount*(r: Redis; key: string; min: string; max: string): RedisInteger",  "desc": "Count the members in a sorted set with scores within the given values" },  { "module": "redis",  "name": "zincrby",  "code": "proc zincrby*(r: Redis; key: string; increment: string; member: string): RedisString",  "desc": "Increment the score of a member in a sorted set" },  { "module": "redis",  "name": "zinterstore",  "code": "proc zinterstore*(r: Redis; destination: string; numkeys: string; \u000A                  keys: openArray[string]; weights: openArray[string] = []; \u000A                  aggregate: string = \"\"): RedisInteger",  "desc": "Intersect multiple sorted sets and store the resulting sorted set in a new key" },  { "module": "redis",  "name": "zrange",  "code": "proc zrange*(r: Redis; key: string; start: string; stop: string; \u000A             withScores: bool): RedisList",  "desc": "Return a range of members in a sorted set, by index" },  { "module": "redis",  "name": "zrangebyscore",  "code": "proc zrangebyscore*(r: Redis; key: string; min: string; max: string; \u000A                    withScore: bool = false; limit: bool = false; \u000A                    limitOffset: int = 0; limitCount: int = 0): RedisList",  "desc": "Return a range of members in a sorted set, by score" },  { "module": "redis",  "name": "zrank",  "code": "proc zrank*(r: Redis; key: string; member: string): RedisString",  "desc": "Determine the index of a member in a sorted set" },  { "module": "redis",  "name": "zrem",  "code": "proc zrem*(r: Redis; key: string; member: string): RedisInteger",  "desc": "Remove a member from a sorted set" },  { "module": "redis",  "name": "zremrangebyrank",  "code": "proc zremrangebyrank*(r: Redis; key: string; start: string; stop: string): RedisInteger",  "desc": "Remove all members in a sorted set within the given indexes" },  { "module": "redis",  "name": "zremrangebyscore",  "code": "proc zremrangebyscore*(r: Redis; key: string; min: string; max: string): RedisInteger",  "desc": "Remove all members in a sorted set within the given scores" },  { "module": "redis",  "name": "zrevrange",  "code": "proc zrevrange*(r: Redis; key: string; start: string; stop: string; \u000A                withScore: bool): RedisList",  "desc": "Return a range of members in a sorted set, by index, with scores ordered from high to low" },  { "module": "redis",  "name": "zrevrangebyscore",  "code": "proc zrevrangebyscore*(r: Redis; key: string; min: string; max: string; \u000A                       withScore: bool = false; limit: bool = false; \u000A                       limitOffset: int = 0; limitCount: int = 0): RedisList",  "desc": "Return a range of members in a sorted set, by score, with scores ordered from high to low" },  { "module": "redis",  "name": "zrevrank",  "code": "proc zrevrank*(r: Redis; key: string; member: string): RedisString",  "desc": "Determine the index of a member in a sorted set, with scores ordered from high to low" },  { "module": "redis",  "name": "zscore",  "code": "proc zscore*(r: Redis; key: string; member: string): RedisString",  "desc": "Get the score associated with the given member in a sorted set" },  { "module": "redis",  "name": "zunionstore",  "code": "proc zunionstore*(r: Redis; destination: string; numkeys: string; \u000A                  keys: openArray[string]; weights: openArray[string] = []; \u000A                  aggregate: string = \"\"): RedisInteger",  "desc": "Add multiple sorted sets and store the resulting sorted set in a new key " },  { "module": "redis",  "name": "discardMulti",  "code": "proc discardMulti*(r: Redis)",  "desc": "Discard all commands issued after MULTI" },  { "module": "redis",  "name": "exec",  "code": "proc exec*(r: Redis): RedisList",  "desc": "Execute all commands issued after MULTI" },  { "module": "redis",  "name": "multi",  "code": "proc multi*(r: Redis)",  "desc": "Mark the start of a transaction block" },  { "module": "redis",  "name": "unwatch",  "code": "proc unwatch*(r: Redis)",  "desc": "Forget about all watched keys" },  { "module": "redis",  "name": "watch",  "code": "proc watch*(r: Redis; key: varargs[string])",  "desc": "Watch the given keys to determine execution of the MULTI/EXEC block " },  { "module": "redis",  "name": "auth",  "code": "proc auth*(r: Redis; password: string)",  "desc": "Authenticate to the server" },  { "module": "redis",  "name": "echoServ",  "code": "proc echoServ*(r: Redis; message: string): RedisString",  "desc": "Echo the given string" },  { "module": "redis",  "name": "ping",  "code": "proc ping*(r: Redis): RedisStatus",  "desc": "Ping the server" },  { "module": "redis",  "name": "quit",  "code": "proc quit*(r: Redis)",  "desc": "Close the connection" },  { "module": "redis",  "name": "select",  "code": "proc select*(r: Redis; index: int): RedisStatus",  "desc": "Change the selected database for the current connection " },  { "module": "redis",  "name": "bgrewriteaof",  "code": "proc bgrewriteaof*(r: Redis)",  "desc": "Asynchronously rewrite the append-only file" },  { "module": "redis",  "name": "bgsave",  "code": "proc bgsave*(r: Redis)",  "desc": "Asynchronously save the dataset to disk" },  { "module": "redis",  "name": "configGet",  "code": "proc configGet*(r: Redis; parameter: string): RedisList",  "desc": "Get the value of a configuration parameter" },  { "module": "redis",  "name": "configSet",  "code": "proc configSet*(r: Redis; parameter: string; value: string)",  "desc": "Set a configuration parameter to the given value" },  { "module": "redis",  "name": "configResetStat",  "code": "proc configResetStat*(r: Redis)",  "desc": "Reset the stats returned by INFO" },  { "module": "redis",  "name": "dbsize",  "code": "proc dbsize*(r: Redis): RedisInteger",  "desc": "Return the number of keys in the selected database" },  { "module": "redis",  "name": "debugObject",  "code": "proc debugObject*(r: Redis; key: string): RedisStatus",  "desc": "Get debugging information about a key" },  { "module": "redis",  "name": "debugSegfault",  "code": "proc debugSegfault*(r: Redis)",  "desc": "Make the server crash" },  { "module": "redis",  "name": "flushall",  "code": "proc flushall*(r: Redis): RedisStatus",  "desc": "Remove all keys from all databases" },  { "module": "redis",  "name": "flushdb",  "code": "proc flushdb*(r: Redis): RedisStatus",  "desc": "Remove all keys from the current database" },  { "module": "redis",  "name": "info",  "code": "proc info*(r: Redis): RedisString",  "desc": "Get information and statistics about the server" },  { "module": "redis",  "name": "lastsave",  "code": "proc lastsave*(r: Redis): RedisInteger",  "desc": "Get the UNIX time stamp of the last successful save to disk" },  { "module": "redis",  "name": "save",  "code": "proc save*(r: Redis)",  "desc": "Synchronously save the dataset to disk" },  { "module": "redis",  "name": "shutdown",  "code": "proc shutdown*(r: Redis)",  "desc": "Synchronously save the dataset to disk and then shut down the server" },  { "module": "redis",  "name": "slaveof",  "code": "proc slaveof*(r: Redis; host: string; port: string)",  "desc": "Make the server a slave of another instance, or promote it as master" },  { "module": "redis",  "name": "hPairs",  "code": "iterator hPairs*(r: Redis; key: string): tuple[key, value: string]",  "desc": "Iterator for keys and values in a hash." },  { "module": "romans",  "name": "romanToDecimal",  "code": "proc romanToDecimal*(romanVal: string): int",  "desc": "Converts a Roman numeral to its int representation." },  { "module": "romans",  "name": "decimalToRoman",  "code": "proc decimalToRoman*(number: range[1 .. 3999]): string",  "desc": "Converts a number to a Roman numeral." },  { "module": "ropes",  "name": "len",  "code": "proc len*(a: Rope): int {.rtl, extern: \"nro$1\".}",  "desc": "the rope's length" },  { "module": "ropes",  "name": "rope",  "code": "proc rope*(s: string): Rope {.rtl, extern: \"nro$1Str\".}",  "desc": "Converts a string to a rope. " },  { "module": "ropes",  "name": "rope",  "code": "proc rope*(i: BiggestInt): Rope {.rtl, extern: \"nro$1BiggestInt\".}",  "desc": "Converts an int to a rope. " },  { "module": "ropes",  "name": "rope",  "code": "proc rope*(f: BiggestFloat): Rope {.rtl, extern: \"nro$1BiggestFloat\".}",  "desc": "Converts a float to a rope. " },  { "module": "ropes",  "name": "enableCache",  "code": "proc enableCache*() {.rtl, extern: \"nro$1\".}",  "desc": "Enables the caching of leaves. This reduces the memory footprint at the cost of runtime efficiency." },  { "module": "ropes",  "name": "disableCache",  "code": "proc disableCache*() {.rtl, extern: \"nro$1\".}",  "desc": "the cache is discarded and disabled. The GC will reuse its used memory." },  { "module": "ropes",  "name": "`&amp;`",  "code": "proc `&`*(a, b: Rope): Rope {.rtl, extern: \"nroConcRopeRope\".}",  "desc": "the concatenation operator for ropes." },  { "module": "ropes",  "name": "`&amp;`",  "code": "proc `&`*(a: Rope; b: string): Rope {.rtl, extern: \"nroConcRopeStr\".}",  "desc": "the concatenation operator for ropes." },  { "module": "ropes",  "name": "`&amp;`",  "code": "proc `&`*(a: string; b: Rope): Rope {.rtl, extern: \"nroConcStrRope\".}",  "desc": "the concatenation operator for ropes." },  { "module": "ropes",  "name": "`&amp;`",  "code": "proc `&`*(a: openArray[Rope]): Rope {.rtl, extern: \"nroConcOpenArray\".}",  "desc": "the concatenation operator for an openarray of ropes." },  { "module": "ropes",  "name": "add",  "code": "proc add*(a: var Rope; b: Rope) {.rtl, extern: \"nro$1Rope\".}",  "desc": "adds <cite>b</cite> to the rope <cite>a</cite>." },  { "module": "ropes",  "name": "add",  "code": "proc add*(a: var Rope; b: string) {.rtl, extern: \"nro$1Str\".}",  "desc": "adds <cite>b</cite> to the rope <cite>a</cite>." },  { "module": "ropes",  "name": "`[]`",  "code": "proc `[]`*(r: Rope; i: int): char {.rtl, extern: \"nroCharAt\".}",  "desc": "returns the character at position <cite>i</cite> in the rope <cite>r</cite>. This is quite expensive! Worst-case: O(n). If <tt class=\"docutils literal\"><span class=\"pre\">i &gt;= r.len</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">\\0</span></tt> is returned." },  { "module": "ropes",  "name": "leaves",  "code": "iterator leaves*(r: Rope): string",  "desc": "iterates over any leaf string in the rope <cite>r</cite>." },  { "module": "ropes",  "name": "items",  "code": "iterator items*(r: Rope): char",  "desc": "iterates over any character in the rope <cite>r</cite>." },  { "module": "ropes",  "name": "write",  "code": "proc write*(f: File; r: Rope) {.rtl, extern: \"nro$1\".}",  "desc": "writes a rope to a file." },  { "module": "ropes",  "name": "`$`",  "code": "proc `$`*(r: Rope): string {.rtl, extern: \"nroToString\".}",  "desc": "converts a rope back to a string." },  { "module": "ropes",  "name": "`%`",  "code": "proc `%`*(frmt: string; args: openArray[Rope]): Rope {.rtl, extern: \"nroFormat\".}",  "desc": "<cite>%</cite> substitution operator for ropes. Does not support the <tt class=\"docutils literal\"><span class=\"pre\">$identifier</span></tt> nor <tt class=\"docutils literal\"><span class=\"pre\">${identifier}</span></tt> notations." },  { "module": "ropes",  "name": "addf",  "code": "proc addf*(c: var Rope; frmt: string; args: openArray[Rope]) {.rtl, \u000A    extern: \"nro$1\".}",  "desc": "shortcut for <tt class=\"docutils literal\"><span class=\"pre\">add(c, frmt % args)</span></tt>." },  { "module": "ropes",  "name": "equalsFile",  "code": "proc equalsFile*(r: Rope; f: File): bool {.rtl, extern: \"nro$1File\".}",  "desc": "returns true if the contents of the file <cite>f</cite> equal <cite>r</cite>." },  { "module": "ropes",  "name": "equalsFile",  "code": "proc equalsFile*(r: Rope; f: string): bool {.rtl, extern: \"nro$1Str\".}",  "desc": "returns true if the contents of the file <cite>f</cite> equal <cite>r</cite>. If <cite>f</cite> does not exist, false is returned." },  { "module": "rtarrays",  "name": "initRtArray",  "code": "proc initRtArray*[T](len: Natural): RtArray[T]" },  { "module": "rtarrays",  "name": "getRawData",  "code": "proc getRawData*[T](x: var RtArray[T]): ptr UncheckedArray[T]" },  { "module": "scgi",  "name": "raiseScgiError",  "code": "proc raiseScgiError*(msg: string) {.noreturn.}",  "desc": "raises an ScgiError exception with message <cite>msg</cite>." },  { "module": "scgi",  "name": "open",  "code": "proc open*(s: var ScgiState; port = Port(4000); address = \"127.0.0.1\"; \u000A           reuseAddr = false)",  "desc": "opens a connection." },  { "module": "scgi",  "name": "close",  "code": "proc close*(s: var ScgiState)",  "desc": "closes the connection." },  { "module": "scgi",  "name": "next",  "code": "proc next*(s: var ScgiState; timeout: int = - 1): bool",  "desc": "proceed to the first/next request. Waits <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> miliseconds for a request, if <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> is <cite>-1</cite> then this function will never time out. Returns <cite>true</cite> if a new request has been processed." },  { "module": "scgi",  "name": "writeStatusOkTextContent",  "code": "proc writeStatusOkTextContent*(c: Socket; contentType = \"text/html\")",  "desc": "<p>sends the following string to the socket <cite>c</cite>:<pre>\u000AStatus: 200 OK\\r\\LContent-Type: text/html\\r\\L\\r\\L</pre>\u000A</p>\u000A<p>You should send this before sending your HTML page, for example.</p>\u000A" },  { "module": "scgi",  "name": "run",  "code": "proc run*(handleRequest: proc (client: Socket; input: string; \u000A                               headers: StringTableRef): bool {.nimcall, gcsafe.}; \u000A          port = Port(4000))",  "desc": "encapsulates the SCGI object and main loop." },  { "module": "scgi",  "name": "open",  "code": "proc open*(handleRequest: proc (client: AsyncSocket; input: string; \u000A                                headers: StringTableRef) {.closure, gcsafe.}; \u000A           port = Port(4000); address = \"127.0.0.1\"; reuseAddr = false): AsyncScgiState",  "desc": "<p>Creates an <tt class=\"docutils literal\"><span class=\"pre\">AsyncScgiState</span></tt> object which serves as a SCGI server.</p>\u000A<p>After the execution of <tt class=\"docutils literal\"><span class=\"pre\">handleRequest</span></tt> the client socket will be closed automatically unless it has already been closed.</p>\u000A" },  { "module": "scgi",  "name": "register",  "code": "proc register*(d: Dispatcher; s: AsyncScgiState): Delegate {.discardable.}",  "desc": "Registers <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> with dispatcher <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt>." },  { "module": "scgi",  "name": "close",  "code": "proc close*(s: AsyncScgiState)",  "desc": "Closes the <tt class=\"docutils literal\"><span class=\"pre\">AsyncScgiState</span></tt>." },  { "module": "sdl",  "name": "init",  "code": "proc init*(flags: int32): int {.cdecl, importc: \"SDL_Init\", dynlib: LibName.}" },  { "module": "sdl",  "name": "initSubSystem",  "code": "proc initSubSystem*(flags: int32): int {.cdecl, importc: \"SDL_InitSubSystem\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "quitSubSystem",  "code": "proc quitSubSystem*(flags: int32) {.cdecl, importc: \"SDL_QuitSubSystem\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "wasInit",  "code": "proc wasInit*(flags: int32): int32 {.cdecl, importc: \"SDL_WasInit\", \u000A                                     dynlib: LibName.}" },  { "module": "sdl",  "name": "quit",  "code": "proc quit*() {.cdecl, importc: \"SDL_Quit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "registerApp",  "code": "proc registerApp*(name: cstring; style: int32; hInst: pointer): int {.cdecl, \u000A    importc: \"SDL_RegisterApp\", dynlib: LibName.}" },  { "module": "sdl",  "name": "tableSize",  "code": "proc tableSize*(table: cstring): int" },  { "module": "sdl",  "name": "getError",  "code": "proc getError*(): cstring {.cdecl, importc: \"SDL_GetError\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setError",  "code": "proc setError*(fmt: cstring) {.cdecl, importc: \"SDL_SetError\", dynlib: LibName.}" },  { "module": "sdl",  "name": "clearError",  "code": "proc clearError*() {.cdecl, importc: \"SDL_ClearError\", dynlib: LibName.}" },  { "module": "sdl",  "name": "error",  "code": "proc error*(Code: Terrorcode) {.cdecl, importc: \"SDL_Error\", dynlib: LibName.}" },  { "module": "sdl",  "name": "rwFromFile",  "code": "proc rwFromFile*(filename, mode: cstring): PRWops {.cdecl, \u000A    importc: \"SDL_RWFromFile\", dynlib: LibName.}" },  { "module": "sdl",  "name": "freeRW",  "code": "proc freeRW*(area: PRWops) {.cdecl, importc: \"SDL_FreeRW\", dynlib: LibName.}" },  { "module": "sdl",  "name": "rwFromFP",  "code": "proc rwFromFP*(fp: pointer; autoclose: int): PRWops {.cdecl, \u000A    importc: \"SDL_RWFromFP\", dynlib: LibName.}" },  { "module": "sdl",  "name": "rwFromMem",  "code": "proc rwFromMem*(mem: pointer; size: int): PRWops {.cdecl, \u000A    importc: \"SDL_RWFromMem\", dynlib: LibName.}" },  { "module": "sdl",  "name": "rwFromConstMem",  "code": "proc rwFromConstMem*(mem: pointer; size: int): PRWops {.cdecl, \u000A    importc: \"SDL_RWFromConstMem\", dynlib: LibName.}" },  { "module": "sdl",  "name": "allocRW",  "code": "proc allocRW*(): PRWops {.cdecl, importc: \"SDL_AllocRW\", dynlib: LibName.}" },  { "module": "sdl",  "name": "rwSeek",  "code": "proc rwSeek*(context: PRWops; offset: int; whence: int): int" },  { "module": "sdl",  "name": "rwTell",  "code": "proc rwTell*(context: PRWops): int" },  { "module": "sdl",  "name": "rwRead",  "code": "proc rwRead*(context: PRWops; theptr: pointer; size: int; n: int): int" },  { "module": "sdl",  "name": "rwWrite",  "code": "proc rwWrite*(context: PRWops; theptr: pointer; size: int; n: int): int" },  { "module": "sdl",  "name": "rwClose",  "code": "proc rwClose*(context: PRWops): int" },  { "module": "sdl",  "name": "getTicks",  "code": "proc getTicks*(): int32 {.cdecl, importc: \"SDL_GetTicks\", dynlib: LibName.}" },  { "module": "sdl",  "name": "delay",  "code": "proc delay*(msec: int32) {.cdecl, importc: \"SDL_Delay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "addTimer",  "code": "proc addTimer*(interval: int32; callback: TNewTimerCallback; param: pointer): PTimerID {.\u000A    cdecl, importc: \"SDL_AddTimer\", dynlib: LibName.}" },  { "module": "sdl",  "name": "removeTimer",  "code": "proc removeTimer*(t: PTimerID): TBool {.cdecl, importc: \"SDL_RemoveTimer\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "setTimer",  "code": "proc setTimer*(interval: int32; callback: TTimerCallback): int {.cdecl, \u000A    importc: \"SDL_SetTimer\", dynlib: LibName.}" },  { "module": "sdl",  "name": "audioInit",  "code": "proc audioInit*(driverName: cstring): int {.cdecl, importc: \"SDL_AudioInit\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "audioQuit",  "code": "proc audioQuit*() {.cdecl, importc: \"SDL_AudioQuit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "audioDriverName",  "code": "proc audioDriverName*(namebuf: cstring; maxlen: int): cstring {.cdecl, \u000A    importc: \"SDL_AudioDriverName\", dynlib: LibName.}" },  { "module": "sdl",  "name": "openAudio",  "code": "proc openAudio*(desired, obtained: PAudioSpec): int {.cdecl, \u000A    importc: \"SDL_OpenAudio\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getAudioStatus",  "code": "proc getAudioStatus*(): TAudiostatus {.cdecl, importc: \"SDL_GetAudioStatus\", \u000A                                       dynlib: LibName.}" },  { "module": "sdl",  "name": "pauseAudio",  "code": "proc pauseAudio*(pauseOn: int) {.cdecl, importc: \"SDL_PauseAudio\", \u000A                                 dynlib: LibName.}" },  { "module": "sdl",  "name": "loadWAV_RW",  "code": "proc loadWAV_RW*(src: PRWops; freesrc: int; spec: PAudioSpec; \u000A                 audioBuf: ptr byte; audiolen: PUInt32): PAudioSpec {.cdecl, \u000A    importc: \"SDL_LoadWAV_RW\", dynlib: LibName.}" },  { "module": "sdl",  "name": "loadWAV",  "code": "proc loadWAV*(filename: cstring; spec: PAudioSpec; audioBuf: ptr byte; \u000A              audiolen: PUInt32): PAudioSpec" },  { "module": "sdl",  "name": "freeWAV",  "code": "proc freeWAV*(audioBuf: ptr byte) {.cdecl, importc: \"SDL_FreeWAV\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "buildAudioCVT",  "code": "proc buildAudioCVT*(cvt: PAudioCVT; srcFormat: uint16; srcChannels: byte; \u000A                    srcRate: int; dstFormat: uint16; dstChannels: byte; \u000A                    dstRate: int): int {.cdecl, importc: \"SDL_BuildAudioCVT\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "convertAudio",  "code": "proc convertAudio*(cvt: PAudioCVT): int {.cdecl, importc: \"SDL_ConvertAudio\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "mixAudio",  "code": "proc mixAudio*(dst, src: ptr byte; length: int32; volume: int) {.cdecl, \u000A    importc: \"SDL_MixAudio\", dynlib: LibName.}" },  { "module": "sdl",  "name": "lockAudio",  "code": "proc lockAudio*() {.cdecl, importc: \"SDL_LockAudio\", dynlib: LibName.}" },  { "module": "sdl",  "name": "unlockAudio",  "code": "proc unlockAudio*() {.cdecl, importc: \"SDL_UnlockAudio\", dynlib: LibName.}" },  { "module": "sdl",  "name": "closeAudio",  "code": "proc closeAudio*() {.cdecl, importc: \"SDL_CloseAudio\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdNumDrives",  "code": "proc cdNumDrives*(): int {.cdecl, importc: \"SDL_CDNumDrives\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdName",  "code": "proc cdName*(drive: int): cstring {.cdecl, importc: \"SDL_CDName\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "cdOpen",  "code": "proc cdOpen*(drive: int): PCD {.cdecl, importc: \"SDL_CDOpen\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdStatus",  "code": "proc cdStatus*(cdrom: PCD): TCDStatus {.cdecl, importc: \"SDL_CDStatus\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "cdPlayTracks",  "code": "proc cdPlayTracks*(cdrom: PCD; startTrack: int; startFrame: int; ntracks: int; \u000A                   nframes: int): int {.cdecl, importc: \"SDL_CDPlayTracks\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "cdPlay",  "code": "proc cdPlay*(cdrom: PCD; start: int; len: int): int {.cdecl, \u000A    importc: \"SDL_CDPlay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdPause",  "code": "proc cdPause*(cdrom: PCD): int {.cdecl, importc: \"SDL_CDPause\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdResume",  "code": "proc cdResume*(cdrom: PCD): int {.cdecl, importc: \"SDL_CDResume\", \u000A                                  dynlib: LibName.}" },  { "module": "sdl",  "name": "cdStop",  "code": "proc cdStop*(cdrom: PCD): int {.cdecl, importc: \"SDL_CDStop\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdEject",  "code": "proc cdEject*(cdrom: PCD): int {.cdecl, importc: \"SDL_CDEject\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdClose",  "code": "proc cdClose*(cdrom: PCD) {.cdecl, importc: \"SDL_CDClose\", dynlib: LibName.}" },  { "module": "sdl",  "name": "cdInDrive",  "code": "proc cdInDrive*(status: TCDStatus): bool" },  { "module": "sdl",  "name": "numJoysticks",  "code": "proc numJoysticks*(): int {.cdecl, importc: \"SDL_NumJoysticks\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickName",  "code": "proc joystickName*(index: int): cstring {.cdecl, importc: \"SDL_JoystickName\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickOpen",  "code": "proc joystickOpen*(index: int): PJoystick {.cdecl, importc: \"SDL_JoystickOpen\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickOpened",  "code": "proc joystickOpened*(index: int): int {.cdecl, importc: \"SDL_JoystickOpened\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickIndex",  "code": "proc joystickIndex*(joystick: PJoystick): int {.cdecl, \u000A    importc: \"SDL_JoystickIndex\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickNumAxes",  "code": "proc joystickNumAxes*(joystick: PJoystick): int {.cdecl, \u000A    importc: \"SDL_JoystickNumAxes\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickNumBalls",  "code": "proc joystickNumBalls*(joystick: PJoystick): int {.cdecl, \u000A    importc: \"SDL_JoystickNumBalls\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickNumHats",  "code": "proc joystickNumHats*(joystick: PJoystick): int {.cdecl, \u000A    importc: \"SDL_JoystickNumHats\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickNumButtons",  "code": "proc joystickNumButtons*(joystick: PJoystick): int {.cdecl, \u000A    importc: \"SDL_JoystickNumButtons\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickUpdate",  "code": "proc joystickUpdate*() {.cdecl, importc: \"SDL_JoystickUpdate\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickEventState",  "code": "proc joystickEventState*(state: int): int {.cdecl, \u000A    importc: \"SDL_JoystickEventState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickGetAxis",  "code": "proc joystickGetAxis*(joystick: PJoystick; axis: int): int16 {.cdecl, \u000A    importc: \"SDL_JoystickGetAxis\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickGetHat",  "code": "proc joystickGetHat*(joystick: PJoystick; hat: int): byte {.cdecl, \u000A    importc: \"SDL_JoystickGetHat\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickGetBall",  "code": "proc joystickGetBall*(joystick: PJoystick; ball: int; dx: var int; dy: var int): int {.\u000A    cdecl, importc: \"SDL_JoystickGetBall\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickGetButton",  "code": "proc joystickGetButton*(joystick: PJoystick; button: int): byte {.cdecl, \u000A    importc: \"SDL_JoystickGetButton\", dynlib: LibName.}" },  { "module": "sdl",  "name": "joystickClose",  "code": "proc joystickClose*(joystick: PJoystick) {.cdecl, importc: \"SDL_JoystickClose\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "pumpEvents",  "code": "proc pumpEvents*() {.cdecl, importc: \"SDL_PumpEvents\", dynlib: LibName.}" },  { "module": "sdl",  "name": "peepEvents",  "code": "proc peepEvents*(events: PEvent; numevents: int; action: TEventAction; \u000A                 mask: int32): int {.cdecl, importc: \"SDL_PeepEvents\", \u000A                                     dynlib: LibName.}" },  { "module": "sdl",  "name": "pollEvent",  "code": "proc pollEvent*(event: PEvent): int {.cdecl, importc: \"SDL_PollEvent\", \u000A                                      dynlib: LibName.}" },  { "module": "sdl",  "name": "waitEvent",  "code": "proc waitEvent*(event: PEvent): int {.cdecl, importc: \"SDL_WaitEvent\", \u000A                                      dynlib: LibName.}" },  { "module": "sdl",  "name": "pushEvent",  "code": "proc pushEvent*(event: PEvent): int {.cdecl, importc: \"SDL_PushEvent\", \u000A                                      dynlib: LibName.}" },  { "module": "sdl",  "name": "setEventFilter",  "code": "proc setEventFilter*(filter: TEventFilter) {.cdecl, \u000A    importc: \"SDL_SetEventFilter\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getEventFilter",  "code": "proc getEventFilter*(): TEventFilter {.cdecl, importc: \"SDL_GetEventFilter\", \u000A                                       dynlib: LibName.}" },  { "module": "sdl",  "name": "eventState",  "code": "proc eventState*(theType: byte; state: int): byte {.cdecl, \u000A    importc: \"SDL_EventState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "version",  "code": "proc version*(x: var Tversion)" },  { "module": "sdl",  "name": "versionnum",  "code": "proc versionnum*(x, y, z: int): int" },  { "module": "sdl",  "name": "compiledversion",  "code": "proc compiledversion*(): int" },  { "module": "sdl",  "name": "versionAtleast",  "code": "proc versionAtleast*(x, y, z: int): bool" },  { "module": "sdl",  "name": "linkedVersion",  "code": "proc linkedVersion*(): PVersion {.cdecl, importc: \"SDL_Linked_Version\", \u000A                                  dynlib: LibName.}" },  { "module": "sdl",  "name": "videoInit",  "code": "proc videoInit*(driverName: cstring; flags: int32): int {.cdecl, \u000A    importc: \"SDL_VideoInit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "videoQuit",  "code": "proc videoQuit*() {.cdecl, importc: \"SDL_VideoQuit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "videoDriverName",  "code": "proc videoDriverName*(namebuf: cstring; maxlen: int): cstring {.cdecl, \u000A    importc: \"SDL_VideoDriverName\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getVideoSurface",  "code": "proc getVideoSurface*(): PSurface {.cdecl, importc: \"SDL_GetVideoSurface\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "getVideoInfo",  "code": "proc getVideoInfo*(): PVideoInfo {.cdecl, importc: \"SDL_GetVideoInfo\", \u000A                                   dynlib: LibName.}" },  { "module": "sdl",  "name": "videoModeOK",  "code": "proc videoModeOK*(width, height, bpp: int; flags: int32): int {.cdecl, \u000A    importc: \"SDL_VideoModeOK\", importc: \"SDL_VideoModeOK\", dynlib: LibName.}" },  { "module": "sdl",  "name": "listModes",  "code": "proc listModes*(format: PPixelFormat; flags: int32): PPSDL_Rect {.cdecl, \u000A    importc: \"SDL_ListModes\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setVideoMode",  "code": "proc setVideoMode*(width, height, bpp: int; flags: uint32): PSurface {.cdecl, \u000A    importc: \"SDL_SetVideoMode\", dynlib: LibName.}" },  { "module": "sdl",  "name": "updateRects",  "code": "proc updateRects*(screen: PSurface; numrects: int; rects: PRect) {.cdecl, \u000A    importc: \"SDL_UpdateRects\", dynlib: LibName.}" },  { "module": "sdl",  "name": "updateRect",  "code": "proc updateRect*(screen: PSurface; x, y: int32; w, h: int32) {.cdecl, \u000A    importc: \"SDL_UpdateRect\", dynlib: LibName.}" },  { "module": "sdl",  "name": "flip",  "code": "proc flip*(screen: PSurface): int {.cdecl, importc: \"SDL_Flip\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setGamma",  "code": "proc setGamma*(redgamma: float32; greengamma: float32; bluegamma: float32): int {.\u000A    cdecl, importc: \"SDL_SetGamma\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setGammaRamp",  "code": "proc setGammaRamp*(redtable: PUInt16; greentable: PUInt16; bluetable: PUInt16): int {.\u000A    cdecl, importc: \"SDL_SetGammaRamp\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getGammaRamp",  "code": "proc getGammaRamp*(redtable: PUInt16; greentable: PUInt16; bluetable: PUInt16): int {.\u000A    cdecl, importc: \"SDL_GetGammaRamp\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setColors",  "code": "proc setColors*(surface: PSurface; colors: PColor; firstcolor: int; ncolors: int): int {.\u000A    cdecl, importc: \"SDL_SetColors\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setPalette",  "code": "proc setPalette*(surface: PSurface; flags: int; colors: PColor; firstcolor: int; \u000A                 ncolors: int): int {.cdecl, importc: \"SDL_SetPalette\", \u000A                                      dynlib: LibName.}" },  { "module": "sdl",  "name": "mapRGB",  "code": "proc mapRGB*(format: PPixelFormat; r: byte; g: byte; b: byte): int32 {.cdecl, \u000A    importc: \"SDL_MapRGB\", dynlib: LibName.}" },  { "module": "sdl",  "name": "mapRGBA",  "code": "proc mapRGBA*(format: PPixelFormat; r: byte; g: byte; b: byte; a: byte): int32 {.\u000A    cdecl, importc: \"SDL_MapRGBA\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getRGB",  "code": "proc getRGB*(pixel: int32; fmt: PPixelFormat; r: ptr byte; g: ptr byte; \u000A             b: ptr byte) {.cdecl, importc: \"SDL_GetRGB\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getRGBA",  "code": "proc getRGBA*(pixel: int32; fmt: PPixelFormat; r: ptr byte; g: ptr byte; \u000A              b: ptr byte; a: ptr byte) {.cdecl, importc: \"SDL_GetRGBA\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "allocSurface",  "code": "proc allocSurface*(flags: int32; width, height, depth: int; \u000A                   rMask, gMask, bMask, aMask: int32): PSurface" },  { "module": "sdl",  "name": "createRGBSurface",  "code": "proc createRGBSurface*(flags: int32; width, height, depth: int; \u000A                       rMask, gMask, bMask, aMask: int32): PSurface {.cdecl, \u000A    importc: \"SDL_CreateRGBSurface\", dynlib: LibName.}" },  { "module": "sdl",  "name": "createRGBSurfaceFrom",  "code": "proc createRGBSurfaceFrom*(pixels: pointer; width, height, depth, pitch: int; \u000A                           rMask, gMask, bMask, aMask: int32): PSurface {.cdecl, \u000A    importc: \"SDL_CreateRGBSurfaceFrom\", dynlib: LibName.}" },  { "module": "sdl",  "name": "freeSurface",  "code": "proc freeSurface*(surface: PSurface) {.cdecl, importc: \"SDL_FreeSurface\", \u000A                                       dynlib: LibName.}" },  { "module": "sdl",  "name": "mustLock",  "code": "proc mustLock*(surface: PSurface): bool" },  { "module": "sdl",  "name": "lockSurface",  "code": "proc lockSurface*(surface: PSurface): int {.cdecl, importc: \"SDL_LockSurface\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "unlockSurface",  "code": "proc unlockSurface*(surface: PSurface) {.cdecl, importc: \"SDL_UnlockSurface\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "loadBMP_RW",  "code": "proc loadBMP_RW*(src: PRWops; freesrc: int): PSurface {.cdecl, \u000A    importc: \"SDL_LoadBMP_RW\", dynlib: LibName.}" },  { "module": "sdl",  "name": "loadBMP",  "code": "proc loadBMP*(filename: cstring): PSurface" },  { "module": "sdl",  "name": "saveBMP_RW",  "code": "proc saveBMP_RW*(surface: PSurface; dst: PRWops; freedst: int): int {.cdecl, \u000A    importc: \"SDL_SaveBMP_RW\", dynlib: LibName.}" },  { "module": "sdl",  "name": "saveBMP",  "code": "proc saveBMP*(surface: PSurface; filename: cstring): int" },  { "module": "sdl",  "name": "setColorKey",  "code": "proc setColorKey*(surface: PSurface; flag, key: int32): int {.cdecl, \u000A    importc: \"SDL_SetColorKey\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setAlpha",  "code": "proc setAlpha*(surface: PSurface; flag: int32; alpha: byte): int {.cdecl, \u000A    importc: \"SDL_SetAlpha\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setClipRect",  "code": "proc setClipRect*(surface: PSurface; rect: PRect) {.cdecl, \u000A    importc: \"SDL_SetClipRect\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getClipRect",  "code": "proc getClipRect*(surface: PSurface; rect: PRect) {.cdecl, \u000A    importc: \"SDL_GetClipRect\", dynlib: LibName.}" },  { "module": "sdl",  "name": "convertSurface",  "code": "proc convertSurface*(src: PSurface; fmt: PPixelFormat; flags: int32): PSurface {.\u000A    cdecl, importc: \"SDL_ConvertSurface\", dynlib: LibName.}" },  { "module": "sdl",  "name": "blitSurface",  "code": "proc blitSurface*(src: PSurface; srcrect: PRect; dst: PSurface; dstrect: PRect): int" },  { "module": "sdl",  "name": "upperBlit",  "code": "proc upperBlit*(src: PSurface; srcrect: PRect; dst: PSurface; dstrect: PRect): int {.\u000A    cdecl, importc: \"SDL_UpperBlit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "lowerBlit",  "code": "proc lowerBlit*(src: PSurface; srcrect: PRect; dst: PSurface; dstrect: PRect): int {.\u000A    cdecl, importc: \"SDL_LowerBlit\", dynlib: LibName.}" },  { "module": "sdl",  "name": "fillRect",  "code": "proc fillRect*(dst: PSurface; dstrect: PRect; color: int32): int {.cdecl, \u000A    importc: \"SDL_FillRect\", dynlib: LibName.}" },  { "module": "sdl",  "name": "displayFormat",  "code": "proc displayFormat*(surface: PSurface): PSurface {.cdecl, \u000A    importc: \"SDL_DisplayFormat\", dynlib: LibName.}" },  { "module": "sdl",  "name": "displayFormatAlpha",  "code": "proc displayFormatAlpha*(surface: PSurface): PSurface {.cdecl, \u000A    importc: \"SDL_DisplayFormatAlpha\", dynlib: LibName.}" },  { "module": "sdl",  "name": "createYUVOverlay",  "code": "proc createYUVOverlay*(width: int; height: int; format: int32; display: PSurface): POverlay {.\u000A    cdecl, importc: \"SDL_CreateYUVOverlay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "lockYUVOverlay",  "code": "proc lockYUVOverlay*(overlay: POverlay): int {.cdecl, \u000A    importc: \"SDL_LockYUVOverlay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "unlockYUVOverlay",  "code": "proc unlockYUVOverlay*(overlay: POverlay) {.cdecl, \u000A    importc: \"SDL_UnlockYUVOverlay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "displayYUVOverlay",  "code": "proc displayYUVOverlay*(overlay: POverlay; dstrect: PRect): int {.cdecl, \u000A    importc: \"SDL_DisplayYUVOverlay\", dynlib: LibName.}" },  { "module": "sdl",  "name": "freeYUVOverlay",  "code": "proc freeYUVOverlay*(overlay: POverlay) {.cdecl, importc: \"SDL_FreeYUVOverlay\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "glLoadLibrary",  "code": "proc glLoadLibrary*(filename: cstring): int {.cdecl, \u000A    importc: \"SDL_GL_LoadLibrary\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glGetProcAddress",  "code": "proc glGetProcAddress*(procname: cstring): pointer {.cdecl, \u000A    importc: \"SDL_GL_GetProcAddress\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glSetAttribute",  "code": "proc glSetAttribute*(attr: TGLAttr; value: int): int {.cdecl, \u000A    importc: \"SDL_GL_SetAttribute\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glGetAttribute",  "code": "proc glGetAttribute*(attr: TGLAttr; value: var int): int {.cdecl, \u000A    importc: \"SDL_GL_GetAttribute\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glSwapBuffers",  "code": "proc glSwapBuffers*() {.cdecl, importc: \"SDL_GL_SwapBuffers\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glUpdateRects",  "code": "proc glUpdateRects*(numrects: int; rects: PRect) {.cdecl, \u000A    importc: \"SDL_GL_UpdateRects\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glLock",  "code": "proc glLock*() {.cdecl, importc: \"SDL_GL_Lock\", dynlib: LibName.}" },  { "module": "sdl",  "name": "glUnlock",  "code": "proc glUnlock*() {.cdecl, importc: \"SDL_GL_Unlock\", dynlib: LibName.}" },  { "module": "sdl",  "name": "wmGetCaption",  "code": "proc wmGetCaption*(title: var cstring; icon: var cstring) {.cdecl, \u000A    importc: \"SDL_WM_GetCaption\", dynlib: LibName.}" },  { "module": "sdl",  "name": "wmSetCaption",  "code": "proc wmSetCaption*(title: cstring; icon: cstring) {.cdecl, \u000A    importc: \"SDL_WM_SetCaption\", dynlib: LibName.}" },  { "module": "sdl",  "name": "wmSetIcon",  "code": "proc wmSetIcon*(icon: PSurface; mask: byte) {.cdecl, importc: \"SDL_WM_SetIcon\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "wmIconifyWindow",  "code": "proc wmIconifyWindow*(): int {.cdecl, importc: \"SDL_WM_IconifyWindow\", \u000A                               dynlib: LibName.}" },  { "module": "sdl",  "name": "wmToggleFullScreen",  "code": "proc wmToggleFullScreen*(surface: PSurface): int {.cdecl, \u000A    importc: \"SDL_WM_ToggleFullScreen\", dynlib: LibName.}" },  { "module": "sdl",  "name": "wmGrabInput",  "code": "proc wmGrabInput*(mode: TGrabMode): TGrabMode {.cdecl, \u000A    importc: \"SDL_WM_GrabInput\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getMouseState",  "code": "proc getMouseState*(x: var int; y: var int): byte {.cdecl, \u000A    importc: \"SDL_GetMouseState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getRelativeMouseState",  "code": "proc getRelativeMouseState*(x: var int; y: var int): byte {.cdecl, \u000A    importc: \"SDL_GetRelativeMouseState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "warpMouse",  "code": "proc warpMouse*(x, y: uint16) {.cdecl, importc: \"SDL_WarpMouse\", dynlib: LibName.}" },  { "module": "sdl",  "name": "createCursor",  "code": "proc createCursor*(data, mask: ptr byte; w, h, hotX, hotY: int): PCursor {.\u000A    cdecl, importc: \"SDL_CreateCursor\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setCursor",  "code": "proc setCursor*(cursor: PCursor) {.cdecl, importc: \"SDL_SetCursor\", \u000A                                   dynlib: LibName.}" },  { "module": "sdl",  "name": "getCursor",  "code": "proc getCursor*(): PCursor {.cdecl, importc: \"SDL_GetCursor\", dynlib: LibName.}" },  { "module": "sdl",  "name": "freeCursor",  "code": "proc freeCursor*(cursor: PCursor) {.cdecl, importc: \"SDL_FreeCursor\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "showCursor",  "code": "proc showCursor*(toggle: int): int {.cdecl, importc: \"SDL_ShowCursor\", \u000A                                     dynlib: LibName.}" },  { "module": "sdl",  "name": "button",  "code": "proc button*(b: int): int" },  { "module": "sdl",  "name": "enableUNICODE",  "code": "proc enableUNICODE*(enable: int): int {.cdecl, importc: \"SDL_EnableUNICODE\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "enableKeyRepeat",  "code": "proc enableKeyRepeat*(delay: int; interval: int): int {.cdecl, \u000A    importc: \"SDL_EnableKeyRepeat\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getKeyRepeat",  "code": "proc getKeyRepeat*(delay: PInteger; interval: PInteger) {.cdecl, \u000A    importc: \"SDL_GetKeyRepeat\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getKeyState",  "code": "proc getKeyState*(numkeys: pointer): ptr byte {.cdecl, \u000A    importc: \"SDL_GetKeyState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getModState",  "code": "proc getModState*(): TMod {.cdecl, importc: \"SDL_GetModState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "setModState",  "code": "proc setModState*(modstate: TMod) {.cdecl, importc: \"SDL_SetModState\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "getKeyName",  "code": "proc getKeyName*(key: TKey): cstring {.cdecl, importc: \"SDL_GetKeyName\", \u000A                                       dynlib: LibName.}" },  { "module": "sdl",  "name": "getAppState",  "code": "proc getAppState*(): byte {.cdecl, importc: \"SDL_GetAppState\", dynlib: LibName.}" },  { "module": "sdl",  "name": "createMutex",  "code": "proc createMutex*(): PMutex {.cdecl, importc: \"SDL_CreateMutex\", dynlib: LibName.}" },  { "module": "sdl",  "name": "mutexP",  "code": "proc mutexP*(mutex: PMutex): int {.cdecl, importc: \"SDL_mutexP\", dynlib: LibName.}" },  { "module": "sdl",  "name": "lockMutex",  "code": "proc lockMutex*(mutex: PMutex): int" },  { "module": "sdl",  "name": "mutexV",  "code": "proc mutexV*(mutex: PMutex): int {.cdecl, importc: \"SDL_mutexV\", dynlib: LibName.}" },  { "module": "sdl",  "name": "unlockMutex",  "code": "proc unlockMutex*(mutex: PMutex): int" },  { "module": "sdl",  "name": "destroyMutex",  "code": "proc destroyMutex*(mutex: PMutex) {.cdecl, importc: \"SDL_DestroyMutex\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "createSemaphore",  "code": "proc createSemaphore*(initialValue: int32): PSem {.cdecl, \u000A    importc: \"SDL_CreateSemaphore\", dynlib: LibName.}" },  { "module": "sdl",  "name": "destroySemaphore",  "code": "proc destroySemaphore*(sem: PSem) {.cdecl, importc: \"SDL_DestroySemaphore\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "semWait",  "code": "proc semWait*(sem: PSem): int {.cdecl, importc: \"SDL_SemWait\", dynlib: LibName.}" },  { "module": "sdl",  "name": "semTryWait",  "code": "proc semTryWait*(sem: PSem): int {.cdecl, importc: \"SDL_SemTryWait\", \u000A                                   dynlib: LibName.}" },  { "module": "sdl",  "name": "semWaitTimeout",  "code": "proc semWaitTimeout*(sem: PSem; ms: int32): int {.cdecl, \u000A    importc: \"SDL_SemWaitTimeout\", dynlib: LibName.}" },  { "module": "sdl",  "name": "semPost",  "code": "proc semPost*(sem: PSem): int {.cdecl, importc: \"SDL_SemPost\", dynlib: LibName.}" },  { "module": "sdl",  "name": "semValue",  "code": "proc semValue*(sem: PSem): int32 {.cdecl, importc: \"SDL_SemValue\", \u000A                                   dynlib: LibName.}" },  { "module": "sdl",  "name": "createCond",  "code": "proc createCond*(): PCond {.cdecl, importc: \"SDL_CreateCond\", dynlib: LibName.}" },  { "module": "sdl",  "name": "destroyCond",  "code": "proc destroyCond*(cond: PCond) {.cdecl, importc: \"SDL_DestroyCond\", \u000A                                 dynlib: LibName.}" },  { "module": "sdl",  "name": "condSignal",  "code": "proc condSignal*(cond: PCond): int {.cdecl, importc: \"SDL_CondSignal\", \u000A                                     dynlib: LibName.}" },  { "module": "sdl",  "name": "condBroadcast",  "code": "proc condBroadcast*(cond: PCond): int {.cdecl, importc: \"SDL_CondBroadcast\", \u000A                                        dynlib: LibName.}" },  { "module": "sdl",  "name": "condWait",  "code": "proc condWait*(cond: PCond; mut: PMutex): int {.cdecl, importc: \"SDL_CondWait\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "condWaitTimeout",  "code": "proc condWaitTimeout*(cond: PCond; mut: PMutex; ms: int32): int {.cdecl, \u000A    importc: \"SDL_CondWaitTimeout\", dynlib: LibName.}" },  { "module": "sdl",  "name": "createThread",  "code": "proc createThread*(fn, data: pointer): PThread {.cdecl, \u000A    importc: \"SDL_CreateThread\", dynlib: LibName.}" },  { "module": "sdl",  "name": "threadID",  "code": "proc threadID*(): int32 {.cdecl, importc: \"SDL_ThreadID\", dynlib: LibName.}" },  { "module": "sdl",  "name": "getThreadID",  "code": "proc getThreadID*(thread: PThread): int32 {.cdecl, importc: \"SDL_GetThreadID\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "waitThread",  "code": "proc waitThread*(thread: PThread; status: var int) {.cdecl, \u000A    importc: \"SDL_WaitThread\", dynlib: LibName.}" },  { "module": "sdl",  "name": "killThread",  "code": "proc killThread*(thread: PThread) {.cdecl, importc: \"SDL_KillThread\", \u000A                                    dynlib: LibName.}" },  { "module": "sdl",  "name": "getWMInfo",  "code": "proc getWMInfo*(info: PSysWMinfo): int {.cdecl, importc: \"SDL_GetWMInfo\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "loadObject",  "code": "proc loadObject*(sofile: cstring): pointer {.cdecl, importc: \"SDL_LoadObject\", \u000A    dynlib: LibName.}" },  { "module": "sdl",  "name": "loadFunction",  "code": "proc loadFunction*(handle: pointer; name: cstring): pointer {.cdecl, \u000A    importc: \"SDL_LoadFunction\", dynlib: LibName.}" },  { "module": "sdl",  "name": "unloadObject",  "code": "proc unloadObject*(handle: pointer) {.cdecl, importc: \"SDL_UnloadObject\", \u000A                                      dynlib: LibName.}" },  { "module": "sdl",  "name": "swap32",  "code": "proc swap32*(d: int32): int32" },  { "module": "sdl",  "name": "isBitOn",  "code": "proc isBitOn*(value: int; bit: int8): bool" },  { "module": "sdl",  "name": "turnBitOn",  "code": "proc turnBitOn*(value: int; bit: int8): int" },  { "module": "sdl",  "name": "turnBitOff",  "code": "proc turnBitOff*(value: int; bit: int8): int" },  { "module": "sdl",  "name": "framesToMsf",  "code": "proc framesToMsf*(frames: int; m, s, f: var int)" },  { "module": "sdl",  "name": "msfToFrames",  "code": "proc msfToFrames*(m, s, f: int): int" },  { "module": "sdl_gfx",  "name": "initFramerate",  "code": "proc initFramerate*(manager: PFPSmanager) {.cdecl, importc: \"SDL_initFramerate\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "setFramerate",  "code": "proc setFramerate*(manager: PFPSmanager; rate: cint): cint {.cdecl, \u000A    importc: \"SDL_setFramerate\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "getFramerate",  "code": "proc getFramerate*(manager: PFPSmanager): cint {.cdecl, \u000A    importc: \"SDL_getFramerate\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "framerateDelay",  "code": "proc framerateDelay*(manager: PFPSmanager) {.cdecl, \u000A    importc: \"SDL_framerateDelay\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "pixelColor",  "code": "proc pixelColor*(dst: PSurface; x: int16; y: int16; color: uint32): cint {.\u000A    cdecl, importc: \"pixelColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "pixelRGBA",  "code": "proc pixelRGBA*(dst: PSurface; x: int16; y: int16; r: byte; g: byte; b: byte; \u000A                a: byte): cint {.cdecl, importc: \"pixelRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "hlineColor",  "code": "proc hlineColor*(dst: PSurface; x1: int16; x2: int16; y: int16; color: uint32): cint {.\u000A    cdecl, importc: \"hlineColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "hlineRGBA",  "code": "proc hlineRGBA*(dst: PSurface; x1: int16; x2: int16; y: int16; r: byte; g: byte; \u000A                b: byte; a: byte): cint {.cdecl, importc: \"hlineRGBA\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "vlineColor",  "code": "proc vlineColor*(dst: PSurface; x: int16; y1: int16; y2: int16; color: uint32): cint {.\u000A    cdecl, importc: \"vlineColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "vlineRGBA",  "code": "proc vlineRGBA*(dst: PSurface; x: int16; y1: int16; y2: int16; r: byte; g: byte; \u000A                b: byte; a: byte): cint {.cdecl, importc: \"vlineRGBA\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rectangleColor",  "code": "proc rectangleColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                     color: uint32): cint {.cdecl, importc: \"rectangleColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rectangleRGBA",  "code": "proc rectangleRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                    r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"rectangleRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "boxColor",  "code": "proc boxColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A               color: uint32): cint {.cdecl, importc: \"boxColor\", \u000A                                      dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "boxRGBA",  "code": "proc boxRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A              r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"boxRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "lineColor",  "code": "proc lineColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                color: uint32): cint {.cdecl, importc: \"lineColor\", \u000A                                       dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "lineRGBA",  "code": "proc lineRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A               r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"lineRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aalineColor",  "code": "proc aalineColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                  color: uint32): cint {.cdecl, importc: \"aalineColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aalineRGBA",  "code": "proc aalineRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                 r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"aalineRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "circleColor",  "code": "proc circleColor*(dst: PSurface; x: int16; y: int16; r: int16; color: uint32): cint {.\u000A    cdecl, importc: \"circleColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "circleRGBA",  "code": "proc circleRGBA*(dst: PSurface; x: int16; y: int16; rad: int16; r: byte; \u000A                 g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"circleRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aacircleColor",  "code": "proc aacircleColor*(dst: PSurface; x: int16; y: int16; r: int16; color: uint32): cint {.\u000A    cdecl, importc: \"aacircleColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aacircleRGBA",  "code": "proc aacircleRGBA*(dst: PSurface; x: int16; y: int16; rad: int16; r: byte; \u000A                   g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"aacircleRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledCircleColor",  "code": "proc filledCircleColor*(dst: PSurface; x: int16; y: int16; r: int16; \u000A                        color: uint32): cint {.cdecl, \u000A    importc: \"filledCircleColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledCircleRGBA",  "code": "proc filledCircleRGBA*(dst: PSurface; x: int16; y: int16; rad: int16; r: byte; \u000A                       g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"filledCircleRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "ellipseColor",  "code": "proc ellipseColor*(dst: PSurface; x: int16; y: int16; rx: int16; ry: int16; \u000A                   color: uint32): cint {.cdecl, importc: \"ellipseColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "ellipseRGBA",  "code": "proc ellipseRGBA*(dst: PSurface; x: int16; y: int16; rx: int16; ry: int16; \u000A                  r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"ellipseRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aaellipseColor",  "code": "proc aaellipseColor*(dst: PSurface; xc: int16; yc: int16; rx: int16; ry: int16; \u000A                     color: uint32): cint {.cdecl, importc: \"aaellipseColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aaellipseRGBA",  "code": "proc aaellipseRGBA*(dst: PSurface; x: int16; y: int16; rx: int16; ry: int16; \u000A                    r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"aaellipseRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledEllipseColor",  "code": "proc filledEllipseColor*(dst: PSurface; x: int16; y: int16; rx: int16; \u000A                         ry: int16; color: uint32): cint {.cdecl, \u000A    importc: \"filledEllipseColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledEllipseRGBA",  "code": "proc filledEllipseRGBA*(dst: PSurface; x: int16; y: int16; rx: int16; ry: int16; \u000A                        r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"filledEllipseRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "pieColor",  "code": "proc pieColor*(dst: PSurface; x: int16; y: int16; rad: int16; start: int16; \u000A               finish: int16; color: uint32): cint {.cdecl, importc: \"pieColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "pieRGBA",  "code": "proc pieRGBA*(dst: PSurface; x: int16; y: int16; rad: int16; start: int16; \u000A              finish: int16; r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"pieRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledPieColor",  "code": "proc filledPieColor*(dst: PSurface; x: int16; y: int16; rad: int16; \u000A                     start: int16; finish: int16; color: uint32): cint {.cdecl, \u000A    importc: \"filledPieColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledPieRGBA",  "code": "proc filledPieRGBA*(dst: PSurface; x: int16; y: int16; rad: int16; start: int16; \u000A                    finish: int16; r: byte; g: byte; b: byte; a: byte): cint {.\u000A    cdecl, importc: \"filledPieRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "trigonColor",  "code": "proc trigonColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                  x3: int16; y3: int16; color: uint32): cint {.cdecl, \u000A    importc: \"trigonColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "trigonRGBA",  "code": "proc trigonRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                 x3: int16; y3: int16; r: byte; g: byte; b: byte; a: byte): cint {.\u000A    cdecl, importc: \"trigonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aatrigonColor",  "code": "proc aatrigonColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                    x3: int16; y3: int16; color: uint32): cint {.cdecl, \u000A    importc: \"aatrigonColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aatrigonRGBA",  "code": "proc aatrigonRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; y2: int16; \u000A                   x3: int16; y3: int16; r: byte; g: byte; b: byte; a: byte): cint {.\u000A    cdecl, importc: \"aatrigonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledTrigonColor",  "code": "proc filledTrigonColor*(dst: PSurface; x1: int16; y1: int16; x2: int16; \u000A                        y2: int16; x3: int16; y3: int16; color: uint32): cint {.\u000A    cdecl, importc: \"filledTrigonColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledTrigonRGBA",  "code": "proc filledTrigonRGBA*(dst: PSurface; x1: int16; y1: int16; x2: int16; \u000A                       y2: int16; x3: int16; y3: int16; r: byte; g: byte; \u000A                       b: byte; a: byte): cint {.cdecl, \u000A    importc: \"filledTrigonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "polygonColor",  "code": "proc polygonColor*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; \u000A                   color: uint32): cint {.cdecl, importc: \"polygonColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "polygonRGBA",  "code": "proc polygonRGBA*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; r: byte; \u000A                  g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"polygonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aapolygonColor",  "code": "proc aapolygonColor*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; \u000A                     color: uint32): cint {.cdecl, importc: \"aapolygonColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "aapolygonRGBA",  "code": "proc aapolygonRGBA*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; \u000A                    r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"aapolygonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledPolygonColor",  "code": "proc filledPolygonColor*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; \u000A                         color: uint32): cint {.cdecl, \u000A    importc: \"filledPolygonColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "filledPolygonRGBA",  "code": "proc filledPolygonRGBA*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; \u000A                        r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"filledPolygonRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "bezierColor",  "code": "proc bezierColor*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; s: cint; \u000A                  color: uint32): cint {.cdecl, importc: \"bezierColor\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "bezierRGBA",  "code": "proc bezierRGBA*(dst: PSurface; vx: ptr int16; vy: ptr int16; n: cint; s: cint; \u000A                 r: byte; g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"bezierRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "characterColor",  "code": "proc characterColor*(dst: PSurface; x: int16; y: int16; c: char; color: uint32): cint {.\u000A    cdecl, importc: \"characterColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "characterRGBA",  "code": "proc characterRGBA*(dst: PSurface; x: int16; y: int16; c: char; r: byte; \u000A                    g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"characterRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "stringColor",  "code": "proc stringColor*(dst: PSurface; x: int16; y: int16; c: cstring; color: uint32): cint {.\u000A    cdecl, importc: \"stringColor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "stringRGBA",  "code": "proc stringRGBA*(dst: PSurface; x: int16; y: int16; c: cstring; r: byte; \u000A                 g: byte; b: byte; a: byte): cint {.cdecl, \u000A    importc: \"stringRGBA\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "gfxPrimitivesSetFont",  "code": "proc gfxPrimitivesSetFont*(fontdata: pointer; cw: cint; ch: cint) {.cdecl, \u000A    importc: \"gfxPrimitivesSetFont\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMMXdetect",  "code": "proc imageFilterMMXdetect*(): cint {.cdecl, importc: \"SDL_imageFilterMMXdetect\", \u000A                                     dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMMXoff",  "code": "proc imageFilterMMXoff*() {.cdecl, importc: \"SDL_imageFilterMMXoff\", \u000A                            dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMMXon",  "code": "proc imageFilterMMXon*() {.cdecl, importc: \"SDL_imageFilterMMXon\", \u000A                           dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAdd",  "code": "proc imageFilterAdd*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterAdd\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMean",  "code": "proc imageFilterMean*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterMean\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterSub",  "code": "proc imageFilterSub*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterSub\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAbsDiff",  "code": "proc imageFilterAbsDiff*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterAbsDiff\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMult",  "code": "proc imageFilterMult*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterMult\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMultNor",  "code": "proc imageFilterMultNor*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterMultNor\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMultDivby2",  "code": "proc imageFilterMultDivby2*(src1: cstring; src2: cstring; dest: cstring; \u000A                            len: cint): cint {.cdecl, \u000A    importc: \"SDL_imageFilterMultDivby2\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMultDivby4",  "code": "proc imageFilterMultDivby4*(src1: cstring; src2: cstring; dest: cstring; \u000A                            len: cint): cint {.cdecl, \u000A    importc: \"SDL_imageFilterMultDivby4\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterBitAnd",  "code": "proc imageFilterBitAnd*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterBitAnd\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterBitOr",  "code": "proc imageFilterBitOr*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterBitOr\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterDiv",  "code": "proc imageFilterDiv*(src1: cstring; src2: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterDiv\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterBitNegation",  "code": "proc imageFilterBitNegation*(src1: cstring; dest: cstring; len: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterBitNegation\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAddByte",  "code": "proc imageFilterAddByte*(src1: cstring; dest: cstring; len: cint; c: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterAddByte\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAddUint",  "code": "proc imageFilterAddUint*(src1: cstring; dest: cstring; len: cint; c: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterAddUint\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAddByteToHalf",  "code": "proc imageFilterAddByteToHalf*(src1: cstring; dest: cstring; len: cint; c: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterAddByteToHalf\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterSubByte",  "code": "proc imageFilterSubByte*(src1: cstring; dest: cstring; len: cint; c: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterSubByte\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterSubUint",  "code": "proc imageFilterSubUint*(src1: cstring; dest: cstring; len: cint; c: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterSubUint\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftRight",  "code": "proc imageFilterShiftRight*(src1: cstring; dest: cstring; len: cint; n: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterShiftRight\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftRightUint",  "code": "proc imageFilterShiftRightUint*(src1: cstring; dest: cstring; len: cint; n: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterShiftRightUint\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterMultByByte",  "code": "proc imageFilterMultByByte*(src1: cstring; dest: cstring; len: cint; c: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterMultByByte\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftRightAndMultByByte",  "code": "proc imageFilterShiftRightAndMultByByte*(src1: cstring; dest: cstring; \u000A    len: cint; n: char; c: char): cint {.cdecl, \u000A    importc: \"SDL_imageFilterShiftRightAndMultByByte\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftLeftByte",  "code": "proc imageFilterShiftLeftByte*(src1: cstring; dest: cstring; len: cint; n: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterShiftLeftByte\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftLeftUint",  "code": "proc imageFilterShiftLeftUint*(src1: cstring; dest: cstring; len: cint; n: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterShiftLeftUint\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterShiftLeft",  "code": "proc imageFilterShiftLeft*(src1: cstring; dest: cstring; len: cint; n: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterShiftLeft\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterBinarizeUsingThreshold",  "code": "proc imageFilterBinarizeUsingThreshold*(src1: cstring; dest: cstring; len: cint; \u000A                                        t: char): cint {.cdecl, \u000A    importc: \"SDL_imageFilterBinarizeUsingThreshold\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterClipToRange",  "code": "proc imageFilterClipToRange*(src1: cstring; dest: cstring; len: cint; \u000A                             tmin: int8; tmax: int8): cint {.cdecl, \u000A    importc: \"SDL_imageFilterClipToRange\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterNormalizeLinear",  "code": "proc imageFilterNormalizeLinear*(src1: cstring; dest: cstring; len: cint; \u000A                                 cmin: cint; cmax: cint; nmin: cint; nmax: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterNormalizeLinear\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel3x3Divide",  "code": "proc imageFilterConvolveKernel3x3Divide*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; divisor: int8): cint {.cdecl, \u000A    importc: \"SDL_imageFilterConvolveKernel3x3Divide\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel5x5Divide",  "code": "proc imageFilterConvolveKernel5x5Divide*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; divisor: int8): cint {.cdecl, \u000A    importc: \"SDL_imageFilterConvolveKernel5x5Divide\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel7x7Divide",  "code": "proc imageFilterConvolveKernel7x7Divide*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; divisor: int8): cint {.cdecl, \u000A    importc: \"SDL_imageFilterConvolveKernel7x7Divide\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel9x9Divide",  "code": "proc imageFilterConvolveKernel9x9Divide*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; divisor: int8): cint {.cdecl, \u000A    importc: \"SDL_imageFilterConvolveKernel9x9Divide\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel3x3ShiftRight",  "code": "proc imageFilterConvolveKernel3x3ShiftRight*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; nRightShift: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterConvolveKernel3x3ShiftRight\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel5x5ShiftRight",  "code": "proc imageFilterConvolveKernel5x5ShiftRight*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; nRightShift: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterConvolveKernel5x5ShiftRight\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel7x7ShiftRight",  "code": "proc imageFilterConvolveKernel7x7ShiftRight*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; nRightShift: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterConvolveKernel7x7ShiftRight\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterConvolveKernel9x9ShiftRight",  "code": "proc imageFilterConvolveKernel9x9ShiftRight*(src: cstring; dest: cstring; \u000A    rows: cint; columns: cint; kernel: pointer; nRightShift: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterConvolveKernel9x9ShiftRight\", \u000A    dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterSobelX",  "code": "proc imageFilterSobelX*(src: cstring; dest: cstring; rows: cint; columns: cint): cint {.\u000A    cdecl, importc: \"SDL_imageFilterSobelX\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterSobelXShiftRight",  "code": "proc imageFilterSobelXShiftRight*(src: cstring; dest: cstring; rows: cint; \u000A                                  columns: cint; nRightShift: char): cint {.\u000A    cdecl, importc: \"SDL_imageFilterSobelXShiftRight\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterAlignStack",  "code": "proc imageFilterAlignStack*() {.cdecl, importc: \"SDL_imageFilterAlignStack\", \u000A                                dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "imageFilterRestoreStack",  "code": "proc imageFilterRestoreStack*() {.cdecl, importc: \"SDL_imageFilterRestoreStack\", \u000A                                  dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rotozoomSurface",  "code": "proc rotozoomSurface*(src: PSurface; angle: float64; zoom: float64; smooth: cint): PSurface {.\u000A    cdecl, importc: \"rotozoomSurface\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rotozoomSurfaceXY",  "code": "proc rotozoomSurfaceXY*(src: PSurface; angle: float64; zoomx: float64; \u000A                        zoomy: float64; smooth: cint): PSurface {.cdecl, \u000A    importc: \"rotozoomSurfaceXY\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rotozoomSurfaceSize",  "code": "proc rotozoomSurfaceSize*(width: cint; height: cint; angle: float64; \u000A                          zoom: float64; dstwidth: var cint; dstheight: var cint) {.\u000A    cdecl, importc: \"rotozoomSurfaceSize\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "rotozoomSurfaceSizeXY",  "code": "proc rotozoomSurfaceSizeXY*(width: cint; height: cint; angle: float64; \u000A                            zoomx: float64; zoomy: float64; dstwidth: var cint; \u000A                            dstheight: var cint) {.cdecl, \u000A    importc: \"rotozoomSurfaceSizeXY\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "zoomSurface",  "code": "proc zoomSurface*(src: PSurface; zoomx: float64; zoomy: float64; smooth: cint): PSurface {.\u000A    cdecl, importc: \"zoomSurface\", dynlib: gfxLibName.}" },  { "module": "sdl_gfx",  "name": "zoomSurfaceSize",  "code": "proc zoomSurfaceSize*(width: cint; height: cint; zoomx: float64; zoomy: float64; \u000A                      dstwidth: var cint; dstheight: var cint) {.cdecl, \u000A    importc: \"zoomSurfaceSize\", dynlib: gfxLibName.}" },  { "module": "sdl_image",  "name": "imageVersion",  "code": "proc imageVersion*(x: var Tversion)" },  { "module": "sdl_image",  "name": "imgLinkedVersion",  "code": "proc imgLinkedVersion*(): Pversion {.importc: \"IMG_Linked_Version\", \u000A                                     dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgInit",  "code": "proc imgInit*(flags: cint): int {.cdecl, importc: \"IMG_Init\", \u000A                                  dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgQuit",  "code": "proc imgQuit*() {.cdecl, importc: \"IMG_Quit\", dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadTypedRW",  "code": "proc imgLoadTypedRW*(src: PRWops; freesrc: cint; theType: cstring): PSurface {.\u000A    cdecl, importc: \"IMG_LoadTyped_RW\", dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoad",  "code": "proc imgLoad*(theFile: cstring): PSurface {.cdecl, importc: \"IMG_Load\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadRW",  "code": "proc imgLoadRW*(src: PRWops; freesrc: cint): PSurface {.cdecl, \u000A    importc: \"IMG_Load_RW\", dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgInvertAlpha",  "code": "proc imgInvertAlpha*(theOn: cint): cint {.cdecl, importc: \"IMG_InvertAlpha\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsBMP",  "code": "proc imgIsBMP*(src: PRWops): cint {.cdecl, importc: \"IMG_isBMP\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsGIF",  "code": "proc imgIsGIF*(src: PRWops): cint {.cdecl, importc: \"IMG_isGIF\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsJPG",  "code": "proc imgIsJPG*(src: PRWops): cint {.cdecl, importc: \"IMG_isJPG\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsLBM",  "code": "proc imgIsLBM*(src: PRWops): cint {.cdecl, importc: \"IMG_isLBM\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsPCX",  "code": "proc imgIsPCX*(src: PRWops): cint {.cdecl, importc: \"IMG_isPCX\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsPNG",  "code": "proc imgIsPNG*(src: PRWops): cint {.cdecl, importc: \"IMG_isPNG\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsPNM",  "code": "proc imgIsPNM*(src: PRWops): cint {.cdecl, importc: \"IMG_isPNM\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsTIF",  "code": "proc imgIsTIF*(src: PRWops): cint {.cdecl, importc: \"IMG_isTIF\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsXCF",  "code": "proc imgIsXCF*(src: PRWops): cint {.cdecl, importc: \"IMG_isXCF\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsXPM",  "code": "proc imgIsXPM*(src: PRWops): cint {.cdecl, importc: \"IMG_isXPM\", \u000A                                    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgIsXV",  "code": "proc imgIsXV*(src: PRWops): cint {.cdecl, importc: \"IMG_isXV\", \u000A                                   dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadBMP_RW",  "code": "proc imgLoadBMP_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadBMP_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadGIF_RW",  "code": "proc imgLoadGIF_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadGIF_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadJPG_RW",  "code": "proc imgLoadJPG_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadJPG_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadLBM_RW",  "code": "proc imgLoadLBM_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadLBM_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadPCX_RW",  "code": "proc imgLoadPCX_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadPCX_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadPNM_RW",  "code": "proc imgLoadPNM_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadPNM_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadPNG_RW",  "code": "proc imgLoadPNG_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadPNG_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadTGA_RW",  "code": "proc imgLoadTGA_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadTGA_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadTIF_RW",  "code": "proc imgLoadTIF_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadTIF_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadXCF_RW",  "code": "proc imgLoadXCF_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadXCF_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadXPM_RW",  "code": "proc imgLoadXPM_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadXPM_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgLoadXV_RW",  "code": "proc imgLoadXV_RW*(src: PRWops): PSurface {.cdecl, importc: \"IMG_LoadXV_RW\", \u000A    dynlib: ImageLibName.}" },  { "module": "sdl_image",  "name": "imgReadXPMFromArray",  "code": "proc imgReadXPMFromArray*(xpm: cstringArray): PSurface {.cdecl, \u000A    importc: \"IMG_ReadXPMFromArray\", dynlib: ImageLibName.}" },  { "module": "sdl_mixer",  "name": "version",  "code": "proc version*(x: var sdl.Tversion)" },  { "module": "sdl_mixer",  "name": "linkedVersion",  "code": "proc linkedVersion*(): sdl.Pversion {.cdecl, importc: \"Mix_Linked_Version\", \u000A                                      dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "openAudio",  "code": "proc openAudio*(frequency: cint; format: uint16; channels: cint; chunksize: cint): cint {.\u000A    cdecl, importc: \"Mix_OpenAudio\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "allocateChannels",  "code": "proc allocateChannels*(numchannels: cint): cint {.cdecl, \u000A    importc: \"Mix_AllocateChannels\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "querySpec",  "code": "proc querySpec*(frequency: var cint; format: var uint16; channels: var cint): cint {.\u000A    cdecl, importc: \"Mix_QuerySpec\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "loadWAV_RW",  "code": "proc loadWAV_RW*(src: PRWops; freesrc: cint): PChunk {.cdecl, \u000A    importc: \"Mix_LoadWAV_RW\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "loadWAV",  "code": "proc loadWAV*(filename: cstring): PChunk" },  { "module": "sdl_mixer",  "name": "loadMUS",  "code": "proc loadMUS*(filename: cstring): PMusic {.cdecl, importc: \"Mix_LoadMUS\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "quickLoadWAV",  "code": "proc quickLoadWAV*(mem: pointer): PChunk {.cdecl, importc: \"Mix_QuickLoad_WAV\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "freeChunk",  "code": "proc freeChunk*(chunk: PChunk) {.cdecl, importc: \"Mix_FreeChunk\", \u000A                                 dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "freeMusic",  "code": "proc freeMusic*(music: PMusic) {.cdecl, importc: \"Mix_FreeMusic\", \u000A                                 dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "getMusicType",  "code": "proc getMusicType*(music: PMusic): TMusicType {.cdecl, \u000A    importc: \"Mix_GetMusicType\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setPostMix",  "code": "proc setPostMix*(mixFunc: TMixFunction; arg: pointer) {.cdecl, \u000A    importc: \"Mix_SetPostMix\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "hookMusic",  "code": "proc hookMusic*(mixFunc: TMixFunction; arg: pointer) {.cdecl, \u000A    importc: \"Mix_HookMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "hookMusicFinished",  "code": "proc hookMusicFinished*(musicFinished: pointer) {.cdecl, \u000A    importc: \"Mix_HookMusicFinished\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "getMusicHookData",  "code": "proc getMusicHookData*(): pointer {.cdecl, importc: \"Mix_GetMusicHookData\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "channelFinished",  "code": "proc channelFinished*(channelFinished: TChannelFinished) {.cdecl, \u000A    importc: \"Mix_ChannelFinished\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "registerEffect",  "code": "proc registerEffect*(chan: cint; f: TEffectFunc; d: TEffectDone; arg: pointer): cint {.\u000A    cdecl, importc: \"Mix_RegisterEffect\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "unregisterEffect",  "code": "proc unregisterEffect*(channel: cint; f: TEffectFunc): cint {.cdecl, \u000A    importc: \"Mix_UnregisterEffect\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "unregisterAllEffects",  "code": "proc unregisterAllEffects*(channel: cint): cint {.cdecl, \u000A    importc: \"Mix_UnregisterAllEffects\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setPanning",  "code": "proc setPanning*(channel: cint; left: byte; right: byte): cint {.cdecl, \u000A    importc: \"Mix_SetPanning\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setPosition",  "code": "proc setPosition*(channel: cint; angle: int16; distance: byte): cint {.cdecl, \u000A    importc: \"Mix_SetPosition\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setDistance",  "code": "proc setDistance*(channel: cint; distance: byte): cint {.cdecl, \u000A    importc: \"Mix_SetDistance\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setReverseStereo",  "code": "proc setReverseStereo*(channel: cint; flip: cint): cint {.cdecl, \u000A    importc: \"Mix_SetReverseStereo\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "reserveChannels",  "code": "proc reserveChannels*(num: cint): cint {.cdecl, importc: \"Mix_ReserveChannels\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupChannel",  "code": "proc groupChannel*(which: cint; tag: cint): cint {.cdecl, \u000A    importc: \"Mix_GroupChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupChannels",  "code": "proc groupChannels*(`from`: cint; `to`: cint; tag: cint): cint {.cdecl, \u000A    importc: \"Mix_GroupChannels\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupAvailable",  "code": "proc groupAvailable*(tag: cint): cint {.cdecl, importc: \"Mix_GroupAvailable\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupCount",  "code": "proc groupCount*(tag: cint): cint {.cdecl, importc: \"Mix_GroupCount\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupOldest",  "code": "proc groupOldest*(tag: cint): cint {.cdecl, importc: \"Mix_GroupOldest\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "groupNewer",  "code": "proc groupNewer*(tag: cint): cint {.cdecl, importc: \"Mix_GroupNewer\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "playChannelTimed",  "code": "proc playChannelTimed*(channel: cint; chunk: PChunk; loops: cint; ticks: cint): cint {.\u000A    cdecl, importc: \"Mix_PlayChannelTimed\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "playChannel",  "code": "proc playChannel*(channel: cint; chunk: PChunk; loops: cint): cint" },  { "module": "sdl_mixer",  "name": "playMusic",  "code": "proc playMusic*(music: PMusic; loops: cint): cint {.cdecl, \u000A    importc: \"Mix_PlayMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeInMusic",  "code": "proc fadeInMusic*(music: PMusic; loops: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeInMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeInChannelTimed",  "code": "proc fadeInChannelTimed*(channel: cint; chunk: PChunk; loops: cint; ms: cint; \u000A                         ticks: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeInChannelTimed\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeInChannel",  "code": "proc fadeInChannel*(channel: cint; chunk: PChunk; loops: cint; ms: cint): cint" },  { "module": "sdl_mixer",  "name": "volume",  "code": "proc volume*(channel: cint; volume: cint): cint {.cdecl, importc: \"Mix_Volume\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "volumeChunk",  "code": "proc volumeChunk*(chunk: PChunk; volume: cint): cint {.cdecl, \u000A    importc: \"Mix_VolumeChunk\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "volumeMusic",  "code": "proc volumeMusic*(volume: cint): cint {.cdecl, importc: \"Mix_VolumeMusic\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "haltChannel",  "code": "proc haltChannel*(channel: cint): cint {.cdecl, importc: \"Mix_HaltChannel\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "haltGroup",  "code": "proc haltGroup*(tag: cint): cint {.cdecl, importc: \"Mix_HaltGroup\", \u000A                                   dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "haltMusic",  "code": "proc haltMusic*(): cint {.cdecl, importc: \"Mix_HaltMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "expireChannel",  "code": "proc expireChannel*(channel: cint; ticks: cint): cint {.cdecl, \u000A    importc: \"Mix_ExpireChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeOutChannel",  "code": "proc fadeOutChannel*(which: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeOutChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeOutGroup",  "code": "proc fadeOutGroup*(tag: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeOutGroup\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadeOutMusic",  "code": "proc fadeOutMusic*(ms: cint): cint {.cdecl, importc: \"Mix_FadeOutMusic\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadingMusic",  "code": "proc fadingMusic*(): TFading {.cdecl, importc: \"Mix_FadingMusic\", \u000A                               dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "fadingChannel",  "code": "proc fadingChannel*(which: cint): TFading {.cdecl, importc: \"Mix_FadingChannel\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "pause",  "code": "proc pause*(channel: cint) {.cdecl, importc: \"Mix_Pause\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "resume",  "code": "proc resume*(channel: cint) {.cdecl, importc: \"Mix_Resume\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "paused",  "code": "proc paused*(channel: cint): cint {.cdecl, importc: \"Mix_Paused\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "pauseMusic",  "code": "proc pauseMusic*() {.cdecl, importc: \"Mix_PauseMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "resumeMusic",  "code": "proc resumeMusic*() {.cdecl, importc: \"Mix_ResumeMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "rewindMusic",  "code": "proc rewindMusic*() {.cdecl, importc: \"Mix_RewindMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "pausedMusic",  "code": "proc pausedMusic*(): cint {.cdecl, importc: \"Mix_PausedMusic\", \u000A                            dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setMusicPosition",  "code": "proc setMusicPosition*(position: float64): cint {.cdecl, \u000A    importc: \"Mix_SetMusicPosition\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "playing",  "code": "proc playing*(channel: cint): cint {.cdecl, importc: \"Mix_Playing\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "playingMusic",  "code": "proc playingMusic*(): cint {.cdecl, importc: \"Mix_PlayingMusic\", \u000A                             dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setMusicCMD",  "code": "proc setMusicCMD*(command: cstring): cint {.cdecl, importc: \"Mix_SetMusicCMD\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "setSynchroValue",  "code": "proc setSynchroValue*(value: cint): cint {.cdecl, \u000A    importc: \"Mix_SetSynchroValue\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "getSynchroValue",  "code": "proc getSynchroValue*(): cint {.cdecl, importc: \"Mix_GetSynchroValue\", \u000A                                dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "getChunk",  "code": "proc getChunk*(channel: cint): PChunk {.cdecl, importc: \"Mix_GetChunk\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer",  "name": "closeAudio",  "code": "proc closeAudio*() {.cdecl, importc: \"Mix_CloseAudio\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "version",  "code": "proc version*(x: var sdl.Tversion)" },  { "module": "sdl_mixer_nosmpeg",  "name": "linkedVersion",  "code": "proc linkedVersion*(): sdl.Pversion {.cdecl, importc: \"Mix_Linked_Version\", \u000A                                      dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "openAudio",  "code": "proc openAudio*(frequency: cint; format: uint16; channels: cint; chunksize: cint): cint {.\u000A    cdecl, importc: \"Mix_OpenAudio\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "allocateChannels",  "code": "proc allocateChannels*(numchannels: cint): cint {.cdecl, \u000A    importc: \"Mix_AllocateChannels\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "querySpec",  "code": "proc querySpec*(frequency: var cint; format: var uint16; channels: var cint): cint {.\u000A    cdecl, importc: \"Mix_QuerySpec\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "LoadWAV_RW",  "code": "proc LoadWAV_RW*(src: PRWops; freesrc: cint): PChunk {.cdecl, \u000A    importc: \"Mix_LoadWAV_RW\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "loadWAV",  "code": "proc loadWAV*(filename: cstring): PChunk" },  { "module": "sdl_mixer_nosmpeg",  "name": "loadMUS",  "code": "proc loadMUS*(filename: cstring): PMusic {.cdecl, importc: \"Mix_LoadMUS\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "quickLoadWAV",  "code": "proc quickLoadWAV*(mem: pointer): PChunk {.cdecl, importc: \"Mix_QuickLoad_WAV\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "freeChunk",  "code": "proc freeChunk*(chunk: PChunk) {.cdecl, importc: \"Mix_FreeChunk\", \u000A                                 dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "freeMusic",  "code": "proc freeMusic*(music: PMusic) {.cdecl, importc: \"Mix_FreeMusic\", \u000A                                 dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "getMusicType",  "code": "proc getMusicType*(music: PMusic): TMusicType {.cdecl, \u000A    importc: \"Mix_GetMusicType\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setPostMix",  "code": "proc setPostMix*(mixfunc: TMixFunction; arg: pointer) {.cdecl, \u000A    importc: \"Mix_SetPostMix\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "hookMusic",  "code": "proc hookMusic*(mixFunc: TMixFunction; arg: pointer) {.cdecl, \u000A    importc: \"Mix_HookMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "hookMusicFinished",  "code": "proc hookMusicFinished*(musicFinished: pointer) {.cdecl, \u000A    importc: \"Mix_HookMusicFinished\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "getMusicHookData",  "code": "proc getMusicHookData*(): pointer {.cdecl, importc: \"Mix_GetMusicHookData\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "channelFinished",  "code": "proc channelFinished*(channelFinished: TChannelFinished) {.cdecl, \u000A    importc: \"Mix_ChannelFinished\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "registerEffect",  "code": "proc registerEffect*(chan: cint; f: TEffectFunc; d: TEffectDone; arg: pointer): cint {.\u000A    cdecl, importc: \"Mix_RegisterEffect\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "unregisterEffect",  "code": "proc unregisterEffect*(channel: cint; f: TEffectFunc): cint {.cdecl, \u000A    importc: \"Mix_UnregisterEffect\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "unregisterAllEffects",  "code": "proc unregisterAllEffects*(channel: cint): cint {.cdecl, \u000A    importc: \"Mix_UnregisterAllEffects\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setPanning",  "code": "proc setPanning*(channel: cint; left: byte; right: byte): cint {.cdecl, \u000A    importc: \"Mix_SetPanning\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setPosition",  "code": "proc setPosition*(channel: cint; angle: int16; distance: byte): cint {.cdecl, \u000A    importc: \"Mix_SetPosition\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setDistance",  "code": "proc setDistance*(channel: cint; distance: byte): cint {.cdecl, \u000A    importc: \"Mix_SetDistance\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setReverseStereo",  "code": "proc setReverseStereo*(channel: cint; flip: cint): cint {.cdecl, \u000A    importc: \"Mix_SetReverseStereo\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "reserveChannels",  "code": "proc reserveChannels*(num: cint): cint {.cdecl, importc: \"Mix_ReserveChannels\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupChannel",  "code": "proc groupChannel*(which: cint; tag: cint): cint {.cdecl, \u000A    importc: \"Mix_GroupChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupChannels",  "code": "proc groupChannels*(`from`: cint; `to`: cint; tag: cint): cint {.cdecl, \u000A    importc: \"Mix_GroupChannels\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupAvailable",  "code": "proc groupAvailable*(tag: cint): cint {.cdecl, importc: \"Mix_GroupAvailable\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupCount",  "code": "proc groupCount*(tag: cint): cint {.cdecl, importc: \"Mix_GroupCount\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupOldest",  "code": "proc groupOldest*(tag: cint): cint {.cdecl, importc: \"Mix_GroupOldest\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "groupNewer",  "code": "proc groupNewer*(tag: cint): cint {.cdecl, importc: \"Mix_GroupNewer\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "playChannelTimed",  "code": "proc playChannelTimed*(channel: cint; chunk: PChunk; loops: cint; ticks: cint): cint {.\u000A    cdecl, importc: \"Mix_PlayChannelTimed\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "playChannel",  "code": "proc playChannel*(channel: cint; chunk: PChunk; loops: cint): cint" },  { "module": "sdl_mixer_nosmpeg",  "name": "playMusic",  "code": "proc playMusic*(music: PMusic; loops: cint): cint {.cdecl, \u000A    importc: \"Mix_PlayMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeInMusic",  "code": "proc fadeInMusic*(music: PMusic; loops: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeInMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeInChannelTimed",  "code": "proc fadeInChannelTimed*(channel: cint; chunk: PChunk; loops: cint; ms: cint; \u000A                         ticks: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeInChannelTimed\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeInChannel",  "code": "proc fadeInChannel*(channel: cint; chunk: PChunk; loops: cint; ms: cint): cint" },  { "module": "sdl_mixer_nosmpeg",  "name": "volume",  "code": "proc volume*(channel: cint; volume: cint): cint {.cdecl, importc: \"Mix_Volume\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "volumeChunk",  "code": "proc volumeChunk*(chunk: PChunk; volume: cint): cint {.cdecl, \u000A    importc: \"Mix_VolumeChunk\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "volumeMusic",  "code": "proc volumeMusic*(volume: cint): cint {.cdecl, importc: \"Mix_VolumeMusic\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "haltChannel",  "code": "proc haltChannel*(channel: cint): cint {.cdecl, importc: \"Mix_HaltChannel\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "haltGroup",  "code": "proc haltGroup*(tag: cint): cint {.cdecl, importc: \"Mix_HaltGroup\", \u000A                                   dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "haltMusic",  "code": "proc haltMusic*(): cint {.cdecl, importc: \"Mix_HaltMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "expireChannel",  "code": "proc expireChannel*(channel: cint; ticks: cint): cint {.cdecl, \u000A    importc: \"Mix_ExpireChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeOutChannel",  "code": "proc fadeOutChannel*(which: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeOutChannel\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeOutGroup",  "code": "proc fadeOutGroup*(tag: cint; ms: cint): cint {.cdecl, \u000A    importc: \"Mix_FadeOutGroup\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadeOutMusic",  "code": "proc fadeOutMusic*(ms: cint): cint {.cdecl, importc: \"Mix_FadeOutMusic\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadingMusic",  "code": "proc fadingMusic*(): TFading {.cdecl, importc: \"Mix_FadingMusic\", \u000A                               dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "fadingChannel",  "code": "proc fadingChannel*(which: cint): TFading {.cdecl, importc: \"Mix_FadingChannel\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "pause",  "code": "proc pause*(channel: cint) {.cdecl, importc: \"Mix_Pause\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "resume",  "code": "proc resume*(channel: cint) {.cdecl, importc: \"Mix_Resume\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "paused",  "code": "proc paused*(channel: cint): cint {.cdecl, importc: \"Mix_Paused\", \u000A                                    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "pauseMusic",  "code": "proc pauseMusic*() {.cdecl, importc: \"Mix_PauseMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "resumeMusic",  "code": "proc resumeMusic*() {.cdecl, importc: \"Mix_ResumeMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "rewindMusic",  "code": "proc rewindMusic*() {.cdecl, importc: \"Mix_RewindMusic\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "pausedMusic",  "code": "proc pausedMusic*(): cint {.cdecl, importc: \"Mix_PausedMusic\", \u000A                            dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setMusicPosition",  "code": "proc setMusicPosition*(position: float64): cint {.cdecl, \u000A    importc: \"Mix_SetMusicPosition\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "playing",  "code": "proc playing*(channel: cint): cint {.cdecl, importc: \"Mix_Playing\", \u000A                                     dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "playingMusic",  "code": "proc playingMusic*(): cint {.cdecl, importc: \"Mix_PlayingMusic\", \u000A                             dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setMusicCMD",  "code": "proc setMusicCMD*(command: cstring): cint {.cdecl, importc: \"Mix_SetMusicCMD\", \u000A    dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "setSynchroValue",  "code": "proc setSynchroValue*(value: cint): cint {.cdecl, \u000A    importc: \"Mix_SetSynchroValue\", dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "getSynchroValue",  "code": "proc getSynchroValue*(): cint {.cdecl, importc: \"Mix_GetSynchroValue\", \u000A                                dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "getChunk",  "code": "proc getChunk*(channel: cint): PChunk {.cdecl, importc: \"Mix_GetChunk\", \u000A                                        dynlib: MixerLibName.}" },  { "module": "sdl_mixer_nosmpeg",  "name": "closeAudio",  "code": "proc closeAudio*() {.cdecl, importc: \"Mix_CloseAudio\", dynlib: MixerLibName.}" },  { "module": "sdl_net",  "name": "version",  "code": "proc version*(x: var Tversion)" },  { "module": "sdl_net",  "name": "init",  "code": "proc init*(): int {.cdecl, importc: \"SDLNet_Init\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "quit",  "code": "proc quit*() {.cdecl, importc: \"SDLNet_Quit\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "resolveHost",  "code": "proc resolveHost*(address: var TIPAddress; host: cstring; port: uint16): int {.\u000A    cdecl, importc: \"SDLNet_ResolveHost\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "resolveIP",  "code": "proc resolveIP*(ip: var TIPAddress): cstring {.cdecl, \u000A    importc: \"SDLNet_ResolveIP\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpOpen",  "code": "proc tcpOpen*(ip: var TIPAddress): PTCPSocket {.cdecl, \u000A    importc: \"SDLNet_TCP_Open\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpAccept",  "code": "proc tcpAccept*(server: PTCPSocket): PTCPSocket {.cdecl, \u000A    importc: \"SDLNet_TCP_Accept\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpGetPeerAddress",  "code": "proc tcpGetPeerAddress*(sock: PTCPSocket): PIPAddress {.cdecl, \u000A    importc: \"SDLNet_TCP_GetPeerAddress\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpSend",  "code": "proc tcpSend*(sock: PTCPSocket; data: pointer; length: int): int {.cdecl, \u000A    importc: \"SDLNet_TCP_Send\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpRecv",  "code": "proc tcpRecv*(sock: PTCPSocket; data: pointer; maxlen: int): int {.cdecl, \u000A    importc: \"SDLNet_TCP_Recv\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpClose",  "code": "proc tcpClose*(sock: PTCPSocket) {.cdecl, importc: \"SDLNet_TCP_Close\", \u000A                                   dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "allocPacket",  "code": "proc allocPacket*(size: int): PUDPpacket {.cdecl, importc: \"SDLNet_AllocPacket\", \u000A    dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "resizePacket",  "code": "proc resizePacket*(packet: PUDPpacket; newsize: int): int {.cdecl, \u000A    importc: \"SDLNet_ResizePacket\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "freePacket",  "code": "proc freePacket*(packet: PUDPpacket) {.cdecl, importc: \"SDLNet_FreePacket\", \u000A                                       dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "allocPacketV",  "code": "proc allocPacketV*(howmany: int; size: int): PUDPpacket {.cdecl, \u000A    importc: \"SDLNet_AllocPacketV\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "freePacketV",  "code": "proc freePacketV*(packetV: PUDPpacket) {.cdecl, importc: \"SDLNet_FreePacketV\", \u000A    dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpOpen",  "code": "proc udpOpen*(port: uint16): PUDPSocket {.cdecl, importc: \"SDLNet_UDP_Open\", \u000A    dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpBind",  "code": "proc udpBind*(sock: PUDPSocket; channel: int; address: var TIPAddress): int {.\u000A    cdecl, importc: \"SDLNet_UDP_Bind\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpUnbind",  "code": "proc udpUnbind*(sock: PUDPSocket; channel: int) {.cdecl, \u000A    importc: \"SDLNet_UDP_Unbind\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpGetPeerAddress",  "code": "proc udpGetPeerAddress*(sock: PUDPSocket; channel: int): PIPAddress {.cdecl, \u000A    importc: \"SDLNet_UDP_GetPeerAddress\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpSendV",  "code": "proc udpSendV*(sock: PUDPSocket; packets: PPUDPpacket; npackets: int): int {.\u000A    cdecl, importc: \"SDLNet_UDP_SendV\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpSend",  "code": "proc udpSend*(sock: PUDPSocket; channel: int; packet: PUDPpacket): int {.cdecl, \u000A    importc: \"SDLNet_UDP_Send\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpRecvV",  "code": "proc udpRecvV*(sock: PUDPSocket; packets: PPUDPpacket): int {.cdecl, \u000A    importc: \"SDLNet_UDP_RecvV\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpRecv",  "code": "proc udpRecv*(sock: PUDPSocket; packet: PUDPpacket): int {.cdecl, \u000A    importc: \"SDLNet_UDP_Recv\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "udpClose",  "code": "proc udpClose*(sock: PUDPSocket) {.cdecl, importc: \"SDLNet_UDP_Close\", \u000A                                   dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "allocSocketSet",  "code": "proc allocSocketSet*(maxsockets: int): PSocketSet {.cdecl, \u000A    importc: \"SDLNet_AllocSocketSet\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "addSocket",  "code": "proc addSocket*(theSet: PSocketSet; sock: PGenericSocket): int {.cdecl, \u000A    importc: \"SDLNet_AddSocket\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpAddSocket",  "code": "proc tcpAddSocket*(theSet: PSocketSet; sock: PTCPSocket): int" },  { "module": "sdl_net",  "name": "udpAddSocket",  "code": "proc udpAddSocket*(theSet: PSocketSet; sock: PUDPSocket): int" },  { "module": "sdl_net",  "name": "delSocket",  "code": "proc delSocket*(theSet: PSocketSet; sock: PGenericSocket): int {.cdecl, \u000A    importc: \"SDLNet_DelSocket\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "tcpDelSocket",  "code": "proc tcpDelSocket*(theSet: PSocketSet; sock: PTCPSocket): int" },  { "module": "sdl_net",  "name": "udpDelSocket",  "code": "proc udpDelSocket*(theSet: PSocketSet; sock: PUDPSocket): int" },  { "module": "sdl_net",  "name": "checkSockets",  "code": "proc checkSockets*(theSet: PSocketSet; timeout: int32): int {.cdecl, \u000A    importc: \"SDLNet_CheckSockets\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "socketReady",  "code": "proc socketReady*(sock: PGenericSocket): bool" },  { "module": "sdl_net",  "name": "freeSocketSet",  "code": "proc freeSocketSet*(theSet: PSocketSet) {.cdecl, \u000A    importc: \"SDLNet_FreeSocketSet\", dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "write16",  "code": "proc write16*(value: uint16; area: pointer) {.cdecl, importc: \"SDLNet_Write16\", \u000A    dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "write32",  "code": "proc write32*(value: uint32; area: pointer) {.cdecl, importc: \"SDLNet_Write32\", \u000A    dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "read16",  "code": "proc read16*(area: pointer): uint16 {.cdecl, importc: \"SDLNet_Read16\", \u000A                                      dynlib: NetLibName.}" },  { "module": "sdl_net",  "name": "read32",  "code": "proc read32*(area: pointer): uint32 {.cdecl, importc: \"SDLNet_Read32\", \u000A                                      dynlib: NetLibName.}" },  { "module": "sdl_ttf",  "name": "linkedVersion",  "code": "proc linkedVersion*(): sdl.Pversion {.cdecl, importc: \"TTF_Linked_Version\", \u000A                                      dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "byteSwappedUNICODE",  "code": "proc byteSwappedUNICODE*(swapped: cint) {.cdecl, \u000A    importc: \"TTF_ByteSwappedUNICODE\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "init",  "code": "proc init*(): cint {.cdecl, importc: \"TTF_Init\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "openFont",  "code": "proc openFont*(filename: cstring; ptsize: cint): PFont {.cdecl, \u000A    importc: \"TTF_OpenFont\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "openFontIndex",  "code": "proc openFontIndex*(filename: cstring; ptsize: cint; index: int32): PFont {.\u000A    cdecl, importc: \"TTF_OpenFontIndex\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "openFontRW",  "code": "proc openFontRW*(src: PRWops; freesrc: cint; ptsize: cint): PFont {.cdecl, \u000A    importc: \"TTF_OpenFontRW\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "openFontIndexRW",  "code": "proc openFontIndexRW*(src: PRWops; freesrc: cint; ptsize: cint; index: int32): PFont {.\u000A    cdecl, importc: \"TTF_OpenFontIndexRW\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "getFontStyle",  "code": "proc getFontStyle*(font: PFont): cint {.cdecl, importc: \"TTF_GetFontStyle\", \u000A                                        dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "setFontStyle",  "code": "proc setFontStyle*(font: PFont; style: cint) {.cdecl, \u000A    importc: \"TTF_SetFontStyle\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontHeight",  "code": "proc fontHeight*(font: PFont): cint {.cdecl, importc: \"TTF_FontHeight\", \u000A                                      dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontAscent",  "code": "proc fontAscent*(font: PFont): cint {.cdecl, importc: \"TTF_FontAscent\", \u000A                                      dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontDescent",  "code": "proc fontDescent*(font: PFont): cint {.cdecl, importc: \"TTF_FontDescent\", \u000A                                       dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontLineSkip",  "code": "proc fontLineSkip*(font: PFont): cint {.cdecl, importc: \"TTF_FontLineSkip\", \u000A                                        dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontFaces",  "code": "proc fontFaces*(font: PFont): int32 {.cdecl, importc: \"TTF_FontFaces\", \u000A                                      dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontFaceIsFixedWidth",  "code": "proc fontFaceIsFixedWidth*(font: PFont): cint {.cdecl, \u000A    importc: \"TTF_FontFaceIsFixedWidth\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontFaceFamilyName",  "code": "proc fontFaceFamilyName*(font: PFont): cstring {.cdecl, \u000A    importc: \"TTF_FontFaceFamilyName\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "fontFaceStyleName",  "code": "proc fontFaceStyleName*(font: PFont): cstring {.cdecl, \u000A    importc: \"TTF_FontFaceStyleName\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "glyphMetrics",  "code": "proc glyphMetrics*(font: PFont; ch: uint16; minx: var cint; maxx: var cint; \u000A                   miny: var cint; maxy: var cint; advance: var cint): cint {.\u000A    cdecl, importc: \"TTF_GlyphMetrics\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "sizeText",  "code": "proc sizeText*(font: PFont; text: cstring; w: var cint; y: var cint): cint {.\u000A    cdecl, importc: \"TTF_SizeText\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "sizeUTF8",  "code": "proc sizeUTF8*(font: PFont; text: cstring; w: var cint; y: var cint): cint {.\u000A    cdecl, importc: \"TTF_SizeUTF8\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "sizeUNICODE",  "code": "proc sizeUNICODE*(font: PFont; text: PUInt16; w: var cint; y: var cint): cint {.\u000A    cdecl, importc: \"TTF_SizeUNICODE\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderUTF8Solid",  "code": "proc renderUTF8Solid*(font: PFont; text: cstring; fg: TColor): PSurface {.cdecl, \u000A    importc: \"TTF_RenderUTF8_Solid\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderUNICODE_Solid",  "code": "proc renderUNICODE_Solid*(font: PFont; text: PUInt16; fg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderUNICODE_Solid\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderGlyphSolid",  "code": "proc renderGlyphSolid*(font: PFont; ch: uint16; fg: TColor): PSurface {.cdecl, \u000A    importc: \"TTF_RenderGlyph_Solid\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderTextShaded",  "code": "proc renderTextShaded*(font: PFont; text: cstring; fg: TColor; bg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderText_Shaded\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderUTF8Shaded",  "code": "proc renderUTF8Shaded*(font: PFont; text: cstring; fg: TColor; bg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderUTF8_Shaded\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderUNICODE_Shaded",  "code": "proc renderUNICODE_Shaded*(font: PFont; text: PUInt16; fg: TColor; bg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderUNICODE_Shaded\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderGlyphShaded",  "code": "proc renderGlyphShaded*(font: PFont; ch: uint16; fg: TColor; bg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderGlyph_Shaded\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderTextBlended",  "code": "proc renderTextBlended*(font: PFont; text: cstring; fg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderText_Blended\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderUTF8Blended",  "code": "proc renderUTF8Blended*(font: PFont; text: cstring; fg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderUTF8_Blended\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "RenderUNICODE_Blended",  "code": "proc RenderUNICODE_Blended*(font: PFont; text: PUInt16; fg: TColor): PSurface {.\u000A    cdecl, importc: \"TTF_RenderUNICODE_Blended\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "renderGlyphBlended",  "code": "proc renderGlyphBlended*(font: PFont; ch: uint16; fg: TColor): PSurface {.cdecl, \u000A    importc: \"TTF_RenderGlyph_Blended\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "closeFont",  "code": "proc closeFont*(font: PFont) {.cdecl, importc: \"TTF_CloseFont\", \u000A                               dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "quit",  "code": "proc quit*() {.cdecl, importc: \"TTF_Quit\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "wasInit",  "code": "proc wasInit*(): cint {.cdecl, importc: \"TTF_WasInit\", dynlib: ttfLibName.}" },  { "module": "sdl_ttf",  "name": "version",  "code": "proc version*(x: var sdl.Tversion)" },  { "module": "sdl_ttf",  "name": "renderTextSolid",  "code": "proc renderTextSolid*(font: PFont; text: cstring; fg: TColor): PSurface {.cdecl, \u000A    importc: \"TTF_RenderText_Solid\", dynlib: ttfLibName.}" },  { "module": "selectors",  "name": "hash",  "code": "proc hash*(x: SocketHandle): THash {.borrow.}" },  { "module": "selectors",  "name": "`$`",  "code": "proc `$`*(x: SocketHandle): string {.borrow.}" },  { "module": "selectors",  "name": "register",  "code": "proc register*(s: Selector; fd: SocketHandle; events: set[Event]; data: RootRef): SelectorKey {.\u000A    discardable.}",  "desc": "Registers file descriptor <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt> to selector <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> with a set of TEvent <tt class=\"docutils literal\"><span class=\"pre\">events</span></tt>." },  { "module": "selectors",  "name": "update",  "code": "proc update*(s: Selector; fd: SocketHandle; events: set[Event]): SelectorKey {.\u000A    discardable.}",  "desc": "Updates the events which <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt> wants notifications for." },  { "module": "selectors",  "name": "select",  "code": "proc select*(s: Selector; timeout: int): seq[ReadyInfo]",  "desc": "The <tt class=\"docutils literal\"><span class=\"pre\">events</span></tt> field of the returned <tt class=\"docutils literal\"><span class=\"pre\">key</span></tt> contains the original events for which the <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt> was bound. This is contrary to the <tt class=\"docutils literal\"><span class=\"pre\">events</span></tt> field of the <tt class=\"docutils literal\"><span class=\"pre\">TReadyInfo</span></tt> tuple which determines which events are ready on the <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt>." },  { "module": "selectors",  "name": "contains",  "code": "proc contains*(s: Selector; fd: SocketHandle): bool",  "desc": "Determines whether selector contains a file descriptor." },  { "module": "selectors",  "name": "`[]`",  "code": "proc `[]`*(s: Selector; fd: SocketHandle): SelectorKey",  "desc": "Retrieves the selector key for <tt class=\"docutils literal\"><span class=\"pre\">fd</span></tt>." },  { "module": "selectors",  "name": "contains",  "code": "proc contains*(s: Selector; key: SelectorKey): bool",  "desc": "Determines whether selector contains this selector key. More accurate than checking if the file descriptor is in the selector because it ensures that the keys are equal. File descriptors may not always be unique especially when an fd is closed and then a new one is opened, the new one may have the same value." },  { "module": "sequtils",  "name": "concat",  "code": "proc concat*[T](seqs: varargs[seq[T]]): seq[T]",  "desc": "<p>Takes several sequences' items and returns them inside a new sequence.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">s1</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">s2</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">s3</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">total</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">concat</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">s1</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">s2</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">s3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">total</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "deduplicate",  "code": "proc deduplicate*[T](seq1: seq[T]): seq[T]",  "desc": "Returns a new sequence without duplicates.<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">dup1</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">dup2</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;d&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;d&quot;</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">unique1</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">deduplicate</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">dup1</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">unique2</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">deduplicate</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">dup2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">unique1</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">unique2</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;d&quot;</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "zip",  "code": "proc zip*[S, T](seq1: seq[S]; seq2: seq[T]): seq[tuple[a: S, b: T]]",  "desc": "<p>Returns a new sequence with a combination of the two input sequences.</p>\u000A<p>For convenience you can access the returned tuples through the named fields <cite>a</cite> and <cite>b</cite>. If one sequence is shorter, the remaining items in the longer sequence are discarded. Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">short</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">long</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">words</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;one&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;two&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;three&quot;</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">zip1</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">zip</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">short</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">long</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">zip2</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">zip</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">short</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">words</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">zip1</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">zip2</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;one&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;two&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;three&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">zip1</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Operator\">.</span><span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">4</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">zip2</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Operator\">.</span><span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;three&quot;</span></pre>" },  { "module": "sequtils",  "name": "distribute",  "code": "proc distribute*[T](s: seq[T]; num: int; spread = true): seq[seq[T]]",  "desc": "<p>Splits and distributes a sequence <cite>s</cite> into <cite>num</cite> sub sequences.</p>\u000A<p>Returns a sequence of <cite>num</cite> sequences. For some input values this is the inverse of the <a class=\"reference external\" href=\"#concat\">concat</a> proc.  The proc will assert in debug builds if <cite>s</cite> is nil or <cite>num</cite> is less than one, and will likely crash on release builds.  The input sequence <cite>s</cite> can be empty, which will produce <cite>num</cite> empty sequences.</p>\u000A<p>If <cite>spread</cite> is false and the length of <cite>s</cite> is not a multiple of <cite>num</cite>, the proc will max out the first sub sequences with <tt class=\"docutils literal\"><span class=\"pre\">1 + len(s) div num</span></tt> entries, leaving the remainder of elements to the last sequence.</p>\u000A<p>On the other hand, if <cite>spread</cite> is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">distribute</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">distribute</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>  <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">distribute</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">distribute</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "filter",  "code": "iterator filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): T",  "desc": "<p>Iterates through a sequence and yields every item that fulfills the predicate.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">9</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">n</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">filter</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">proc</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">bool</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">x</span> <span class=\"Keyword\">mod</span> <span class=\"DecNumber\">2</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span><span class=\"Punctuation\">(</span><span class=\"Operator\">$</span><span class=\"Identifier\">n</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># echoes 4, 8, 4 in separate lines</span></pre>" },  { "module": "sequtils",  "name": "filter",  "code": "proc filter*[T](seq1: seq[T]; pred: proc (item: T): bool {.closure.}): seq[T]",  "desc": "<p>Returns a new sequence with all the items that fulfilled the predicate.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">colors</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;red&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;yellow&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;black&quot;</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">f1</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">filter</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">colors</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">bool</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">x</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">&lt;</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">f2</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">filter</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">colors</span><span class=\"Punctuation\">)</span> <span class=\"Keyword\">do</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Identifier\">bool</span> <span class=\"Punctuation\">:</span> <span class=\"Identifier\">x</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">&gt;</span> <span class=\"DecNumber\">5</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">f1</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;red&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;black&quot;</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">f2</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;yellow&quot;</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "keepIf",  "code": "proc keepIf*[T](seq1: var seq[T]; pred: proc (item: T): bool {.closure.})",  "desc": "<p>Keeps the items in the passed sequence if they fulfilled the predicate. Same as the <tt class=\"docutils literal\"><span class=\"pre\">filter</span></tt> proc, but modifies the sequence directly.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">floats</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"FloatNumber\">13.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">12.5</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">5.8</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">2.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">6.1</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">9.9</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">10.1</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">keepIf</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">floats</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">float</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">bool</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">x</span> <span class=\"Operator\">&gt;</span> <span class=\"DecNumber\">10</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">floats</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"FloatNumber\">13.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">12.5</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">10.1</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "delete",  "code": "proc delete*[T](s: var seq[T]; first = 0; last = 0)",  "desc": "<p>Deletes in <cite>s</cite> the items at position <cite>first</cite> .. <cite>last</cite>. This modifies <cite>s</cite> itself, it does not return a copy.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">outcome</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">dest</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">dest</span><span class=\"Operator\">.</span><span class=\"Identifier\">delete</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">outcome</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">dest</span></pre>" },  { "module": "sequtils",  "name": "insert",  "code": "proc insert*[T](dest: var seq[T]; src: openArray[T]; pos = 0)",  "desc": "<p>Inserts items from <cite>src</cite> into <cite>dest</cite> at position <cite>pos</cite>. This modifies <cite>dest</cite> itself, it does not return a copy.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">dest</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">src</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">outcome</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">dest</span><span class=\"Operator\">.</span><span class=\"Identifier\">insert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">src</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">dest</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">outcome</span></pre>" },  { "module": "sequtils",  "name": "filterIt",  "code": "template filterIt*(seq1, pred: expr): expr {.immediate.}",  "desc": "<p>Returns a new sequence with all the items that fulfilled the predicate.</p>\u000A<p>Unlike the <cite>proc</cite> version, the predicate needs to be an expression using the <tt class=\"docutils literal\"><span class=\"pre\">it</span></tt> variable for testing, like: <tt class=\"docutils literal\"><span class=\"pre\">filterIt(&quot;abcxyz&quot;, it == 'x')</span></tt>. Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">temperatures</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Operator\">-</span><span class=\"FloatNumber\">272.15</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">-</span><span class=\"FloatNumber\">2.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">24.5</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">44.31</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">99.9</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">-</span><span class=\"FloatNumber\">113.44</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">acceptable</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">filterIt</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">temperatures</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">it</span> <span class=\"Operator\">&lt;</span> <span class=\"DecNumber\">50</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">it</span> <span class=\"Operator\">&gt;</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">notAcceptable</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">filterIt</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">temperatures</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">it</span> <span class=\"Operator\">&gt;</span> <span class=\"DecNumber\">50</span> <span class=\"Keyword\">or</span> <span class=\"Identifier\">it</span> <span class=\"Operator\">&lt;</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">acceptable</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Operator\">-</span><span class=\"FloatNumber\">2.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">24.5</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">44.31</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">notAcceptable</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Operator\">-</span><span class=\"FloatNumber\">272.15</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">99.9</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">-</span><span class=\"FloatNumber\">113.44</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "keepItIf",  "code": "template keepItIf*(varSeq, pred: expr)",  "desc": "<p>Convenience template around the <tt class=\"docutils literal\"><span class=\"pre\">keepIf</span></tt> proc to reduce typing.</p>\u000A<p>Unlike the <cite>proc</cite> version, the predicate needs to be an expression using the <tt class=\"docutils literal\"><span class=\"pre\">it</span></tt> variable for testing, like: <tt class=\"docutils literal\"><span class=\"pre\">keepItIf(&quot;abcxyz&quot;, it == 'x')</span></tt>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">candidates</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;foo&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;bar&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;foobar&quot;</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">keepItIf</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">candidates</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">it</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">it</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"CharLit\">'b'</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">candidates</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;bar&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "toSeq",  "code": "template toSeq*(iter: expr): expr {.immediate.}",  "desc": "<p>Transforms any iterator into a sequence.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">numeric</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">9</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">odd_numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSeq</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filter</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numeric</span><span class=\"Punctuation\">)</span> <span class=\"Keyword\">do</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-&gt;</span> <span class=\"Identifier\">bool</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">if</span> <span class=\"Identifier\">x</span> <span class=\"Keyword\">mod</span> <span class=\"DecNumber\">2</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">:</span>\u000A      <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">odd_numbers</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">9</span><span class=\"Punctuation\">]</span></pre><p><strong>Note</strong>: Since this is an immediate macro, you cannot always invoke this as <tt class=\"docutils literal\"><span class=\"pre\">x.toSeq</span></tt>, depending on the <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. See <a class=\"reference external\" href=\"manual.html#limitations-of-the-method-call-syntax\">this</a> for an explanation.</p>\u000A" },  { "module": "sequtils",  "name": "foldl",  "code": "template foldl*(sequence, operation: expr): expr",  "desc": "<p>Template to fold a sequence from left to right, returning the accumulation.</p>\u000A<p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <tt class=\"docutils literal\"><span class=\"pre\">operation</span></tt>.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">operation</span></tt> parameter should be an expression which uses the variables <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">b</span></tt> for each step of the fold. Since this is a left fold, for non associative binary operations like substraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).  Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">9</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">11</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">addition</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">+</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">substraction</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">multiplication</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">*</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">words</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;nim&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;cool&quot;</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">concatenation</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">words</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">addition</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">25</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Addition is (((5)+9)+11)&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">substraction</span> <span class=\"Operator\">==</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">15</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Substraction is (((5)-9)-11)&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">multiplication</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">495</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Multiplication is (((5)*9)*11)&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">concatenation</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;nimiscool&quot;</span></pre>" },  { "module": "sequtils",  "name": "foldr",  "code": "template foldr*(sequence, operation: expr): expr",  "desc": "<p>Template to fold a sequence from right to left, returning the accumulation.</p>\u000A<p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <tt class=\"docutils literal\"><span class=\"pre\">operation</span></tt>.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">operation</span></tt> parameter should be an expression which uses the variables <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">b</span></tt> for each step of the fold. Since this is a right fold, for non associative binary operations like substraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))). Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">9</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">11</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">addition</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">+</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">substraction</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">multiplication</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">numbers</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">*</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">words</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;nim&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;cool&quot;</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">concatenation</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">foldr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">words</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">addition</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">25</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Addition is (5+(9+(11)))&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">substraction</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Substraction is (5-(9-(11)))&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">multiplication</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">495</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Multiplication is (5*(9*(11)))&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">concatenation</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;nimiscool&quot;</span></pre>" },  { "module": "sequtils",  "name": "mapIt",  "code": "template mapIt*(seq1, typ, pred: expr): expr",  "desc": "<p>Convenience template around the <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc to reduce typing.</p>\u000A<p>The template injects the <tt class=\"docutils literal\"><span class=\"pre\">it</span></tt> variable which you can use directly in an expression. You also need to pass as <cite>typ</cite> the type of the expression, since the new returned sequence can have a different type than the original.  Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">nums</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">strings</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">nums</span><span class=\"Operator\">.</span><span class=\"Identifier\">mapIt</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">$</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span> <span class=\"Operator\">*</span> <span class=\"Identifier\">it</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">strings</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;4&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;8&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;12&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;16&quot;</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "sequtils",  "name": "mapIt",  "code": "template mapIt*(varSeq, pred: expr)",  "desc": "<p>Convenience template around the mutable <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc to reduce typing.</p>\u000A<p>The template injects the <tt class=\"docutils literal\"><span class=\"pre\">it</span></tt> variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">nums</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">nums</span><span class=\"Operator\">.</span><span class=\"Identifier\">mapIt</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">it</span> <span class=\"Operator\">*</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">nums</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">+</span> <span class=\"Identifier\">nums</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">15</span></pre>" },  { "module": "sequtils",  "name": "newSeqWith",  "code": "template newSeqWith*(len: int; init: expr): expr",  "desc": "creates a new sequence, calling <cite>init</cite> to initialize each value. Example:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">seq2D</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newSeqWith</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">20</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">newSeq</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">bool</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">seq2D</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">true</span>\u000A<span class=\"Identifier\">seq2D</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">true</span>\u000A<span class=\"Identifier\">seq2D</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">true</span>\u000A\u000A<span class=\"Keyword\">import</span> <span class=\"Identifier\">math</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">seqRand</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newSeqWith</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">20</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">random</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">seqRand</span></pre>" },  { "module": "sets",  "name": "isValid",  "code": "proc isValid*[A](s: HashSet[A]): bool",  "desc": "<p>Returns <cite>true</cite> if the set has been initialized with <a class=\"reference external\" href=\"#initSet\">initSet</a>.</p>\u000A<p>Most operations over an uninitialized set will crash at runtime and <a class=\"reference external\" href=\"system.html#assert\">assert</a> in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</p>\u000A<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">savePreferences</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">options</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">assert</span> <span class=\"Identifier\">options</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Pass an initialized set!&quot;</span>\u000A  <span class=\"Comment\"># Do stuff here, may crash in release builds!</span></pre>" },  { "module": "sets",  "name": "len",  "code": "proc len*[A](s: HashSet[A]): int",  "desc": "<p>Returns the number of keys in <cite>s</cite>.</p>\u000A<p>Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span></pre>" },  { "module": "sets",  "name": "card",  "code": "proc card*[A](s: HashSet[A]): int",  "desc": "<p>Alias for <a class=\"reference external\" href=\"#len,TSet[A]\">len()</a>.</p>\u000A<p>Card stands for the <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cardinality\">cardinality</a> of a set.</p>\u000A" },  { "module": "sets",  "name": "items",  "code": "iterator items*[A](s: HashSet[A]): A",  "desc": "<p>Iterates over keys in the set <cite>s</cite>.</p>\u000A<p>If you need a sequence with the keys you can use <a class=\"reference external\" href=\"sequtils.html#toSeq\">sequtils.toSeq()</a> on the iterator. Usage example:</p>\u000A<pre><span class=\"Keyword\">type</span>\u000A  <span class=\"Identifier\">pair</span> <span class=\"Operator\">=</span> <span class=\"Keyword\">tuple</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">pair</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">x</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">items</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">b</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span> <span class=\"Operator\">-</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">y</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">2</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Comment\"># --&gt; {(a: 1, b: 3), (a: 0, b: 4)}</span></pre>" },  { "module": "sets",  "name": "mget",  "code": "proc mget*[A](s: var HashSet[A]; key: A): var A",  "desc": "returns the element that is actually stored in 's' which has the same value as 'key' or raises the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception. This is useful when one overloaded 'hash' and '==' but still needs reference semantics for sharing." },  { "module": "sets",  "name": "contains",  "code": "proc contains*[A](s: HashSet[A]; key: A): bool",  "desc": "<p>Returns true iff <cite>key</cite> is in <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "incl",  "code": "proc incl*[A](s: var HashSet[A]; key: A)",  "desc": "<p>Includes an element <cite>key</cite> in <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is already in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">1</span></pre>" },  { "module": "sets",  "name": "incl",  "code": "proc incl*[A](s: var HashSet[A]; other: HashSet[A])",  "desc": "<p>Includes all elements from <cite>other</cite> into <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">others</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">others</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>" },  { "module": "sets",  "name": "excl",  "code": "proc excl*[A](s: var HashSet[A]; key: A)",  "desc": "<p>Excludes <cite>key</cite> from the set <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is not found in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>" },  { "module": "sets",  "name": "excl",  "code": "proc excl*[A](s: var HashSet[A]; other: HashSet[A])",  "desc": "<p>Excludes everything in <cite>other</cite> from <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">even</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">excl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">even</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">numbers</span>\u000A<span class=\"Comment\"># --&gt; {1, 3, 5}</span></pre>" },  { "module": "sets",  "name": "containsOrIncl",  "code": "proc containsOrIncl*[A](s: var HashSet[A]; key: A): bool",  "desc": "<p>Includes <cite>key</cite> in the set <cite>s</cite> and tells if <cite>key</cite> was added to <cite>s</cite>.</p>\u000A<p>The difference with regards to the <a class=\"reference external\" href=\"#incl,TSet[A],A\">incl()</a> proc is that this proc returns <cite>true</cite> if <cite>key</cite> was already present in <cite>s</cite>. The proc will return false if <cite>key</cite> was added as a new value to <cite>s</cite> during this call. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>" },  { "module": "sets",  "name": "init",  "code": "proc init*[A](s: var HashSet[A]; initialSize = 64)",  "desc": "<p>Initializes a hash set.</p>\u000A<p>The <cite>initialSize</cite> parameter needs to be a power of too. You can use <a class=\"reference external\" href=\"math.html#nextPowerOfTwo\">math.nextPowerOfTwo()</a> to guarantee that at runtime. All set variables have to be initialized before you can use them with other procs from this module with the exception of <a class=\"reference external\" href=\"#isValid,TSet[A]\">isValid()</a> and <a class=\"reference external\" href=\"#len,TSet[A]\">len()</a>.</p>\u000A<p>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling <a class=\"reference external\" href=\"#excl,TSet[A],A\">excl()</a> on them. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span></pre>" },  { "module": "sets",  "name": "initSet",  "code": "proc initSet*[A](initialSize = 64): HashSet[A]",  "desc": "<p>Wrapper around <a class=\"reference external\" href=\"#init,TSet[A],int\">init()</a> for initialization of hash sets.</p>\u000A<p>Returns an empty hash set you can assign directly in <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> blocks in a single line. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "toSet",  "code": "proc toSet*[A](keys: openArray[A]): HashSet[A]",  "desc": "<p>Creates a new hash set that contains the given <cite>keys</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "`$`",  "code": "proc `$`*[A](s: HashSet[A]): string",  "desc": "<p>Converts the set <cite>s</cite> to a string, mostly for logging purposes.</p>\u000A<p>Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Identifier\">echo</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {2, 4, 5}</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;no&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;esc'aping&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is </span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\"> provided&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {no, esc'aping, is &quot; provided}</span></pre>" },  { "module": "sets",  "name": "union",  "code": "proc union*[A](s1, s2: HashSet[A]): HashSet[A]",  "desc": "<p>Returns the union of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The union of two sets is represented mathematically as <em>A \u222A B</em> and is the set of all objects that are members of <cite>s1</cite>, <cite>s2</cite> or both. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">union</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "intersection",  "code": "proc intersection*[A](s1, s2: HashSet[A]): HashSet[A]",  "desc": "<p>Returns the intersection of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The intersection of two sets is represented mathematically as <em>A \u2229 B</em> and is the set of all objects that are members of <cite>s1</cite> and <cite>s2</cite> at the same time. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "difference",  "code": "proc difference*[A](s1, s2: HashSet[A]): HashSet[A]",  "desc": "<p>Returns the difference of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The difference of two sets is represented mathematically as <em>A B</em> and is the set of all objects that are members of <cite>s1</cite> and not members of <cite>s2</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">difference</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "symmetricDifference",  "code": "proc symmetricDifference*[A](s1, s2: HashSet[A]): HashSet[A]",  "desc": "<p>Returns the symmetric difference of the sets <cite>s1</cite> and <cite>s2</cite>.</p>\u000A<p>The symmetric difference of two sets is represented mathematically as <em>A \u25B3 B</em> or <em>A \u2296 B</em> and is the set of all objects that are members of <cite>s1</cite> or <cite>s2</cite> but not both at the same time. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">symmetricDifference</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "`+`",  "code": "proc `+`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}",  "desc": "Alias for <a class=\"reference external\" href=\"#union\">union(s1, s2)</a>." },  { "module": "sets",  "name": "`*`",  "code": "proc `*`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}",  "desc": "Alias for <a class=\"reference external\" href=\"#intersection\">intersection(s1, s2)</a>." },  { "module": "sets",  "name": "`-`",  "code": "proc `-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}",  "desc": "Alias for <a class=\"reference external\" href=\"#difference\">difference(s1, s2)</a>." },  { "module": "sets",  "name": "`-+-`",  "code": "proc `-+-`*[A](s1, s2: HashSet[A]): HashSet[A] {.inline.}",  "desc": "Alias for <a class=\"reference external\" href=\"#symmetricDifference\">symmetricDifference(s1, s2)</a>." },  { "module": "sets",  "name": "disjoint",  "code": "proc disjoint*[A](s1, s2: HashSet[A]): bool",  "desc": "<p>Returns true iff the sets <cite>s1</cite> and <cite>s2</cite> have no items in common.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">disjoint</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">disjoint</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>" },  { "module": "sets",  "name": "`&lt;`",  "code": "proc `<`*[A](s, t: HashSet[A]): bool",  "desc": "<p>Returns true if <cite>s</cite> is a strict or proper subset of <cite>t</cite>.</p>\u000A<p>A strict or proper subset <cite>s</cite> has all of its members in <cite>t</cite> but <cite>t</cite> has more elements than <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">a</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span> <span class=\"Operator\">&lt;</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "`&lt;=`",  "code": "proc `<=`*[A](s, t: HashSet[A]): bool",  "desc": "<p>Returns true if <cite>s</cite> is subset of <cite>t</cite>.</p>\u000A<p>A subset <cite>s</cite> has all of its members in <cite>t</cite> and <cite>t</cite> doesn't necessarily have more members than <cite>s</cite>. That is, <cite>s</cite> can be equal to <cite>t</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;b&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;c&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">intersection</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">a</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">c</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span> <span class=\"Operator\">&lt;=</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "`==`",  "code": "proc `==`*[A](s, t: HashSet[A]): bool",  "desc": "<p>Returns true if both <cite>s</cite> and <cite>t</cite> have the same members and set size.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">b</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">b</span></pre>" },  { "module": "sets",  "name": "map",  "code": "proc map*[A, B](data: HashSet[A]; op: proc (x: A): B {.closure.}): HashSet[B]",  "desc": "<p>Returns a new set after applying <cite>op</cite> on each of the elements of <cite>data</cite>.</p>\u000A<p>You can use this proc to transform the elements from a set. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">map</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">proc</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span> <span class=\"Operator\">$</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">toSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "isValid",  "code": "proc isValid*[A](s: OrderedSet[A]): bool",  "desc": "<p>Returns <cite>true</cite> if the ordered set has been initialized with <a class=\"reference external\" href=\"#initOrderedSet\">initSet</a>.</p>\u000A<p>Most operations over an uninitialized ordered set will crash at runtime and <a class=\"reference external\" href=\"system.html#assert\">assert</a> in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</p>\u000A<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">saveTarotCards</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">cards</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">assert</span> <span class=\"Identifier\">cards</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;Pass an initialized set!&quot;</span>\u000A  <span class=\"Comment\"># Do stuff here, may crash in release builds!</span></pre>" },  { "module": "sets",  "name": "len",  "code": "proc len*[A](s: OrderedSet[A]): int {.inline.}",  "desc": "<p>Returns the number of keys in <cite>s</cite>.</p>\u000A<p>Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span></pre>" },  { "module": "sets",  "name": "card",  "code": "proc card*[A](s: OrderedSet[A]): int {.inline.}",  "desc": "<p>Alias for <a class=\"reference external\" href=\"#len,TOrderedSet[A]\">len()</a>.</p>\u000A<p>Card stands for the <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cardinality\">cardinality</a> of a set.</p>\u000A" },  { "module": "sets",  "name": "items",  "code": "iterator items*[A](s: OrderedSet[A]): A",  "desc": "<p>Iterates over keys in the ordered set <cite>s</cite> in insertion order.</p>\u000A<p>If you need a sequence with the keys you can use <a class=\"reference external\" href=\"sequtils.html#toSeq\">sequtils.toSeq()</a> on the iterator. Usage example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">9</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">8</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">items</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Got &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span>\u000A<span class=\"Comment\"># --&gt; Got 9</span>\u000A<span class=\"Comment\"># --&gt; Got 2</span>\u000A<span class=\"Comment\"># --&gt; Got 1</span>\u000A<span class=\"Comment\"># --&gt; Got 5</span>\u000A<span class=\"Comment\"># --&gt; Got 8</span>\u000A<span class=\"Comment\"># --&gt; Got 4</span></pre>" },  { "module": "sets",  "name": "contains",  "code": "proc contains*[A](s: OrderedSet[A]; key: A): bool",  "desc": "<p>Returns true iff <cite>key</cite> is in <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Keyword\">not</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "incl",  "code": "proc incl*[A](s: var OrderedSet[A]; key: A)",  "desc": "<p>Includes an element <cite>key</cite> in <cite>s</cite>.</p>\u000A<p>This doesn't do anything if <cite>key</cite> is already in <cite>s</cite>. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">1</span></pre>" },  { "module": "sets",  "name": "incl",  "code": "proc incl*[A](s: var HashSet[A]; other: OrderedSet[A])",  "desc": "<p>Includes all elements from <cite>other</cite> into <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">var</span> <span class=\"Identifier\">others</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">others</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span></pre>" },  { "module": "sets",  "name": "containsOrIncl",  "code": "proc containsOrIncl*[A](s: var OrderedSet[A]; key: A): bool",  "desc": "<p>Includes <cite>key</cite> in the set <cite>s</cite> and tells if <cite>key</cite> was added to <cite>s</cite>.</p>\u000A<p>The difference with regards to the <a class=\"reference external\" href=\"#incl,TOrderedSet[A],A\">incl()</a> proc is that this proc returns <cite>true</cite> if <cite>key</cite> was already present in <cite>s</cite>. The proc will return false if <cite>key</cite> was added as a new value to <cite>s</cite> during this call. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">values</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">values</span><span class=\"Operator\">.</span><span class=\"Identifier\">containsOrIncl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span></pre>" },  { "module": "sets",  "name": "init",  "code": "proc init*[A](s: var OrderedSet[A]; initialSize = 64)",  "desc": "<p>Initializes an ordered hash set.</p>\u000A<p>The <cite>initialSize</cite> parameter needs to be a power of too. You can use <a class=\"reference external\" href=\"math.html#nextPowerOfTwo\">math.nextPowerOfTwo()</a> to guarantee that at runtime. All set variables have to be initialized before you can use them with other procs from this module with the exception of <a class=\"reference external\" href=\"#isValid,TOrderedSet[A]\">isValid()</a> and <a class=\"reference external\" href=\"#len,TOrderedSet[A]\">len()</a>.</p>\u000A<p>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">init</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">isValid</span></pre>" },  { "module": "sets",  "name": "initOrderedSet",  "code": "proc initOrderedSet*[A](initialSize = 64): OrderedSet[A]",  "desc": "<p>Wrapper around <a class=\"reference external\" href=\"#init,TOrderedSet[A],int\">init()</a> for initialization of ordered hash sets.</p>\u000A<p>Returns an empty ordered hash set you can assign directly in <tt class=\"docutils literal\"><span class=\"pre\">var</span></tt> blocks in a single line. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">initOrderedSet</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">a</span><span class=\"Operator\">.</span><span class=\"Identifier\">incl</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "toOrderedSet",  "code": "proc toOrderedSet*[A](keys: openArray[A]): OrderedSet[A]",  "desc": "<p>Creates a new ordered hash set that contains the given <cite>keys</cite>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">numbers</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">numbers</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "sets",  "name": "`$`",  "code": "proc `$`*[A](s: OrderedSet[A]): string",  "desc": "<p>Converts the ordered hash set <cite>s</cite> to a string, mostly for logging purposes.</p>\u000A<p>Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Identifier\">echo</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {2, 4, 5}</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">toOrderedSet</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;no&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;esc'aping&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;is </span><span class=\"EscapeSequence\">\\&quot;</span><span class=\"StringLit\"> provided&quot;</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; {no, esc'aping, is &quot; provided}</span></pre>" },  { "module": "sets",  "name": "`==`",  "code": "proc `==`*[A](s, t: OrderedSet[A]): bool",  "desc": "Equality for ordered sets." },  { "module": "shellapi",  "name": "DragQueryFileA",  "code": "proc DragQueryFileA*(arg1: HDROP; arg2: uint32; arg3: LPSTR; arg4: uint32): uint32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"DragQueryFileA\".}" },  { "module": "shellapi",  "name": "DragQueryFileW",  "code": "proc DragQueryFileW*(arg1: HDROP; arg2: uint32; arg3: LPWSTR; arg4: uint32): uint32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"DragQueryFileW\".}" },  { "module": "shellapi",  "name": "DragQueryFile",  "code": "proc DragQueryFile*(arg1: HDROP; arg2: uint32; arg3: LPSTR; arg4: uint32): uint32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"DragQueryFileA\".}" },  { "module": "shellapi",  "name": "DragQueryFile",  "code": "proc DragQueryFile*(arg1: HDROP; arg2: uint32; arg3: LPWSTR; arg4: uint32): uint32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"DragQueryFileW\".}" },  { "module": "shellapi",  "name": "DragQueryPoint",  "code": "proc DragQueryPoint*(arg1: HDROP; arg2: LPPOINT): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DragQueryPoint\".}" },  { "module": "shellapi",  "name": "DragFinish",  "code": "proc DragFinish*(arg1: HDROP) {.stdcall, dynlib: \"shell32.dll\", \u000A                                importc: \"DragFinish\".}" },  { "module": "shellapi",  "name": "DragAcceptFiles",  "code": "proc DragAcceptFiles*(hwnd: HWND; arg2: bool) {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"DragAcceptFiles\".}" },  { "module": "shellapi",  "name": "ShellExecuteA",  "code": "proc ShellExecuteA*(hwnd: HWND; lpOperation: LPCSTR; lpFile: LPCSTR; \u000A                    lpParameters: LPCSTR; lpDirectory: LPCSTR; nShowCmd: int32): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellExecuteA\".}" },  { "module": "shellapi",  "name": "ShellExecuteW",  "code": "proc ShellExecuteW*(hwnd: HWND; lpOperation: LPCWSTR; lpFile: LPCWSTR; \u000A                    lpParameters: LPCWSTR; lpDirectory: LPCWSTR; nShowCmd: int32): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellExecuteW\".}" },  { "module": "shellapi",  "name": "ShellExecute",  "code": "proc ShellExecute*(hwnd: HWND; lpOperation: LPCSTR; lpFile: LPCSTR; \u000A                   lpParameters: LPCSTR; lpDirectory: LPCSTR; nShowCmd: int32): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellExecuteA\".}" },  { "module": "shellapi",  "name": "ShellExecute",  "code": "proc ShellExecute*(hwnd: HWND; lpOperation: LPCWSTR; lpFile: LPCWSTR; \u000A                   lpParameters: LPCWSTR; lpDirectory: LPCWSTR; nShowCmd: int32): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellExecuteW\".}" },  { "module": "shellapi",  "name": "FindExecutableA",  "code": "proc FindExecutableA*(lpFile: LPCSTR; lpDirectory: LPCSTR; lpResult: LPSTR): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"FindExecutableA\".}" },  { "module": "shellapi",  "name": "FindExecutableW",  "code": "proc FindExecutableW*(lpFile: LPCWSTR; lpDirectory: LPCWSTR; lpResult: LPWSTR): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"FindExecutableW\".}" },  { "module": "shellapi",  "name": "FindExecutable",  "code": "proc FindExecutable*(lpFile: LPCSTR; lpDirectory: LPCSTR; lpResult: LPSTR): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"FindExecutableA\".}" },  { "module": "shellapi",  "name": "FindExecutable",  "code": "proc FindExecutable*(lpFile: LPCWSTR; lpDirectory: LPCWSTR; lpResult: LPWSTR): HInst {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"FindExecutableW\".}" },  { "module": "shellapi",  "name": "CommandLineToArgvW",  "code": "proc CommandLineToArgvW*(lpCmdLine: LPCWSTR; pNumArgs: ptr int32): PLPWSTR {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"CommandLineToArgvW\".}" },  { "module": "shellapi",  "name": "ShellAboutA",  "code": "proc ShellAboutA*(hwnd: HWND; szApp: LPCSTR; szOtherStuff: LPCSTR; hIcon: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellAboutA\".}" },  { "module": "shellapi",  "name": "ShellAboutW",  "code": "proc ShellAboutW*(hwnd: HWND; szApp: LPCWSTR; szOtherStuff: LPCWSTR; \u000A                  hIcon: HICON): int32 {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"ShellAboutW\".}" },  { "module": "shellapi",  "name": "ShellAbout",  "code": "proc ShellAbout*(hwnd: HWND; szApp: LPCSTR; szOtherStuff: LPCSTR; hIcon: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellAboutA\".}" },  { "module": "shellapi",  "name": "ShellAbout",  "code": "proc ShellAbout*(hwnd: HWND; szApp: LPCWSTR; szOtherStuff: LPCWSTR; hIcon: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellAboutW\".}" },  { "module": "shellapi",  "name": "DuplicateIcon",  "code": "proc DuplicateIcon*(inst: HINST; icon: HICON): HIcon {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DuplicateIcon\".}" },  { "module": "shellapi",  "name": "ExtractAssociatedIconA",  "code": "proc ExtractAssociatedIconA*(hInst: HINST; lpIconPath: LPSTR; lpiIcon: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractAssociatedIconA\".}" },  { "module": "shellapi",  "name": "ExtractAssociatedIconW",  "code": "proc ExtractAssociatedIconW*(hInst: HINST; lpIconPath: LPWSTR; lpiIcon: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractAssociatedIconW\".}" },  { "module": "shellapi",  "name": "ExtractAssociatedIcon",  "code": "proc ExtractAssociatedIcon*(hInst: HINST; lpIconPath: LPSTR; lpiIcon: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractAssociatedIconA\".}" },  { "module": "shellapi",  "name": "ExtractAssociatedIcon",  "code": "proc ExtractAssociatedIcon*(hInst: HINST; lpIconPath: LPWSTR; lpiIcon: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractAssociatedIconW\".}" },  { "module": "shellapi",  "name": "ExtractIconA",  "code": "proc ExtractIconA*(hInst: HINST; lpszExeFileName: LPCSTR; nIconIndex: uint32): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractIconA\".}" },  { "module": "shellapi",  "name": "ExtractIconW",  "code": "proc ExtractIconW*(hInst: HINST; lpszExeFileName: LPCWSTR; nIconIndex: uint32): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractIconW\".}" },  { "module": "shellapi",  "name": "ExtractIcon",  "code": "proc ExtractIcon*(hInst: HINST; lpszExeFileName: LPCSTR; nIconIndex: uint32): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractIconA\".}" },  { "module": "shellapi",  "name": "ExtractIcon",  "code": "proc ExtractIcon*(hInst: HINST; lpszExeFileName: LPCWSTR; nIconIndex: uint32): HICON {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ExtractIconW\".}" },  { "module": "shellapi",  "name": "SHAppBarMessage",  "code": "proc SHAppBarMessage*(dwMessage: DWORD; pData: APPBARDATA): UINT_PTR {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHAppBarMessage\".}" },  { "module": "shellapi",  "name": "DoEnvironmentSubstA",  "code": "proc DoEnvironmentSubstA*(szString: LPSTR; cchString: uint32): DWORD {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DoEnvironmentSubstA\".}" },  { "module": "shellapi",  "name": "DoEnvironmentSubstW",  "code": "proc DoEnvironmentSubstW*(szString: LPWSTR; cchString: uint32): DWORD {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DoEnvironmentSubstW\".}" },  { "module": "shellapi",  "name": "DoEnvironmentSubst",  "code": "proc DoEnvironmentSubst*(szString: LPSTR; cchString: uint32): DWORD {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DoEnvironmentSubstA\".}" },  { "module": "shellapi",  "name": "DoEnvironmentSubst",  "code": "proc DoEnvironmentSubst*(szString: LPWSTR; cchString: uint32): DWORD {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"DoEnvironmentSubstW\".}" },  { "module": "shellapi",  "name": "EIRESID",  "code": "proc EIRESID*(x: int32): int32" },  { "module": "shellapi",  "name": "ExtractIconExA",  "code": "proc ExtractIconExA*(lpszFile: LPCSTR; nIconIndex: int32; phiconLarge: PHICON; \u000A                     phiconSmall: PHICON; nIcons: uint32): uint32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ExtractIconExA\".}" },  { "module": "shellapi",  "name": "ExtractIconExW",  "code": "proc ExtractIconExW*(lpszFile: LPCWSTR; nIconIndex: int32; phiconLarge: PHICON; \u000A                     phiconSmall: PHICON; nIcons: uint32): uint32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ExtractIconExW\".}" },  { "module": "shellapi",  "name": "ExtractIconExA",  "code": "proc ExtractIconExA*(lpszFile: LPCSTR; nIconIndex: int32; \u000A                     phiconLarge: var HICON; phiconSmall: var HIcon; \u000A                     nIcons: uint32): uint32 {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"ExtractIconExA\".}" },  { "module": "shellapi",  "name": "ExtractIconExW",  "code": "proc ExtractIconExW*(lpszFile: LPCWSTR; nIconIndex: int32; \u000A                     phiconLarge: var HICON; phiconSmall: var HIcon; \u000A                     nIcons: uint32): uint32 {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"ExtractIconExW\".}" },  { "module": "shellapi",  "name": "ExtractIconEx",  "code": "proc ExtractIconEx*(lpszFile: LPCSTR; nIconIndex: int32; phiconLarge: PHICON; \u000A                    phiconSmall: PHICON; nIcons: uint32): uint32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ExtractIconExA\".}" },  { "module": "shellapi",  "name": "ExtractIconEx",  "code": "proc ExtractIconEx*(lpszFile: LPCWSTR; nIconIndex: int32; phiconLarge: PHICON; \u000A                    phiconSmall: PHICON; nIcons: uint32): uint32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ExtractIconExW\".}" },  { "module": "shellapi",  "name": "ExtractIconEx",  "code": "proc ExtractIconEx*(lpszFile: LPCSTR; nIconIndex: int32; phiconLarge: var HICON; \u000A                    phiconSmall: var HIcon; nIcons: uint32): uint32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ExtractIconExA\".}" },  { "module": "shellapi",  "name": "ExtractIconEx",  "code": "proc ExtractIconEx*(lpszFile: LPCWSTR; nIconIndex: int32; \u000A                    phiconLarge: var HICON; phiconSmall: var HIcon; \u000A                    nIcons: uint32): uint32 {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"ExtractIconExW\".}" },  { "module": "shellapi",  "name": "SHFileOperationA",  "code": "proc SHFileOperationA*(lpFileOp: LPSHFILEOPSTRUCTA): int32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHFileOperationA\".}" },  { "module": "shellapi",  "name": "SHFileOperationW",  "code": "proc SHFileOperationW*(lpFileOp: LPSHFILEOPSTRUCTW): int32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHFileOperationW\".}" },  { "module": "shellapi",  "name": "SHFileOperation",  "code": "proc SHFileOperation*(lpFileOp: LPSHFILEOPSTRUCTA): int32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHFileOperationA\".}" },  { "module": "shellapi",  "name": "SHFileOperation",  "code": "proc SHFileOperation*(lpFileOp: LPSHFILEOPSTRUCTW): int32 {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHFileOperationW\".}" },  { "module": "shellapi",  "name": "SHFreeNameMappings",  "code": "proc SHFreeNameMappings*(hNameMappings: THandle) {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHFreeNameMappings\".}" },  { "module": "shellapi",  "name": "ShellExecuteExA",  "code": "proc ShellExecuteExA*(lpExecInfo: LPSHELLEXECUTEINFOA): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ShellExecuteExA\".}" },  { "module": "shellapi",  "name": "ShellExecuteExW",  "code": "proc ShellExecuteExW*(lpExecInfo: LPSHELLEXECUTEINFOW): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ShellExecuteExW\".}" },  { "module": "shellapi",  "name": "ShellExecuteEx",  "code": "proc ShellExecuteEx*(lpExecInfo: LPSHELLEXECUTEINFOA): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ShellExecuteExA\".}" },  { "module": "shellapi",  "name": "ShellExecuteEx",  "code": "proc ShellExecuteEx*(lpExecInfo: LPSHELLEXECUTEINFOW): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"ShellExecuteExW\".}" },  { "module": "shellapi",  "name": "WinExecErrorA",  "code": "proc WinExecErrorA*(hwnd: HWND; error: int32; lpstrFileName: LPCSTR; \u000A                    lpstrTitle: LPCSTR) {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"WinExecErrorA\".}" },  { "module": "shellapi",  "name": "WinExecErrorW",  "code": "proc WinExecErrorW*(hwnd: HWND; error: int32; lpstrFileName: LPCWSTR; \u000A                    lpstrTitle: LPCWSTR) {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"WinExecErrorW\".}" },  { "module": "shellapi",  "name": "WinExecError",  "code": "proc WinExecError*(hwnd: HWND; error: int32; lpstrFileName: LPCSTR; \u000A                   lpstrTitle: LPCSTR) {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"WinExecErrorA\".}" },  { "module": "shellapi",  "name": "WinExecError",  "code": "proc WinExecError*(hwnd: HWND; error: int32; lpstrFileName: LPCWSTR; \u000A                   lpstrTitle: LPCWSTR) {.stdcall, dynlib: \"shell32.dll\", \u000A    importc: \"WinExecErrorW\".}" },  { "module": "shellapi",  "name": "SHCreateProcessAsUserW",  "code": "proc SHCreateProcessAsUserW*(pscpi: PSHCREATEPROCESSINFOW): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHCreateProcessAsUserW\".}" },  { "module": "shellapi",  "name": "SHQueryRecycleBinA",  "code": "proc SHQueryRecycleBinA*(pszRootPath: LPCSTR; pSHQueryRBInfo: LPSHQUERYRBINFO): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHQueryRecycleBinA\".}" },  { "module": "shellapi",  "name": "SHQueryRecycleBinW",  "code": "proc SHQueryRecycleBinW*(pszRootPath: LPCWSTR; pSHQueryRBInfo: LPSHQUERYRBINFO): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHQueryRecycleBinW\".}" },  { "module": "shellapi",  "name": "SHQueryRecycleBin",  "code": "proc SHQueryRecycleBin*(pszRootPath: LPCSTR; pSHQueryRBInfo: LPSHQUERYRBINFO): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHQueryRecycleBinA\".}" },  { "module": "shellapi",  "name": "SHQueryRecycleBin",  "code": "proc SHQueryRecycleBin*(pszRootPath: LPCWSTR; pSHQueryRBInfo: LPSHQUERYRBINFO): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHQueryRecycleBinW\".}" },  { "module": "shellapi",  "name": "SHEmptyRecycleBinA",  "code": "proc SHEmptyRecycleBinA*(hwnd: HWND; pszRootPath: LPCSTR; dwFlags: DWORD): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHEmptyRecycleBinA\".}" },  { "module": "shellapi",  "name": "SHEmptyRecycleBinW",  "code": "proc SHEmptyRecycleBinW*(hwnd: HWND; pszRootPath: LPCWSTR; dwFlags: DWORD): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHEmptyRecycleBinW\".}" },  { "module": "shellapi",  "name": "SHEmptyRecycleBin",  "code": "proc SHEmptyRecycleBin*(hwnd: HWND; pszRootPath: LPCSTR; dwFlags: DWORD): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHEmptyRecycleBinA\".}" },  { "module": "shellapi",  "name": "SHEmptyRecycleBin",  "code": "proc SHEmptyRecycleBin*(hwnd: HWND; pszRootPath: LPCWSTR; dwFlags: DWORD): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHEmptyRecycleBinW\".}" },  { "module": "shellapi",  "name": "Shell_NotifyIconA",  "code": "proc Shell_NotifyIconA*(dwMessage: Dword; lpData: PNOTIFYICONDATAA): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"Shell_NotifyIconA\".}" },  { "module": "shellapi",  "name": "Shell_NotifyIconW",  "code": "proc Shell_NotifyIconW*(dwMessage: Dword; lpData: PNOTIFYICONDATAW): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"Shell_NotifyIconW\".}" },  { "module": "shellapi",  "name": "Shell_NotifyIcon",  "code": "proc Shell_NotifyIcon*(dwMessage: Dword; lpData: PNOTIFYICONDATAA): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"Shell_NotifyIconA\".}" },  { "module": "shellapi",  "name": "Shell_NotifyIcon",  "code": "proc Shell_NotifyIcon*(dwMessage: Dword; lpData: PNOTIFYICONDATAW): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"Shell_NotifyIconW\".}" },  { "module": "shellapi",  "name": "SHGetFileInfoA",  "code": "proc SHGetFileInfoA*(pszPath: LPCSTR; dwFileAttributes: DWORD; \u000A                     psfi: PSHFILEINFOA; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoA\".}" },  { "module": "shellapi",  "name": "SHGetFileInfoW",  "code": "proc SHGetFileInfoW*(pszPath: LPCWSTR; dwFileAttributes: DWORD; \u000A                     psfi: PSHFILEINFOW; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoW\".}" },  { "module": "shellapi",  "name": "SHGetFileInfo",  "code": "proc SHGetFileInfo*(pszPath: LPCSTR; dwFileAttributes: DWORD; \u000A                    psfi: PSHFILEINFOA; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoA\".}" },  { "module": "shellapi",  "name": "SHGetFileInfoA",  "code": "proc SHGetFileInfoA*(pszPath: LPCSTR; dwFileAttributes: DWORD; \u000A                     psfi: var TSHFILEINFOA; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoA\".}" },  { "module": "shellapi",  "name": "SHGetFileInfoW",  "code": "proc SHGetFileInfoW*(pszPath: LPCWSTR; dwFileAttributes: DWORD; \u000A                     psfi: var TSHFILEINFOW; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoW\".}" },  { "module": "shellapi",  "name": "SHGetFileInfo",  "code": "proc SHGetFileInfo*(pszPath: LPCSTR; dwFileAttributes: DWORD; \u000A                    psfi: var TSHFILEINFOA; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoA\".}" },  { "module": "shellapi",  "name": "SHGetFileInfo",  "code": "proc SHGetFileInfo*(pszPath: LPCWSTR; dwFileAttributes: DWORD; \u000A                    psfi: var TSHFILEINFOW; cbFileInfo, UFlags: uint32): DWORD {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetFileInfoW\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpaceExA",  "code": "proc SHGetDiskFreeSpaceExA*(pszDirectoryName: LPCSTR; \u000A                            pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                            pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                            pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExA\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpaceExW",  "code": "proc SHGetDiskFreeSpaceExW*(pszDirectoryName: LPCWSTR; \u000A                            pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                            pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                            pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExW\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpaceEx",  "code": "proc SHGetDiskFreeSpaceEx*(pszDirectoryName: LPCSTR; \u000A                           pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                           pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                           pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExA\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpace",  "code": "proc SHGetDiskFreeSpace*(pszDirectoryName: LPCSTR; \u000A                         pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                         pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                         pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExA\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpaceEx",  "code": "proc SHGetDiskFreeSpaceEx*(pszDirectoryName: LPCWSTR; \u000A                           pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                           pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                           pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExW\".}" },  { "module": "shellapi",  "name": "SHGetDiskFreeSpace",  "code": "proc SHGetDiskFreeSpace*(pszDirectoryName: LPCWSTR; \u000A                         pulFreeBytesAvailableToCaller: PULARGE_INTEGER; \u000A                         pulTotalNumberOfBytes: PULARGE_INTEGER; \u000A                         pulTotalNumberOfFreeBytes: PULARGE_INTEGER): bool {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetDiskFreeSpaceExW\".}" },  { "module": "shellapi",  "name": "SHGetNewLinkInfoA",  "code": "proc SHGetNewLinkInfoA*(pszLinkTo: LPCSTR; pszDir: LPCSTR; pszName: LPSTR; \u000A                        pfMustCopy: PBool; uFlags: uint32): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetNewLinkInfoA\".}" },  { "module": "shellapi",  "name": "SHGetNewLinkInfoW",  "code": "proc SHGetNewLinkInfoW*(pszLinkTo: LPCWSTR; pszDir: LPCWSTR; pszName: LPWSTR; \u000A                        pfMustCopy: PBool; uFlags: uint32): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetNewLinkInfoW\".}" },  { "module": "shellapi",  "name": "SHGetNewLinkInfo",  "code": "proc SHGetNewLinkInfo*(pszLinkTo: LPCSTR; pszDir: LPCSTR; pszName: LPSTR; \u000A                       pfMustCopy: PBool; uFlags: uint32): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetNewLinkInfoA\".}" },  { "module": "shellapi",  "name": "SHGetNewLinkInfo",  "code": "proc SHGetNewLinkInfo*(pszLinkTo: LPCWSTR; pszDir: LPCWSTR; pszName: LPWSTR; \u000A                       pfMustCopy: PBool; uFlags: uint32): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetNewLinkInfoW\".}" },  { "module": "shellapi",  "name": "SHInvokePrinterCommandA",  "code": "proc SHInvokePrinterCommandA*(hwnd: HWND; uAction: uint32; lpBuf1: LPCSTR; \u000A                              lpBuf2: LPCSTR; fModal: bool): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHInvokePrinterCommandA\".}" },  { "module": "shellapi",  "name": "SHInvokePrinterCommandW",  "code": "proc SHInvokePrinterCommandW*(hwnd: HWND; uAction: uint32; lpBuf1: LPCWSTR; \u000A                              lpBuf2: LPCWSTR; fModal: bool): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHInvokePrinterCommandW\".}" },  { "module": "shellapi",  "name": "SHInvokePrinterCommand",  "code": "proc SHInvokePrinterCommand*(hwnd: HWND; uAction: uint32; lpBuf1: LPCSTR; \u000A                             lpBuf2: LPCSTR; fModal: bool): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHInvokePrinterCommandA\".}" },  { "module": "shellapi",  "name": "SHInvokePrinterCommand",  "code": "proc SHInvokePrinterCommand*(hwnd: HWND; uAction: uint32; lpBuf1: LPCWSTR; \u000A                             lpBuf2: LPCWSTR; fModal: bool): bool {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHInvokePrinterCommandW\".}" },  { "module": "shellapi",  "name": "SHLoadNonloadedIconOverlayIdentifiers",  "code": "proc SHLoadNonloadedIconOverlayIdentifiers*(): HResult {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHInvokePrinterCommandW\".}" },  { "module": "shellapi",  "name": "SHIsFileAvailableOffline",  "code": "proc SHIsFileAvailableOffline*(pwszPath: LPCWSTR; pdwStatus: LPDWORD): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHIsFileAvailableOffline\".}" },  { "module": "shellapi",  "name": "SHSetLocalizedName",  "code": "proc SHSetLocalizedName*(pszPath: LPWSTR; pszResModule: LPCWSTR; idsRes: int32): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHSetLocalizedName\".}" },  { "module": "shellapi",  "name": "SHEnumerateUnreadMailAccountsA",  "code": "proc SHEnumerateUnreadMailAccountsA*(hKeyUser: HKEY; dwIndex: DWORD; \u000A                                     pszMailAddress: LPSTR; \u000A                                     cchMailAddress: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHEnumerateUnreadMailAccountsA\".}" },  { "module": "shellapi",  "name": "SHEnumerateUnreadMailAccountsW",  "code": "proc SHEnumerateUnreadMailAccountsW*(hKeyUser: HKEY; dwIndex: DWORD; \u000A                                     pszMailAddress: LPWSTR; \u000A                                     cchMailAddress: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHEnumerateUnreadMailAccountsW\".}" },  { "module": "shellapi",  "name": "SHEnumerateUnreadMailAccounts",  "code": "proc SHEnumerateUnreadMailAccounts*(hKeyUser: HKEY; dwIndex: DWORD; \u000A                                    pszMailAddress: LPWSTR; \u000A                                    cchMailAddress: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHEnumerateUnreadMailAccountsW\".}" },  { "module": "shellapi",  "name": "SHGetUnreadMailCountA",  "code": "proc SHGetUnreadMailCountA*(hKeyUser: HKEY; pszMailAddress: LPCSTR; \u000A                            pdwCount: PDWORD; pFileTime: PFILETIME; \u000A                            pszShellExecuteCommand: LPSTR; \u000A                            cchShellExecuteCommand: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetUnreadMailCountA\".}" },  { "module": "shellapi",  "name": "SHGetUnreadMailCountW",  "code": "proc SHGetUnreadMailCountW*(hKeyUser: HKEY; pszMailAddress: LPCWSTR; \u000A                            pdwCount: PDWORD; pFileTime: PFILETIME; \u000A                            pszShellExecuteCommand: LPWSTR; \u000A                            cchShellExecuteCommand: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetUnreadMailCountW\".}" },  { "module": "shellapi",  "name": "SHGetUnreadMailCount",  "code": "proc SHGetUnreadMailCount*(hKeyUser: HKEY; pszMailAddress: LPCSTR; \u000A                           pdwCount: PDWORD; pFileTime: PFILETIME; \u000A                           pszShellExecuteCommand: LPSTR; \u000A                           cchShellExecuteCommand: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetUnreadMailCountA\".}" },  { "module": "shellapi",  "name": "SHGetUnreadMailCount",  "code": "proc SHGetUnreadMailCount*(hKeyUser: HKEY; pszMailAddress: LPCWSTR; \u000A                           pdwCount: PDWORD; pFileTime: PFILETIME; \u000A                           pszShellExecuteCommand: LPWSTR; \u000A                           cchShellExecuteCommand: int32): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHGetUnreadMailCountW\".}" },  { "module": "shellapi",  "name": "SHSetUnreadMailCountA",  "code": "proc SHSetUnreadMailCountA*(pszMailAddress: LPCSTR; dwCount: DWORD; \u000A                            pszShellExecuteCommand: LPCSTR): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHSetUnreadMailCountA\".}" },  { "module": "shellapi",  "name": "SHSetUnreadMailCountW",  "code": "proc SHSetUnreadMailCountW*(pszMailAddress: LPCWSTR; dwCount: DWORD; \u000A                            pszShellExecuteCommand: LPCWSTR): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHSetUnreadMailCountW\".}" },  { "module": "shellapi",  "name": "SHSetUnreadMailCount",  "code": "proc SHSetUnreadMailCount*(pszMailAddress: LPCSTR; dwCount: DWORD; \u000A                           pszShellExecuteCommand: LPCSTR): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHSetUnreadMailCountA\".}" },  { "module": "shellapi",  "name": "SHSetUnreadMailCount",  "code": "proc SHSetUnreadMailCount*(pszMailAddress: LPCWSTR; dwCount: DWORD; \u000A                           pszShellExecuteCommand: LPCWSTR): HRESULT {.stdcall, \u000A    dynlib: \"shell32.dll\", importc: \"SHSetUnreadMailCountW\".}" },  { "module": "shellapi",  "name": "SHGetImageList",  "code": "proc SHGetImageList*(iImageList: int32; riid: TIID; ppvObj: ptr pointer): HRESULT {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"SHGetImageList\".}" },  { "module": "shfolder",  "name": "SHGetFolderPathA",  "code": "proc SHGetFolderPathA*(Ahwnd: HWND; Csidl: int; Token: THandle; Flags: DWord; \u000A                       Path: cstring): HRESULT {.stdcall, dynlib: LibName, \u000A    importc: \"SHGetFolderPathA\".}" },  { "module": "shfolder",  "name": "SHGetFolderPathW",  "code": "proc SHGetFolderPathW*(Ahwnd: HWND; Csidl: int; Token: THandle; Flags: DWord; \u000A                       Path: cstring): HRESULT {.stdcall, dynlib: LibName, \u000A    importc: \"SHGetFolderPathW\".}" },  { "module": "shfolder",  "name": "SHGetFolderPath",  "code": "proc SHGetFolderPath*(Ahwnd: HWND; Csidl: int; Token: THandle; Flags: DWord; \u000A                      Path: cstring): HRESULT {.stdcall, dynlib: LibName, \u000A    importc: \"SHGetFolderPathA\".}" },  { "module": "smpeg",  "name": "filterNull",  "code": "proc filterNull*(): PFilter {.cdecl, importc: \"SMPEGfilter_null\", \u000A                              dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "filterBilinear",  "code": "proc filterBilinear*(): PFilter {.cdecl, importc: \"SMPEGfilter_bilinear\", \u000A                                  dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "filterDeblocking",  "code": "proc filterDeblocking*(): PFilter {.cdecl, importc: \"SMPEGfilter_deblocking\", \u000A                                    dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "new",  "code": "proc new*(theFile: cstring; info: PInfo; audio: int): PSMPEG {.cdecl, \u000A    importc: \"SMPEG_new\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "newDescr",  "code": "proc newDescr*(theFile: int; info: PInfo; audio: int): PSMPEG {.cdecl, \u000A    importc: \"SMPEG_new_descr\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "newData",  "code": "proc newData*(data: pointer; size: int; info: PInfo; audio: int): PSMPEG {.\u000A    cdecl, importc: \"SMPEG_new_data\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "getinfo",  "code": "proc getinfo*(mpeg: PSMPEG; info: PInfo) {.cdecl, importc: \"SMPEG_getinfo\", \u000A    dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "enableaudio",  "code": "proc enableaudio*(mpeg: PSMPEG; enable: int) {.cdecl, \u000A    importc: \"SMPEG_enableaudio\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "enablevideo",  "code": "proc enablevideo*(mpeg: PSMPEG; enable: int) {.cdecl, \u000A    importc: \"SMPEG_enablevideo\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "delete",  "code": "proc delete*(mpeg: PSMPEG) {.cdecl, importc: \"SMPEG_delete\", \u000A                             dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "status",  "code": "proc status*(mpeg: PSMPEG): Tstatus {.cdecl, importc: \"SMPEG_status\", \u000A                                      dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "setVolume",  "code": "proc setVolume*(mpeg: PSMPEG; volume: int) {.cdecl, importc: \"SMPEG_setvolume\", \u000A    dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "setDisplay",  "code": "proc setDisplay*(mpeg: PSMPEG; dst: PSurface; surfLock: PMutex; \u000A                 callback: TDisplayCallback) {.cdecl, \u000A    importc: \"SMPEG_setdisplay\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "loop",  "code": "proc loop*(mpeg: PSMPEG; repeat: int) {.cdecl, importc: \"SMPEG_loop\", \u000A                                        dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "scaleXY",  "code": "proc scaleXY*(mpeg: PSMPEG; width, height: int) {.cdecl, \u000A    importc: \"SMPEG_scaleXY\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "scale",  "code": "proc scale*(mpeg: PSMPEG; scale: int) {.cdecl, importc: \"SMPEG_scale\", \u000A                                        dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "double",  "code": "proc double*(mpeg: PSMPEG; doubleit: bool)" },  { "module": "smpeg",  "name": "move",  "code": "proc move*(mpeg: PSMPEG; x, y: int) {.cdecl, importc: \"SMPEG_move\", \u000A                                      dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "setDisplayRegion",  "code": "proc setDisplayRegion*(mpeg: PSMPEG; x, y, w, h: int) {.cdecl, \u000A    importc: \"SMPEG_setdisplayregion\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "play",  "code": "proc play*(mpeg: PSMPEG) {.cdecl, importc: \"SMPEG_play\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "pause",  "code": "proc pause*(mpeg: PSMPEG) {.cdecl, importc: \"SMPEG_pause\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "stop",  "code": "proc stop*(mpeg: PSMPEG) {.cdecl, importc: \"SMPEG_stop\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "rewind",  "code": "proc rewind*(mpeg: PSMPEG) {.cdecl, importc: \"SMPEG_rewind\", \u000A                             dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "seek",  "code": "proc seek*(mpeg: PSMPEG; bytes: int) {.cdecl, importc: \"SMPEG_seek\", \u000A                                       dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "skip",  "code": "proc skip*(mpeg: PSMPEG; seconds: float32) {.cdecl, importc: \"SMPEG_skip\", \u000A    dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "renderFrame",  "code": "proc renderFrame*(mpeg: PSMPEG; framenum: int) {.cdecl, \u000A    importc: \"SMPEG_renderFrame\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "renderFinal",  "code": "proc renderFinal*(mpeg: PSMPEG; dst: PSurface; x, y: int) {.cdecl, \u000A    importc: \"SMPEG_renderFinal\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "filter",  "code": "proc filter*(mpeg: PSMPEG; filter: PFilter): PFilter {.cdecl, \u000A    importc: \"SMPEG_filter\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "error",  "code": "proc error*(mpeg: PSMPEG): cstring {.cdecl, importc: \"SMPEG_error\", \u000A                                     dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "playAudio",  "code": "proc playAudio*(mpeg: PSMPEG; stream: pointer; length: int): int {.cdecl, \u000A    importc: \"SMPEG_playAudio\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "playAudioSDL",  "code": "proc playAudioSDL*(mpeg: pointer; stream: pointer; length: int) {.cdecl, \u000A    importc: \"SMPEG_playAudioSDL\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "wantedSpec",  "code": "proc wantedSpec*(mpeg: PSMPEG; wanted: PAudioSpec): int {.cdecl, \u000A    importc: \"SMPEG_wantedSpec\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "actualSpec",  "code": "proc actualSpec*(mpeg: PSMPEG; spec: PAudioSpec) {.cdecl, \u000A    importc: \"SMPEG_actualSpec\", dynlib: SmpegLibName.}" },  { "module": "smpeg",  "name": "getversion",  "code": "proc getversion*(x: var TVersion)" },  { "module": "smtp",  "name": "connect",  "code": "proc connect*(address: string; port = Port(25); ssl = false; debug = false; \u000A              sslContext = defaultSSLContext): Smtp",  "desc": "Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error." },  { "module": "smtp",  "name": "auth",  "code": "proc auth*(smtp: var Smtp; username, password: string)",  "desc": "Sends an AUTH command to the server to login as the <cite>username</cite> using <cite>password</cite>. May fail with ReplyError." },  { "module": "smtp",  "name": "sendmail",  "code": "proc sendmail*(smtp: var Smtp; fromaddr: string; toaddrs: seq[string]; \u000A               msg: string)",  "desc": "Sends <cite>msg</cite> from <cite>fromaddr</cite> to <cite>toaddr</cite>. Messages may be formed using <tt class=\"docutils literal\"><span class=\"pre\">createMessage</span></tt> by converting the Message into a string." },  { "module": "smtp",  "name": "close",  "code": "proc close*(smtp: Smtp)",  "desc": "Disconnects from the SMTP server and closes the socket." },  { "module": "smtp",  "name": "createMessage",  "code": "proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string]; \u000A                    otherHeaders: openarray[tuple[name, value: string]]): Message",  "desc": "Creates a new MIME compliant message." },  { "module": "smtp",  "name": "createMessage",  "code": "proc createMessage*(mSubject, mBody: string; mTo, mCc: seq[string] = @ []): Message",  "desc": "Alternate version of the above." },  { "module": "smtp",  "name": "`$`",  "code": "proc `$`*(msg: Message): string",  "desc": "stringify for <tt class=\"docutils literal\"><span class=\"pre\">Message</span></tt>." },  { "module": "smtp",  "name": "newAsyncSmtp",  "code": "proc newAsyncSmtp*(address: string; port: Port; useSsl = false; \u000A                   sslContext = defaultSslContext): AsyncSmtp",  "desc": "Creates a new <tt class=\"docutils literal\"><span class=\"pre\">AsyncSmtp</span></tt> instance." },  { "module": "smtp",  "name": "connect",  "code": "proc connect*(smtp: AsyncSmtp) {.async.}",  "desc": "Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error." },  { "module": "smtp",  "name": "auth",  "code": "proc auth*(smtp: AsyncSmtp; username, password: string) {.async.}",  "desc": "Sends an AUTH command to the server to login as the <cite>username</cite> using <cite>password</cite>. May fail with ReplyError." },  { "module": "smtp",  "name": "sendMail",  "code": "proc sendMail*(smtp: AsyncSmtp; fromAddr: string; toAddrs: seq[string]; \u000A               msg: string) {.async.}",  "desc": "Sends <tt class=\"docutils literal\"><span class=\"pre\">msg</span></tt> from <tt class=\"docutils literal\"><span class=\"pre\">fromAddr</span></tt> to the addresses specified in <tt class=\"docutils literal\"><span class=\"pre\">toAddrs</span></tt>. Messages may be formed using <tt class=\"docutils literal\"><span class=\"pre\">createMessage</span></tt> by converting the Message into a string." },  { "module": "smtp",  "name": "close",  "code": "proc close*(smtp: AsyncSmtp) {.async.}",  "desc": "Disconnects from the SMTP server and closes the socket." },  { "module": "sockets",  "name": "`==`",  "code": "proc `==`*(a, b: Port): bool {.borrow.}",  "desc": "<tt class=\"docutils literal\"><span class=\"pre\">==</span></tt> for ports." },  { "module": "sockets",  "name": "`$`",  "code": "proc `$`*(p: Port): string {.borrow.}",  "desc": "returns the port number as a string" },  { "module": "sockets",  "name": "ntohl",  "code": "proc ntohl*(x: int32): int32",  "desc": "Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation." },  { "module": "sockets",  "name": "ntohs",  "code": "proc ntohs*(x: int16): int16",  "desc": "Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation." },  { "module": "sockets",  "name": "htonl",  "code": "proc htonl*(x: int32): int32",  "desc": "Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation." },  { "module": "sockets",  "name": "htons",  "code": "proc htons*(x: int16): int16",  "desc": "Converts 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation." },  { "module": "sockets",  "name": "socket",  "code": "proc socket*(domain: Domain = AF_INET; typ: SockType = SOCK_STREAM; \u000A             protocol: Protocol = IPPROTO_TCP; buffered = true): Socket",  "desc": "Creates a new socket; returns <cite>InvalidSocket</cite> if an error occurs." },  { "module": "sockets",  "name": "newContext",  "code": "proc newContext*(protVersion = protSSLv23; verifyMode = CVerifyPeer; \u000A                 certFile = \"\"; keyFile = \"\"): SSLContext",  "desc": "<p>Creates an SSL context.</p>\u000A<p>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are are available with the addition of <tt class=\"docutils literal\"><span class=\"pre\">ProtSSLv23</span></tt> which allows for compatibility with all of them.</p>\u000A<p>There are currently only two options for verify mode; one is <tt class=\"docutils literal\"><span class=\"pre\">CVerifyNone</span></tt> and with it certificates will not be verified the other is <tt class=\"docutils literal\"><span class=\"pre\">CVerifyPeer</span></tt> and certificates will be verified for it, <tt class=\"docutils literal\"><span class=\"pre\">CVerifyPeer</span></tt> is the safest choice.</p>\u000A<p>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: <tt class=\"docutils literal\"><span class=\"pre\">openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</span></tt>.</p>\u000A" },  { "module": "sockets",  "name": "wrapSocket",  "code": "proc wrapSocket*(ctx: SSLContext; socket: Socket)",  "desc": "<p>Wraps a socket in an SSL context. This function effectively turns <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> into an SSL socket.</p>\u000A<p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p>\u000A" },  { "module": "sockets",  "name": "raiseSocketError",  "code": "proc raiseSocketError*(socket: Socket; err: int = - 1; async = false)",  "desc": "<p>Raises proper errors based on return values of <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt> functions.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">async</span></tt> is <tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> no error will be thrown in the case when the error was caused by no data being available to be read.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">err</span></tt> is not lower than 0 no exception will be raised.</p>\u000A" },  { "module": "sockets",  "name": "listen",  "code": "proc listen*(socket: Socket; backlog = SOMAXCONN) {.tags: [ReadIOEffect].}",  "desc": "Marks <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> as accepting connections. <tt class=\"docutils literal\"><span class=\"pre\">Backlog</span></tt> specifies the maximum length of the queue of pending connections." },  { "module": "sockets",  "name": "parseIp4",  "code": "proc parseIp4*(s: string): BiggestInt",  "desc": "<p>parses an IP version 4 in dotted decimal form like &quot;a.b.c.d&quot;.</p>\u000A<p>This is equivalent to <span id=\"inet-ntoa_1\">inet_ntoa</span>.</p>\u000A<p>Raises EInvalidValue in case of an error.</p>\u000A" },  { "module": "sockets",  "name": "bindAddr",  "code": "proc bindAddr*(socket: Socket; port = Port(0); address = \"\") {.\u000A    tags: [ReadIOEffect].}",  "desc": "binds an address/port number to a socket. Use address string in dotted decimal form like &quot;a.b.c.d&quot; or leave &quot;&quot; for any address." },  { "module": "sockets",  "name": "getSockName",  "code": "proc getSockName*(socket: Socket): Port",  "desc": "returns the socket's associated port number." },  { "module": "sockets",  "name": "acceptAddr",  "code": "proc acceptAddr*(server: Socket; client: var Socket; address: var string) {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Blocks until a connection is being made from a client. When a connection is made sets <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> to the client socket and <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> to the address of the connecting client. If <tt class=\"docutils literal\"><span class=\"pre\">server</span></tt> is non-blocking then this function returns immediately, and if there are no connections queued the returned socket will be <tt class=\"docutils literal\"><span class=\"pre\">InvalidSocket</span></tt>. This function will raise EOS if an error occurs.</p>\u000A<p>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> must be initialised (with <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt>), this function makes no effort to initialise the <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> variable.</p>\u000A<p><strong>Warning:</strong> When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</p>\u000A" },  { "module": "sockets",  "name": "setBlocking",  "code": "proc setBlocking*(s: Socket; blocking: bool) {.tags: [], gcsafe.}",  "desc": "Sets blocking mode on socket" },  { "module": "sockets",  "name": "acceptAddrSSL",  "code": "proc acceptAddrSSL*(server: Socket; client: var Socket; address: var string): SSLAcceptResult {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>This procedure should only be used for non-blocking <strong>SSL</strong> sockets. It will immediately return with one of the following values:</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">AcceptSuccess</span></tt> will be returned when a client has been successfully accepted and the handshake has been successfully performed between <tt class=\"docutils literal\"><span class=\"pre\">server</span></tt> and the newly connected client.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">AcceptNoHandshake</span></tt> will be returned when a client has been accepted but no handshake could be performed. This can happen when the client connects but does not yet initiate a handshake. In this case <tt class=\"docutils literal\"><span class=\"pre\">acceptAddrSSL</span></tt> should be called again with the same parameters.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">AcceptNoClient</span></tt> will be returned when no client is currently attempting to connect.</p>\u000A" },  { "module": "sockets",  "name": "accept",  "code": "proc accept*(server: Socket; client: var Socket) {.tags: [ReadIOEffect].}",  "desc": "<p>Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">acceptAddr</span></tt> but doesn't return the address, only the socket.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> must be initialised (with <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt>), this function makes no effort to initialise the <tt class=\"docutils literal\"><span class=\"pre\">client</span></tt> variable.</p>\u000A" },  { "module": "sockets",  "name": "acceptAddr",  "code": "proc acceptAddr*(server: Socket): tuple[client: Socket, address: string] {.\u000A    deprecated, tags: [ReadIOEffect].}",  "desc": "<p>Slightly different version of <tt class=\"docutils literal\"><span class=\"pre\">acceptAddr</span></tt>.</p>\u000A<p><strong>Deprecated since version 0.9.0:</strong> Please use the function above.</p>\u000A" },  { "module": "sockets",  "name": "accept",  "code": "proc accept*(server: Socket): Socket {.deprecated, tags: [ReadIOEffect].}",  "desc": "<strong>Deprecated since version 0.9.0:</strong> Please use the function above." },  { "module": "sockets",  "name": "close",  "code": "proc close*(socket: Socket)",  "desc": "closes a socket." },  { "module": "sockets",  "name": "getServByName",  "code": "proc getServByName*(name, proto: string): Servent {.tags: [ReadIOEffect].}",  "desc": "<p>Searches the database from the beginning and finds the first entry for which the service name specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> matches the s_name member and the protocol name specified by <tt class=\"docutils literal\"><span class=\"pre\">proto</span></tt> matches the s_proto member.</p>\u000A<p>On posix this will search through the <tt class=\"docutils literal\"><span class=\"pre\">/etc/services</span></tt> file.</p>\u000A" },  { "module": "sockets",  "name": "getServByPort",  "code": "proc getServByPort*(port: Port; proto: string): Servent {.tags: [ReadIOEffect].}",  "desc": "<p>Searches the database from the beginning and finds the first entry for which the port specified by <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> matches the s_port member and the protocol name specified by <tt class=\"docutils literal\"><span class=\"pre\">proto</span></tt> matches the s_proto member.</p>\u000A<p>On posix this will search through the <tt class=\"docutils literal\"><span class=\"pre\">/etc/services</span></tt> file.</p>\u000A" },  { "module": "sockets",  "name": "getHostByAddr",  "code": "proc getHostByAddr*(ip: string): Hostent {.tags: [ReadIOEffect].}",  "desc": "This function will lookup the hostname of an IP Address." },  { "module": "sockets",  "name": "getHostByName",  "code": "proc getHostByName*(name: string): Hostent {.tags: [ReadIOEffect].}",  "desc": "This function will lookup the IP address of a hostname." },  { "module": "sockets",  "name": "getSockOptInt",  "code": "proc getSockOptInt*(socket: Socket; level, optname: int): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "getsockopt for integer options." },  { "module": "sockets",  "name": "setSockOptInt",  "code": "proc setSockOptInt*(socket: Socket; level, optname, optval: int) {.\u000A    tags: [WriteIOEffect].}",  "desc": "setsockopt for integer options." },  { "module": "sockets",  "name": "getSockOpt",  "code": "proc getSockOpt*(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {.\u000A    tags: [ReadIOEffect].}",  "desc": "Retrieves option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> as a boolean value." },  { "module": "sockets",  "name": "setSockOpt",  "code": "proc setSockOpt*(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {.\u000A    tags: [WriteIOEffect].}",  "desc": "Sets option <tt class=\"docutils literal\"><span class=\"pre\">opt</span></tt> to a boolean value specified by <tt class=\"docutils literal\"><span class=\"pre\">value</span></tt>." },  { "module": "sockets",  "name": "connect",  "code": "proc connect*(socket: Socket; address: string; port = Port(0); \u000A              af: Domain = AF_INET) {.tags: [ReadIOEffect].}",  "desc": "<p>Connects socket to <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>:<tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">Address</span></tt> can be an IP address or a host name. If <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> is a host name, this function will try each IP of that host name. <tt class=\"docutils literal\"><span class=\"pre\">htons</span></tt> is already performed on <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt> so you must not do it.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is an SSL socket a handshake will be automatically performed.</p>\u000A" },  { "module": "sockets",  "name": "connectAsync",  "code": "proc connectAsync*(socket: Socket; name: string; port = Port(0); \u000A                   af: Domain = AF_INET) {.tags: [ReadIOEffect].}",  "desc": "<p>A variant of <tt class=\"docutils literal\"><span class=\"pre\">connect</span></tt> for non-blocking sockets.</p>\u000A<p>This procedure will immediatelly return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using <tt class=\"docutils literal\"><span class=\"pre\">select</span></tt>) whether the socket is writeable.</p>\u000A<p><strong>Note</strong>: For SSL sockets, the <tt class=\"docutils literal\"><span class=\"pre\">handshake</span></tt> procedure must be called whenever the socket successfully connects to a server.</p>\u000A" },  { "module": "sockets",  "name": "handshake",  "code": "proc handshake*(socket: Socket): bool {.tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "<p>This proc needs to be called on a socket after it connects. This is only applicable when using <tt class=\"docutils literal\"><span class=\"pre\">connectAsync</span></tt>. This proc performs the SSL handshake.</p>\u000A<p>Returns <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt> whenever the socket is not yet ready for a handshake, <tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> whenever handshake completed successfully.</p>\u000A<p>A ESSL error is raised on any other errors.</p>\u000A" },  { "module": "sockets",  "name": "gotHandshake",  "code": "proc gotHandshake*(socket: Socket): bool",  "desc": "<p>Determines whether a handshake has occurred between a client (<tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>) and the server that <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is connected to.</p>\u000A<p>Throws ESSL if <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is not an SSL socket.</p>\u000A" },  { "module": "sockets",  "name": "hasDataBuffered",  "code": "proc hasDataBuffered*(s: Socket): bool",  "desc": "Determines whether a socket has data buffered." },  { "module": "sockets",  "name": "select",  "code": "proc select*(readfds, writefds, exceptfds: var seq[Socket]; timeout = 500): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. <tt class=\"docutils literal\"><span class=\"pre\">Timeout</span></tt> is in miliseconds and -1 can be specified for no timeout.</p>\u000A<p>Sockets which are <strong>not</strong> ready for reading, writing or which don't have errors waiting on them are removed from the <tt class=\"docutils literal\"><span class=\"pre\">readfds</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">writefds</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">exceptfds</span></tt> sequences respectively.</p>\u000A" },  { "module": "sockets",  "name": "select",  "code": "proc select*(readfds, writefds: var seq[Socket]; timeout = 500): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "Variant of select with only a read and write list." },  { "module": "sockets",  "name": "selectWrite",  "code": "proc selectWrite*(writefds: var seq[Socket]; timeout = 500): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>When a socket in <tt class=\"docutils literal\"><span class=\"pre\">writefds</span></tt> is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which <strong>cannot</strong> be written to will also be removed from <tt class=\"docutils literal\"><span class=\"pre\">writefds</span></tt>.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> is specified in miliseconds and <tt class=\"docutils literal\"><span class=\"pre\">-1</span></tt> can be specified for an unlimited time.</p>\u000A" },  { "module": "sockets",  "name": "select",  "code": "proc select*(readfds: var seq[Socket]; timeout = 500): int",  "desc": "variant of select with a read list only" },  { "module": "sockets",  "name": "recv",  "code": "proc recv*(socket: Socket; data: pointer; size: int): int {.tags: [ReadIOEffect].}",  "desc": "<p>Receives data from a socket.</p>\u000A<p><strong>Note</strong>: This is a low-level function, you may be interested in the higher level versions of this function which are also named <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt>.</p>\u000A" },  { "module": "sockets",  "name": "recv",  "code": "proc recv*(socket: Socket; data: pointer; size: int; timeout: int): int {.\u000A    tags: [ReadIOEffect, TimeEffect].}",  "desc": "overload with a <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> parameter in miliseconds." },  { "module": "sockets",  "name": "recv",  "code": "proc recv*(socket: Socket; data: var string; size: int; timeout = - 1): int",  "desc": "<p>Higher-level version of <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt>.</p>\u000A<p>When 0 is returned the socket's connection has been closed.</p>\u000A<p>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</p>\u000A<p>A timeout may be specified in miliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> must be initialised.</p>\u000A" },  { "module": "sockets",  "name": "recvAsync",  "code": "proc recvAsync*(socket: Socket; data: var string; size: int): int",  "desc": "<p>Async version of <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt>.</p>\u000A<p>When socket is non-blocking and no data is available on the socket, <tt class=\"docutils literal\"><span class=\"pre\">-1</span></tt> will be returned and <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> will be <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p><strong>Note</strong>: <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> must be initialised.</p>\u000A" },  { "module": "sockets",  "name": "recvLine",  "code": "proc recvLine*(socket: Socket; line: var TaintedString; timeout = - 1): bool {.\u000A    tags: [ReadIOEffect, TimeEffect], deprecated.}",  "desc": "<p>Receive a line of data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>.</p>\u000A<p>If a full line is received <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is not added to <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt>, however if solely <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is received then <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to it.</p>\u000A<p><tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> is returned if data is available. <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt> suggests an error, EOS exceptions are not raised and <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt> is simply returned instead.</p>\u000A<p>If the socket is disconnected, <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">True</span></tt> will be returned.</p>\u000A<p>A timeout can be specified in miliseconds, if data is not received within the specified time an ETimeout exception will be raised.</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function has been deprecated in favour of readLine.</p>\u000A" },  { "module": "sockets",  "name": "readLine",  "code": "proc readLine*(socket: Socket; line: var TaintedString; timeout = - 1) {.\u000A    tags: [ReadIOEffect, TimeEffect].}",  "desc": "<p>Reads a line of data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>.</p>\u000A<p>If a full line is read <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is not added to <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt>, however if solely <tt class=\"docutils literal\"><span class=\"pre\">\\r\\L</span></tt> is read then <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to it.</p>\u000A<p>If the socket is disconnected, <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p>An EOS exception will be raised in the case of a socket error.</p>\u000A<p>A timeout can be specified in miliseconds, if data is not received within the specified time an ETimeout exception will be raised.</p>\u000A" },  { "module": "sockets",  "name": "recvLineAsync",  "code": "proc recvLineAsync*(socket: Socket; line: var TaintedString): RecvLineResult {.\u000A    tags: [ReadIOEffect], deprecated.}",  "desc": "<p>Similar to <tt class=\"docutils literal\"><span class=\"pre\">recvLine</span></tt> but designed for non-blocking sockets.</p>\u000A<p>The values of the returned enum should be pretty self explanatory:</p>\u000A<blockquote><p><ul class=\"simple\"><li>If a full line has been retrieved; <tt class=\"docutils literal\"><span class=\"pre\">RecvFullLine</span></tt> is returned.</li>\u000A<li>If some data has been retrieved; <tt class=\"docutils literal\"><span class=\"pre\">RecvPartialLine</span></tt> is returned.</li>\u000A<li>If the socket has been disconnected; <tt class=\"docutils literal\"><span class=\"pre\">RecvDisconnected</span></tt> is returned.</li>\u000A<li>If call to <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt> failed; <tt class=\"docutils literal\"><span class=\"pre\">RecvFail</span></tt> is returned.</li>\u000A</ul>\u000A</p></blockquote>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function has been deprecated in favour of readLineAsync.</p>\u000A" },  { "module": "sockets",  "name": "readLineAsync",  "code": "proc readLineAsync*(socket: Socket; line: var TaintedString): ReadLineResult {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Similar to <tt class=\"docutils literal\"><span class=\"pre\">recvLine</span></tt> but designed for non-blocking sockets.</p>\u000A<p>The values of the returned enum should be pretty self explanatory:</p>\u000A<blockquote><p><ul class=\"simple\"><li>If a full line has been retrieved; <tt class=\"docutils literal\"><span class=\"pre\">ReadFullLine</span></tt> is returned.</li>\u000A<li>If some data has been retrieved; <tt class=\"docutils literal\"><span class=\"pre\">ReadPartialLine</span></tt> is returned.</li>\u000A<li>If the socket has been disconnected; <tt class=\"docutils literal\"><span class=\"pre\">ReadDisconnected</span></tt> is returned.</li>\u000A<li>If no data could be retrieved; <tt class=\"docutils literal\"><span class=\"pre\">ReadNone</span></tt> is returned.</li>\u000A<li>If call to <tt class=\"docutils literal\"><span class=\"pre\">recv</span></tt> failed; <strong>an EOS exception is raised.</strong></li>\u000A</ul>\u000A</p></blockquote>\u000A" },  { "module": "sockets",  "name": "recv",  "code": "proc recv*(socket: Socket): TaintedString {.tags: [ReadIOEffect], deprecated.}",  "desc": "<p>receives all the available data from the socket. Socket errors will result in an <tt class=\"docutils literal\"><span class=\"pre\">EOS</span></tt> error. If socket is not a connectionless socket and socket is not connected <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt> will be returned.</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function is not safe for use.</p>\u000A" },  { "module": "sockets",  "name": "recvTimeout",  "code": "proc recvTimeout*(socket: Socket; timeout: int): TaintedString {.\u000A    tags: [ReadIOEffect], deprecated.}",  "desc": "<p>overloaded variant to support a <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> parameter, the <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> parameter specifies the amount of miliseconds to wait for data on the socket.</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function is not safe for use.</p>\u000A" },  { "module": "sockets",  "name": "recvAsync",  "code": "proc recvAsync*(socket: Socket; s: var TaintedString): bool {.\u000A    tags: [ReadIOEffect], deprecated.}",  "desc": "<p>receives all the data from a non-blocking socket. If socket is non-blocking and there are no messages available, <cite>False</cite> will be returned. Other socket errors will result in an <tt class=\"docutils literal\"><span class=\"pre\">EOS</span></tt> error. If socket is not a connectionless socket and socket is not connected <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> will be set to <tt class=\"docutils literal\"><span class=\"pre\">&quot;&quot;</span></tt>.</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function is not safe for use.</p>\u000A" },  { "module": "sockets",  "name": "recvFrom",  "code": "proc recvFrom*(socket: Socket; data: var string; length: int; \u000A               address: var string; port: var Port; flags = 0'i32): int {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Receives data from <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt>. This function should normally be used with connection-less sockets (UDP sockets).</p>\u000A<p>If an error occurs the return value will be <tt class=\"docutils literal\"><span class=\"pre\">-1</span></tt>. Otherwise the return value will be the length of data received.</p>\u000A<p><strong>Warning:</strong> This function does not yet have a buffered implementation, so when <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is buffered the non-buffered implementation will be used. Therefore if <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> contains something in its buffer this function will make no effort to return it.</p>\u000A" },  { "module": "sockets",  "name": "recvFromAsync",  "code": "proc recvFromAsync*(socket: Socket; data: var string; length: int; \u000A                    address: var string; port: var Port; flags = 0'i32): bool {.\u000A    tags: [ReadIOEffect].}",  "desc": "<p>Variant of <tt class=\"docutils literal\"><span class=\"pre\">recvFrom</span></tt> for non-blocking sockets. Unlike <tt class=\"docutils literal\"><span class=\"pre\">recvFrom</span></tt>, this function will raise an EOS error whenever a socket error occurs.</p>\u000A<p>If there is no data to be read from the socket <tt class=\"docutils literal\"><span class=\"pre\">False</span></tt> will be returned.</p>\u000A" },  { "module": "sockets",  "name": "skip",  "code": "proc skip*(socket: Socket) {.tags: [ReadIOEffect], deprecated.}",  "desc": "<p>skips all the data that is pending for the socket</p>\u000A<p><strong>Deprecated since version 0.9.2</strong>: This function is not safe for use.</p>\u000A" },  { "module": "sockets",  "name": "skip",  "code": "proc skip*(socket: Socket; size: int; timeout = - 1)",  "desc": "<p>Skips <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> amount of bytes.</p>\u000A<p>An optional timeout can be specified in miliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</p>\u000A<p>Returns the number of skipped bytes.</p>\u000A" },  { "module": "sockets",  "name": "send",  "code": "proc send*(socket: Socket; data: pointer; size: int): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "sends data to a socket." },  { "module": "sockets",  "name": "send",  "code": "proc send*(socket: Socket; data: string) {.tags: [WriteIOEffect].}",  "desc": "sends data to a socket." },  { "module": "sockets",  "name": "sendAsync",  "code": "proc sendAsync*(socket: Socket; data: string): int {.tags: [WriteIOEffect].}",  "desc": "<p>sends data to a non-blocking socket. Returns <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> if no data could be sent, if data has been sent returns the amount of bytes of <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> that was successfully sent. This number may not always be the length of <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> but typically is.</p>\u000A<p>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</p>\u000A" },  { "module": "sockets",  "name": "trySend",  "code": "proc trySend*(socket: Socket; data: string): bool {.tags: [WriteIOEffect].}",  "desc": "safe alternative to <tt class=\"docutils literal\"><span class=\"pre\">send</span></tt>. Does not raise an EOS when an error occurs, and instead returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> on failure." },  { "module": "sockets",  "name": "sendTo",  "code": "proc sendTo*(socket: Socket; address: string; port: Port; data: pointer; \u000A             size: int; af: Domain = AF_INET; flags = 0'i32): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "<p>low-level sendTo proc. This proc sends <tt class=\"docutils literal\"><span class=\"pre\">data</span></tt> to the specified <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt>, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</p>\u000A<p><strong>Note:</strong> This proc is not available for SSL sockets.</p>\u000A" },  { "module": "sockets",  "name": "sendTo",  "code": "proc sendTo*(socket: Socket; address: string; port: Port; data: string): int {.\u000A    tags: [WriteIOEffect].}",  "desc": "Friendlier version of the low-level <tt class=\"docutils literal\"><span class=\"pre\">sendTo</span></tt>." },  { "module": "sockets",  "name": "connect",  "code": "proc connect*(socket: Socket; address: string; port = Port(0); timeout: int; \u000A              af: Domain = AF_INET) {.tags: [ReadIOEffect, WriteIOEffect].}",  "desc": "<p>Connects to server as specified by <tt class=\"docutils literal\"><span class=\"pre\">address</span></tt> on port specified by <tt class=\"docutils literal\"><span class=\"pre\">port</span></tt>.</p>\u000A<p>The <tt class=\"docutils literal\"><span class=\"pre\">timeout</span></tt> paremeter specifies the time in miliseconds to allow for the connection to the server to be made.</p>\u000A" },  { "module": "sockets",  "name": "isSSL",  "code": "proc isSSL*(socket: Socket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is a SSL socket." },  { "module": "sockets",  "name": "getFD",  "code": "proc getFD*(socket: Socket): SocketHandle",  "desc": "Returns the socket's file descriptor" },  { "module": "sockets",  "name": "isBlocking",  "code": "proc isBlocking*(socket: Socket): bool",  "desc": "Determines whether <tt class=\"docutils literal\"><span class=\"pre\">socket</span></tt> is blocking." },  { "module": "sphinx",  "name": "create",  "code": "proc create*(copy_args: TSphinxBool): PClient {.cdecl, importc: \"sphinx_create\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "cleanup",  "code": "proc cleanup*(client: PClient) {.cdecl, importc: \"sphinx_cleanup\", \u000A                                 dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "destroy",  "code": "proc destroy*(client: PClient) {.cdecl, importc: \"sphinx_destroy\", \u000A                                 dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "error",  "code": "proc error*(client: PClient): cstring {.cdecl, importc: \"sphinx_error\", \u000A                                        dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "warning",  "code": "proc warning*(client: PClient): cstring {.cdecl, importc: \"sphinx_warning\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_server",  "code": "proc set_server*(client: PClient; host: cstring; port: cint): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_server\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_connect_timeout",  "code": "proc set_connect_timeout*(client: PClient; seconds: float32): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_connect_timeout\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "open",  "code": "proc open*(client: PClient): TSphinxBool {.cdecl, importc: \"sphinx_open\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "close",  "code": "proc close*(client: PClient): TSphinxBool {.cdecl, importc: \"sphinx_close\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_limits",  "code": "proc set_limits*(client: PClient; offset: cint; limit: cint; max_matches: cint; \u000A                 cutoff: cint): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_limits\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_max_query_time",  "code": "proc set_max_query_time*(client: PClient; max_query_time: cint): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_max_query_time\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_match_mode",  "code": "proc set_match_mode*(client: PClient; mode: cint): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_match_mode\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_ranking_mode",  "code": "proc set_ranking_mode*(client: PClient; ranker: cint): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_ranking_mode\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_sort_mode",  "code": "proc set_sort_mode*(client: PClient; mode: cint; sortby: cstring): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_sort_mode\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_field_weights",  "code": "proc set_field_weights*(client: PClient; num_weights: cint; \u000A                        field_names: cstringArray; field_weights: ptr cint): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_field_weights\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_index_weights",  "code": "proc set_index_weights*(client: PClient; num_weights: cint; \u000A                        index_names: cstringArray; index_weights: ptr cint): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_index_weights\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_id_range",  "code": "proc set_id_range*(client: PClient; minid: int64; maxid: int64): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_id_range\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "add_filter",  "code": "proc add_filter*(client: PClient; attr: cstring; num_values: cint; \u000A                 values: ptr int64; exclude: TSphinxBool): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_add_filter\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "add_filter_range",  "code": "proc add_filter_range*(client: PClient; attr: cstring; umin: int64; umax: int64; \u000A                       exclude: TSphinxBool): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_add_filter_range\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "add_filter_float_range",  "code": "proc add_filter_float_range*(client: PClient; attr: cstring; fmin: float32; \u000A                             fmax: float32; exclude: TSphinxBool): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_add_filter_float_range\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_geoanchor",  "code": "proc set_geoanchor*(client: PClient; attr_latitude: cstring; \u000A                    attr_longitude: cstring; latitude: float32; \u000A                    longitude: float32): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_geoanchor\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_groupby",  "code": "proc set_groupby*(client: PClient; attr: cstring; groupby_func: cint; \u000A                  group_sort: cstring): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_groupby\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_groupby_distinct",  "code": "proc set_groupby_distinct*(client: PClient; attr: cstring): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_groupby_distinct\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_retries",  "code": "proc set_retries*(client: PClient; count: cint; delay: cint): TSphinxBool {.\u000A    cdecl, importc: \"sphinx_set_retries\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "add_override",  "code": "proc add_override*(client: PClient; attr: cstring; docids: ptr int64; \u000A                   num_values: cint; values: ptr cint): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_add_override\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "set_select",  "code": "proc set_select*(client: PClient; select_list: cstring): TSphinxBool {.cdecl, \u000A    importc: \"sphinx_set_select\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "reset_filters",  "code": "proc reset_filters*(client: PClient) {.cdecl, importc: \"sphinx_reset_filters\", \u000A                                       dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "reset_groupby",  "code": "proc reset_groupby*(client: PClient) {.cdecl, importc: \"sphinx_reset_groupby\", \u000A                                       dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "query",  "code": "proc query*(client: PClient; query: cstring; index_list: cstring; \u000A            comment: cstring): ptr Tresult {.cdecl, importc: \"sphinx_query\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "add_query",  "code": "proc add_query*(client: PClient; query: cstring; index_list: cstring; \u000A                comment: cstring): cint {.cdecl, importc: \"sphinx_add_query\", \u000A    dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "run_queries",  "code": "proc run_queries*(client: PClient): ptr Tresult {.cdecl, \u000A    importc: \"sphinx_run_queries\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_num_results",  "code": "proc get_num_results*(client: PClient): cint {.cdecl, \u000A    importc: \"sphinx_get_num_results\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_id",  "code": "proc get_id*(result: ptr Tresult; match: cint): int64 {.cdecl, \u000A    importc: \"sphinx_get_id\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_weight",  "code": "proc get_weight*(result: ptr Tresult; match: cint): cint {.cdecl, \u000A    importc: \"sphinx_get_weight\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_int",  "code": "proc get_int*(result: ptr Tresult; match: cint; attr: cint): int64 {.cdecl, \u000A    importc: \"sphinx_get_int\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_float",  "code": "proc get_float*(result: ptr Tresult; match: cint; attr: cint): float32 {.cdecl, \u000A    importc: \"sphinx_get_float\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_mva",  "code": "proc get_mva*(result: ptr Tresult; match: cint; attr: cint): ptr cint {.cdecl, \u000A    importc: \"sphinx_get_mva\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "get_string",  "code": "proc get_string*(result: ptr Tresult; match: cint; attr: cint): cstring {.cdecl, \u000A    importc: \"sphinx_get_string\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "init_excerpt_options",  "code": "proc init_excerpt_options*(opts: ptr Texcerpt_options) {.cdecl, \u000A    importc: \"sphinx_init_excerpt_options\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "build_excerpts",  "code": "proc build_excerpts*(client: PClient; num_docs: cint; docs: cstringArray; \u000A                     index: cstring; words: cstring; opts: ptr Texcerpt_options): cstringArray {.\u000A    cdecl, importc: \"sphinx_build_excerpts\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "update_attributes",  "code": "proc update_attributes*(client: PClient; index: cstring; num_attrs: cint; \u000A                        attrs: cstringArray; num_docs: cint; docids: ptr int64; \u000A                        values: ptr int64): cint {.cdecl, \u000A    importc: \"sphinx_update_attributes\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "update_attributes_mva",  "code": "proc update_attributes_mva*(client: PClient; index: cstring; attr: cstring; \u000A                            docid: int64; num_values: cint; values: ptr cint): cint {.\u000A    cdecl, importc: \"sphinx_update_attributes_mva\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "build_keywords",  "code": "proc build_keywords*(client: PClient; query: cstring; index: cstring; \u000A                     hits: TSphinxBool; out_num_keywords: ptr cint): ptr Tkeyword_info {.\u000A    cdecl, importc: \"sphinx_build_keywords\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "status",  "code": "proc status*(client: PClient; num_rows: ptr cint; num_cols: ptr cint): cstringArray {.\u000A    cdecl, importc: \"sphinx_status\", dynlib: sphinxDll.}" },  { "module": "sphinx",  "name": "status_destroy",  "code": "proc status_destroy*(status: cstringArray; num_rows: cint; num_cols: cint) {.\u000A    cdecl, importc: \"sphinx_status_destroy\", dynlib: sphinxDll.}" },  { "module": "sqlite3",  "name": "close",  "code": "proc close*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A                                      importc: \"sqlite3_close\".}" },  { "module": "sqlite3",  "name": "exec",  "code": "proc exec*(para1: PSqlite3; sql: cstring; para3: Tcallback; para4: pointer; \u000A           errmsg: var cstring): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_exec\".}" },  { "module": "sqlite3",  "name": "last_insert_rowid",  "code": "proc last_insert_rowid*(para1: PSqlite3): int64 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_last_insert_rowid\".}" },  { "module": "sqlite3",  "name": "changes",  "code": "proc changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A                                        importc: \"sqlite3_changes\".}" },  { "module": "sqlite3",  "name": "total_changes",  "code": "proc total_changes*(para1: PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_total_changes\".}" },  { "module": "sqlite3",  "name": "interrupt",  "code": "proc interrupt*(para1: PSqlite3) {.cdecl, dynlib: Lib, \u000A                                   importc: \"sqlite3_interrupt\".}" },  { "module": "sqlite3",  "name": "complete",  "code": "proc complete*(sql: cstring): int32 {.cdecl, dynlib: Lib, \u000A                                      importc: \"sqlite3_complete\".}" },  { "module": "sqlite3",  "name": "complete16",  "code": "proc complete16*(sql: pointer): int32 {.cdecl, dynlib: Lib, \u000A                                        importc: \"sqlite3_complete16\".}" },  { "module": "sqlite3",  "name": "busy_handler",  "code": "proc busy_handler*(para1: PSqlite3; \u000A                   para2: proc (para1: pointer; para2: int32): int32 {.cdecl.}; \u000A                   para3: pointer): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_busy_handler\".}" },  { "module": "sqlite3",  "name": "busy_timeout",  "code": "proc busy_timeout*(para1: PSqlite3; ms: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_busy_timeout\".}" },  { "module": "sqlite3",  "name": "get_table",  "code": "proc get_table*(para1: PSqlite3; sql: cstring; resultp: var cstringArray; \u000A                nrow, ncolumn: var cint; errmsg: ptr cstring): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_get_table\".}" },  { "module": "sqlite3",  "name": "free_table",  "code": "proc free_table*(result: cstringArray) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_free_table\".}" },  { "module": "sqlite3",  "name": "mprintf",  "code": "proc mprintf*(para1: cstring): cstring {.cdecl, varargs, dynlib: Lib, \u000A    importc: \"sqlite3_mprintf\".}" },  { "module": "sqlite3",  "name": "free",  "code": "proc free*(z: cstring) {.cdecl, dynlib: Lib, importc: \"sqlite3_free\".}" },  { "module": "sqlite3",  "name": "snprintf",  "code": "proc snprintf*(para1: int32; para2: cstring; para3: cstring): cstring {.cdecl, \u000A    dynlib: Lib, varargs, importc: \"sqlite3_snprintf\".}" },  { "module": "sqlite3",  "name": "set_authorizer",  "code": "proc set_authorizer*(para1: PSqlite3; xAuth: proc (para1: pointer; para2: int32; \u000A    para3: cstring; para4: cstring; para5: cstring; para6: cstring): int32 {.\u000A    cdecl.}; pUserData: pointer): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_set_authorizer\".}" },  { "module": "sqlite3",  "name": "trace",  "code": "proc trace*(para1: PSqlite3; \u000A            xTrace: proc (para1: pointer; para2: cstring) {.cdecl.}; \u000A            para3: pointer): pointer {.cdecl, dynlib: Lib, \u000A                                       importc: \"sqlite3_trace\".}" },  { "module": "sqlite3",  "name": "progress_handler",  "code": "proc progress_handler*(para1: PSqlite3; para2: int32; \u000A                       para3: proc (para1: pointer): int32 {.cdecl.}; \u000A                       para4: pointer) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_progress_handler\".}" },  { "module": "sqlite3",  "name": "commit_hook",  "code": "proc commit_hook*(para1: PSqlite3; para2: proc (para1: pointer): int32 {.cdecl.}; \u000A                  para3: pointer): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_commit_hook\".}" },  { "module": "sqlite3",  "name": "open",  "code": "proc open*(filename: cstring; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_open\".}" },  { "module": "sqlite3",  "name": "open16",  "code": "proc open16*(filename: pointer; ppDb: var PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_open16\".}" },  { "module": "sqlite3",  "name": "errcode",  "code": "proc errcode*(db: PSqlite3): int32 {.cdecl, dynlib: Lib, \u000A                                     importc: \"sqlite3_errcode\".}" },  { "module": "sqlite3",  "name": "errmsg",  "code": "proc errmsg*(para1: PSqlite3): cstring {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_errmsg\".}" },  { "module": "sqlite3",  "name": "errmsg16",  "code": "proc errmsg16*(para1: PSqlite3): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_errmsg16\".}" },  { "module": "sqlite3",  "name": "prepare",  "code": "proc prepare*(db: PSqlite3; zSql: cstring; nBytes: int32; ppStmt: var Pstmt; \u000A              pzTail: ptr cstring): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_prepare\".}" },  { "module": "sqlite3",  "name": "prepare_v2",  "code": "proc prepare_v2*(db: PSqlite3; zSql: cstring; nByte: cint; ppStmt: var Pstmt; \u000A                 pzTail: ptr cstring): cint {.importc: \"sqlite3_prepare_v2\", \u000A    cdecl, dynlib: Lib.}" },  { "module": "sqlite3",  "name": "prepare16",  "code": "proc prepare16*(db: PSqlite3; zSql: pointer; nBytes: int32; ppStmt: var Pstmt; \u000A                pzTail: var pointer): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_prepare16\".}" },  { "module": "sqlite3",  "name": "bind_blob",  "code": "proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32; \u000A                para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_blob\".}" },  { "module": "sqlite3",  "name": "bind_double",  "code": "proc bind_double*(para1: Pstmt; para2: int32; para3: float64): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_bind_double\".}" },  { "module": "sqlite3",  "name": "bind_int",  "code": "proc bind_int*(para1: Pstmt; para2: int32; para3: int32): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_bind_int\".}" },  { "module": "sqlite3",  "name": "bind_int64",  "code": "proc bind_int64*(para1: Pstmt; para2: int32; para3: int64): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_bind_int64\".}" },  { "module": "sqlite3",  "name": "bind_null",  "code": "proc bind_null*(para1: Pstmt; para2: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_null\".}" },  { "module": "sqlite3",  "name": "bind_text",  "code": "proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32; \u000A                para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_text\".}" },  { "module": "sqlite3",  "name": "bind_text16",  "code": "proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32; \u000A                  para5: Tbind_destructor_func): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_text16\".}" },  { "module": "sqlite3",  "name": "bind_blob",  "code": "proc bind_blob*(para1: Pstmt; para2: int32; para3: pointer; n: int32; \u000A                para5: int32): int32 {.cdecl, dynlib: Lib, \u000A                                       importc: \"sqlite3_bind_blob\".}" },  { "module": "sqlite3",  "name": "bind_text",  "code": "proc bind_text*(para1: Pstmt; para2: int32; para3: cstring; n: int32; \u000A                para5: int32): int32 {.cdecl, dynlib: Lib, \u000A                                       importc: \"sqlite3_bind_text\".}" },  { "module": "sqlite3",  "name": "bind_text16",  "code": "proc bind_text16*(para1: Pstmt; para2: int32; para3: pointer; para4: int32; \u000A                  para5: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_text16\".}" },  { "module": "sqlite3",  "name": "bind_parameter_count",  "code": "proc bind_parameter_count*(para1: Pstmt): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_bind_parameter_count\".}" },  { "module": "sqlite3",  "name": "bind_parameter_name",  "code": "proc bind_parameter_name*(para1: Pstmt; para2: int32): cstring {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_bind_parameter_name\".}" },  { "module": "sqlite3",  "name": "bind_parameter_index",  "code": "proc bind_parameter_index*(para1: Pstmt; zName: cstring): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_bind_parameter_index\".}" },  { "module": "sqlite3",  "name": "column_count",  "code": "proc column_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_count\".}" },  { "module": "sqlite3",  "name": "column_name",  "code": "proc column_name*(para1: Pstmt; para2: int32): cstring {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_name\".}" },  { "module": "sqlite3",  "name": "column_name16",  "code": "proc column_name16*(para1: Pstmt; para2: int32): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_name16\".}" },  { "module": "sqlite3",  "name": "column_decltype",  "code": "proc column_decltype*(para1: Pstmt; i: int32): cstring {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_decltype\".}" },  { "module": "sqlite3",  "name": "column_decltype16",  "code": "proc column_decltype16*(para1: Pstmt; para2: int32): pointer {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_column_decltype16\".}" },  { "module": "sqlite3",  "name": "step",  "code": "proc step*(para1: Pstmt): int32 {.cdecl, dynlib: Lib, importc: \"sqlite3_step\".}" },  { "module": "sqlite3",  "name": "data_count",  "code": "proc data_count*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, \u000A                                        importc: \"sqlite3_data_count\".}" },  { "module": "sqlite3",  "name": "column_blob",  "code": "proc column_blob*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_blob\".}" },  { "module": "sqlite3",  "name": "column_bytes",  "code": "proc column_bytes*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_bytes\".}" },  { "module": "sqlite3",  "name": "column_bytes16",  "code": "proc column_bytes16*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_bytes16\".}" },  { "module": "sqlite3",  "name": "column_double",  "code": "proc column_double*(para1: Pstmt; iCol: int32): float64 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_double\".}" },  { "module": "sqlite3",  "name": "column_int",  "code": "proc column_int*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_int\".}" },  { "module": "sqlite3",  "name": "column_int64",  "code": "proc column_int64*(para1: Pstmt; iCol: int32): int64 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_int64\".}" },  { "module": "sqlite3",  "name": "column_text",  "code": "proc column_text*(para1: Pstmt; iCol: int32): cstring {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_text\".}" },  { "module": "sqlite3",  "name": "column_text16",  "code": "proc column_text16*(para1: Pstmt; iCol: int32): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_text16\".}" },  { "module": "sqlite3",  "name": "column_type",  "code": "proc column_type*(para1: Pstmt; iCol: int32): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_column_type\".}" },  { "module": "sqlite3",  "name": "finalize",  "code": "proc finalize*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, \u000A                                      importc: \"sqlite3_finalize\".}" },  { "module": "sqlite3",  "name": "reset",  "code": "proc reset*(pStmt: Pstmt): int32 {.cdecl, dynlib: Lib, importc: \"sqlite3_reset\".}" },  { "module": "sqlite3",  "name": "create_function",  "code": "proc create_function*(para1: PSqlite3; zFunctionName: cstring; nArg: int32; \u000A                      eTextRep: int32; para5: pointer; \u000A                      xFunc: Tcreate_function_func_func; \u000A                      xStep: Tcreate_function_step_func; \u000A                      xFinal: Tcreate_function_final_func): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_create_function\".}" },  { "module": "sqlite3",  "name": "create_function16",  "code": "proc create_function16*(para1: PSqlite3; zFunctionName: pointer; nArg: int32; \u000A                        eTextRep: int32; para5: pointer; \u000A                        xFunc: Tcreate_function_func_func; \u000A                        xStep: Tcreate_function_step_func; \u000A                        xFinal: Tcreate_function_final_func): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_create_function16\".}" },  { "module": "sqlite3",  "name": "aggregate_count",  "code": "proc aggregate_count*(para1: Pcontext): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_aggregate_count\".}" },  { "module": "sqlite3",  "name": "value_blob",  "code": "proc value_blob*(para1: Pvalue): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_blob\".}" },  { "module": "sqlite3",  "name": "value_bytes",  "code": "proc value_bytes*(para1: Pvalue): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_bytes\".}" },  { "module": "sqlite3",  "name": "value_bytes16",  "code": "proc value_bytes16*(para1: Pvalue): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_bytes16\".}" },  { "module": "sqlite3",  "name": "value_double",  "code": "proc value_double*(para1: Pvalue): float64 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_double\".}" },  { "module": "sqlite3",  "name": "value_int",  "code": "proc value_int*(para1: Pvalue): int32 {.cdecl, dynlib: Lib, \u000A                                        importc: \"sqlite3_value_int\".}" },  { "module": "sqlite3",  "name": "value_int64",  "code": "proc value_int64*(para1: Pvalue): int64 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_int64\".}" },  { "module": "sqlite3",  "name": "value_text",  "code": "proc value_text*(para1: Pvalue): cstring {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_text\".}" },  { "module": "sqlite3",  "name": "value_text16",  "code": "proc value_text16*(para1: Pvalue): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_text16\".}" },  { "module": "sqlite3",  "name": "value_text16le",  "code": "proc value_text16le*(para1: Pvalue): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_text16le\".}" },  { "module": "sqlite3",  "name": "value_text16be",  "code": "proc value_text16be*(para1: Pvalue): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_text16be\".}" },  { "module": "sqlite3",  "name": "value_type",  "code": "proc value_type*(para1: Pvalue): int32 {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_value_type\".}" },  { "module": "sqlite3",  "name": "aggregate_context",  "code": "proc aggregate_context*(para1: Pcontext; nBytes: int32): pointer {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_aggregate_context\".}" },  { "module": "sqlite3",  "name": "user_data",  "code": "proc user_data*(para1: Pcontext): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_user_data\".}" },  { "module": "sqlite3",  "name": "get_auxdata",  "code": "proc get_auxdata*(para1: Pcontext; para2: int32): pointer {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_get_auxdata\".}" },  { "module": "sqlite3",  "name": "set_auxdata",  "code": "proc set_auxdata*(para1: Pcontext; para2: int32; para3: pointer; \u000A                  para4: proc (para1: pointer) {.cdecl.}) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_set_auxdata\".}" },  { "module": "sqlite3",  "name": "result_blob",  "code": "proc result_blob*(para1: Pcontext; para2: pointer; para3: int32; \u000A                  para4: Tresult_func) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_blob\".}" },  { "module": "sqlite3",  "name": "result_double",  "code": "proc result_double*(para1: Pcontext; para2: float64) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_double\".}" },  { "module": "sqlite3",  "name": "result_error",  "code": "proc result_error*(para1: Pcontext; para2: cstring; para3: int32) {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_result_error\".}" },  { "module": "sqlite3",  "name": "result_error16",  "code": "proc result_error16*(para1: Pcontext; para2: pointer; para3: int32) {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_result_error16\".}" },  { "module": "sqlite3",  "name": "result_int",  "code": "proc result_int*(para1: Pcontext; para2: int32) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_int\".}" },  { "module": "sqlite3",  "name": "result_int64",  "code": "proc result_int64*(para1: Pcontext; para2: int64) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_int64\".}" },  { "module": "sqlite3",  "name": "result_null",  "code": "proc result_null*(para1: Pcontext) {.cdecl, dynlib: Lib, \u000A                                     importc: \"sqlite3_result_null\".}" },  { "module": "sqlite3",  "name": "result_text",  "code": "proc result_text*(para1: Pcontext; para2: cstring; para3: int32; \u000A                  para4: Tresult_func) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_text\".}" },  { "module": "sqlite3",  "name": "result_text16",  "code": "proc result_text16*(para1: Pcontext; para2: pointer; para3: int32; \u000A                    para4: Tresult_func) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_text16\".}" },  { "module": "sqlite3",  "name": "result_text16le",  "code": "proc result_text16le*(para1: Pcontext; para2: pointer; para3: int32; \u000A                      para4: Tresult_func) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_text16le\".}" },  { "module": "sqlite3",  "name": "result_text16be",  "code": "proc result_text16be*(para1: Pcontext; para2: pointer; para3: int32; \u000A                      para4: Tresult_func) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_text16be\".}" },  { "module": "sqlite3",  "name": "result_value",  "code": "proc result_value*(para1: Pcontext; para2: Pvalue) {.cdecl, dynlib: Lib, \u000A    importc: \"sqlite3_result_value\".}" },  { "module": "sqlite3",  "name": "create_collation",  "code": "proc create_collation*(para1: PSqlite3; zName: cstring; eTextRep: int32; \u000A                       para4: pointer; xCompare: Tcreate_collation_func): int32 {.\u000A    cdecl, dynlib: Lib, importc: \"sqlite3_create_collation\".}" },  { "module": "sqlite3",  "name": "create_collation16",  "code": "proc create_collation16*(para1: PSqlite3; zName: cstring; eTextRep: int32; \u000A                         para4: pointer; xCompare: Tcreate_collation_func): int32 {.\u000A    cdecl, dynlib: Lib, importc: \"sqlite3_create_collation16\".}" },  { "module": "sqlite3",  "name": "collation_needed",  "code": "proc collation_needed*(para1: PSqlite3; para2: pointer; \u000A                       para3: Tcollation_needed_func): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_collation_needed\".}" },  { "module": "sqlite3",  "name": "collation_needed16",  "code": "proc collation_needed16*(para1: PSqlite3; para2: pointer; \u000A                         para3: Tcollation_needed_func): int32 {.cdecl, \u000A    dynlib: Lib, importc: \"sqlite3_collation_needed16\".}" },  { "module": "sqlite3",  "name": "libversion",  "code": "proc libversion*(): cstring {.cdecl, dynlib: Lib, importc: \"sqlite3_libversion\".}" },  { "module": "sqlite3",  "name": "version",  "code": "proc version*(): cstring {.cdecl, dynlib: Lib, importc: \"sqlite3_libversion\".}" },  { "module": "sqlite3",  "name": "libversion_number",  "code": "proc libversion_number*(): int32 {.cdecl, dynlib: Lib, \u000A                                   importc: \"sqlite3_libversion_number\".}" },  { "module": "ssl",  "name": "connect",  "code": "proc connect*(sock: var TSecureSocket; address: string; port: int): int",  "desc": "Connects to the specified <cite>address</cite> on the specified <cite>port</cite>. Returns the result of the certificate validation." },  { "module": "ssl",  "name": "recvLine",  "code": "proc recvLine*(sock: TSecureSocket; line: var TaintedString): bool",  "desc": "Acts in a similar fashion to the <cite>recvLine</cite> in the sockets module. Returns false when no data is available to be read. <cite>Line</cite> must be initialized and not nil!" },  { "module": "ssl",  "name": "send",  "code": "proc send*(sock: TSecureSocket; data: string)",  "desc": "Writes <cite>data</cite> to the socket." },  { "module": "ssl",  "name": "close",  "code": "proc close*(sock: TSecureSocket)",  "desc": "Closes the socket" },  { "module": "streams",  "name": "flush",  "code": "proc flush*(s: Stream)",  "desc": "flushes the buffers that the stream <cite>s</cite> might use." },  { "module": "streams",  "name": "close",  "code": "proc close*(s: Stream)",  "desc": "closes the stream <cite>s</cite>." },  { "module": "streams",  "name": "close",  "code": "proc close*(s, unused: Stream) {.deprecated.}",  "desc": "closes the stream <cite>s</cite>." },  { "module": "streams",  "name": "atEnd",  "code": "proc atEnd*(s: Stream): bool",  "desc": "checks if more data can be read from <cite>f</cite>. Returns true if all data has been read." },  { "module": "streams",  "name": "atEnd",  "code": "proc atEnd*(s, unused: Stream): bool {.deprecated.}",  "desc": "checks if more data can be read from <cite>f</cite>. Returns true if all data has been read." },  { "module": "streams",  "name": "setPosition",  "code": "proc setPosition*(s: Stream; pos: int)",  "desc": "sets the position <cite>pos</cite> of the stream <cite>s</cite>." },  { "module": "streams",  "name": "setPosition",  "code": "proc setPosition*(s, unused: Stream; pos: int) {.deprecated.}",  "desc": "sets the position <cite>pos</cite> of the stream <cite>s</cite>." },  { "module": "streams",  "name": "getPosition",  "code": "proc getPosition*(s: Stream): int",  "desc": "retrieves the current position in the stream <cite>s</cite>." },  { "module": "streams",  "name": "getPosition",  "code": "proc getPosition*(s, unused: Stream): int {.deprecated.}",  "desc": "retrieves the current position in the stream <cite>s</cite>." },  { "module": "streams",  "name": "readData",  "code": "proc readData*(s: Stream; buffer: pointer; bufLen: int): int",  "desc": "low level proc that reads data into an untyped <cite>buffer</cite> of <cite>bufLen</cite> size." },  { "module": "streams",  "name": "readData",  "code": "proc readData*(s, unused: Stream; buffer: pointer; bufLen: int): int {.\u000A    deprecated.}",  "desc": "low level proc that reads data into an untyped <cite>buffer</cite> of <cite>bufLen</cite> size." },  { "module": "streams",  "name": "writeData",  "code": "proc writeData*(s: Stream; buffer: pointer; bufLen: int)",  "desc": "low level proc that writes an untyped <cite>buffer</cite> of <cite>bufLen</cite> size to the stream <cite>s</cite>." },  { "module": "streams",  "name": "writeData",  "code": "proc writeData*(s, unused: Stream; buffer: pointer; bufLen: int) {.deprecated.}",  "desc": "low level proc that writes an untyped <cite>buffer</cite> of <cite>bufLen</cite> size to the stream <cite>s</cite>." },  { "module": "streams",  "name": "write",  "code": "proc write*[T](s: Stream; x: T)",  "desc": "generic write procedure. Writes <cite>x</cite> to the stream <cite>s</cite>. Implementation:<pre><span class=\"Identifier\">s</span><span class=\"Operator\">.</span><span class=\"Identifier\">writeData</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">s</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">addr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">sizeof</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "streams",  "name": "write",  "code": "proc write*(s: Stream; x: string)",  "desc": "writes the string <cite>x</cite> to the the stream <cite>s</cite>. No length field or terminating zero is written." },  { "module": "streams",  "name": "writeln",  "code": "proc writeln*(s: Stream; args: varargs[string, `$`])",  "desc": "writes one or more strings to the the stream <cite>s</cite> followed by a new line. No length field or terminating zero is written." },  { "module": "streams",  "name": "readChar",  "code": "proc readChar*(s: Stream): char",  "desc": "reads a char from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured. Returns '0' as an EOF marker." },  { "module": "streams",  "name": "readBool",  "code": "proc readBool*(s: Stream): bool",  "desc": "reads a bool from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readInt8",  "code": "proc readInt8*(s: Stream): int8",  "desc": "reads an int8 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readInt16",  "code": "proc readInt16*(s: Stream): int16",  "desc": "reads an int16 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readInt32",  "code": "proc readInt32*(s: Stream): int32",  "desc": "reads an int32 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readInt64",  "code": "proc readInt64*(s: Stream): int64",  "desc": "reads an int64 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readFloat32",  "code": "proc readFloat32*(s: Stream): float32",  "desc": "reads a float32 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readFloat64",  "code": "proc readFloat64*(s: Stream): float64",  "desc": "reads a float64 from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readStr",  "code": "proc readStr*(s: Stream; length: int): TaintedString",  "desc": "reads a string of length <cite>length</cite> from the stream <cite>s</cite>. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "readLine",  "code": "proc readLine*(s: Stream; line: var TaintedString): bool",  "desc": "reads a line of text from the stream <cite>s</cite> into <cite>line</cite>. <cite>line</cite> must not be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>! May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string. Returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> if the end of the file has been reached, <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> otherwise. If <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned <cite>line</cite> contains no new data." },  { "module": "streams",  "name": "readLine",  "code": "proc readLine*(s: Stream): TaintedString",  "desc": "Reads a line from a stream <cite>s</cite>. Note: This is not very efficient. Raises <cite>EIO</cite> if an error occured." },  { "module": "streams",  "name": "newStringStream",  "code": "proc newStringStream*(s: string = \"\"): StringStream",  "desc": "creates a new stream from the string <cite>s</cite>." },  { "module": "streams",  "name": "newFileStream",  "code": "proc newFileStream*(f: File): FileStream",  "desc": "creates a new stream from the file <cite>f</cite>." },  { "module": "streams",  "name": "newFileStream",  "code": "proc newFileStream*(filename: string; mode: FileMode): FileStream",  "desc": "creates a new stream from the file named <cite>filename</cite> with the mode <cite>mode</cite>. If the file cannot be opened, nil is returned. See the <a class=\"reference external\" href=\"system.html\">system</a> module for a list of available TFileMode enums." },  { "module": "strtabs",  "name": "len",  "code": "proc len*(t: StringTableRef): int {.rtl, extern: \"nst$1\".}",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "strtabs",  "name": "pairs",  "code": "iterator pairs*(t: StringTableRef): tuple[key, value: string]",  "desc": "iterates over every (key, value) pair in the table <cite>t</cite>." },  { "module": "strtabs",  "name": "keys",  "code": "iterator keys*(t: StringTableRef): string",  "desc": "iterates over every key in the table <cite>t</cite>." },  { "module": "strtabs",  "name": "values",  "code": "iterator values*(t: StringTableRef): string",  "desc": "iterates over every value in the table <cite>t</cite>." },  { "module": "strtabs",  "name": "`[]`",  "code": "proc `[]`*(t: StringTableRef; key: string): string {.rtl, extern: \"nstGet\".}",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, &quot;&quot; is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "strtabs",  "name": "mget",  "code": "proc mget*(t: StringTableRef; key: string): var string {.rtl, extern: \"nstTake\".}",  "desc": "retrieves the location at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "strtabs",  "name": "hasKey",  "code": "proc hasKey*(t: StringTableRef; key: string): bool {.rtl, extern: \"nst$1\".}",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "strtabs",  "name": "`[]=`",  "code": "proc `[]=`*(t: StringTableRef; key, val: string) {.rtl, extern: \"nstPut\".}",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "strtabs",  "name": "newStringTable",  "code": "proc newStringTable*(mode: StringTableMode): StringTableRef {.rtl, \u000A    extern: \"nst$1\".}",  "desc": "creates a new string table that is empty." },  { "module": "strtabs",  "name": "newStringTable",  "code": "proc newStringTable*(keyValuePairs: varargs[string]; mode: StringTableMode): StringTableRef {.\u000A    rtl, extern: \"nst$1WithPairs\".}",  "desc": "creates a new string table with given key value pairs. Example:<pre>var mytab = newStringTable(&quot;key1&quot;, &quot;val1&quot;, &quot;key2&quot;, &quot;val2&quot;,\u000A                           modeCaseInsensitive)</pre>\u000A" },  { "module": "strtabs",  "name": "newStringTable",  "code": "proc newStringTable*(keyValuePairs: varargs[tuple[key, val: string]]; \u000A                     mode: StringTableMode = modeCaseSensitive): StringTableRef {.\u000A    rtl, extern: \"nst$1WithTableConstr\".}",  "desc": "creates a new string table with given key value pairs. Example:<pre>var mytab = newStringTable({&quot;key1&quot;: &quot;val1&quot;, &quot;key2&quot;: &quot;val2&quot;},\u000A                           modeCaseInsensitive)</pre>\u000A" },  { "module": "strtabs",  "name": "`%`",  "code": "proc `%`*(f: string; t: StringTableRef; flags: set[FormatFlag] = {}): string {.\u000A    rtl, extern: \"nstFormat\".}",  "desc": "The <cite>%</cite> operator for string tables." },  { "module": "strtabs",  "name": "`$`",  "code": "proc `$`*(t: StringTableRef): string {.rtl, extern: \"nstDollar\".}",  "desc": "The <cite>$</cite> operator for string tables." },  { "module": "strutils",  "name": "toLower",  "code": "proc toLower*(c: char): char {.noSideEffect, procvar, rtl, \u000A                               extern: \"nsuToLowerChar\".}",  "desc": "<p>Converts <cite>c</cite> into lower case.</p>\u000A<p>This works only for the letters <tt class=\"docutils literal\"><span class=\"pre\">A-Z</span></tt>. See <a class=\"reference external\" href=\"unicode.html#toLower\">unicode.toLower</a> for a version that works for any Unicode character.</p>\u000A" },  { "module": "strutils",  "name": "toLower",  "code": "proc toLower*(s: string): string {.noSideEffect, procvar, rtl, \u000A                                   extern: \"nsuToLowerStr\".}",  "desc": "<p>Converts <cite>s</cite> into lower case.</p>\u000A<p>This works only for the letters <tt class=\"docutils literal\"><span class=\"pre\">A-Z</span></tt>. See <a class=\"reference external\" href=\"unicode.html#toLower\">unicode.toLower</a> for a version that works for any Unicode character.</p>\u000A" },  { "module": "strutils",  "name": "toUpper",  "code": "proc toUpper*(c: char): char {.noSideEffect, procvar, rtl, \u000A                               extern: \"nsuToUpperChar\".}",  "desc": "<p>Converts <cite>c</cite> into upper case.</p>\u000A<p>This works only for the letters <tt class=\"docutils literal\"><span class=\"pre\">A-Z</span></tt>.  See <a class=\"reference external\" href=\"unicode.html#toUpper\">unicode.toUpper</a> for a version that works for any Unicode character.</p>\u000A" },  { "module": "strutils",  "name": "toUpper",  "code": "proc toUpper*(s: string): string {.noSideEffect, procvar, rtl, \u000A                                   extern: \"nsuToUpperStr\".}",  "desc": "<p>Converts <cite>s</cite> into upper case.</p>\u000A<p>This works only for the letters <tt class=\"docutils literal\"><span class=\"pre\">A-Z</span></tt>.  See <a class=\"reference external\" href=\"unicode.html#toUpper\">unicode.toUpper</a> for a version that works for any Unicode character.</p>\u000A" },  { "module": "strutils",  "name": "capitalize",  "code": "proc capitalize*(s: string): string {.noSideEffect, procvar, rtl, \u000A                                      extern: \"nsuCapitalize\".}",  "desc": "<p>Converts the first character of <cite>s</cite> into upper case.</p>\u000A<p>This works only for the letters <tt class=\"docutils literal\"><span class=\"pre\">A-Z</span></tt>.</p>\u000A" },  { "module": "strutils",  "name": "normalize",  "code": "proc normalize*(s: string): string {.noSideEffect, procvar, rtl, \u000A                                     extern: \"nsuNormalize\".}",  "desc": "<p>Normalizes the string <cite>s</cite>.</p>\u000A<p>That means to convert it to lower case and remove any '_'. This is needed for Nim identifiers for example.</p>\u000A" },  { "module": "strutils",  "name": "cmpIgnoreCase",  "code": "proc cmpIgnoreCase*(a, b: string): int {.noSideEffect, rtl, \u000A    extern: \"nsuCmpIgnoreCase\", procvar.}",  "desc": "Compares two strings in a case insensitive manner. Returns:<p>0 iff a == b<br />&lt; 0 iff a &lt; b<br />&gt; 0 iff a &gt; b<br /></p>" },  { "module": "strutils",  "name": "cmpIgnoreStyle",  "code": "proc cmpIgnoreStyle*(a, b: string): int {.noSideEffect, rtl, \u000A    extern: \"nsuCmpIgnoreStyle\", procvar.}",  "desc": "Compares two strings normalized (i.e. case and underscores do not matter). Returns:<p>0 iff a == b<br />&lt; 0 iff a &lt; b<br />&gt; 0 iff a &gt; b<br /></p>" },  { "module": "strutils",  "name": "strip",  "code": "proc strip*(s: string; leading = true; trailing = true): string {.noSideEffect, \u000A    rtl, extern: \"nsuStrip\".}",  "desc": "<p>Strips whitespace from <cite>s</cite> and returns the resulting string.</p>\u000A<p>If <cite>leading</cite> is true, leading whitespace is stripped. If <cite>trailing</cite> is true, trailing whitespace is stripped.</p>\u000A" },  { "module": "strutils",  "name": "toOctal",  "code": "proc toOctal*(c: char): string {.noSideEffect, rtl, extern: \"nsuToOctal\".}",  "desc": "<p>Converts a character <cite>c</cite> to its octal representation.</p>\u000A<p>The resulting string may not have a leading zero. Its length is always exactly 3.</p>\u000A" },  { "module": "strutils",  "name": "split",  "code": "iterator split*(s: string; seps: set[char] = Whitespace): string",  "desc": "<p>Splits the string <cite>s</cite> into substrings using a group of separators.</p>\u000A<p>Substrings are separated by a substring containing only <cite>seps</cite>. Note that whole sequences of characters found in <tt class=\"docutils literal\"><span class=\"pre\">seps</span></tt> will be counted as a single split point and leading/trailing separators will be ignored. The following example:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  this is an  example  &quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>...generates this output:</p>\u000A<pre><span class=\"StringLit\">&quot;this&quot;</span>\u000A<span class=\"StringLit\">&quot;is&quot;</span>\u000A<span class=\"StringLit\">&quot;an&quot;</span>\u000A<span class=\"StringLit\">&quot;example&quot;</span></pre><p>And the following code:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;;;this;is;an;;example;;;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Punctuation\">{</span><span class=\"CharLit\">';'</span><span class=\"Punctuation\">}</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>...produces the same output as the first example. The code:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">date</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;2012-11-20T22:08:08.398990&quot;</span>\u000A<span class=\"Keyword\">let</span> <span class=\"Identifier\">separators</span> <span class=\"Operator\">=</span> <span class=\"Punctuation\">{</span><span class=\"CharLit\">' '</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">'-'</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">':'</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">'T'</span><span class=\"Punctuation\">}</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">number</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">date</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">separators</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">number</span><span class=\"Punctuation\">)</span></pre><p>...results in:</p>\u000A<pre><span class=\"StringLit\">&quot;2012&quot;</span>\u000A<span class=\"StringLit\">&quot;11&quot;</span>\u000A<span class=\"StringLit\">&quot;20&quot;</span>\u000A<span class=\"StringLit\">&quot;22&quot;</span>\u000A<span class=\"StringLit\">&quot;08&quot;</span>\u000A<span class=\"StringLit\">&quot;08.398990&quot;</span></pre>" },  { "module": "strutils",  "name": "split",  "code": "iterator split*(s: string; sep: char): string",  "desc": "<p>Splits the string <cite>s</cite> into substrings using a single separator.</p>\u000A<p>Substrings are separated by the character <cite>sep</cite>. Unlike the version of the iterator which accepts a set of separator characters, this proc will not coalesce groups of the separator, returning a string for each found character. The code:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">split</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;;;this;is;an;;example;;;&quot;</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">';'</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;this&quot;</span>\u000A<span class=\"StringLit\">&quot;is&quot;</span>\u000A<span class=\"StringLit\">&quot;an&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;example&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span></pre>" },  { "module": "strutils",  "name": "split",  "code": "iterator split*(s: string; sep: string): string",  "desc": "<p>Splits the string <cite>s</cite> into substrings using a string separator.</p>\u000A<p>Substrings are separated by the string <cite>sep</cite>.</p>\u000A" },  { "module": "strutils",  "name": "splitLines",  "code": "iterator splitLines*(s: string): string",  "desc": "<p>Splits the string <cite>s</cite> into its containing lines.</p>\u000A<p>Every <a class=\"reference external\" href=\"manual.html#character-literals\">character literal</a> newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing <tt class=\"docutils literal\"><span class=\"pre\">\\n</span></tt>.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">line</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">splitLines</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">this\\n</span><span class=\"EscapeSequence\">is\\n</span><span class=\"EscapeSequence\">an\\n</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">example\\n</span><span class=\"StringLit\">&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">line</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;this&quot;</span>\u000A<span class=\"StringLit\">&quot;is&quot;</span>\u000A<span class=\"StringLit\">&quot;an&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"StringLit\">&quot;example&quot;</span>\u000A<span class=\"StringLit\">&quot;&quot;</span></pre>" },  { "module": "strutils",  "name": "splitLines",  "code": "proc splitLines*(s: string): seq[string] {.noSideEffect, rtl, \u000A    extern: \"nsuSplitLines\".}",  "desc": "The same as the <a class=\"reference external\" href=\"#splitLines.i,string\">splitLines</a> iterator, but is a proc that returns a sequence of substrings." },  { "module": "strutils",  "name": "countLines",  "code": "proc countLines*(s: string): int {.noSideEffect, rtl, extern: \"nsuCountLines\".}",  "desc": "<p>Returns the number of new line separators in the string <cite>s</cite>.</p>\u000A<p>This is the same as <tt class=\"docutils literal\"><span class=\"pre\">len(splitLines(s))</span></tt>, but much more efficient because it doesn't modify the string creating temporal objects. Every <a class=\"reference external\" href=\"manual.html#character-literals\">character literal</a> newline combination (CR, LF, CR-LF) is supported.</p>\u000A<p>Despite its name this proc might not actually return the <em>number of lines</em> in <cite>s</cite> because the concept of what a line is can vary. For example, a string like <tt class=\"docutils literal\"><span class=\"pre\">Hello world</span></tt> is a line of text, but the proc will return a value of zero because there are no newline separators.  Also, text editors usually don't count trailing newline characters in a text file as a new empty line, but this proc will.</p>\u000A" },  { "module": "strutils",  "name": "split",  "code": "proc split*(s: string; seps: set[char] = Whitespace): seq[string] {.\u000A    noSideEffect, rtl, extern: \"nsuSplitCharSet\".}",  "desc": "The same as the <a class=\"reference external\" href=\"#split.i,string,set[char]\">split iterator</a>, but is a proc that returns a sequence of substrings." },  { "module": "strutils",  "name": "split",  "code": "proc split*(s: string; sep: char): seq[string] {.noSideEffect, rtl, \u000A    extern: \"nsuSplitChar\".}",  "desc": "The same as the <a class=\"reference external\" href=\"#split.i,string,char\">split iterator</a>, but is a proc that returns a sequence of substrings." },  { "module": "strutils",  "name": "split",  "code": "proc split*(s: string; sep: string): seq[string] {.noSideEffect, rtl, \u000A    extern: \"nsuSplitString\".}",  "desc": "<p>Splits the string <cite>s</cite> into substrings using a string separator.</p>\u000A<p>Substrings are separated by the string <cite>sep</cite>. This is a wrapper around the <a class=\"reference external\" href=\"#split.i,string,string\">split iterator</a>.</p>\u000A" },  { "module": "strutils",  "name": "toHex",  "code": "proc toHex*(x: BiggestInt; len: int): string {.noSideEffect, rtl, \u000A    extern: \"nsuToHex\".}",  "desc": "<p>Converts <cite>x</cite> to its hexadecimal representation.</p>\u000A<p>The resulting string will be exactly <cite>len</cite> characters long. No prefix like <tt class=\"docutils literal\"><span class=\"pre\">0x</span></tt> is generated. <cite>x</cite> is treated as an unsigned value.</p>\u000A" },  { "module": "strutils",  "name": "intToStr",  "code": "proc intToStr*(x: int; minchars: int = 1): string {.noSideEffect, rtl, \u000A    extern: \"nsuIntToStr\".}",  "desc": "<p>Converts <cite>x</cite> to its decimal representation.</p>\u000A<p>The resulting string will be minimally <cite>minchars</cite> characters long. This is achieved by adding leading zeros.</p>\u000A" },  { "module": "strutils",  "name": "parseInt",  "code": "proc parseInt*(s: string): int {.noSideEffect, procvar, rtl, \u000A                                 extern: \"nsuParseInt\".}",  "desc": "<p>Parses a decimal integer value contained in <cite>s</cite>.</p>\u000A<p>If <cite>s</cite> is not a valid integer, <cite>ValueError</cite> is raised.</p>\u000A" },  { "module": "strutils",  "name": "parseBiggestInt",  "code": "proc parseBiggestInt*(s: string): BiggestInt {.noSideEffect, procvar, rtl, \u000A    extern: \"nsuParseBiggestInt\".}",  "desc": "<p>Parses a decimal integer value contained in <cite>s</cite>.</p>\u000A<p>If <cite>s</cite> is not a valid integer, <cite>ValueError</cite> is raised.</p>\u000A" },  { "module": "strutils",  "name": "parseFloat",  "code": "proc parseFloat*(s: string): float {.noSideEffect, procvar, rtl, \u000A                                     extern: \"nsuParseFloat\".}",  "desc": "Parses a decimal floating point value contained in <cite>s</cite>. If <cite>s</cite> is not a valid floating point number, <cite>ValueError</cite> is raised. <tt class=\"docutils literal\"><span class=\"pre\">NAN</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">INF</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">-INF</span></tt> are also supported (case insensitive comparison)." },  { "module": "strutils",  "name": "parseHexInt",  "code": "proc parseHexInt*(s: string): int {.noSideEffect, procvar, rtl, \u000A                                    extern: \"nsuParseHexInt\".}",  "desc": "<p>Parses a hexadecimal integer value contained in <cite>s</cite>.</p>\u000A<p>If <cite>s</cite> is not a valid integer, <cite>ValueError</cite> is raised. <cite>s</cite> can have one of the following optional prefixes: <tt class=\"docutils literal\"><span class=\"pre\">0x</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">0X</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">#</span></tt>.  Underscores within <cite>s</cite> are ignored.</p>\u000A" },  { "module": "strutils",  "name": "parseBool",  "code": "proc parseBool*(s: string): bool",  "desc": "<p>Parses a value into a <cite>bool</cite>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is one of the following values: <tt class=\"docutils literal\"><span class=\"pre\">y, yes, true, 1, on</span></tt>, then returns <cite>true</cite>. If <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is one of the following values: <tt class=\"docutils literal\"><span class=\"pre\">n, no, false, 0, off</span></tt>, then returns <cite>false</cite>.  If <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is something else a <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> exception is raised.</p>\u000A" },  { "module": "strutils",  "name": "parseEnum",  "code": "proc parseEnum*[T: enum](s: string): T",  "desc": "<p>Parses an enum <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt>.</p>\u000A<p>Raises <tt class=\"docutils literal\"><span class=\"pre\">ValueError</span></tt> for an invalid value in <cite>s</cite>. The comparison is done in a style insensitive way.</p>\u000A" },  { "module": "strutils",  "name": "parseEnum",  "code": "proc parseEnum*[T: enum](s: string; default: T): T",  "desc": "<p>Parses an enum <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt>.</p>\u000A<p>Uses <cite>default</cite> for an invalid value in <cite>s</cite>. The comparison is done in a style insensitive way.</p>\u000A" },  { "module": "strutils",  "name": "repeatChar",  "code": "proc repeatChar*(count: int; c: char = ' '): string {.noSideEffect, rtl, \u000A    extern: \"nsuRepeatChar\".}",  "desc": "Returns a string of length <cite>count</cite> consisting only of the character <cite>c</cite>. You can use this proc to left align strings. Example:<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">width</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">15</span>\u000A  <span class=\"Identifier\">text1</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;Hello user!&quot;</span>\u000A  <span class=\"Identifier\">text2</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;This is a very long string&quot;</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">text1</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">repeatChar</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">max</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">width</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">text1</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;|&quot;</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">text2</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">repeatChar</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">max</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">width</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">text2</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;|&quot;</span></pre>" },  { "module": "strutils",  "name": "repeatStr",  "code": "proc repeatStr*(count: int; s: string): string {.noSideEffect, rtl, \u000A    extern: \"nsuRepeatStr\".}",  "desc": "Returns <cite>s</cite> concatenated <cite>count</cite> times." },  { "module": "strutils",  "name": "align",  "code": "proc align*(s: string; count: int; padding = ' '): string {.noSideEffect, rtl, \u000A    extern: \"nsuAlignString\".}",  "desc": "<p>Aligns a string <cite>s</cite> with <cite>padding</cite>, so that is of length <cite>count</cite>.</p>\u000A<p><cite>padding</cite> characters (by default spaces) are added before <cite>s</cite> resulting in right alignment. If <tt class=\"docutils literal\"><span class=\"pre\">s.len &gt;= count</span></tt>, no spaces are added and <cite>s</cite> is returned unchanged. If you need to left align a string use the <a class=\"reference external\" href=\"#repeatChar\">repeatChar proc</a>. Example:</p>\u000A<pre><span class=\"Identifier\">assert</span> <span class=\"Identifier\">align</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;abc&quot;</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot; abc&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">align</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">0</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;a&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">align</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;1232&quot;</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;  1232&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">align</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;1232&quot;</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">'#'</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;##1232&quot;</span></pre>" },  { "module": "strutils",  "name": "tokenize",  "code": "iterator tokenize*(s: string; seps: set[char] = Whitespace): tuple[\u000A    token: string, isSep: bool]",  "desc": "<p>Tokenizes the string <cite>s</cite> into substrings.</p>\u000A<p>Substrings are separated by a substring containing only <cite>seps</cite>. Examples:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">word</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">tokenize</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  this is an  example  &quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">word</span><span class=\"Punctuation\">)</span></pre><p>Results in:</p>\u000A<pre><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;this&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot; &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;is&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot; &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;an&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;example&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;  &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "strutils",  "name": "wordWrap",  "code": "proc wordWrap*(s: string; maxLineWidth = 80; splitLongWords = true; \u000A               seps: set[char] = Whitespace; newLine = \"\\x0A\"): string {.\u000A    noSideEffect, rtl, extern: \"nsuWordWrap\".}",  "desc": "Word wraps <cite>s</cite>." },  { "module": "strutils",  "name": "unindent",  "code": "proc unindent*(s: string; eatAllIndent = false): string {.noSideEffect, rtl, \u000A    extern: \"nsuUnindent\".}",  "desc": "Unindents <cite>s</cite>." },  { "module": "strutils",  "name": "startsWith",  "code": "proc startsWith*(s, prefix: string): bool {.noSideEffect, rtl, \u000A    extern: \"nsuStartsWith\".}",  "desc": "<p>Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> starts with <tt class=\"docutils literal\"><span class=\"pre\">prefix</span></tt>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">prefix == &quot;&quot;</span></tt> true is returned.</p>\u000A" },  { "module": "strutils",  "name": "endsWith",  "code": "proc endsWith*(s, suffix: string): bool {.noSideEffect, rtl, \u000A    extern: \"nsuEndsWith\".}",  "desc": "<p>Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> ends with <tt class=\"docutils literal\"><span class=\"pre\">suffix</span></tt>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">suffix == &quot;&quot;</span></tt> true is returned.</p>\u000A" },  { "module": "strutils",  "name": "continuesWith",  "code": "proc continuesWith*(s, substr: string; start: int): bool {.noSideEffect, rtl, \u000A    extern: \"nsuContinuesWith\".}",  "desc": "<p>Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> continues with <tt class=\"docutils literal\"><span class=\"pre\">substr</span></tt> at position <tt class=\"docutils literal\"><span class=\"pre\">start</span></tt>.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">substr == &quot;&quot;</span></tt> true is returned.</p>\u000A" },  { "module": "strutils",  "name": "addSep",  "code": "proc addSep*(dest: var string; sep = \", \"; startLen = 0) {.noSideEffect, inline.}",  "desc": "<p>Adds a separator to <cite>dest</cite> only if its length is bigger than <cite>startLen</cite>.</p>\u000A<p>A shorthand for:</p>\u000A<pre><span class=\"Keyword\">if</span> <span class=\"Identifier\">dest</span><span class=\"Operator\">.</span><span class=\"Identifier\">len</span> <span class=\"Operator\">&gt;</span> <span class=\"Identifier\">startLen</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">dest</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">sep</span><span class=\"Punctuation\">)</span></pre><p>This is often useful for generating some code where the items need to be <em>separated</em> by <cite>sep</cite>. <cite>sep</cite> is only added if <cite>dest</cite> is longer than <cite>startLen</cite>. The following example creates a string describing an array of integers:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">arr</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;[&quot;</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">x</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">items</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">7</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">11</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">addSep</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">arr</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">startLen</span><span class=\"Operator\">=</span><span class=\"Identifier\">len</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;[&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">arr</span><span class=\"Punctuation\">,</span> <span class=\"Operator\">$</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">arr</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;]&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "strutils",  "name": "allCharsInSet",  "code": "proc allCharsInSet*(s: string; theSet: set[char]): bool",  "desc": "Returns true iff each character of <cite>s</cite> is in the set <cite>theSet</cite>." },  { "module": "strutils",  "name": "abbrev",  "code": "proc abbrev*(s: string; possibilities: openArray[string]): int",  "desc": "<p>Returns the index of the first item in <cite>possibilities</cite> if not ambiguous.</p>\u000A<p>Returns -1 if no item has been found and -2 if multiple items match.</p>\u000A" },  { "module": "strutils",  "name": "join",  "code": "proc join*(a: openArray[string]; sep: string): string {.noSideEffect, rtl, \u000A    extern: \"nsuJoinSep\".}",  "desc": "Concatenates all strings in <cite>a</cite> separating them with <cite>sep</cite>." },  { "module": "strutils",  "name": "join",  "code": "proc join*(a: openArray[string]): string {.noSideEffect, rtl, extern: \"nsuJoin\".}",  "desc": "Concatenates all strings in <cite>a</cite>." },  { "module": "strutils",  "name": "find",  "code": "proc find*(s, sub: string; start: int = 0): int {.noSideEffect, rtl, \u000A    extern: \"nsuFindStr\".}",  "desc": "<p>Searches for <cite>sub</cite> in <cite>s</cite> starting at position <cite>start</cite>.</p>\u000A<p>Searching is case-sensitive. If <cite>sub</cite> is not in <cite>s</cite>, -1 is returned.</p>\u000A" },  { "module": "strutils",  "name": "find",  "code": "proc find*(s: string; sub: char; start: int = 0): int {.noSideEffect, rtl, \u000A    extern: \"nsuFindChar\".}",  "desc": "<p>Searches for <cite>sub</cite> in <cite>s</cite> starting at position <cite>start</cite>.</p>\u000A<p>Searching is case-sensitive. If <cite>sub</cite> is not in <cite>s</cite>, -1 is returned.</p>\u000A" },  { "module": "strutils",  "name": "find",  "code": "proc find*(s: string; chars: set[char]; start: int = 0): int {.noSideEffect, \u000A    rtl, extern: \"nsuFindCharSet\".}",  "desc": "<p>Searches for <cite>chars</cite> in <cite>s</cite> starting at position <cite>start</cite>.</p>\u000A<p>If <cite>s</cite> contains none of the characters in <cite>chars</cite>, -1 is returned.</p>\u000A" },  { "module": "strutils",  "name": "rfind",  "code": "proc rfind*(s, sub: string; start: int = - 1): int {.noSideEffect.}",  "desc": "<p>Searches for <cite>sub</cite> in <cite>s</cite> in reverse, starting at <cite>start</cite> and going backwards to 0.</p>\u000A<p>Searching is case-sensitive. If <cite>sub</cite> is not in <cite>s</cite>, -1 is returned.</p>\u000A" },  { "module": "strutils",  "name": "rfind",  "code": "proc rfind*(s: string; sub: char; start: int = - 1): int {.noSideEffect, rtl.}",  "desc": "<p>Searches for <cite>sub</cite> in <cite>s</cite> in reverse starting at position <cite>start</cite>.</p>\u000A<p>Searching is case-sensitive. If <cite>sub</cite> is not in <cite>s</cite>, -1 is returned.</p>\u000A" },  { "module": "strutils",  "name": "count",  "code": "proc count*(s: string; sub: string; overlapping: bool = false): int {.\u000A    noSideEffect, rtl, extern: \"nsuCountString\".}",  "desc": "Count the occurences of a substring <cite>sub</cite> in the string <cite>s</cite>. Overlapping occurences of <cite>sub</cite> only count when <cite>overlapping</cite> is set to true." },  { "module": "strutils",  "name": "count",  "code": "proc count*(s: string; sub: char): int {.noSideEffect, rtl, \u000A    extern: \"nsuCountChar\".}",  "desc": "Count the occurences of the character <cite>sub</cite> in the string <cite>s</cite>." },  { "module": "strutils",  "name": "count",  "code": "proc count*(s: string; subs: set[char]): int {.noSideEffect, rtl, \u000A    extern: \"nsuCountCharSet\".}",  "desc": "Count the occurences of the group of character <cite>subs</cite> in the string <cite>s</cite>." },  { "module": "strutils",  "name": "quoteIfContainsWhite",  "code": "proc quoteIfContainsWhite*(s: string): string {.deprecated.}",  "desc": "<p>Returns <tt class=\"docutils literal\"><span class=\"pre\">'&quot;' &amp; s &amp; '&quot;'</span></tt> if <cite>s</cite> contains a space and does not start with a quote, else returns <cite>s</cite>.</p>\u000A<p><strong>DEPRECATED</strong> as it was confused for shell quoting function.  For this application use <a class=\"reference external\" href=\"osproc.html#quoteShell\">osproc.quoteShell</a>.</p>\u000A" },  { "module": "strutils",  "name": "contains",  "code": "proc contains*(s: string; c: char): bool {.noSideEffect.}",  "desc": "Same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, c) &gt;= 0</span></tt>." },  { "module": "strutils",  "name": "contains",  "code": "proc contains*(s, sub: string): bool {.noSideEffect.}",  "desc": "Same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, sub) &gt;= 0</span></tt>." },  { "module": "strutils",  "name": "contains",  "code": "proc contains*(s: string; chars: set[char]): bool {.noSideEffect.}",  "desc": "Same as <tt class=\"docutils literal\"><span class=\"pre\">find(s, chars) &gt;= 0</span></tt>." },  { "module": "strutils",  "name": "replace",  "code": "proc replace*(s, sub: string; by = \"\"): string {.noSideEffect, rtl, \u000A    extern: \"nsuReplaceStr\".}",  "desc": "Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>." },  { "module": "strutils",  "name": "replace",  "code": "proc replace*(s: string; sub, by: char): string {.noSideEffect, rtl, \u000A    extern: \"nsuReplaceChar\".}",  "desc": "<p>Replaces <cite>sub</cite> in <cite>s</cite> by the character <cite>by</cite>.</p>\u000A<p>Optimized version of <a class=\"reference external\" href=\"#replace,string,string\">replace</a> for characters.</p>\u000A" },  { "module": "strutils",  "name": "replaceWord",  "code": "proc replaceWord*(s, sub: string; by = \"\"): string {.noSideEffect, rtl, \u000A    extern: \"nsuReplaceWord\".}",  "desc": "<p>Replaces <cite>sub</cite> in <cite>s</cite> by the string <cite>by</cite>.</p>\u000A<p>Each occurance of <cite>sub</cite> has to be surrounded by word boundaries (comparable to <tt class=\"docutils literal\"><span class=\"pre\">\\\\w</span></tt> in regular expressions), otherwise it is not replaced.</p>\u000A" },  { "module": "strutils",  "name": "delete",  "code": "proc delete*(s: var string; first, last: int) {.noSideEffect, rtl, \u000A    extern: \"nsuDelete\".}",  "desc": "<p>Deletes in <cite>s</cite> the characters at position <cite>first</cite> .. <cite>last</cite>.</p>\u000A<p>This modifies <cite>s</cite> itself, it does not return a copy.</p>\u000A" },  { "module": "strutils",  "name": "parseOctInt",  "code": "proc parseOctInt*(s: string): int {.noSideEffect, rtl, extern: \"nsuParseOctInt\".}",  "desc": "<p>Parses an octal integer value contained in <cite>s</cite>.</p>\u000A<p>If <cite>s</cite> is not a valid integer, <cite>ValueError</cite> is raised. <cite>s</cite> can have one of the following optional prefixes: <tt class=\"docutils literal\"><span class=\"pre\">0o</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">0O</span></tt>.  Underscores within <cite>s</cite> are ignored.</p>\u000A" },  { "module": "strutils",  "name": "toOct",  "code": "proc toOct*(x: BiggestInt; len: int): string {.noSideEffect, rtl, \u000A    extern: \"nsuToOct\".}",  "desc": "<p>Converts <cite>x</cite> into its octal representation.</p>\u000A<p>The resulting string is always <cite>len</cite> characters long. No leading <tt class=\"docutils literal\"><span class=\"pre\">0o</span></tt> prefix is generated.</p>\u000A" },  { "module": "strutils",  "name": "toBin",  "code": "proc toBin*(x: BiggestInt; len: int): string {.noSideEffect, rtl, \u000A    extern: \"nsuToBin\".}",  "desc": "<p>Converts <cite>x</cite> into its binary representation.</p>\u000A<p>The resulting string is always <cite>len</cite> characters long. No leading <tt class=\"docutils literal\"><span class=\"pre\">0b</span></tt> prefix is generated.</p>\u000A" },  { "module": "strutils",  "name": "insertSep",  "code": "proc insertSep*(s: string; sep = '_'; digits = 3): string {.noSideEffect, rtl, \u000A    extern: \"nsuInsertSep\".}",  "desc": "<p>Inserts the separator <cite>sep</cite> after <cite>digits</cite> digits from right to left.</p>\u000A<p>Even though the algorithm works with any string <cite>s</cite>, it is only useful if <cite>s</cite> contains a number. Example: <tt class=\"docutils literal\"><span class=\"pre\">insertSep(&quot;1000000&quot;) == &quot;1_000_000&quot;</span></tt></p>\u000A" },  { "module": "strutils",  "name": "escape",  "code": "proc escape*(s: string; prefix = \"\\\"\"; suffix = \"\\\"\"): string {.noSideEffect, \u000A    rtl, extern: \"nsuEscape\".}",  "desc": "<p>Escapes a string <cite>s</cite>.</p>\u000A<p>This does these operations (at the same time):</p>\u000A<ul class=\"simple\"><li>replaces any <tt class=\"docutils literal\"><span class=\"pre\">\\</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">\\\\</span></tt></li>\u000A<li>replaces any <tt class=\"docutils literal\"><span class=\"pre\">'</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">\\'</span></tt></li>\u000A<li>replaces any <tt class=\"docutils literal\"><span class=\"pre\">&quot;</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">\\&quot;</span></tt></li>\u000A<li>replaces any other character in the set <tt class=\"docutils literal\"><span class=\"pre\">{'\\0'..'\\31', '\\128'..'\\255'}</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">\\xHH</span></tt> where <tt class=\"docutils literal\"><span class=\"pre\">HH</span></tt> is its hexadecimal value.</li>\u000A</ul>\u000A<p>The procedure has been designed so that its output is usable for many different common syntaxes. The resulting string is prefixed with <cite>prefix</cite> and suffixed with <cite>suffix</cite>. Both may be empty strings.</p>\u000A" },  { "module": "strutils",  "name": "unescape",  "code": "proc unescape*(s: string; prefix = \"\\\"\"; suffix = \"\\\"\"): string {.noSideEffect, \u000A    rtl, extern: \"nsuUnescape\".}",  "desc": "<p>Unescapes a string <cite>s</cite>.</p>\u000A<p>This complements <a class=\"reference external\" href=\"#escape\">escape</a> as it performs the opposite operations.</p>\u000A<p>If <cite>s</cite> does not begin with <tt class=\"docutils literal\"><span class=\"pre\">prefix</span></tt> and end with <tt class=\"docutils literal\"><span class=\"pre\">suffix</span></tt> a ValueError exception will be raised.</p>\u000A" },  { "module": "strutils",  "name": "validIdentifier",  "code": "proc validIdentifier*(s: string): bool {.noSideEffect, rtl, \u000A    extern: \"nsuValidIdentifier\".}",  "desc": "<p>Returns true if <cite>s</cite> is a valid identifier.</p>\u000A<p>A valid identifier starts with a character of the set <cite>IdentStartChars</cite> and is followed by any number of characters of the set <cite>IdentChars</cite>.</p>\u000A" },  { "module": "strutils",  "name": "editDistance",  "code": "proc editDistance*(a, b: string): int {.noSideEffect, rtl, \u000A                                        extern: \"nsuEditDistance\".}",  "desc": "<p>Returns the edit distance between <cite>a</cite> and <cite>b</cite>.</p>\u000A<p>This uses the <span id=\"levenshtein_1\">Levenshtein</span> distance algorithm with only a linear memory overhead.  This implementation is highly optimized!</p>\u000A" },  { "module": "strutils",  "name": "formatBiggestFloat",  "code": "proc formatBiggestFloat*(f: BiggestFloat; format: FloatFormatMode = ffDefault; \u000A                         precision: range[0 .. 32] = 16): string {.noSideEffect, \u000A    rtl, extern: \"nsu$1\".}",  "desc": "<p>Converts a floating point value <cite>f</cite> to a string.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">format == ffDecimal</span></tt> then precision is the number of digits to be printed after the decimal point. If <tt class=\"docutils literal\"><span class=\"pre\">format == ffScientific</span></tt> then precision is the maximum number of significant digits to be printed. <cite>precision</cite>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <tt class=\"docutils literal\"><span class=\"pre\">biggestFloat</span></tt> type.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">precision == 0</span></tt>, it tries to format it nicely.</p>\u000A" },  { "module": "strutils",  "name": "formatFloat",  "code": "proc formatFloat*(f: float; format: FloatFormatMode = ffDefault; \u000A                  precision: range[0 .. 32] = 16): string {.noSideEffect, rtl, \u000A    extern: \"nsu$1\".}",  "desc": "<p>Converts a floating point value <cite>f</cite> to a string.</p>\u000A<p>If <tt class=\"docutils literal\"><span class=\"pre\">format == ffDecimal</span></tt> then precision is the number of digits to be printed after the decimal point. If <tt class=\"docutils literal\"><span class=\"pre\">format == ffScientific</span></tt> then precision is the maximum number of significant digits to be printed. <cite>precision</cite>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <tt class=\"docutils literal\"><span class=\"pre\">float</span></tt> type.</p>\u000A" },  { "module": "strutils",  "name": "formatSize",  "code": "proc formatSize*(bytes: BiggestInt; decimalSep = '.'): string",  "desc": "Rounds and formats <cite>bytes</cite>. Examples:<pre><span class=\"Identifier\">formatSize</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1'i64</span> <span class=\"Keyword\">shl</span> <span class=\"DecNumber\">31</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">300'i64</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;2.204GB&quot;</span>\u000A<span class=\"Identifier\">formatSize</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4096</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;4KB&quot;</span></pre>" },  { "module": "strutils",  "name": "addf",  "code": "proc addf*(s: var string; formatstr: string; a: varargs[string, `$`]) {.\u000A    noSideEffect, rtl, extern: \"nsuAddf\".}",  "desc": "The same as <tt class=\"docutils literal\"><span class=\"pre\">add(s, formatstr % a)</span></tt>, but more efficient." },  { "module": "strutils",  "name": "`%`",  "code": "proc `%`*(formatstr: string; a: openArray[string]): string {.noSideEffect, rtl, \u000A    extern: \"nsuFormatOpenArray\".}",  "desc": "<p>Interpolates a format string with the values from <cite>a</cite>.</p>\u000A<p>The <span id=\"substitution_1\">substitution</span> operator performs string substitutions in <cite>formatstr</cite> and returns a modified <cite>formatstr</cite>. This is often called <span id=\"string-interpolation_1\">string interpolation</span>.</p>\u000A<p>This is best explained by an example:</p>\u000A<pre><span class=\"StringLit\">&quot;$1 eats $2.&quot;</span> <span class=\"Operator\">%</span> <span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;The cat&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;fish&quot;</span><span class=\"Punctuation\">]</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;The cat eats fish.&quot;</span></pre><p>The substitution variables (the thing after the <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt>) are enumerated from 1 to <tt class=\"docutils literal\"><span class=\"pre\">a.len</span></tt>. To produce a verbatim <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt>, use <tt class=\"docutils literal\"><span class=\"pre\">$$</span></tt>. The notation <tt class=\"docutils literal\"><span class=\"pre\">$#</span></tt> can be used to refer to the next substitution variable:</p>\u000A<pre><span class=\"StringLit\">&quot;$# eats $#.&quot;</span> <span class=\"Operator\">%</span> <span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;The cat&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;fish&quot;</span><span class=\"Punctuation\">]</span></pre><p>Substitution variables can also be words (that is <tt class=\"docutils literal\"><span class=\"pre\">[A-Za-z_]+[A-Za-z0-9_]*</span></tt>) in which case the arguments in <cite>a</cite> with even indices are keys and with odd indices are the corresponding values. An example:</p>\u000A<pre><span class=\"StringLit\">&quot;$animal eats $food.&quot;</span> <span class=\"Operator\">%</span> <span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;animal&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;The cat&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;food&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;fish&quot;</span><span class=\"Punctuation\">]</span></pre><p>Results in:</p>\u000A<pre><span class=\"StringLit\">&quot;The cat eats fish.&quot;</span></pre><p>The variables are compared with <cite>cmpIgnoreStyle</cite>. <cite>ValueError</cite> is raised if an ill-formed format string has been passed to the <cite>%</cite> operator.</p>\u000A" },  { "module": "strutils",  "name": "`%`",  "code": "proc `%`*(formatstr, a: string): string {.noSideEffect, rtl, \u000A    extern: \"nsuFormatSingleElem\".}",  "desc": "This is the same as <tt class=\"docutils literal\"><span class=\"pre\">formatstr % [a]</span></tt>." },  { "module": "strutils",  "name": "format",  "code": "proc format*(formatstr: string; a: varargs[string, `$`]): string {.noSideEffect, \u000A    rtl, extern: \"nsuFormatVarargs\".}",  "desc": "This is the same as <tt class=\"docutils literal\"><span class=\"pre\">formatstr % a</span></tt> except that it supports auto stringification." },  { "module": "subexes",  "name": "subex",  "code": "proc subex*(s: string): Subex",  "desc": "constructs a <em>substitution expression</em> from <cite>s</cite>. Currently this performs no syntax checking but this may change in later versions." },  { "module": "subexes",  "name": "addf",  "code": "proc addf*(s: var string; formatstr: Subex; a: varargs[string, `$`]) {.\u000A    noSideEffect, rtl, extern: \"nfrmtAddf\".}",  "desc": "The same as <tt class=\"docutils literal\"><span class=\"pre\">add(s, formatstr % a)</span></tt>, but more efficient." },  { "module": "subexes",  "name": "`%`",  "code": "proc `%`*(formatstr: Subex; a: openarray[string]): string {.noSideEffect, rtl, \u000A    extern: \"nfrmtFormatOpenArray\".}",  "desc": "The <span id=\"substitution_1\">substitution</span> operator performs string substitutions in <cite>formatstr</cite> and returns a modified <cite>formatstr</cite>. This is often called <span id=\"string-interpolation_1\">string interpolation</span>. " },  { "module": "subexes",  "name": "`%`",  "code": "proc `%`*(formatstr: Subex; a: string): string {.noSideEffect, rtl, \u000A    extern: \"nfrmtFormatSingleElem\".}",  "desc": "This is the same as <tt class=\"docutils literal\"><span class=\"pre\">formatstr % [a]</span></tt>." },  { "module": "subexes",  "name": "format",  "code": "proc format*(formatstr: Subex; a: varargs[string, `$`]): string {.noSideEffect, \u000A    rtl, extern: \"nfrmtFormatVarargs\".}",  "desc": "The <span id=\"substitution_2\">substitution</span> operator performs string substitutions in <cite>formatstr</cite> and returns a modified <cite>formatstr</cite>. This is often called <span id=\"string-interpolation_2\">string interpolation</span>. " },  { "module": "system",  "name": "defined",  "code": "proc defined*(x: expr): bool {.magic: \"Defined\", noSideEffect.}",  "desc": "Special compile-time procedure that checks whether <cite>x</cite> is defined. <cite>x</cite> is an external symbol introduced through the compiler's <a class=\"reference external\" href=\"nimc.html#compile-time-symbols\">-d:x switch</a> to enable build time conditionals:<pre><span class=\"Keyword\">when</span> <span class=\"Keyword\">not</span> <span class=\"Identifier\">defined</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">release</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># Do here programmer friendly expensive sanity checks.</span>\u000A<span class=\"Comment\"># Put here the normal code</span></pre>" },  { "module": "system",  "name": "declared",  "code": "proc declared*(x: expr): bool {.magic: \"Defined\", noSideEffect.}",  "desc": "Special compile-time procedure that checks whether <cite>x</cite> is declared. <cite>x</cite> has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:<pre><span class=\"Keyword\">when</span> <span class=\"Keyword\">not</span> <span class=\"Identifier\">defined</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">strutils</span><span class=\"Operator\">.</span><span class=\"Identifier\">toUpper</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Comment\"># provide our own toUpper proc here, because strutils is</span>\u000A  <span class=\"Comment\"># missing it.</span></pre>" },  { "module": "system",  "name": "definedInScope",  "code": "proc definedInScope*(x: expr): bool {.magic: \"DefinedInScope\", noSideEffect, \u000A                                      deprecated.}",  "desc": "<strong>Deprecated since version 0.9.6</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">declaredInScope</span></tt> instead." },  { "module": "system",  "name": "declaredInScope",  "code": "proc declaredInScope*(x: expr): bool {.magic: \"DefinedInScope\", noSideEffect.}",  "desc": "Special compile-time procedure that checks whether <cite>x</cite> is declared in the current scope. <cite>x</cite> has to be an identifier." },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: bool): bool {.magic: \"Not\", noSideEffect.}",  "desc": "Boolean not; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x == false</span></tt>." },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: bool): bool {.magic: \"And\", noSideEffect.}",  "desc": "Boolean <tt class=\"docutils literal\"><span class=\"pre\">and</span></tt>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x == y == true</span></tt>. Evaluation is lazy: if <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> is false, <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> will not even be evaluated." },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: bool): bool {.magic: \"Or\", noSideEffect.}",  "desc": "Boolean <tt class=\"docutils literal\"><span class=\"pre\">or</span></tt>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">not (not x and not y)</span></tt>. Evaluation is lazy: if <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> is true, <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> will not even be evaluated." },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: bool): bool {.magic: \"Xor\", noSideEffect.}",  "desc": "Boolean <cite>exclusive or</cite>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x != y</span></tt>." },  { "module": "system",  "name": "new",  "code": "proc new*[T](a: var ref T) {.magic: \"New\", noSideEffect.}",  "desc": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>." },  { "module": "system",  "name": "new",  "code": "proc new*(T: typedesc): ref T",  "desc": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it as result value" },  { "module": "system",  "name": "unsafeNew",  "code": "proc unsafeNew*[T](a: var ref T; size: int) {.magic: \"New\", noSideEffect.}",  "desc": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>. This is <strong>unsafe</strong> as it allocates an object of the passed <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt>. This should only be used for optimization purposes when you know what you're doing!" },  { "module": "system",  "name": "internalNew",  "code": "proc internalNew*[T](a: var ref T) {.magic: \"New\", noSideEffect.}",  "desc": "leaked implementation detail. Do not use." },  { "module": "system",  "name": "new",  "code": "proc new*[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.\u000A    magic: \"NewFinalize\", noSideEffect.}",  "desc": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>. When the garbage collector frees the object, <cite>finalizer</cite> is called. The <cite>finalizer</cite> may not keep a reference to the object pointed to by <cite>x</cite>. The <cite>finalizer</cite> cannot prevent the GC from freeing the object. Note: The <cite>finalizer</cite> refers to the type <cite>T</cite>, not to the object! This means that for each object of type <cite>T</cite> the finalizer will be called!" },  { "module": "system",  "name": "reset",  "code": "proc reset*[T](obj: var T) {.magic: \"Reset\", noSideEffect.}",  "desc": "resets an object <cite>obj</cite> to its initial (binary zero) value. This needs to be called before any possible <span id=\"object-branch-transition_1\">object branch transition</span>." },  { "module": "system",  "name": "high",  "code": "proc high*[T](x: T): T {.magic: \"High\", noSideEffect.}",  "desc": "returns the highest possible index of an array, a sequence, a string or the highest possible value of an ordinal value <cite>x</cite>. As a special semantic rule, <cite>x</cite> may also be a type identifier. <tt class=\"docutils literal\"><span class=\"pre\">high(int)</span></tt> is Nim's way of writing <span id=\"int-max_1\">INT_MAX</span> or <span id=\"max-int_1\">MAX_INT</span>." },  { "module": "system",  "name": "low",  "code": "proc low*[T](x: T): T {.magic: \"Low\", noSideEffect.}",  "desc": "returns the lowest possible index of an array, a sequence, a string or the lowest possible value of an ordinal value <cite>x</cite>. As a special semantic rule, <cite>x</cite> may also be a type identifier." },  { "module": "system",  "name": "`..`",  "code": "proc `..`*[T](a, b: T): Slice[T] {.noSideEffect, inline.}",  "desc": "<span id=\"slice_1\">slice</span> operator that constructs an interval <tt class=\"docutils literal\"><span class=\"pre\">[a, b]</span></tt>, both <cite>a</cite> and <cite>b</cite> are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler." },  { "module": "system",  "name": "`..`",  "code": "proc `..`*[T](b: T): Slice[T] {.noSideEffect, inline.}",  "desc": "<span id=\"slice_2\">slice</span> operator that constructs an interval <tt class=\"docutils literal\"><span class=\"pre\">[default(T), b]</span></tt>" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[TEnum: enum](x, y: TEnum): bool {.magic: \"EqEnum\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: pointer): bool {.magic: \"EqRef\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: string): bool {.magic: \"EqStr\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: cstring): bool {.magic: \"EqCString\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: char): bool {.magic: \"EqCh\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: bool): bool {.magic: \"EqB\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T](x, y: set[T]): bool {.magic: \"EqSet\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T](x, y: ref T): bool {.magic: \"EqRef\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T](x, y: ptr T): bool {.magic: \"EqRef\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T: proc](x, y: T): bool {.magic: \"EqProc\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*[TEnum: enum](x, y: TEnum): bool {.magic: \"LeEnum\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: string): bool {.magic: \"LeStr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: char): bool {.magic: \"LeCh\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*[T](x, y: set[T]): bool {.magic: \"LeSet\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: bool): bool {.magic: \"LeB\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*[T](x, y: ref T): bool {.magic: \"LePtr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: pointer): bool {.magic: \"LePtr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[TEnum: enum](x, y: TEnum): bool {.magic: \"LtEnum\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: string): bool {.magic: \"LtStr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: char): bool {.magic: \"LtCh\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[T](x, y: set[T]): bool {.magic: \"LtSet\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: bool): bool {.magic: \"LtB\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[T](x, y: ref T): bool {.magic: \"LtPtr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[T](x, y: ptr T): bool {.magic: \"LtPtr\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: pointer): bool {.magic: \"LtPtr\", noSideEffect.}" },  { "module": "system",  "name": "`!=`",  "code": "template `!=`*(x, y: expr): expr {.immediate.}",  "desc": "unequals operator. This is a shorthand for <tt class=\"docutils literal\"><span class=\"pre\">not (x == y)</span></tt>." },  { "module": "system",  "name": "`&gt;=`",  "code": "template `>=`*(x, y: expr): expr {.immediate.}",  "desc": "&quot;is greater or equals&quot; operator. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">y &lt;= x</span></tt>." },  { "module": "system",  "name": "`&gt;`",  "code": "template `>`*(x, y: expr): expr {.immediate.}",  "desc": "&quot;is greater&quot; operator. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">y &lt; x</span></tt>." },  { "module": "system",  "name": "sizeof",  "code": "proc sizeof*[T](x: T): Natural {.magic: \"SizeOf\", noSideEffect.}",  "desc": "returns the size of <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> in bytes. Since this is a low-level proc, its usage is discouraged - using <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt> for the most cases suffices that one never needs to know <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>'s size. As a special semantic rule, <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> may also be a type identifier (<tt class=\"docutils literal\"><span class=\"pre\">sizeof(int)</span></tt> is valid)." },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[T](x: Ordinal[T]): T {.magic: \"UnaryLt\", noSideEffect.}",  "desc": "unary <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> that can be used for nice looking excluding ranges:<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">i</span> <span class=\"Keyword\">in</span> <span class=\"DecNumber\">0</span> <span class=\"Operator\">..</span> <span class=\"Operator\">&lt;</span><span class=\"DecNumber\">10</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">echo</span> <span class=\"Identifier\">i</span></pre><p>Semantically this is the same as <tt class=\"docutils literal\"><span class=\"pre\">pred</span></tt>. </p>\u000A" },  { "module": "system",  "name": "succ",  "code": "proc succ*[T](x: Ordinal[T]; y = 1): T {.magic: \"Succ\", noSideEffect.}",  "desc": "returns the <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>-th successor of the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> has to be an ordinal type. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs." },  { "module": "system",  "name": "pred",  "code": "proc pred*[T](x: Ordinal[T]; y = 1): T {.magic: \"Pred\", noSideEffect.}",  "desc": "returns the <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>-th predecessor of the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> has to be an ordinal type. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs." },  { "module": "system",  "name": "inc",  "code": "proc inc*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: \"Inc\", \u000A    noSideEffect.}",  "desc": "increments the ordinal <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs. This is a short notation for: <tt class=\"docutils literal\"><span class=\"pre\">x = succ(x, y)</span></tt>." },  { "module": "system",  "name": "dec",  "code": "proc dec*[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: \"Dec\", \u000A    noSideEffect.}",  "desc": "decrements the ordinal <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs. This is a short notation for: <tt class=\"docutils literal\"><span class=\"pre\">x = pred(x, y)</span></tt>." },  { "module": "system",  "name": "newSeq",  "code": "proc newSeq*[T](s: var seq[T]; len: int) {.magic: \"NewSeq\", noSideEffect.}",  "desc": "<p>creates a new sequence of type <tt class=\"docutils literal\"><span class=\"pre\">seq[T]</span></tt> with length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>. This is equivalent to <tt class=\"docutils literal\"><span class=\"pre\">s = @[]; setlen(s, len)</span></tt>, but more efficient since no reallocation is needed.</p>\u000A<p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">inputStrings</span> <span class=\"Punctuation\">:</span> <span class=\"Identifier\">seq</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">newSeq</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;The fourth&quot;</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;assignment&quot;</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;would crash&quot;</span>\u000A<span class=\"Comment\">#inputStrings[3] = &quot;out of bounds&quot;</span></pre>" },  { "module": "system",  "name": "newSeq",  "code": "proc newSeq*[T](len = 0): seq[T]",  "desc": "<p>creates a new sequence of type <tt class=\"docutils literal\"><span class=\"pre\">seq[T]</span></tt> with length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>.</p>\u000A<p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">inputStrings</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newSeq</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;The fourth&quot;</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;assignment&quot;</span>\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;would crash&quot;</span>\u000A<span class=\"Comment\">#inputStrings[3] = &quot;out of bounds&quot;</span></pre>" },  { "module": "system",  "name": "len",  "code": "proc len*[TOpenArray: openArray | varargs](x: TOpenArray): int {.\u000A    magic: \"LengthOpenArray\", noSideEffect.}" },  { "module": "system",  "name": "len",  "code": "proc len*(x: string): int {.magic: \"LengthStr\", noSideEffect.}" },  { "module": "system",  "name": "len",  "code": "proc len*(x: cstring): int {.magic: \"LengthStr\", noSideEffect.}" },  { "module": "system",  "name": "len",  "code": "proc len*[I, T](x: array[I, T]): int {.magic: \"LengthArray\", noSideEffect.}" },  { "module": "system",  "name": "len",  "code": "proc len*[T](x: seq[T]): int {.magic: \"LengthSeq\", noSideEffect.}",  "desc": "returns the length of an array, an openarray, a sequence or a string. This is rougly the same as <tt class=\"docutils literal\"><span class=\"pre\">high(T)-low(T)+1</span></tt>, but its resulting type is always an int." },  { "module": "system",  "name": "incl",  "code": "proc incl*[T](x: var set[T]; y: T) {.magic: \"Incl\", noSideEffect.}",  "desc": "includes element <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> to the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x = x + {y}</span></tt>, but it might be more efficient." },  { "module": "system",  "name": "incl",  "code": "template incl*[T](s: var set[T]; flags: set[T])",  "desc": "includes the set of flags to the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>." },  { "module": "system",  "name": "excl",  "code": "proc excl*[T](x: var set[T]; y: T) {.magic: \"Excl\", noSideEffect.}",  "desc": "excludes element <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> to the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x = x - {y}</span></tt>, but it might be more efficient." },  { "module": "system",  "name": "excl",  "code": "template excl*[T](s: var set[T]; flags: set[T])",  "desc": "excludes the set of flags to <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>." },  { "module": "system",  "name": "card",  "code": "proc card*[T](x: set[T]): int {.magic: \"Card\", noSideEffect.}",  "desc": "returns the cardinality of the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>, i.e. the number of elements in the set." },  { "module": "system",  "name": "ord",  "code": "proc ord*[T](x: T): int {.magic: \"Ord\", noSideEffect.}",  "desc": "returns the internal int value of an ordinal value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>." },  { "module": "system",  "name": "chr",  "code": "proc chr*(u: range[0 .. 255]): char {.magic: \"Chr\", noSideEffect.}",  "desc": "converts an int in the range 0..255 to a character." },  { "module": "system",  "name": "ze",  "code": "proc ze*(x: int8): int {.magic: \"Ze8ToI\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. This treats <cite>x</cite> as unsigned." },  { "module": "system",  "name": "ze",  "code": "proc ze*(x: int16): int {.magic: \"Ze16ToI\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. This treats <cite>x</cite> as unsigned." },  { "module": "system",  "name": "ze64",  "code": "proc ze64*(x: int8): int64 {.magic: \"Ze8ToI64\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned." },  { "module": "system",  "name": "ze64",  "code": "proc ze64*(x: int16): int64 {.magic: \"Ze16ToI64\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned." },  { "module": "system",  "name": "ze64",  "code": "proc ze64*(x: int32): int64 {.magic: \"Ze32ToI64\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned." },  { "module": "system",  "name": "ze64",  "code": "proc ze64*(x: int): int64 {.magic: \"ZeIToI64\", noSideEffect.}",  "desc": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned. Does nothing if the size of an <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt> is the same as <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. (This is the case on 64 bit processors.)" },  { "module": "system",  "name": "toU8",  "code": "proc toU8*(x: int): int8 {.magic: \"ToU8\", noSideEffect.}",  "desc": "treats <cite>x</cite> as unsigned and converts it to a byte by taking the last 8 bits from <cite>x</cite>.    " },  { "module": "system",  "name": "toU16",  "code": "proc toU16*(x: int): int16 {.magic: \"ToU16\", noSideEffect.}",  "desc": "treats <cite>x</cite> as unsigned and converts it to an <tt class=\"docutils literal\"><span class=\"pre\">int16</span></tt> by taking the last 16 bits from <cite>x</cite>." },  { "module": "system",  "name": "toU32",  "code": "proc toU32*(x: int64): int32 {.magic: \"ToU32\", noSideEffect.}",  "desc": "treats <cite>x</cite> as unsigned and converts it to an <tt class=\"docutils literal\"><span class=\"pre\">int32</span></tt> by taking the last 32 bits from <cite>x</cite>." },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: int): int {.magic: \"UnaryPlusI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: int8): int8 {.magic: \"UnaryPlusI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: int16): int16 {.magic: \"UnaryPlusI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: int32): int32 {.magic: \"UnaryPlusI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: int64): int64 {.magic: \"UnaryPlusI64\", noSideEffect.}",  "desc": "Unary <cite>+</cite> operator for an integer. Has no effect." },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: int): int {.magic: \"UnaryMinusI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: int8): int8 {.magic: \"UnaryMinusI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: int16): int16 {.magic: \"UnaryMinusI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: int32): int32 {.magic: \"UnaryMinusI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: int64): int64 {.magic: \"UnaryMinusI64\", noSideEffect.}",  "desc": "Unary <cite>-</cite> operator for an integer. Negates <cite>x</cite>." },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: int): int {.magic: \"BitnotI\", noSideEffect.}" },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: int8): int8 {.magic: \"BitnotI\", noSideEffect.}" },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: int16): int16 {.magic: \"BitnotI\", noSideEffect.}" },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: int32): int32 {.magic: \"BitnotI\", noSideEffect.}" },  { "module": "system",  "name": "`not`",  "code": "proc `not`*(x: int64): int64 {.magic: \"BitnotI64\", noSideEffect.}",  "desc": "computes the <cite>bitwise complement</cite> of the integer <cite>x</cite>." },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: int): int {.magic: \"AddI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: int8): int8 {.magic: \"AddI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: int16): int16 {.magic: \"AddI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: int32): int32 {.magic: \"AddI\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: int64): int64 {.magic: \"AddI64\", noSideEffect.}",  "desc": "Binary <cite>+</cite> operator for an integer." },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: int): int {.magic: \"SubI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: int8): int8 {.magic: \"SubI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: int16): int16 {.magic: \"SubI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: int32): int32 {.magic: \"SubI\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: int64): int64 {.magic: \"SubI64\", noSideEffect.}",  "desc": "Binary <cite>-</cite> operator for an integer." },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: int): int {.magic: \"MulI\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: int8): int8 {.magic: \"MulI\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: int16): int16 {.magic: \"MulI\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: int32): int32 {.magic: \"MulI\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: int64): int64 {.magic: \"MulI64\", noSideEffect.}",  "desc": "Binary <cite>*</cite> operator for an integer." },  { "module": "system",  "name": "`div`",  "code": "proc `div`*(x, y: int): int {.magic: \"DivI\", noSideEffect.}" },  { "module": "system",  "name": "`div`",  "code": "proc `div`*(x, y: int8): int8 {.magic: \"DivI\", noSideEffect.}" },  { "module": "system",  "name": "`div`",  "code": "proc `div`*(x, y: int16): int16 {.magic: \"DivI\", noSideEffect.}" },  { "module": "system",  "name": "`div`",  "code": "proc `div`*(x, y: int32): int32 {.magic: \"DivI\", noSideEffect.}" },  { "module": "system",  "name": "`div`",  "code": "proc `div`*(x, y: int64): int64 {.magic: \"DivI64\", noSideEffect.}",  "desc": "computes the integer division. This is roughly the same as <tt class=\"docutils literal\"><span class=\"pre\">floor(x/y)</span></tt>. .. code-block:: Nim<blockquote><p>1 div 2 == 0 2 div 2 == 1 3 div 2 == 1</p></blockquote>\u000A" },  { "module": "system",  "name": "`mod`",  "code": "proc `mod`*(x, y: int): int {.magic: \"ModI\", noSideEffect.}" },  { "module": "system",  "name": "`mod`",  "code": "proc `mod`*(x, y: int8): int8 {.magic: \"ModI\", noSideEffect.}" },  { "module": "system",  "name": "`mod`",  "code": "proc `mod`*(x, y: int16): int16 {.magic: \"ModI\", noSideEffect.}" },  { "module": "system",  "name": "`mod`",  "code": "proc `mod`*(x, y: int32): int32 {.magic: \"ModI\", noSideEffect.}" },  { "module": "system",  "name": "`mod`",  "code": "proc `mod`*(x, y: int64): int64 {.magic: \"ModI64\", noSideEffect.}",  "desc": "computes the integer modulo operation. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x - (x div y) * y</span></tt>." },  { "module": "system",  "name": "`shr`",  "code": "proc `shr`*(x, y: int): int {.magic: \"ShrI\", noSideEffect.}" },  { "module": "system",  "name": "`shr`",  "code": "proc `shr`*(x, y: int8): int8 {.magic: \"ShrI\", noSideEffect.}" },  { "module": "system",  "name": "`shr`",  "code": "proc `shr`*(x, y: int16): int16 {.magic: \"ShrI\", noSideEffect.}" },  { "module": "system",  "name": "`shr`",  "code": "proc `shr`*(x, y: int32): int32 {.magic: \"ShrI\", noSideEffect.}" },  { "module": "system",  "name": "`shr`",  "code": "proc `shr`*(x, y: int64): int64 {.magic: \"ShrI64\", noSideEffect.}",  "desc": "computes the <cite>shift right</cite> operation of <cite>x</cite> and <cite>y</cite>. .. code-block:: Nim<blockquote><p>0b0001_0000'i8 shr 2 == 0b0100_0000'i8 0b1000_0000'i8 shr 2 == 0b0000_0000'i8 0b0000_0001'i8 shr 9 == 0b0000_0000'i8</p></blockquote>\u000A" },  { "module": "system",  "name": "`shl`",  "code": "proc `shl`*(x, y: int): int {.magic: \"ShlI\", noSideEffect.}" },  { "module": "system",  "name": "`shl`",  "code": "proc `shl`*(x, y: int8): int8 {.magic: \"ShlI\", noSideEffect.}" },  { "module": "system",  "name": "`shl`",  "code": "proc `shl`*(x, y: int16): int16 {.magic: \"ShlI\", noSideEffect.}" },  { "module": "system",  "name": "`shl`",  "code": "proc `shl`*(x, y: int32): int32 {.magic: \"ShlI\", noSideEffect.}" },  { "module": "system",  "name": "`shl`",  "code": "proc `shl`*(x, y: int64): int64 {.magic: \"ShlI64\", noSideEffect.}",  "desc": "computes the <cite>shift left</cite> operation of <cite>x</cite> and <cite>y</cite>." },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: int): int {.magic: \"BitandI\", noSideEffect.}" },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: int8): int8 {.magic: \"BitandI\", noSideEffect.}" },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: int16): int16 {.magic: \"BitandI\", noSideEffect.}" },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: int32): int32 {.magic: \"BitandI\", noSideEffect.}" },  { "module": "system",  "name": "`and`",  "code": "proc `and`*(x, y: int64): int64 {.magic: \"BitandI64\", noSideEffect.}",  "desc": "computes the <cite>bitwise and</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: int): int {.magic: \"BitorI\", noSideEffect.}" },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: int8): int8 {.magic: \"BitorI\", noSideEffect.}" },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: int16): int16 {.magic: \"BitorI\", noSideEffect.}" },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: int32): int32 {.magic: \"BitorI\", noSideEffect.}" },  { "module": "system",  "name": "`or`",  "code": "proc `or`*(x, y: int64): int64 {.magic: \"BitorI64\", noSideEffect.}",  "desc": "computes the <cite>bitwise or</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: int): int {.magic: \"BitxorI\", noSideEffect.}" },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: int8): int8 {.magic: \"BitxorI\", noSideEffect.}" },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: int16): int16 {.magic: \"BitxorI\", noSideEffect.}" },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: int32): int32 {.magic: \"BitxorI\", noSideEffect.}" },  { "module": "system",  "name": "`xor`",  "code": "proc `xor`*(x, y: int64): int64 {.magic: \"BitxorI64\", noSideEffect.}",  "desc": "computes the <cite>bitwise xor</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: int): bool {.magic: \"EqI\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: int8): bool {.magic: \"EqI\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: int16): bool {.magic: \"EqI\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: int32): bool {.magic: \"EqI\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: int64): bool {.magic: \"EqI64\", noSideEffect.}",  "desc": "Compares two integers for equality." },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: int): bool {.magic: \"LeI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: int8): bool {.magic: \"LeI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: int16): bool {.magic: \"LeI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: int32): bool {.magic: \"LeI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: int64): bool {.magic: \"LeI64\", noSideEffect.}",  "desc": "Returns true iff <cite>x</cite> is less than or equal to <cite>y</cite>." },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: int): bool {.magic: \"LtI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: int8): bool {.magic: \"LtI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: int16): bool {.magic: \"LtI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: int32): bool {.magic: \"LtI\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: int64): bool {.magic: \"LtI64\", noSideEffect.}",  "desc": "Returns true iff <cite>x</cite> is less than <cite>y</cite>." },  { "module": "system",  "name": "`+%`",  "code": "proc `+%`*(x, y: IntMax32): IntMax32 {.magic: \"AddU\", noSideEffect.}" },  { "module": "system",  "name": "`+%`",  "code": "proc `+%`*(x, y: int64): int64 {.magic: \"AddU\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible." },  { "module": "system",  "name": "`-%`",  "code": "proc `-%`*(x, y: IntMax32): IntMax32 {.magic: \"SubU\", noSideEffect.}" },  { "module": "system",  "name": "`-%`",  "code": "proc `-%`*(x, y: int64): int64 {.magic: \"SubU\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible." },  { "module": "system",  "name": "`*%`",  "code": "proc `*%`*(x, y: IntMax32): IntMax32 {.magic: \"MulU\", noSideEffect.}" },  { "module": "system",  "name": "`*%`",  "code": "proc `*%`*(x, y: int64): int64 {.magic: \"MulU\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible." },  { "module": "system",  "name": "`/%`",  "code": "proc `/%`*(x, y: IntMax32): IntMax32 {.magic: \"DivU\", noSideEffect.}" },  { "module": "system",  "name": "`/%`",  "code": "proc `/%`*(x, y: int64): int64 {.magic: \"DivU\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible." },  { "module": "system",  "name": "`%%`",  "code": "proc `%%`*(x, y: IntMax32): IntMax32 {.magic: \"ModU\", noSideEffect.}" },  { "module": "system",  "name": "`%%`",  "code": "proc `%%`*(x, y: int64): int64 {.magic: \"ModU\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compute the modulo of <cite>x</cite> and <cite>y</cite>. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible." },  { "module": "system",  "name": "`&lt;=%`",  "code": "proc `<=%`*(x, y: IntMax32): bool {.magic: \"LeU\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=%`",  "code": "proc `<=%`*(x, y: int64): bool {.magic: \"LeU64\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &lt;= unsigned(y)</span></tt>." },  { "module": "system",  "name": "`&lt;%`",  "code": "proc `<%`*(x, y: IntMax32): bool {.magic: \"LtU\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;%`",  "code": "proc `<%`*(x, y: int64): bool {.magic: \"LtU64\", noSideEffect.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &lt; unsigned(y)</span></tt>." },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: float32): float32 {.magic: \"UnaryPlusF64\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: float32): float32 {.magic: \"UnaryMinusF64\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: float32): float32 {.magic: \"AddF64\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: float32): float32 {.magic: \"SubF64\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: float32): float32 {.magic: \"MulF64\", noSideEffect.}" },  { "module": "system",  "name": "`/`",  "code": "proc `/`*(x, y: float32): float32 {.magic: \"DivF64\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x: float): float {.magic: \"UnaryPlusF64\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x: float): float {.magic: \"UnaryMinusF64\", noSideEffect.}" },  { "module": "system",  "name": "`+`",  "code": "proc `+`*(x, y: float): float {.magic: \"AddF64\", noSideEffect.}" },  { "module": "system",  "name": "`-`",  "code": "proc `-`*(x, y: float): float {.magic: \"SubF64\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*(x, y: float): float {.magic: \"MulF64\", noSideEffect.}" },  { "module": "system",  "name": "`/`",  "code": "proc `/`*(x, y: float): float {.magic: \"DivF64\", noSideEffect.}",  "desc": "computes the floating point division" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: float32): bool {.magic: \"EqF64\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: float32): bool {.magic: \"LeF64\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: float32): bool {.magic: \"LtF64\", noSideEffect.}" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*(x, y: float): bool {.magic: \"EqF64\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*(x, y: float): bool {.magic: \"LeF64\", noSideEffect.}" },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*(x, y: float): bool {.magic: \"LtF64\", noSideEffect.}" },  { "module": "system",  "name": "`*`",  "code": "proc `*`*[T](x, y: set[T]): set[T] {.magic: \"MulSet\", noSideEffect.}",  "desc": "This operator computes the intersection of two sets." },  { "module": "system",  "name": "`+`",  "code": "proc `+`*[T](x, y: set[T]): set[T] {.magic: \"PlusSet\", noSideEffect.}",  "desc": "This operator computes the union of two sets." },  { "module": "system",  "name": "`-`",  "code": "proc `-`*[T](x, y: set[T]): set[T] {.magic: \"MinusSet\", noSideEffect.}",  "desc": "This operator computes the difference of two sets." },  { "module": "system",  "name": "contains",  "code": "proc contains*[T](x: set[T]; y: T): bool {.magic: \"InSet\", noSideEffect.}",  "desc": "One should overload this proc if one wants to overload the <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> operator. The parameters are in reverse order! <tt class=\"docutils literal\"><span class=\"pre\">a in b</span></tt> is a template for <tt class=\"docutils literal\"><span class=\"pre\">contains(b, a)</span></tt>. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> operator that would be the wrong direction for this piece of code:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">set</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">range</span><span class=\"Punctuation\">[</span><span class=\"CharLit\">'a'</span><span class=\"Operator\">..</span><span class=\"CharLit\">'z'</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"Punctuation\">{</span><span class=\"CharLit\">'a'</span><span class=\"Operator\">..</span><span class=\"CharLit\">'c'</span><span class=\"Punctuation\">}</span>\u000A<span class=\"Identifier\">writeln</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctuation\">,</span> <span class=\"CharLit\">'b'</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">s</span><span class=\"Punctuation\">)</span></pre><p>If <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> had been declared as <tt class=\"docutils literal\"><span class=\"pre\">[T](elem: T, s: set[T])</span></tt> then <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> would have been bound to <tt class=\"docutils literal\"><span class=\"pre\">char</span></tt>. But <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is not compatible to type <tt class=\"docutils literal\"><span class=\"pre\">set[char]</span></tt>! The solution is to bind <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">range['a'..'z']</span></tt>. This is achieved by reversing the parameters for <tt class=\"docutils literal\"><span class=\"pre\">contains</span></tt>; <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> then passes its arguments in reverse order.</p>\u000A" },  { "module": "system",  "name": "contains",  "code": "proc contains*[T](s: Slice[T]; value: T): bool {.noSideEffect, inline.}",  "desc": "Checks if <cite>value</cite> is withing the range of <cite>s</cite>; returns true iff <cite>value &gt;= s.a and value &lt;= s.b</cite><pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">contains</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`in`",  "code": "template `in`*(x, y: expr): expr {.immediate, dirty.}",  "desc": "Sugar for contains<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span> <span class=\"Keyword\">in</span> <span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">5</span> <span class=\"Keyword\">in</span> <span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`notin`",  "code": "template `notin`*(x, y: expr): expr {.immediate, dirty.}",  "desc": "Sugar for not containing<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span> <span class=\"Keyword\">notin</span> <span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">5</span> <span class=\"Keyword\">notin</span> <span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.</span><span class=\"Operator\">.</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"Identifier\">true</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`is`",  "code": "proc `is`*[T, S](x: T; y: S): bool {.magic: \"Is\", noSideEffect.}",  "desc": "Checks if T is of the same type as S<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">test</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">T</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">T</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">when</span> <span class=\"Punctuation\">(</span><span class=\"Identifier\">T</span> <span class=\"Keyword\">is</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">return</span> <span class=\"Identifier\">a</span>\u000A  <span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">return</span> <span class=\"DecNumber\">0</span>\u000A\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">test</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">test</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;xyz&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"DecNumber\">0</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`isnot`",  "code": "template `isnot`*(x, y: expr): expr {.immediate.}",  "desc": "Negated version of <cite>is</cite>. Equivalent to <tt class=\"docutils literal\"><span class=\"pre\">not(x is y)</span></tt>." },  { "module": "system",  "name": "`of`",  "code": "proc `of`*[T, S](x: T; y: S): bool {.magic: \"Of\", noSideEffect.}",  "desc": "Checks if <cite>x</cite> has a type of <cite>y</cite><pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">FloatingPointError</span> <span class=\"Keyword\">of</span> <span class=\"Identifier\">Exception</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">DivByZeroError</span> <span class=\"Keyword\">of</span> <span class=\"Identifier\">Exception</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "cmp",  "code": "proc cmp*[T](x, y: T): int {.procvar.}",  "desc": "Generic compare proc. Returns a value &lt; 0 iff x &lt; y, a value &gt; 0 iff x &gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the <cite>==</cite> and <cite>&lt;</cite> operators." },  { "module": "system",  "name": "cmp",  "code": "proc cmp*(x, y: string): int {.noSideEffect, procvar.}",  "desc": "Compare proc for strings. More efficient than the generic version." },  { "module": "system",  "name": "`@`",  "code": "proc `@`*[IDX, T](a: array[IDX, T]): seq[T] {.magic: \"ArrToSeq\", nosideeffect.}",  "desc": "turns an array into a sequence. This most often useful for constructing sequences with the array constructor: <tt class=\"docutils literal\"><span class=\"pre\">@[1, 2, 3]</span></tt> has the type <tt class=\"docutils literal\"><span class=\"pre\">seq[int]</span></tt>, while <tt class=\"docutils literal\"><span class=\"pre\">[1, 2, 3]</span></tt> has the type <tt class=\"docutils literal\"><span class=\"pre\">array[0..2, int]</span></tt>." },  { "module": "system",  "name": "setLen",  "code": "proc setLen*[T](s: var seq[T]; newlen: int) {.magic: \"SetLengthSeq\", \u000A    noSideEffect.}",  "desc": "sets the length of <cite>s</cite> to <cite>newlen</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> may be any sequence type. If the current length is greater than the new length, <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> will be truncated. <cite>s</cite> cannot be nil! To initialize a sequence with a size, use <tt class=\"docutils literal\"><span class=\"pre\">newSeq</span></tt> instead. " },  { "module": "system",  "name": "setLen",  "code": "proc setLen*(s: var string; newlen: int) {.magic: \"SetLengthStr\", noSideEffect.}",  "desc": "sets the length of <cite>s</cite> to <cite>newlen</cite>. If the current length is greater than the new length, <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> will be truncated. <cite>s</cite> cannot be nil! To initialize a string with a size, use <tt class=\"docutils literal\"><span class=\"pre\">newString</span></tt> instead. " },  { "module": "system",  "name": "newString",  "code": "proc newString*(len: int): string {.magic: \"NewString\", importc: \"mnewString\", \u000A                                    noSideEffect.}",  "desc": "returns a new string of length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt> but with uninitialized content. One needs to fill the string character after character with the index operator <tt class=\"docutils literal\"><span class=\"pre\">s[i]</span></tt>. This procedure exists only for optimization purposes; the same effect can be achieved with the <tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt> operator or with <tt class=\"docutils literal\"><span class=\"pre\">add</span></tt>." },  { "module": "system",  "name": "newStringOfCap",  "code": "proc newStringOfCap*(cap: int): string {.magic: \"NewStringOfCap\", \u000A    importc: \"rawNewString\", noSideEffect.}",  "desc": "returns a new string of length <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> but with capacity <cite>cap</cite>.This procedure exists only for optimization purposes; the same effect can be achieved with the <tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt> operator or with <tt class=\"docutils literal\"><span class=\"pre\">add</span></tt>." },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*(x: string; y: char): string {.magic: \"ConStrStr\", noSideEffect, merge.}",  "desc": "Concatenates <cite>x</cite> with <cite>y</cite><pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;ab&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"CharLit\">'c'</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;abc&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*(x: char; y: char): string {.magic: \"ConStrStr\", noSideEffect, merge.}",  "desc": "Concatenates <cite>x</cite> and <cite>y</cite> into a string<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"CharLit\">'a'</span> <span class=\"Operator\">&amp;</span> <span class=\"CharLit\">'b'</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;ab&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*(x, y: string): string {.magic: \"ConStrStr\", noSideEffect, merge.}",  "desc": "Concatenates <cite>x</cite> and <cite>y</cite><pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;ab&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;cd&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;abcd&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*(x: char; y: string): string {.magic: \"ConStrStr\", noSideEffect, merge.}",  "desc": "Concatenates <cite>x</cite> with <cite>y</cite><pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"CharLit\">'a'</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;bc&quot;</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;abc&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "add",  "code": "proc add*(x: var string; y: char) {.magic: \"AppendStrCh\", noSideEffect.}",  "desc": "Appends <cite>y</cite> to <cite>x</cite> in place<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">tmp</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"Identifier\">tmp</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"CharLit\">'a'</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">tmp</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"CharLit\">'b'</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">tmp</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;ab&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "add",  "code": "proc add*(x: var string; y: string) {.magic: \"AppendStrStr\", noSideEffect.}",  "desc": "Concatenates <cite>x</cite> and <cite>y</cite> in place<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">tmp</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;&quot;</span>\u000A<span class=\"Identifier\">tmp</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;ab&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">tmp</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;cd&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">tmp</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;abcd&quot;</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "compileOption",  "code": "proc compileOption*(option: string): bool {.magic: \"CompileOption\", noSideEffect.}",  "desc": "can be used to determine an on|off compile-time option. Example:<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;floatchecks&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;compiled with floating point NaN and Inf checks&quot;</span></pre>" },  { "module": "system",  "name": "compileOption",  "code": "proc compileOption*(option, arg: string): bool {.magic: \"CompileOptionArg\", \u000A    noSideEffect.}",  "desc": "can be used to determine an enum compile-time option. Example:<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;opt&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;size&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;gc&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;boehm&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;compiled with optimization for size and uses Boehm's GC&quot;</span></pre>" },  { "module": "system",  "name": "len",  "code": "proc len*(s: TaintedString): int {.borrow.}" },  { "module": "system",  "name": "quit",  "code": "proc quit*(errorcode: int = QuitSuccess) {.magic: \"Exit\", importc: \"exit\", \u000A    header: \"<stdlib.h>\", noReturn.}",  "desc": "<p>Stops the program immediately with an exit code.</p>\u000A<p>Before stopping the program the &quot;quit procedures&quot; are called in the opposite order they were added with <a class=\"reference external\" href=\"#addQuitProc\">addQuitProc</a>. <tt class=\"docutils literal\"><span class=\"pre\">quit</span></tt> never returns and ignores any exception that may have been raised by the quit procedures.  It does <em>not</em> call the garbage collector to free all the memory, unless a quit procedure calls <a class=\"reference external\" href=\"#GC_fullCollect\">GC_fullCollect</a>.</p>\u000A<p>The proc <tt class=\"docutils literal\"><span class=\"pre\">quit(QuitSuccess)</span></tt> is called implicitly when your nim program finishes without incident. A raised unhandled exception is equivalent to calling <tt class=\"docutils literal\"><span class=\"pre\">quit(QuitFailure)</span></tt>.</p>\u000A<p>Note that this is a <em>runtime</em> call and using <tt class=\"docutils literal\"><span class=\"pre\">quit</span></tt> inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the <a class=\"reference external\" href=\"manual.html#error-pragma\">error</a> or <a class=\"reference external\" href=\"manual.html#fatal-pragma\">fatal</a> pragmas.</p>\u000A" },  { "module": "system",  "name": "add",  "code": "proc add*[T](x: var seq[T]; y: T) {.magic: \"AppendSeqElem\", noSideEffect.}" },  { "module": "system",  "name": "add",  "code": "proc add*[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}",  "desc": "Generic proc for adding a data item <cite>y</cite> to a container <cite>x</cite>. For containers that have an order, <cite>add</cite> means <em>append</em>. New generic containers should also call their adding proc <cite>add</cite> for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected." },  { "module": "system",  "name": "shallowCopy",  "code": "proc shallowCopy*[T](x: var T; y: T) {.noSideEffect, magic: \"ShallowCopy\".}",  "desc": "use this instead of <cite>=</cite> for a <span id=\"shallow-copy_1\">shallow copy</span>. The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings." },  { "module": "system",  "name": "del",  "code": "proc del*[T](x: var seq[T]; i: int) {.noSideEffect.}",  "desc": "deletes the item at index <cite>i</cite> by putting <tt class=\"docutils literal\"><span class=\"pre\">x[high(x)]</span></tt> into position <cite>i</cite>. This is an O(1) operation." },  { "module": "system",  "name": "delete",  "code": "proc delete*[T](x: var seq[T]; i: int) {.noSideEffect.}",  "desc": "deletes the item at index <cite>i</cite> by moving <tt class=\"docutils literal\"><span class=\"pre\">x[i+1..]</span></tt> by one position. This is an O(n) operation." },  { "module": "system",  "name": "insert",  "code": "proc insert*[T](x: var seq[T]; item: T; i = 0) {.noSideEffect.}",  "desc": "inserts <cite>item</cite> into <cite>x</cite> at position <cite>i</cite>." },  { "module": "system",  "name": "repr",  "code": "proc repr*[T](x: T): string {.magic: \"Repr\", noSideEffect.}",  "desc": "takes any Nim variable and returns its string representation. It works even for complex data graphs with cycles. This is a great debugging tool." },  { "module": "system",  "name": "toFloat",  "code": "proc toFloat*(i: int): float {.magic: \"ToFloat\", noSideEffect, \u000A                               importc: \"toFloat\".}",  "desc": "converts an integer <cite>i</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">float</span></tt>. If the conversion fails, <cite>EInvalidValue</cite> is raised. However, on most platforms the conversion cannot fail." },  { "module": "system",  "name": "toBiggestFloat",  "code": "proc toBiggestFloat*(i: BiggestInt): BiggestFloat {.magic: \"ToBiggestFloat\", \u000A    noSideEffect, importc: \"toBiggestFloat\".}",  "desc": "converts an biggestint <cite>i</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">biggestfloat</span></tt>. If the conversion fails, <cite>EInvalidValue</cite> is raised. However, on most platforms the conversion cannot fail." },  { "module": "system",  "name": "toInt",  "code": "proc toInt*(f: float): int {.magic: \"ToInt\", noSideEffect, importc: \"toInt\".}",  "desc": "converts a floating point number <cite>f</cite> into an <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. Conversion rounds <cite>f</cite> if it does not contain an integer value. If the conversion fails (because <cite>f</cite> is infinite for example), <cite>EInvalidValue</cite> is raised." },  { "module": "system",  "name": "toBiggestInt",  "code": "proc toBiggestInt*(f: BiggestFloat): BiggestInt {.magic: \"ToBiggestInt\", \u000A    noSideEffect, importc: \"toBiggestInt\".}",  "desc": "converts a biggestfloat <cite>f</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">biggestint</span></tt>. Conversion rounds <cite>f</cite> if it does not contain an integer value. If the conversion fails (because <cite>f</cite> is infinite for example), <cite>EInvalidValue</cite> is raised." },  { "module": "system",  "name": "addQuitProc",  "code": "proc addQuitProc*(QuitProc: proc () {.noconv.}) {.importc: \"atexit\", \u000A    header: \"<stdlib.h>\".}",  "desc": "<p>Adds/registers a quit procedure.</p>\u000A<p>Each call to <tt class=\"docutils literal\"><span class=\"pre\">addQuitProc</span></tt> registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). <tt class=\"docutils literal\"><span class=\"pre\">addQuitProc</span></tt> raises an EOutOfIndex exception if <tt class=\"docutils literal\"><span class=\"pre\">QuitProc</span></tt> cannot be registered.</p>\u000A" },  { "module": "system",  "name": "copy",  "code": "proc copy*(s: string; first = 0): string {.magic: \"CopyStr\", importc: \"copyStr\", \u000A    noSideEffect, deprecated.}" },  { "module": "system",  "name": "copy",  "code": "proc copy*(s: string; first, last: int): string {.magic: \"CopyStrLast\", \u000A    importc: \"copyStrLast\", noSideEffect, deprecated.}",  "desc": "copies a slice of <cite>s</cite> into a new string and returns this new string. The bounds <cite>first</cite> and <cite>last</cite> denote the indices of the first and last characters that shall be copied. If <tt class=\"docutils literal\"><span class=\"pre\">last</span></tt> is omitted, it is treated as <tt class=\"docutils literal\"><span class=\"pre\">high(s)</span></tt>. <strong>Deprecated since version 0.8.12</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">substr</span></tt> instead." },  { "module": "system",  "name": "substr",  "code": "proc substr*(s: string; first = 0): string {.magic: \"CopyStr\", \u000A    importc: \"copyStr\", noSideEffect.}" },  { "module": "system",  "name": "substr",  "code": "proc substr*(s: string; first, last: int): string {.magic: \"CopyStrLast\", \u000A    importc: \"copyStrLast\", noSideEffect.}",  "desc": "copies a slice of <cite>s</cite> into a new string and returns this new string. The bounds <cite>first</cite> and <cite>last</cite> denote the indices of the first and last characters that shall be copied. If <tt class=\"docutils literal\"><span class=\"pre\">last</span></tt> is omitted, it is treated as <tt class=\"docutils literal\"><span class=\"pre\">high(s)</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">last &gt;= s.len</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">s.len</span></tt> is used instead: This means <tt class=\"docutils literal\"><span class=\"pre\">substr</span></tt> can also be used to <span id=\"cut_1\">cut</span> or <span id=\"limit_1\">limit</span> a string's length." },  { "module": "system",  "name": "zeroMem",  "code": "proc zeroMem*(p: pointer; size: int) {.importc, noDecl, benign.}",  "desc": "overwrites the contents of the memory at <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> with the value 0. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be overwritten. Like any procedure dealing with raw memory this is <em>unsafe</em>." },  { "module": "system",  "name": "copyMem",  "code": "proc copyMem*(dest, source: pointer; size: int) {.importc: \"memcpy\", \u000A    header: \"<string.h>\", benign.}",  "desc": "copies the contents from the memory at <tt class=\"docutils literal\"><span class=\"pre\">source</span></tt> to the memory at <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is <em>unsafe</em>." },  { "module": "system",  "name": "moveMem",  "code": "proc moveMem*(dest, source: pointer; size: int) {.importc: \"memmove\", \u000A    header: \"<string.h>\", benign.}",  "desc": "copies the contents from the memory at <tt class=\"docutils literal\"><span class=\"pre\">source</span></tt> to the memory at <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be copied. The memory regions may overlap, <tt class=\"docutils literal\"><span class=\"pre\">moveMem</span></tt> handles this case appropriately and is thus somewhat more safe than <tt class=\"docutils literal\"><span class=\"pre\">copyMem</span></tt>. Like any procedure dealing with raw memory this is still <em>unsafe</em>, though." },  { "module": "system",  "name": "equalMem",  "code": "proc equalMem*(a, b: pointer; size: int): bool {.importc: \"equalMem\", noDecl, \u000A    noSideEffect.}",  "desc": "compares the memory blocks <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">b</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is <em>unsafe</em>." },  { "module": "system",  "name": "alloc",  "code": "proc alloc*(size: int): pointer {.noconv, rtl, tags: [], benign.}",  "desc": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">realloc(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">dealloc(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <cite>allocShared</cite> to allocate from a shared heap." },  { "module": "system",  "name": "createU",  "code": "proc createU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}",  "desc": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">resize(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">free(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <cite>createSharedU</cite> to allocate from a shared heap." },  { "module": "system",  "name": "alloc0",  "code": "proc alloc0*(size: int): pointer {.noconv, rtl, tags: [], benign.}",  "desc": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">realloc(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">dealloc(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">alloc</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>allocShared0</cite> to allocate from a shared heap." },  { "module": "system",  "name": "create",  "code": "proc create*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}",  "desc": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">resize(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">free(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">createU</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>createShared</cite> to allocate from a shared heap." },  { "module": "system",  "name": "realloc",  "code": "proc realloc*(p: pointer; newSize: int): pointer {.noconv, rtl, tags: [], benign.}",  "desc": "grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">newSize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newSize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">realloc</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">dealloc(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">dealloc</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>reallocShared</cite> to reallocate from a shared heap." },  { "module": "system",  "name": "resize",  "code": "proc resize*[T](p: ptr T; newSize: Natural): ptr T {.inline, benign.}",  "desc": "grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * newSize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newSize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">resize</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">free(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">free</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>resizeShared</cite> to reallocate from a shared heap." },  { "module": "system",  "name": "dealloc",  "code": "proc dealloc*(p: pointer) {.noconv, rtl, tags: [], benign.}",  "desc": "frees the memory allocated with <tt class=\"docutils literal\"><span class=\"pre\">alloc</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">alloc0</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">realloc</span></tt>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted. The freed memory must belong to its allocating thread! Use <cite>deallocShared</cite> to deallocate from a shared heap." },  { "module": "system",  "name": "free",  "code": "proc free*[T](p: ptr T) {.inline, benign.}" },  { "module": "system",  "name": "allocShared",  "code": "proc allocShared*(size: int): pointer {.noconv, rtl, benign.}",  "desc": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">reallocShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour!" },  { "module": "system",  "name": "createSharedU",  "code": "proc createSharedU*(T: typedesc; size = 1.Positive): ptr T {.inline, benign.}",  "desc": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">resizeShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">freeShared(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour!" },  { "module": "system",  "name": "allocShared0",  "code": "proc allocShared0*(size: int): pointer {.noconv, rtl, benign.}",  "desc": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">reallocShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">allocShared</span></tt>." },  { "module": "system",  "name": "createShared",  "code": "proc createShared*(T: typedesc; size = 1.Positive): ptr T {.inline.}",  "desc": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">resizeShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">freeShared(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">createSharedU</span></tt>." },  { "module": "system",  "name": "reallocShared",  "code": "proc reallocShared*(p: pointer; newSize: int): pointer {.noconv, rtl, benign.}",  "desc": "grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">newSize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newSize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">reallocShared</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">deallocShared</span></tt>." },  { "module": "system",  "name": "resizeShared",  "code": "proc resizeShared*[T](p: ptr T; newSize: Natural): ptr T {.inline.}",  "desc": "grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">T.sizeof * newSize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newSize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">resizeShared</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">freeShared(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">freeShared</span></tt>." },  { "module": "system",  "name": "deallocShared",  "code": "proc deallocShared*(p: pointer) {.noconv, rtl, benign.}",  "desc": "frees the memory allocated with <tt class=\"docutils literal\"><span class=\"pre\">allocShared</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">allocShared0</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">reallocShared</span></tt>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted." },  { "module": "system",  "name": "freeShared",  "code": "proc freeShared*[T](p: ptr T) {.inline, benign.}",  "desc": "frees the memory allocated with <tt class=\"docutils literal\"><span class=\"pre\">createShared</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">createSharedU</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">resizeShared</span></tt>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted." },  { "module": "system",  "name": "swap",  "code": "proc swap*[T](a, b: var T) {.magic: \"Swap\", noSideEffect.}",  "desc": "swaps the values <cite>a</cite> and <cite>b</cite>. This is often more efficient than <tt class=\"docutils literal\"><span class=\"pre\">tmp = a; a = b; b = tmp</span></tt>. Particularly useful for sorting algorithms." },  { "module": "system",  "name": "`&gt;=%`",  "code": "template `>=%`*(x, y: expr): expr {.immediate.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &gt;= unsigned(y)</span></tt>." },  { "module": "system",  "name": "`&gt;%`",  "code": "template `>%`*(x, y: expr): expr {.immediate.}",  "desc": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &gt; unsigned(y)</span></tt>." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: int): string {.magic: \"IntToStr\", noSideEffect.}",  "desc": "The stringify operator for an integer argument. Returns <cite>x</cite> converted to a decimal string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: int64): string {.magic: \"Int64ToStr\", noSideEffect.}",  "desc": "The stringify operator for an integer argument. Returns <cite>x</cite> converted to a decimal string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: uint64): string {.noSideEffect.}",  "desc": "The stringify operator for an unsigned integer argument. Returns <cite>x</cite> converted to a decimal string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: float): string {.magic: \"FloatToStr\", noSideEffect.}",  "desc": "The stringify operator for a float argument. Returns <cite>x</cite> converted to a decimal string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: bool): string {.magic: \"BoolToStr\", noSideEffect.}",  "desc": "The stringify operator for a boolean argument. Returns <cite>x</cite> converted to the string &quot;false&quot; or &quot;true&quot;." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: char): string {.magic: \"CharToStr\", noSideEffect.}",  "desc": "The stringify operator for a character argument. Returns <cite>x</cite> converted to a string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: cstring): string {.magic: \"CStrToStr\", noSideEffect.}",  "desc": "The stringify operator for a CString argument. Returns <cite>x</cite> converted to a string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*(x: string): string {.magic: \"StrToStr\", noSideEffect.}",  "desc": "The stringify operator for a string argument. Returns <cite>x</cite> as it is. This operator is useful for generic code, so that <tt class=\"docutils literal\"><span class=\"pre\">$expr</span></tt> also works if <tt class=\"docutils literal\"><span class=\"pre\">expr</span></tt> is already a string." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*[TEnum: enum](x: TEnum): string {.magic: \"EnumToStr\", noSideEffect.}",  "desc": "The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for a concrete enumeration is provided, this is used instead. (In other words: <em>Overwriting</em> is possible.)" },  { "module": "system",  "name": "getRefcount",  "code": "proc getRefcount*[T](x: ref T): int {.importc: \"getRefcount\", noSideEffect.}" },  { "module": "system",  "name": "getRefcount",  "code": "proc getRefcount*(x: string): int {.importc: \"getRefcount\", noSideEffect.}" },  { "module": "system",  "name": "getRefcount",  "code": "proc getRefcount*[T](x: seq[T]): int {.importc: \"getRefcount\", noSideEffect.}",  "desc": "retrieves the reference count of an heap-allocated object. The value is implementation-dependent." },  { "module": "system",  "name": "getOccupiedMem",  "code": "proc getOccupiedMem*(): int {.rtl.}",  "desc": "returns the number of bytes that are owned by the process and hold data." },  { "module": "system",  "name": "getFreeMem",  "code": "proc getFreeMem*(): int {.rtl.}",  "desc": "returns the number of bytes that are owned by the process, but do not hold any meaningful data." },  { "module": "system",  "name": "getTotalMem",  "code": "proc getTotalMem*(): int {.rtl.}",  "desc": "returns the number of bytes that are owned by the process." },  { "module": "system",  "name": "getOccupiedSharedMem",  "code": "proc getOccupiedSharedMem*(): int {.rtl.}",  "desc": "returns the number of bytes that are owned by the process on the shared heap and hold data. This is only available when threads are enabled." },  { "module": "system",  "name": "getFreeSharedMem",  "code": "proc getFreeSharedMem*(): int {.rtl.}",  "desc": "returns the number of bytes that are owned by the process on the shared heap, but do not hold any meaningful data. This is only available when threads are enabled." },  { "module": "system",  "name": "getTotalSharedMem",  "code": "proc getTotalSharedMem*(): int {.rtl.}",  "desc": "returns the number of bytes on the shared heap that are owned by the process. This is only available when threads are enabled." },  { "module": "system",  "name": "countdown",  "code": "iterator countdown*[T](a, b: T; step = 1): T {.inline.}",  "desc": "Counts from ordinal value <cite>a</cite> down to <cite>b</cite> with the given step count. <cite>T</cite> may be any ordinal type, <cite>step</cite> may only be positive." },  { "module": "system",  "name": "countup",  "code": "iterator countup*[S, T](a: S; b: T; step = 1): T {.inline.}",  "desc": "Counts from ordinal value <cite>a</cite> up to <cite>b</cite> with the given step count. <cite>S</cite>, <cite>T</cite> may be any ordinal type, <cite>step</cite> may only be positive." },  { "module": "system",  "name": "`..`",  "code": "iterator `..`*[S, T](a: S; b: T): T {.inline.}",  "desc": "An alias for <cite>countup</cite>." },  { "module": "system",  "name": "`||`",  "code": "iterator `||`*[S, T](a: S; b: T; annotation = \"\"): T {.inline, \u000A    magic: \"OmpParFor\", sideEffect.}",  "desc": "parallel loop iterator. Same as <cite>..</cite> but the loop may run in parallel. <cite>annotation</cite> is an additional annotation for the code generator to use. Note that the compiler maps that to the <tt class=\"docutils literal\"><span class=\"pre\">#pragma omp parallel for</span></tt> construct of <span id=\"openmp_1\">OpenMP</span> and as such isn't aware of the parallelism in your code! Be careful! Later versions of <tt class=\"docutils literal\"><span class=\"pre\">||</span></tt> will get proper support by Nim's code generator and GC." },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: int): int {.magic: \"MinI\", noSideEffect.}" },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: int8): int8 {.magic: \"MinI\", noSideEffect.}" },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: int16): int16 {.magic: \"MinI\", noSideEffect.}" },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: int32): int32 {.magic: \"MinI\", noSideEffect.}" },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: int64): int64 {.magic: \"MinI64\", noSideEffect.}",  "desc": "The minimum value of two integers." },  { "module": "system",  "name": "min",  "code": "proc min*[T](x: varargs[T]): T",  "desc": "The minimum value of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> needs to have a <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator." },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: int): int {.magic: \"MaxI\", noSideEffect.}" },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: int8): int8 {.magic: \"MaxI\", noSideEffect.}" },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: int16): int16 {.magic: \"MaxI\", noSideEffect.}" },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: int32): int32 {.magic: \"MaxI\", noSideEffect.}" },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: int64): int64 {.magic: \"MaxI64\", noSideEffect.}",  "desc": "The maximum value of two integers." },  { "module": "system",  "name": "max",  "code": "proc max*[T](x: varargs[T]): T",  "desc": "The maximum value of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> needs to have a <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator." },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: float): float {.magic: \"AbsF64\", noSideEffect.}" },  { "module": "system",  "name": "min",  "code": "proc min*(x, y: float): float {.magic: \"MinF64\", noSideEffect.}" },  { "module": "system",  "name": "max",  "code": "proc max*(x, y: float): float {.magic: \"MaxF64\", noSideEffect.}" },  { "module": "system",  "name": "clamp",  "code": "proc clamp*[T](x, a, b: T): T",  "desc": "limits the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> within the interval [a, b]<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">1.4</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">clamp</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">0.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">1.0</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"FloatNumber\">1.0</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">0.5</span><span class=\"Punctuation\">)</span><span class=\"Operator\">.</span><span class=\"Identifier\">clamp</span><span class=\"Punctuation\">(</span><span class=\"FloatNumber\">0.0</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">1.0</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"FloatNumber\">0.5</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "items",  "code": "iterator items*[T](a: openArray[T]): T {.inline.}",  "desc": "iterates over each item of <cite>a</cite>." },  { "module": "system",  "name": "items",  "code": "iterator items*[IX, T](a: array[IX, T]): T {.inline.}",  "desc": "iterates over each item of <cite>a</cite>." },  { "module": "system",  "name": "items",  "code": "iterator items*[T](a: set[T]): T {.inline.}",  "desc": "iterates over each element of <cite>a</cite>. <cite>items</cite> iterates only over the elements that are really in the set (and not over the ones the set is able to hold)." },  { "module": "system",  "name": "items",  "code": "iterator items*(a: cstring): char {.inline.}",  "desc": "iterates over each item of <cite>a</cite>." },  { "module": "system",  "name": "items",  "code": "iterator items*(E: typedesc[enum]): E",  "desc": "iterates over the values of the enum <tt class=\"docutils literal\"><span class=\"pre\">E</span></tt>." },  { "module": "system",  "name": "pairs",  "code": "iterator pairs*[T](a: openArray[T]): tuple[key: int, val: T] {.inline.}",  "desc": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs." },  { "module": "system",  "name": "pairs",  "code": "iterator pairs*[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {.inline.}",  "desc": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs." },  { "module": "system",  "name": "pairs",  "code": "iterator pairs*[T](a: seq[T]): tuple[key: int, val: T] {.inline.}",  "desc": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs." },  { "module": "system",  "name": "pairs",  "code": "iterator pairs*(a: string): tuple[key: int, val: char] {.inline.}",  "desc": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs." },  { "module": "system",  "name": "isNil",  "code": "proc isNil*[T](x: seq[T]): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*[T](x: ref T): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*(x: string): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*[T](x: ptr T): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*(x: pointer): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*(x: cstring): bool {.noSideEffect, magic: \"IsNil\".}" },  { "module": "system",  "name": "isNil",  "code": "proc isNil*[T: proc](x: T): bool {.noSideEffect, magic: \"IsNil\".}",  "desc": "Fast check whether <cite>x</cite> is nil. This is sometimes more efficient than <tt class=\"docutils literal\"><span class=\"pre\">== nil</span></tt>." },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[I, T](x, y: array[I, T]): bool" },  { "module": "system",  "name": "`@`",  "code": "proc `@`*[T](a: openArray[T]): seq[T]",  "desc": "turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of <cite>a</cite>." },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*[T](x, y: seq[T]): seq[T] {.noSideEffect.}",  "desc": "Concatenates two sequences. Requires copying of the sequences.<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">&amp;</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">5</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">6</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}",  "desc": "Appends element y to the end of the sequence. Requires copying of the sequence<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">&amp;</span> <span class=\"DecNumber\">4</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`&amp;`",  "code": "proc `&`*[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}",  "desc": "Prepends the element x to the beginning of the sequence. Requires copying of the sequence<pre><span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span> <span class=\"Operator\">&amp;</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T](x, y: seq[T]): bool {.noSideEffect.}",  "desc": "Generic equals operator for sequences: relies on a equals operator for the element type <cite>T</cite>." },  { "module": "system",  "name": "find",  "code": "proc find*[T, S](a: T; item: S): int {.inline.}",  "desc": "Returns the first index of <cite>item</cite> in <cite>a</cite> or -1 if not found. This requires appropriate <cite>items</cite> and <cite>==</cite> operations to work." },  { "module": "system",  "name": "contains",  "code": "proc contains*[T](a: openArray[T]; item: T): bool {.inline.}",  "desc": "Returns true if <cite>item</cite> is in <cite>a</cite> or false if not found. This is a shortcut for <tt class=\"docutils literal\"><span class=\"pre\">find(a, item) &gt;= 0</span></tt>." },  { "module": "system",  "name": "pop",  "code": "proc pop*[T](s: var seq[T]): T {.inline, noSideEffect.}",  "desc": "returns the last item of <cite>s</cite> and decreases <tt class=\"docutils literal\"><span class=\"pre\">s.len</span></tt> by one. This treats <cite>s</cite> as a stack and implements the common <em>pop</em> operation." },  { "module": "system",  "name": "each",  "code": "proc each*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.\u000A    deprecated.}",  "desc": "<p>The well-known <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> operation from functional programming. Applies <cite>op</cite> to every item in <cite>data</cite> and returns the result as a sequence.</p>\u000A<p><strong>Deprecated since version 0.9:</strong> Use the <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc instead.</p>\u000A" },  { "module": "system",  "name": "each",  "code": "proc each*[T](data: var openArray[T]; op: proc (x: var T) {.closure.}) {.\u000A    deprecated.}",  "desc": "<p>The well-known <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> operation from functional programming. Applies <cite>op</cite> to every item in <cite>data</cite> modifying it directly.</p>\u000A<p><strong>Deprecated since version 0.9:</strong> Use the <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc instead.</p>\u000A" },  { "module": "system",  "name": "map",  "code": "proc map*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S]",  "desc": "<p>Returns a new sequence with the results of <cite>op</cite> applied to every item in <cite>data</cite>.</p>\u000A<p>Since the input is not modified you can use this version of <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> to transform the type of the elements in the input sequence. Example:</p>\u000A<pre><span class=\"Keyword\">let</span>\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">map</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span> <span class=\"Operator\">$</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;4&quot;</span><span class=\"Punctuation\">]</span></pre>" },  { "module": "system",  "name": "map",  "code": "proc map*[T](data: var openArray[T]; op: proc (x: var T) {.closure.})",  "desc": "<p>Applies <cite>op</cite> to every item in <cite>data</cite> modifying it directly.</p>\u000A<p>Note that this version of <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> requires your input and output types to be the same, since they are modified in-place. Example:</p>\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;4&quot;</span><span class=\"Punctuation\">]</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">repr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</span>\u000A<span class=\"Identifier\">map</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Keyword\">var</span> <span class=\"Identifier\">string</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">x</span> <span class=\"Operator\">&amp;=</span> <span class=\"StringLit\">&quot;42&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">repr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; [&quot;142&quot;, &quot;242&quot;, &quot;342&quot;, &quot;442&quot;]</span></pre>" },  { "module": "system",  "name": "fields",  "code": "iterator fields*[T: tuple |\u000A    object](x: T): RootObj {.magic: \"Fields\", noSideEffect.}",  "desc": "iterates over every field of <cite>x</cite>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body." },  { "module": "system",  "name": "fields",  "code": "iterator fields*[S: tuple |\u000A    object, T: tuple |\u000A    object](x: S; y: T): tuple[a, b: expr] {.magic: \"Fields\", noSideEffect.}",  "desc": "iterates over every field of <cite>x</cite> and <cite>y</cite>. Warning: This is really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body." },  { "module": "system",  "name": "fieldPairs",  "code": "iterator fieldPairs*[T: tuple |\u000A    object](x: T): RootObj {.magic: \"FieldPairs\", noSideEffect.}",  "desc": "<p>Iterates over every field of <cite>x</cite> returning their name and value.</p>\u000A<p>When you iterate over objects with different field types you have to use the compile time <tt class=\"docutils literal\"><span class=\"pre\">when</span></tt> instead of a runtime <tt class=\"docutils literal\"><span class=\"pre\">if</span></tt> to select the code you want to run for each type. To perform the comparison use the <a class=\"reference external\" href=\"manual.html#is-operator\">is operator</a>. Example:</p>\u000A<pre><span class=\"Keyword\">type</span>\u000A  <span class=\"Identifier\">Custom</span> <span class=\"Operator\">=</span> <span class=\"Keyword\">object</span>\u000A    <span class=\"Identifier\">foo</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span>\u000A    <span class=\"Identifier\">bar</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">bool</span>\u000A\u000A<span class=\"Keyword\">proc</span> <span class=\"Punctuation\">`</span><span class=\"Operator\">$</span><span class=\"Punctuation\">`</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">Custom</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;Custom:&quot;</span>\u000A  <span class=\"Keyword\">for</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">x</span><span class=\"Operator\">.</span><span class=\"Identifier\">fieldPairs</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">when</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">is</span> <span class=\"Identifier\">bool</span><span class=\"Punctuation\">:</span>\u000A      <span class=\"Identifier\">result</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">\\t</span><span class=\"StringLit\">&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">name</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot; is &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Operator\">$</span><span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A      <span class=\"Keyword\">if</span> <span class=\"Identifier\">value</span><span class=\"Operator\">.</span><span class=\"Identifier\">isNil</span><span class=\"Punctuation\">:</span>\u000A        <span class=\"Identifier\">result</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">\\t</span><span class=\"StringLit\">&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">name</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot; (nil)&quot;</span><span class=\"Punctuation\">)</span>\u000A      <span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A        <span class=\"Identifier\">result</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"EscapeSequence\">\\t</span><span class=\"StringLit\">&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">name</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot; '&quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">value</span> <span class=\"Operator\">&amp;</span> <span class=\"StringLit\">&quot;'&quot;</span><span class=\"Punctuation\">)</span></pre><p>Another way to do the same without <tt class=\"docutils literal\"><span class=\"pre\">when</span></tt> is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the <cite>value</cite> to.</p>\u000A<p>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</p>\u000A" },  { "module": "system",  "name": "fieldPairs",  "code": "iterator fieldPairs*[S: tuple |\u000A    object, T: tuple |\u000A    object](x: S; y: T): tuple[a, b: expr] {.magic: \"FieldPairs\", noSideEffect.}",  "desc": "iterates over every field of <cite>x</cite> and <cite>y</cite>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body." },  { "module": "system",  "name": "`==`",  "code": "proc `==`*[T: tuple |\u000A    object](x, y: T): bool",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">==</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>." },  { "module": "system",  "name": "`&lt;=`",  "code": "proc `<=`*[T: tuple](x, y: T): bool",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">&lt;=</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>. This implementation uses <cite>cmp</cite>." },  { "module": "system",  "name": "`&lt;`",  "code": "proc `<`*[T: tuple](x, y: T): bool",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>. This implementation uses <cite>cmp</cite>." },  { "module": "system",  "name": "`$`",  "code": "proc `$`*[T: tuple |\u000A    object](x: T): string",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for tuples that is lifted from the components of <cite>x</cite>. Example:<pre><span class=\"Operator\">$</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">23</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">45</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;(23, 45)&quot;</span>\u000A<span class=\"Operator\">$</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;()&quot;</span></pre>" },  { "module": "system",  "name": "`$`",  "code": "proc `$`*[T](x: set[T]): string",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for sets that is lifted from the components of <cite>x</cite>. Example:<pre><span class=\"Operator\">$</span><span class=\"Punctuation\">{</span><span class=\"DecNumber\">23</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">45</span><span class=\"Punctuation\">}</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;{23, 45}&quot;</span></pre>" },  { "module": "system",  "name": "`$`",  "code": "proc `$`*[T](x: seq[T]): string",  "desc": "generic <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for seqs that is lifted from the components of <cite>x</cite>. Example:<pre><span class=\"Operator\">$</span><span class=\"Punctuation\">(</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">23</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">45</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;@[23, 45]&quot;</span></pre>" },  { "module": "system",  "name": "GC_disable",  "code": "proc GC_disable*() {.rtl, inl, benign.}",  "desc": "disables the GC. If called n-times, n calls to <cite>GC_enable</cite> are needed to reactivate the GC. Note that in most circumstances one should only disable the mark and sweep phase with <cite>GC_disableMarkAndSweep</cite>." },  { "module": "system",  "name": "GC_enable",  "code": "proc GC_enable*() {.rtl, inl, benign.}",  "desc": "enables the GC again." },  { "module": "system",  "name": "GC_fullCollect",  "code": "proc GC_fullCollect*() {.rtl, benign.}",  "desc": "forces a full garbage collection pass. Ordinary code does not need to call this (and should not)." },  { "module": "system",  "name": "GC_setStrategy",  "code": "proc GC_setStrategy*(strategy: GC_Strategy) {.rtl, deprecated, benign.}",  "desc": "tells the GC the desired strategy for the application. <strong>Deprecated</strong> since version 0.8.14. This has always been a nop." },  { "module": "system",  "name": "GC_enableMarkAndSweep",  "code": "proc GC_enableMarkAndSweep*() {.rtl, benign.}" },  { "module": "system",  "name": "GC_disableMarkAndSweep",  "code": "proc GC_disableMarkAndSweep*() {.rtl, benign.}",  "desc": "the current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC." },  { "module": "system",  "name": "GC_getStatistics",  "code": "proc GC_getStatistics*(): string {.rtl, benign.}",  "desc": "returns an informative string about the GC's activity. This may be useful for tweaking." },  { "module": "system",  "name": "GC_ref",  "code": "proc GC_ref*[T](x: ref T) {.magic: \"GCref\", gcsafe.}" },  { "module": "system",  "name": "GC_ref",  "code": "proc GC_ref*[T](x: seq[T]) {.magic: \"GCref\", gcsafe.}" },  { "module": "system",  "name": "GC_ref",  "code": "proc GC_ref*(x: string) {.magic: \"GCref\", gcsafe.}",  "desc": "marks the object <cite>x</cite> as referenced, so that it will not be freed until it is unmarked via <cite>GC_unref</cite>. If called n-times for the same object <cite>x</cite>, n calls to <cite>GC_unref</cite> are needed to unmark <cite>x</cite>. " },  { "module": "system",  "name": "GC_unref",  "code": "proc GC_unref*[T](x: ref T) {.magic: \"GCunref\", gcsafe.}" },  { "module": "system",  "name": "GC_unref",  "code": "proc GC_unref*[T](x: seq[T]) {.magic: \"GCunref\", gcsafe.}" },  { "module": "system",  "name": "GC_unref",  "code": "proc GC_unref*(x: string) {.magic: \"GCunref\", gcsafe.}",  "desc": "see the documentation of <cite>GC_ref</cite>." },  { "module": "system",  "name": "accumulateResult",  "code": "template accumulateResult*(iter: expr)",  "desc": "helps to convert an iterator to a proc." },  { "module": "system",  "name": "add",  "code": "proc add*(x: var string; y: cstring) {.asmNoStackFrame.}" },  { "module": "system",  "name": "add",  "code": "proc add*(x: var cstring; y: cstring) {.magic: \"AppendStrStr\".}" },  { "module": "system",  "name": "echo",  "code": "proc echo*(x: varargs[expr, `$`]) {.magic: \"Echo\", tags: [WriteIOEffect], benign.}",  "desc": "<p>Writes and flushes the parameters to the standard output.</p>\u000A<p>Special built-in that takes a variable number of arguments. Each argument is converted to a string via <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt>, so it works for user-defined types that have an overloaded <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator. It is roughly equivalent to <tt class=\"docutils literal\"><span class=\"pre\">writeln(stdout, x); flushFile(stdout)</span></tt>, but available for the JavaScript target too.</p>\u000A<p>Unlike other IO operations this is guaranteed to be thread-safe as <tt class=\"docutils literal\"><span class=\"pre\">echo</span></tt> is very often used for debugging convenience. If you want to use <tt class=\"docutils literal\"><span class=\"pre\">echo</span></tt> inside a <a class=\"reference external\" href=\"manual.html#nosideeffect-pragma\">proc without side effects</a> you can use <a class=\"reference external\" href=\"#debugEcho\">debugEcho</a> instead.</p>\u000A" },  { "module": "system",  "name": "debugEcho",  "code": "proc debugEcho*(x: varargs[expr, `$`]) {.magic: \"Echo\", noSideEffect, tags: [], \u000A    raises: [].}",  "desc": "Same as <a class=\"reference external\" href=\"#echo\">echo</a>, but as a special semantic rule, <tt class=\"docutils literal\"><span class=\"pre\">debugEcho</span></tt> pretends to be free of side effects, so that it can be used for debugging routines marked as <a class=\"reference external\" href=\"manual.html#nosideeffect-pragma\">noSideEffect</a>." },  { "module": "system",  "name": "newException",  "code": "template newException*(exceptn: typedesc; message: string): expr",  "desc": "creates an exception object of type <tt class=\"docutils literal\"><span class=\"pre\">exceptn</span></tt> and sets its <tt class=\"docutils literal\"><span class=\"pre\">msg</span></tt> field to <cite>message</cite>. Returns the new exception object." },  { "module": "system",  "name": "getTypeInfo",  "code": "proc getTypeInfo*[T](x: T): pointer {.magic: \"GetTypeInfo\", gcsafe, locks: 0.}",  "desc": "get type information for <cite>x</cite>. Ordinary code should not use this, but the <cite>typeinfo</cite> module instead." },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: int): int {.magic: \"AbsI\", noSideEffect.}" },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: int8): int8 {.magic: \"AbsI\", noSideEffect.}" },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: int16): int16 {.magic: \"AbsI\", noSideEffect.}" },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: int32): int32 {.magic: \"AbsI\", noSideEffect.}" },  { "module": "system",  "name": "abs",  "code": "proc abs*(x: int64): int64 {.magic: \"AbsI64\", noSideEffect.}",  "desc": "returns the absolute value of <cite>x</cite>. If <cite>x</cite> is <tt class=\"docutils literal\"><span class=\"pre\">low(x)</span></tt> (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on)." },  { "module": "system",  "name": "stdmsg",  "code": "template stdmsg*(): File" },  { "module": "system",  "name": "open",  "code": "proc open*(f: var File; filename: string; mode: FileMode = fmRead; \u000A           bufSize: int = - 1): bool {.tags: [], benign.}",  "desc": "<p>Opens a file named <cite>filename</cite> with given <cite>mode</cite>.</p>\u000A<p>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</p>\u000A" },  { "module": "system",  "name": "open",  "code": "proc open*(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.\u000A    tags: [], benign.}",  "desc": "<p>Creates a <tt class=\"docutils literal\"><span class=\"pre\">TFile</span></tt> from a <cite>filehandle</cite> with given <cite>mode</cite>.</p>\u000A<p>Default mode is readonly. Returns true iff the file could be opened.</p>\u000A" },  { "module": "system",  "name": "open",  "code": "proc open*(filename: string; mode: FileMode = fmRead; bufSize: int = - 1): File",  "desc": "<p>Opens a file named <cite>filename</cite> with given <cite>mode</cite>.</p>\u000A<p>Default mode is readonly. Raises an <tt class=\"docutils literal\"><span class=\"pre\">IO</span></tt> exception if the file could not be opened.</p>\u000A" },  { "module": "system",  "name": "reopen",  "code": "proc reopen*(f: File; filename: string; mode: FileMode = fmRead): bool {.\u000A    tags: [], benign.}",  "desc": "<p>reopens the file <cite>f</cite> with given <cite>filename</cite> and <cite>mode</cite>. This is often used to redirect the <cite>stdin</cite>, <cite>stdout</cite> or <cite>stderr</cite> file variables.</p>\u000A<p>Default mode is readonly. Returns true iff the file could be reopened.</p>\u000A" },  { "module": "system",  "name": "close",  "code": "proc close*(f: File) {.importc: \"fclose\", header: \"<stdio.h>\", tags: [].}",  "desc": "Closes the file." },  { "module": "system",  "name": "endOfFile",  "code": "proc endOfFile*(f: File): bool {.tags: [], benign.}",  "desc": "Returns true iff <cite>f</cite> is at the end." },  { "module": "system",  "name": "readChar",  "code": "proc readChar*(f: File): char {.importc: \"fgetc\", header: \"<stdio.h>\", \u000A                                tags: [ReadIOEffect].}",  "desc": "Reads a single character from the stream <cite>f</cite>." },  { "module": "system",  "name": "flushFile",  "code": "proc flushFile*(f: File) {.importc: \"fflush\", header: \"<stdio.h>\", \u000A                           tags: [WriteIOEffect].}",  "desc": "Flushes <cite>f</cite>'s buffer." },  { "module": "system",  "name": "readAll",  "code": "proc readAll*(file: File): TaintedString {.tags: [ReadIOEffect], benign.}",  "desc": "<p>Reads all data from the stream <cite>file</cite>.</p>\u000A<p>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</p>\u000A" },  { "module": "system",  "name": "readFile",  "code": "proc readFile*(filename: string): TaintedString {.tags: [ReadIOEffect], benign.}",  "desc": "<p>Opens a file named <cite>filename</cite> for reading.</p>\u000A<p>Then calls <a class=\"reference external\" href=\"#readAll\">readAll</a> and closes the file afterwards. Returns the string.  Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use <a class=\"reference external\" href=\"#staticRead\">staticRead</a>.</p>\u000A" },  { "module": "system",  "name": "writeFile",  "code": "proc writeFile*(filename, content: string) {.tags: [WriteIOEffect], benign.}",  "desc": "Opens a file named <cite>filename</cite> for writing. Then writes the <cite>content</cite> completely to the file and closes the file afterwards. Raises an IO exception in case of an error." },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; r: float32) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; i: int) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; i: BiggestInt) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; r: BiggestFloat) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; s: string) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; b: bool) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; c: char) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; c: cstring) {.tags: [WriteIOEffect], benign.}" },  { "module": "system",  "name": "write",  "code": "proc write*(f: File; a: varargs[string, `$`]) {.tags: [WriteIOEffect], benign.}",  "desc": "Writes a value to the file <cite>f</cite>. May throw an IO exception." },  { "module": "system",  "name": "readLine",  "code": "proc readLine*(f: File): TaintedString {.tags: [ReadIOEffect], benign.}",  "desc": "reads a line of text from the file <cite>f</cite>. May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string." },  { "module": "system",  "name": "readLine",  "code": "proc readLine*(f: File; line: var TaintedString): bool {.tags: [ReadIOEffect], \u000A    benign.}",  "desc": "reads a line of text from the file <cite>f</cite> into <cite>line</cite>. <cite>line</cite> must not be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>! May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string. Returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> if the end of the file has been reached, <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> otherwise. If <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned <cite>line</cite> contains no new data." },  { "module": "system",  "name": "writeln",  "code": "proc writeln*[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect], \u000A    gcsafe, locks: 0.}",  "desc": "writes the values <cite>x</cite> to <cite>f</cite> and then writes &quot;n&quot;. May throw an IO exception." },  { "module": "system",  "name": "getFileSize",  "code": "proc getFileSize*(f: File): int64 {.tags: [ReadIOEffect], benign.}",  "desc": "retrieves the file size (in bytes) of <cite>f</cite>." },  { "module": "system",  "name": "readBytes",  "code": "proc readBytes*(f: File; a: var openArray[int8]; start, len: int): int {.\u000A    tags: [ReadIOEffect], benign.}",  "desc": "reads <cite>len</cite> bytes into the buffer <cite>a</cite> starting at <tt class=\"docutils literal\"><span class=\"pre\">a[start]</span></tt>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater." },  { "module": "system",  "name": "readChars",  "code": "proc readChars*(f: File; a: var openArray[char]; start, len: int): int {.\u000A    tags: [ReadIOEffect], benign.}",  "desc": "reads <cite>len</cite> bytes into the buffer <cite>a</cite> starting at <tt class=\"docutils literal\"><span class=\"pre\">a[start]</span></tt>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater." },  { "module": "system",  "name": "readBuffer",  "code": "proc readBuffer*(f: File; buffer: pointer; len: int): int {.\u000A    tags: [ReadIOEffect], benign.}",  "desc": "reads <cite>len</cite> bytes into the buffer pointed to by <cite>buffer</cite>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater." },  { "module": "system",  "name": "writeBytes",  "code": "proc writeBytes*(f: File; a: openArray[int8]; start, len: int): int {.\u000A    tags: [WriteIOEffect], benign.}",  "desc": "writes the bytes of <tt class=\"docutils literal\"><span class=\"pre\">a[start..start+len-1]</span></tt> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error." },  { "module": "system",  "name": "writeChars",  "code": "proc writeChars*(f: File; a: openArray[char]; start, len: int): int {.\u000A    tags: [WriteIOEffect], benign.}",  "desc": "writes the bytes of <tt class=\"docutils literal\"><span class=\"pre\">a[start..start+len-1]</span></tt> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error." },  { "module": "system",  "name": "writeBuffer",  "code": "proc writeBuffer*(f: File; buffer: pointer; len: int): int {.\u000A    tags: [WriteIOEffect], benign.}",  "desc": "writes the bytes of buffer pointed to by the parameter <cite>buffer</cite> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error." },  { "module": "system",  "name": "setFilePos",  "code": "proc setFilePos*(f: File; pos: int64) {.benign.}",  "desc": "sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero." },  { "module": "system",  "name": "getFilePos",  "code": "proc getFilePos*(f: File): int64 {.benign.}",  "desc": "retrieves the current position of the file pointer that is used to read from the file <cite>f</cite>. The file's first byte has the index zero." },  { "module": "system",  "name": "getFileHandle",  "code": "proc getFileHandle*(f: File): FileHandle {.importc: \"fileno\", \u000A    header: \"<stdio.h>\".}",  "desc": "returns the OS file handle of the file <tt class=\"docutils literal\"><span class=\"pre\">f</span></tt>. This is only useful for platform specific programming." },  { "module": "system",  "name": "cstringArrayToSeq",  "code": "proc cstringArrayToSeq*(a: cstringArray; len: int): seq[string]",  "desc": "converts a <tt class=\"docutils literal\"><span class=\"pre\">cstringArray</span></tt> to a <tt class=\"docutils literal\"><span class=\"pre\">seq[string]</span></tt>. <cite>a</cite> is supposed to be of length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>." },  { "module": "system",  "name": "cstringArrayToSeq",  "code": "proc cstringArrayToSeq*(a: cstringArray): seq[string]",  "desc": "converts a <tt class=\"docutils literal\"><span class=\"pre\">cstringArray</span></tt> to a <tt class=\"docutils literal\"><span class=\"pre\">seq[string]</span></tt>. <cite>a</cite> is supposed to be terminated by <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>." },  { "module": "system",  "name": "allocCStringArray",  "code": "proc allocCStringArray*(a: openArray[string]): cstringArray",  "desc": "creates a NULL terminated cstringArray from <cite>a</cite>. The result has to be freed with <cite>deallocCStringArray</cite> after it's not needed anymore." },  { "module": "system",  "name": "deallocCStringArray",  "code": "proc deallocCStringArray*(a: cstringArray)",  "desc": "frees a NULL terminated cstringArray." },  { "module": "system",  "name": "atomicInc",  "code": "proc atomicInc*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}",  "desc": "atomic increment of <cite>memLoc</cite>. Returns the value after the operation." },  { "module": "system",  "name": "atomicDec",  "code": "proc atomicDec*(memLoc: var int; x: int = 1): int {.inline, discardable, benign.}",  "desc": "atomic decrement of <cite>memLoc</cite>. Returns the value after the operation." },  { "module": "system",  "name": "setControlCHook",  "code": "proc setControlCHook*(hook: proc () {.noconv.})",  "desc": "allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported." },  { "module": "system",  "name": "writeStackTrace",  "code": "proc writeStackTrace*() {.tags: [WriteIOEffect].}",  "desc": "writes the current stack trace to <tt class=\"docutils literal\"><span class=\"pre\">stderr</span></tt>. This is only works for debug builds." },  { "module": "system",  "name": "getStackTrace",  "code": "proc getStackTrace*(): string",  "desc": "gets the current stack trace. This only works for debug builds." },  { "module": "system",  "name": "getStackTrace",  "code": "proc getStackTrace*(e: ref Exception): string",  "desc": "gets the stack trace associated with <cite>e</cite>, which is the stack that lead to the <tt class=\"docutils literal\"><span class=\"pre\">raise</span></tt> statement. This only works for debug builds." },  { "module": "system",  "name": "lines",  "code": "iterator lines*(filename: string): TaintedString {.tags: [ReadIOEffect].}",  "desc": "<p>Iterates over any line in the file named <cite>filename</cite>.</p>\u000A<p>If the file does not exist <cite>EIO</cite> is raised. The trailing newline character(s) are removed from the iterated lines. Example:</p>\u000A<pre><span class=\"Keyword\">import</span> <span class=\"Identifier\">strutils</span>\u000A\u000A<span class=\"Keyword\">proc</span> <span class=\"Identifier\">transformLetters</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">var</span> <span class=\"Identifier\">buffer</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;&quot;</span>\u000A  <span class=\"Keyword\">for</span> <span class=\"Identifier\">line</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">filename</span><span class=\"Operator\">.</span><span class=\"Identifier\">lines</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">buffer</span><span class=\"Operator\">.</span><span class=\"Identifier\">add</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">line</span><span class=\"Operator\">.</span><span class=\"Identifier\">replace</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;a&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;0&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">&amp;</span> <span class=\"CharLit\">'\\x0A'</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">writeFile</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">buffer</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "lines",  "code": "iterator lines*(f: File): TaintedString {.tags: [ReadIOEffect].}",  "desc": "<p>Iterate over any line in the file <cite>f</cite>.</p>\u000A<p>The trailing newline character(s) are removed from the iterated lines. Example:</p>\u000A<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">countZeros</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">File</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Keyword\">tuple</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">lines</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">zeros</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">for</span> <span class=\"Identifier\">line</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">filename</span><span class=\"Operator\">.</span><span class=\"Identifier\">lines</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">for</span> <span class=\"Identifier\">letter</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">line</span><span class=\"Punctuation\">:</span>\u000A      <span class=\"Keyword\">if</span> <span class=\"Identifier\">letter</span> <span class=\"Operator\">==</span> <span class=\"CharLit\">'0'</span><span class=\"Punctuation\">:</span>\u000A        <span class=\"Identifier\">result</span><span class=\"Operator\">.</span><span class=\"Identifier\">zeros</span> <span class=\"Operator\">+=</span> <span class=\"DecNumber\">1</span>\u000A    <span class=\"Identifier\">result</span><span class=\"Operator\">.</span><span class=\"Identifier\">lines</span> <span class=\"Operator\">+=</span> <span class=\"DecNumber\">1</span></pre>" },  { "module": "system",  "name": "getCurrentException",  "code": "proc getCurrentException*(): ref Exception {.compilerRtl, inl, benign.}",  "desc": "retrieves the current exception; if there is none, nil is returned." },  { "module": "system",  "name": "getCurrentExceptionMsg",  "code": "proc getCurrentExceptionMsg*(): string {.inline, benign.}",  "desc": "retrieves the error message that was attached to the current exception; if there is none, &quot;&quot; is returned." },  { "module": "system",  "name": "onRaise",  "code": "proc onRaise*(action: proc (e: ref Exception): bool {.closure.})",  "desc": "can be used in a <tt class=\"docutils literal\"><span class=\"pre\">try</span></tt> statement to setup a Lisp-like <span id=\"condition-system_1\">condition system</span>: This prevents the 'raise' statement to raise an exception but instead calls <tt class=\"docutils literal\"><span class=\"pre\">action</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">action</span></tt> returns false, the exception has been handled and does not propagate further through the call stack." },  { "module": "system",  "name": "setCurrentException",  "code": "proc setCurrentException*(exc: ref Exception) {.inline, benign.}",  "desc": "<p>sets the current exception.</p>\u000A<p><strong>Warning</strong>: Only use this if you know what you are doing.</p>\u000A" },  { "module": "system",  "name": "likely",  "code": "proc likely*(val: bool): bool {.importc: \"likely\", nodecl, nosideeffect.}",  "desc": "<p>Hints the optimizer that <cite>val</cite> is likely going to be true.</p>\u000A<p>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">inputValues</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Keyword\">if</span> <span class=\"Identifier\">likely</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span> <span class=\"Operator\">&lt;=</span> <span class=\"DecNumber\">100</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">process</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Value too big!&quot;</span></pre>" },  { "module": "system",  "name": "unlikely",  "code": "proc unlikely*(val: bool): bool {.importc: \"unlikely\", nodecl, nosideeffect.}",  "desc": "<p>Hints the optimizer that <cite>val</cite> is likely going to be false.</p>\u000A<p>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p>\u000A<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">inputValues</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Keyword\">if</span> <span class=\"Identifier\">unlikely</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span> <span class=\"Operator\">&gt;</span> <span class=\"DecNumber\">100</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Value too big!&quot;</span>\u000A  <span class=\"Keyword\">else</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">process</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">value</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "rawProc",  "code": "proc rawProc*[T: proc](x: T): pointer {.noSideEffect, inline.}",  "desc": "retrieves the raw proc pointer of the closure <cite>x</cite>. This is useful for interfacing closures with C." },  { "module": "system",  "name": "rawEnv",  "code": "proc rawEnv*[T: proc](x: T): pointer {.noSideEffect, inline.}",  "desc": "retrieves the raw environment pointer of the closure <cite>x</cite>. This is useful for interfacing closures with C." },  { "module": "system",  "name": "finished",  "code": "proc finished*[T: proc](x: T): bool {.noSideEffect, inline.}",  "desc": "can be used to determine if a first class iterator has finished." },  { "module": "system",  "name": "quit",  "code": "proc quit*(errormsg: string; errorcode = QuitFailure) {.noReturn.}",  "desc": "a shorthand for <tt class=\"docutils literal\"><span class=\"pre\">echo(errormsg); quit(errorcode)</span></tt>." },  { "module": "system",  "name": "`/`",  "code": "proc `/`*(x, y: int): float {.inline, noSideEffect.}",  "desc": "integer division that results in a float." },  { "module": "system",  "name": "`-|`",  "code": "template `-|`*(b, s: expr): expr" },  { "module": "system",  "name": "`[]`",  "code": "proc `[]`*(s: string; x: Slice[int]): string {.inline.}",  "desc": "slice operation for strings. Negative indexes are supported." },  { "module": "system",  "name": "`[]=`",  "code": "proc `[]=`*(s: var string; x: Slice[int]; b: string)",  "desc": "slice assignment for strings. Negative indexes are supported. If <tt class=\"docutils literal\"><span class=\"pre\">b.len</span></tt> is not exactly the number of elements that are referred to by <cite>x</cite>, a <span id=\"splice_1\">splice</span> is performed:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;abcdef&quot;</span>\u000A<span class=\"Identifier\">s</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span> <span class=\"Operator\">..</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">2</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;xyz&quot;</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;axyzf&quot;</span></pre>" },  { "module": "system",  "name": "`[]`",  "code": "proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[int]): seq[T]",  "desc": "slice operation for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds." },  { "module": "system",  "name": "`[]=`",  "code": "proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[int]; b: openArray[T])",  "desc": "slice assignment for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds." },  { "module": "system",  "name": "`[]`",  "code": "proc `[]`*[Idx, T](a: array[Idx, T]; x: Slice[Idx]): seq[T]",  "desc": "slice operation for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds." },  { "module": "system",  "name": "`[]=`",  "code": "proc `[]=`*[Idx, T](a: var array[Idx, T]; x: Slice[Idx]; b: openArray[T])",  "desc": "slice assignment for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds." },  { "module": "system",  "name": "`[]`",  "code": "proc `[]`*[T](s: seq[T]; x: Slice[int]): seq[T]",  "desc": "slice operation for sequences. Negative indexes are supported." },  { "module": "system",  "name": "`[]=`",  "code": "proc `[]=`*[T](s: var seq[T]; x: Slice[int]; b: openArray[T])",  "desc": "slice assignment for sequences. Negative indexes are supported. If <tt class=\"docutils literal\"><span class=\"pre\">b.len</span></tt> is not exactly the number of elements that are referred to by <cite>x</cite>, a <span id=\"splice_2\">splice</span> is performed. " },  { "module": "system",  "name": "slurp",  "code": "proc slurp*(filename: string): string {.magic: \"Slurp\".}",  "desc": "This is an alias for <a class=\"reference external\" href=\"#staticRead\">staticRead</a>." },  { "module": "system",  "name": "staticRead",  "code": "proc staticRead*(filename: string): string {.magic: \"Slurp\".}",  "desc": "Compile-time <a class=\"reference external\" href=\"#readFile\">readFile</a> proc for easy <span id=\"resource_1\">resource</span> embedding:<pre><span class=\"Keyword\">const</span> <span class=\"Identifier\">myResource</span> <span class=\"Operator\">=</span> <span class=\"RawData\">staticRead&quot;mydatafile.bin&quot;</span></pre><p><a class=\"reference external\" href=\"#slurp\">slurp</a> is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticRead</span></tt>.</p>\u000A" },  { "module": "system",  "name": "gorge",  "code": "proc gorge*(command: string; input = \"\"): string {.magic: \"StaticExec\".}",  "desc": "This is an alias for <a class=\"reference external\" href=\"#staticExec\">staticExec</a>." },  { "module": "system",  "name": "staticExec",  "code": "proc staticExec*(command: string; input = \"\"): string {.magic: \"StaticExec\".}",  "desc": "Executes an external process at compile-time. if <cite>input</cite> is not an empty string, it will be passed as a standard input to the executed program.<pre><span class=\"Keyword\">const</span> <span class=\"Identifier\">buildInfo</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;Revision &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">staticExec</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;git rev-parse HEAD&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">&amp;</span>\u000A                  <span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"StringLit\">Compiled on &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">staticExec</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;uname -v&quot;</span><span class=\"Punctuation\">)</span></pre><p><a class=\"reference external\" href=\"#gorge\">gorge</a> is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticExec</span></tt>. Note that you can use this proc inside a pragma like <a class=\"reference external\" href=\"nimc.html#passc-pragma\">passC</a> or <a class=\"reference external\" href=\"nimc.html#passl-pragma\">passL</a>.</p>\u000A" },  { "module": "system",  "name": "`+=`",  "code": "proc `+=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: \"Inc\", \u000A    noSideEffect.}",  "desc": "Increments an ordinal" },  { "module": "system",  "name": "`-=`",  "code": "proc `-=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: \"Dec\", \u000A    noSideEffect.}",  "desc": "Decrements an ordinal" },  { "module": "system",  "name": "`*=`",  "code": "proc `*=`*[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.inline, \u000A    noSideEffect.}",  "desc": "Binary <cite>*=</cite> operator for ordinals" },  { "module": "system",  "name": "`+=`",  "code": "proc `+=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}",  "desc": "Increments in placee a floating point number" },  { "module": "system",  "name": "`-=`",  "code": "proc `-=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}",  "desc": "Decrements in place a floating point number" },  { "module": "system",  "name": "`*=`",  "code": "proc `*=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}",  "desc": "Multiplies in place a floating point number" },  { "module": "system",  "name": "`/=`",  "code": "proc `/=`*(x: var float64; y: float64) {.inline, noSideEffect.}",  "desc": "Divides in place a floating point number" },  { "module": "system",  "name": "`/=`",  "code": "proc `/=`*[T: float | float32](x: var T; y: T) {.inline, noSideEffect.}",  "desc": "Divides in place a floating point number" },  { "module": "system",  "name": "`&amp;=`",  "code": "proc `&=`*(x: var string; y: string) {.magic: \"AppendStrStr\", noSideEffect.}" },  { "module": "system",  "name": "astToStr",  "code": "proc astToStr*[T](x: T): string {.magic: \"AstToStr\", noSideEffect.}",  "desc": "converts the AST of <cite>x</cite> into a string representation. This is very useful for debugging." },  { "module": "system",  "name": "instantiationInfo",  "code": "proc instantiationInfo*(index = - 1; fullPaths = false): tuple[filename: string, \u000A    line: int] {.magic: \"InstantiationInfo\", noSideEffect.}",  "desc": "<p>provides access to the compiler's instantiation stack line information.</p>\u000A<p>This proc is mostly useful for meta programming (eg. <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> template) to retrieve information about the current filename and line number. Example:</p>\u000A<pre><span class=\"Keyword\">import</span> <span class=\"Identifier\">strutils</span>\u000A\u000A<span class=\"Keyword\">template</span> <span class=\"Identifier\">testException</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">exception</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">code</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">expr</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">stmt</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">try</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">let</span> <span class=\"Identifier\">pos</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">instantiationInfo</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Keyword\">discard</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">code</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Test failure at $1:$2 with '$3'&quot;</span> <span class=\"Operator\">%</span> <span class=\"Punctuation\">[</span><span class=\"Identifier\">pos</span><span class=\"Operator\">.</span><span class=\"Identifier\">filename</span><span class=\"Punctuation\">,</span>\u000A      <span class=\"Operator\">$</span><span class=\"Identifier\">pos</span><span class=\"Operator\">.</span><span class=\"Identifier\">line</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">astToStr</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">code</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">]</span>\u000A    <span class=\"Identifier\">assert</span> <span class=\"Identifier\">false</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;A test expecting failure succeeded?&quot;</span>\u000A  <span class=\"Keyword\">except</span> <span class=\"Identifier\">exception</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">discard</span>\u000A\u000A<span class=\"Keyword\">proc</span> <span class=\"Identifier\">tester</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">pos</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">let</span>\u000A    <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctuation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctuation\">]</span>\u000A  <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">a</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">pos</span><span class=\"Punctuation\">]</span>\u000A\u000A<span class=\"Keyword\">when</span> <span class=\"Identifier\">isMainModule</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">testException</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">EInvalidIndex</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">tester</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">30</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Identifier\">testException</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">EInvalidIndex</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">tester</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">1</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A  <span class=\"Comment\"># --&gt; Test failure at example.nim:20 with 'tester(1)'</span></pre>" },  { "module": "system",  "name": "currentSourcePath",  "code": "template currentSourcePath*(): string",  "desc": "returns the full file-system path of the current source" },  { "module": "system",  "name": "raiseAssert",  "code": "proc raiseAssert*(msg: string) {.noinline.}" },  { "module": "system",  "name": "failedAssertImpl",  "code": "proc failedAssertImpl*(msg: string) {.raises: [], tags: [].}" },  { "module": "system",  "name": "assert",  "code": "template assert*(cond: bool; msg = \"\")",  "desc": "Raises <tt class=\"docutils literal\"><span class=\"pre\">AssertionError</span></tt> with <cite>msg</cite> if <cite>cond</cite> is false. Note that <tt class=\"docutils literal\"><span class=\"pre\">AssertionError</span></tt> is hidden from the effect system, so it doesn't produce <tt class=\"docutils literal\"><span class=\"pre\">{.raises: [AssertionError].}</span></tt>. This exception is only supposed to be caught by unit testing frameworks. The compiler may not generate any code at all for <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> if it is advised to do so through the <tt class=\"docutils literal\"><span class=\"pre\">-d:release</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">--assertions:off</span></tt> <a class=\"reference external\" href=\"nimc.html#command-line-switches\">command line switches</a>." },  { "module": "system",  "name": "doAssert",  "code": "template doAssert*(cond: bool; msg = \"\")",  "desc": "same as <cite>assert</cite> but is always turned on and not affected by the <tt class=\"docutils literal\"><span class=\"pre\">--assertions</span></tt> command line switch." },  { "module": "system",  "name": "items",  "code": "iterator items*[T](a: seq[T]): T {.inline.}",  "desc": "iterates over each item of <cite>a</cite>." },  { "module": "system",  "name": "items",  "code": "iterator items*(a: string): char {.inline.}",  "desc": "iterates over each item of <cite>a</cite>." },  { "module": "system",  "name": "onFailedAssert",  "code": "template onFailedAssert*(msg: expr; code: stmt): stmt {.dirty, immediate.}",  "desc": "Sets an assertion failure handler that will intercept any assert statements following <cite>onFailedAssert</cite> in the current lexical scope. Can be defined multiple times in a single function.<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">example</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">TErrorCode</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">onFailedAssert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">msg</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">log</span> <span class=\"Identifier\">msg</span>\u000A    <span class=\"Keyword\">return</span> <span class=\"Identifier\">E_FAIL</span>\u000A  \u000A  <span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Operator\">...</span><span class=\"Punctuation\">)</span>\u000A  \u000A  <span class=\"Identifier\">onFailedAssert</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">msg</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Keyword\">raise</span> <span class=\"Identifier\">newException</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">EMyException</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">msg</span><span class=\"Punctuation\">)</span>\u000A  \u000A  <span class=\"Identifier\">assert</span><span class=\"Punctuation\">(</span><span class=\"Operator\">...</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "system",  "name": "shallow",  "code": "proc shallow*[T](s: var seq[T]) {.noSideEffect, inline.}",  "desc": "marks a sequence <cite>s</cite> as <span id=\"shallow_1\">shallow</span>. Subsequent assignments will not perform deep copies of <cite>s</cite>. This is only useful for optimization purposes." },  { "module": "system",  "name": "shallow",  "code": "proc shallow*(s: var string) {.noSideEffect, inline.}",  "desc": "marks a string <cite>s</cite> as <span id=\"shallow_2\">shallow</span>. Subsequent assignments will not perform deep copies of <cite>s</cite>. This is only useful for optimization purposes." },  { "module": "system",  "name": "insert",  "code": "proc insert*(x: var string; item: string; i = 0) {.noSideEffect.}",  "desc": "inserts <cite>item</cite> into <cite>x</cite> at position <cite>i</cite>." },  { "module": "system",  "name": "compiles",  "code": "proc compiles*(x): bool {.magic: \"Compiles\", noSideEffect.}",  "desc": "Special compile-time procedure that checks whether <cite>x</cite> can be compiled without any semantic error. This can be used to check whether a type supports some operation:<pre><span class=\"Keyword\">when</span> <span class=\"Keyword\">not</span> <span class=\"Identifier\">compiles</span><span class=\"Punctuation\">(</span><span class=\"DecNumber\">3</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">4</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;'+' for integers is available&quot;</span></pre>" },  { "module": "system",  "name": "safeAdd",  "code": "proc safeAdd*[T](x: var seq[T]; y: T) {.noSideEffect.}" },  { "module": "system",  "name": "safeAdd",  "code": "proc safeAdd*(x: var string; y: char)" },  { "module": "system",  "name": "safeAdd",  "code": "proc safeAdd*(x: var string; y: string)" },  { "module": "system",  "name": "locals",  "code": "proc locals*(): RootObj {.magic: \"Locals\", noSideEffect.}",  "desc": "generates a tuple constructor expression listing all the local variables in the current scope. This is quite fast as it does not rely on any debug or runtime information. Note that in constrast to what the official signature says, the return type is not <tt class=\"docutils literal\"><span class=\"pre\">RootObj</span></tt> but a tuple of a structure that depends on the current scope. Example:<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">testLocals</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Keyword\">var</span>\u000A    <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;something&quot;</span>\u000A    <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">4</span>\u000A    <span class=\"Identifier\">c</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">locals</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A    <span class=\"Identifier\">d</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;super!&quot;</span>\u000A  \u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"DecNumber\">1</span>\u000A  <span class=\"Keyword\">for</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">fieldPairs</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">c</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A    <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;name &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot; with value &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">value</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;B is &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span>\u000A<span class=\"Comment\"># -&gt; name a with value something</span>\u000A<span class=\"Comment\"># -&gt; name b with value 4</span>\u000A<span class=\"Comment\"># -&gt; B is 1</span></pre>" },  { "module": "system",  "name": "deepCopy",  "code": "proc deepCopy*[T](x: var T; y: T) {.noSideEffect, magic: \"DeepCopy\".}",  "desc": "performs a deep copy of <cite>x</cite>. This is also used by the code generator for the implementation of <tt class=\"docutils literal\"><span class=\"pre\">spawn</span></tt>." },  { "module": "system",  "name": "procCall",  "code": "proc procCall*(x: expr) {.magic: \"ProcCall\".}",  "desc": "special magic to prohibit dynamic binding for <span id=\"method_1\">method</span> calls. This is similar to <span id=\"super_1\">super</span> in ordinary OO languages.<pre><span class=\"Comment\"># 'someMethod' will be resolved fully statically:</span>\u000A<span class=\"Identifier\">procCall</span> <span class=\"Identifier\">someMethod</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">b</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "tables",  "name": "len",  "code": "proc len*[A, B](t: Table[A, B]): int",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A, B](t: Table[A, B]): tuple[key: A, val: B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A, B](t: var Table[A, B]): tuple[key: A, val: var B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A, B](t: Table[A, B]): A",  "desc": "iterates over any key in the table <cite>t</cite>." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A, B](t: Table[A, B]): B",  "desc": "iterates over any value in the table <cite>t</cite>." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A, B](t: var Table[A, B]): var B",  "desc": "iterates over any value in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A, B](t: Table[A, B]; key: A): B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, default empty value for the type <cite>B</cite> is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A, B](t: var Table[A, B]; key: A): var B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "allValues",  "code": "iterator allValues*[A, B](t: Table[A, B]; key: A): B",  "desc": "iterates over any value in the table <cite>t</cite> that belongs to the given <cite>key</cite>." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A, B](t: Table[A, B]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A, B](t: var Table[A, B]; key: A; val: B)",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "tables",  "name": "add",  "code": "proc add*[A, B](t: var Table[A, B]; key: A; val: B)",  "desc": "puts a new (key, value)-pair into <cite>t</cite> even if <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt> already exists." },  { "module": "tables",  "name": "del",  "code": "proc del*[A, B](t: var Table[A, B]; key: A)",  "desc": "deletes <cite>key</cite> from hash table <cite>t</cite>." },  { "module": "tables",  "name": "initTable",  "code": "proc initTable*[A, B](initialSize = 64): Table[A, B]",  "desc": "<p>creates a new hash table that is empty.</p>\u000A<p><cite>initialSize</cite> needs to be a power of two. If you need to accept runtime values for this you could use the <tt class=\"docutils literal\"><span class=\"pre\">nextPowerOfTwo</span></tt> proc from the <a class=\"reference external\" href=\"math.html\">math</a> module.</p>\u000A" },  { "module": "tables",  "name": "toTable",  "code": "proc toTable*[A, B](pairs: openArray[tuple[key: A, val: B]]): Table[A, B]",  "desc": "creates a new hash table that contains the given <cite>pairs</cite>." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A, B](t: Table[A, B]): string",  "desc": "The <cite>$</cite> operator for hash tables." },  { "module": "tables",  "name": "`==`",  "code": "proc `==`*[A, B](s, t: Table[A, B]): bool" },  { "module": "tables",  "name": "indexBy",  "code": "proc indexBy*[A, B, C](collection: A; index: proc (x: B): C): Table[C, B]",  "desc": "Index the collection with the proc provided." },  { "module": "tables",  "name": "len",  "code": "proc len*[A, B](t: TableRef[A, B]): int",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A, B](t: TableRef[A, B]): tuple[key: A, val: B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A, B](t: TableRef[A, B]): tuple[key: A, val: var B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A, B](t: TableRef[A, B]): A",  "desc": "iterates over any key in the table <cite>t</cite>." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A, B](t: TableRef[A, B]): B",  "desc": "iterates over any value in the table <cite>t</cite>." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A, B](t: TableRef[A, B]): var B",  "desc": "iterates over any value in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A, B](t: TableRef[A, B]; key: A): B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, default empty value for the type <cite>B</cite> is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A, B](t: TableRef[A, B]; key: A): var B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A, B](t: TableRef[A, B]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A, B](t: TableRef[A, B]; key: A; val: B)",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "tables",  "name": "add",  "code": "proc add*[A, B](t: TableRef[A, B]; key: A; val: B)",  "desc": "puts a new (key, value)-pair into <cite>t</cite> even if <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt> already exists." },  { "module": "tables",  "name": "del",  "code": "proc del*[A, B](t: TableRef[A, B]; key: A)",  "desc": "deletes <cite>key</cite> from hash table <cite>t</cite>." },  { "module": "tables",  "name": "newTable",  "code": "proc newTable*[A, B](initialSize = 64): TableRef[A, B]" },  { "module": "tables",  "name": "newTable",  "code": "proc newTable*[A, B](pairs: openArray[tuple[key: A, val: B]]): TableRef[A, B]",  "desc": "creates a new hash table that contains the given <cite>pairs</cite>." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A, B](t: TableRef[A, B]): string",  "desc": "The <cite>$</cite> operator for hash tables." },  { "module": "tables",  "name": "`==`",  "code": "proc `==`*[A, B](s, t: TableRef[A, B]): bool" },  { "module": "tables",  "name": "newTableFrom",  "code": "proc newTableFrom*[A, B, C](collection: A; index: proc (x: B): C): TableRef[C, B]",  "desc": "Index the collection with the proc provided." },  { "module": "tables",  "name": "len",  "code": "proc len*[A, B](t: OrderedTable[A, B]): int {.inline.}",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A, B](t: OrderedTable[A, B]): tuple[key: A, val: B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A, B](t: var OrderedTable[A, B]): tuple[key: A, val: var B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite> in insertion order. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A, B](t: OrderedTable[A, B]): A",  "desc": "iterates over any key in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A, B](t: OrderedTable[A, B]): B",  "desc": "iterates over any value in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A, B](t: var OrderedTable[A, B]): var B",  "desc": "iterates over any value in the table <cite>t</cite> in insertion order. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A, B](t: OrderedTable[A, B]; key: A): B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, default empty value for the type <cite>B</cite> is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A, B](t: var OrderedTable[A, B]; key: A): var B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A, B](t: OrderedTable[A, B]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A, B](t: var OrderedTable[A, B]; key: A; val: B)",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "tables",  "name": "add",  "code": "proc add*[A, B](t: var OrderedTable[A, B]; key: A; val: B)",  "desc": "puts a new (key, value)-pair into <cite>t</cite> even if <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt> already exists." },  { "module": "tables",  "name": "initOrderedTable",  "code": "proc initOrderedTable*[A, B](initialSize = 64): OrderedTable[A, B]",  "desc": "<p>creates a new ordered hash table that is empty.</p>\u000A<p><cite>initialSize</cite> needs to be a power of two. If you need to accept runtime values for this you could use the <tt class=\"docutils literal\"><span class=\"pre\">nextPowerOfTwo</span></tt> proc from the <a class=\"reference external\" href=\"math.html\">math</a> module.</p>\u000A" },  { "module": "tables",  "name": "toOrderedTable",  "code": "proc toOrderedTable*[A, B](pairs: openArray[tuple[key: A, val: B]]): OrderedTable[\u000A    A, B]",  "desc": "creates a new ordered hash table that contains the given <cite>pairs</cite>." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A, B](t: OrderedTable[A, B]): string",  "desc": "The <cite>$</cite> operator for ordered hash tables." },  { "module": "tables",  "name": "sort",  "code": "proc sort*[A, B](t: var OrderedTable[A, B]; \u000A                 cmp: proc (x, y: tuple[key: A, val: B]): int)",  "desc": "sorts <cite>t</cite> according to <cite>cmp</cite>. This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after <cite>sort</cite> (in contrast to the <cite>sort</cite> for count tables)." },  { "module": "tables",  "name": "len",  "code": "proc len*[A, B](t: OrderedTableRef[A, B]): int {.inline.}",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A, B](t: OrderedTableRef[A, B]): tuple[key: A, val: B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A, B](t: OrderedTableRef[A, B]): tuple[key: A, val: var B]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite> in insertion order. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A, B](t: OrderedTableRef[A, B]): A",  "desc": "iterates over any key in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A, B](t: OrderedTableRef[A, B]): B",  "desc": "iterates over any value in the table <cite>t</cite> in insertion order." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A, B](t: OrderedTableRef[A, B]): var B",  "desc": "iterates over any value in the table <cite>t</cite> in insertion order. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A, B](t: OrderedTableRef[A, B]; key: A): B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, default empty value for the type <cite>B</cite> is returned and no exception is raised. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A, B](t: OrderedTableRef[A, B]; key: A): var B",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A, B](t: OrderedTableRef[A, B]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A, B](t: OrderedTableRef[A, B]; key: A; val: B)",  "desc": "puts a (key, value)-pair into <cite>t</cite>." },  { "module": "tables",  "name": "add",  "code": "proc add*[A, B](t: OrderedTableRef[A, B]; key: A; val: B)",  "desc": "puts a new (key, value)-pair into <cite>t</cite> even if <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt> already exists." },  { "module": "tables",  "name": "newOrderedTable",  "code": "proc newOrderedTable*[A, B](initialSize = 64): OrderedTableRef[A, B]",  "desc": "<p>creates a new ordered hash table that is empty.</p>\u000A<p><cite>initialSize</cite> needs to be a power of two. If you need to accept runtime values for this you could use the <tt class=\"docutils literal\"><span class=\"pre\">nextPowerOfTwo</span></tt> proc from the <a class=\"reference external\" href=\"math.html\">math</a> module.</p>\u000A" },  { "module": "tables",  "name": "newOrderedTable",  "code": "proc newOrderedTable*[A, B](pairs: openArray[tuple[key: A, val: B]]): OrderedTableRef[\u000A    A, B]",  "desc": "creates a new ordered hash table that contains the given <cite>pairs</cite>." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A, B](t: OrderedTableRef[A, B]): string",  "desc": "The <cite>$</cite> operator for ordered hash tables." },  { "module": "tables",  "name": "sort",  "code": "proc sort*[A, B](t: OrderedTableRef[A, B]; \u000A                 cmp: proc (x, y: tuple[key: A, val: B]): int)",  "desc": "sorts <cite>t</cite> according to <cite>cmp</cite>. This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after <cite>sort</cite> (in contrast to the <cite>sort</cite> for count tables)." },  { "module": "tables",  "name": "len",  "code": "proc len*[A](t: CountTable[A]): int",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A](t: CountTable[A]): tuple[key: A, val: int]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A](t: var CountTable[A]): tuple[key: A, val: var int]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A](t: CountTable[A]): A",  "desc": "iterates over any key in the table <cite>t</cite>." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A](t: CountTable[A]): int",  "desc": "iterates over any value in the table <cite>t</cite>." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A](t: CountTable[A]): var int",  "desc": "iterates over any value in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A](t: CountTable[A]; key: A): int",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, 0 is returned. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A](t: var CountTable[A]; key: A): var int",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A](t: CountTable[A]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A](t: var CountTable[A]; key: A; val: int)",  "desc": "puts a (key, value)-pair into <cite>t</cite>. <cite>val</cite> has to be positive." },  { "module": "tables",  "name": "initCountTable",  "code": "proc initCountTable*[A](initialSize = 64): CountTable[A]",  "desc": "<p>creates a new count table that is empty.</p>\u000A<p><cite>initialSize</cite> needs to be a power of two. If you need to accept runtime values for this you could use the <tt class=\"docutils literal\"><span class=\"pre\">nextPowerOfTwo</span></tt> proc from the <a class=\"reference external\" href=\"math.html\">math</a> module.</p>\u000A" },  { "module": "tables",  "name": "toCountTable",  "code": "proc toCountTable*[A](keys: openArray[A]): CountTable[A]",  "desc": "creates a new count table with every key in <cite>keys</cite> having a count of 1." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A](t: CountTable[A]): string",  "desc": "The <cite>$</cite> operator for count tables." },  { "module": "tables",  "name": "inc",  "code": "proc inc*[A](t: var CountTable[A]; key: A; val = 1)",  "desc": "increments <cite>t[key]</cite> by <cite>val</cite>." },  { "module": "tables",  "name": "smallest",  "code": "proc smallest*[A](t: CountTable[A]): tuple[key: A, val: int]",  "desc": "returns the largest (key,val)-pair. Efficiency: O(n)" },  { "module": "tables",  "name": "largest",  "code": "proc largest*[A](t: CountTable[A]): tuple[key: A, val: int]",  "desc": "returns the (key,val)-pair with the largest <cite>val</cite>. Efficiency: O(n)" },  { "module": "tables",  "name": "sort",  "code": "proc sort*[A](t: var CountTable[A])",  "desc": "sorts the count table so that the entry with the highest counter comes first. This is destructive! You must not modify <cite>t</cite> afterwards! You can use the iterators <cite>pairs</cite>,  <cite>keys</cite>, and <cite>values</cite> to iterate over <cite>t</cite> in the sorted order." },  { "module": "tables",  "name": "len",  "code": "proc len*[A](t: CountTableRef[A]): int",  "desc": "returns the number of keys in <cite>t</cite>." },  { "module": "tables",  "name": "pairs",  "code": "iterator pairs*[A](t: CountTableRef[A]): tuple[key: A, val: int]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>." },  { "module": "tables",  "name": "mpairs",  "code": "iterator mpairs*[A](t: CountTableRef[A]): tuple[key: A, val: var int]",  "desc": "iterates over any (key, value) pair in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "keys",  "code": "iterator keys*[A](t: CountTableRef[A]): A",  "desc": "iterates over any key in the table <cite>t</cite>." },  { "module": "tables",  "name": "values",  "code": "iterator values*[A](t: CountTableRef[A]): int",  "desc": "iterates over any value in the table <cite>t</cite>." },  { "module": "tables",  "name": "mvalues",  "code": "iterator mvalues*[A](t: CountTableRef[A]): var int",  "desc": "iterates over any value in the table <cite>t</cite>. The values can be modified." },  { "module": "tables",  "name": "`[]`",  "code": "proc `[]`*[A](t: CountTableRef[A]; key: A): int",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. If <cite>key</cite> is not in <cite>t</cite>, 0 is returned. One can check with <tt class=\"docutils literal\"><span class=\"pre\">hasKey</span></tt> whether the key exists." },  { "module": "tables",  "name": "mget",  "code": "proc mget*[A](t: CountTableRef[A]; key: A): var int",  "desc": "retrieves the value at <tt class=\"docutils literal\"><span class=\"pre\">t[key]</span></tt>. The value can be modified. If <cite>key</cite> is not in <cite>t</cite>, the <tt class=\"docutils literal\"><span class=\"pre\">EInvalidKey</span></tt> exception is raised." },  { "module": "tables",  "name": "hasKey",  "code": "proc hasKey*[A](t: CountTableRef[A]; key: A): bool",  "desc": "returns true iff <cite>key</cite> is in the table <cite>t</cite>." },  { "module": "tables",  "name": "`[]=`",  "code": "proc `[]=`*[A](t: CountTableRef[A]; key: A; val: int)",  "desc": "puts a (key, value)-pair into <cite>t</cite>. <cite>val</cite> has to be positive." },  { "module": "tables",  "name": "newCountTable",  "code": "proc newCountTable*[A](initialSize = 64): CountTableRef[A]",  "desc": "<p>creates a new count table that is empty.</p>\u000A<p><cite>initialSize</cite> needs to be a power of two. If you need to accept runtime values for this you could use the <tt class=\"docutils literal\"><span class=\"pre\">nextPowerOfTwo</span></tt> proc from the <a class=\"reference external\" href=\"math.html\">math</a> module.</p>\u000A" },  { "module": "tables",  "name": "newCountTable",  "code": "proc newCountTable*[A](keys: openArray[A]): CountTableRef[A]",  "desc": "creates a new count table with every key in <cite>keys</cite> having a count of 1." },  { "module": "tables",  "name": "`$`",  "code": "proc `$`*[A](t: CountTableRef[A]): string",  "desc": "The <cite>$</cite> operator for count tables." },  { "module": "tables",  "name": "inc",  "code": "proc inc*[A](t: CountTableRef[A]; key: A; val = 1)",  "desc": "increments <cite>t[key]</cite> by <cite>val</cite>." },  { "module": "tables",  "name": "smallest",  "code": "proc smallest*[A](t: CountTableRef[A]): tuple[key: A, val: int]",  "desc": "returns the largest (key,val)-pair. Efficiency: O(n)" },  { "module": "tables",  "name": "largest",  "code": "proc largest*[A](t: CountTableRef[A]): tuple[key: A, val: int]",  "desc": "returns the (key,val)-pair with the largest <cite>val</cite>. Efficiency: O(n)" },  { "module": "tables",  "name": "sort",  "code": "proc sort*[A](t: CountTableRef[A])",  "desc": "sorts the count table so that the entry with the highest counter comes first. This is destructive! You must not modify <cite>t</cite> afterwards! You can use the iterators <cite>pairs</cite>,  <cite>keys</cite>, and <cite>values</cite> to iterate over <cite>t</cite> in the sorted order." },  { "module": "terminal",  "name": "setCursorPos",  "code": "proc setCursorPos*(x, y: int)",  "desc": "sets the terminal's cursor to the (x,y) position. (0,0) is the upper left of the screen." },  { "module": "terminal",  "name": "setCursorXPos",  "code": "proc setCursorXPos*(x: int)",  "desc": "sets the terminal's cursor to the x position. The y position is not changed." },  { "module": "terminal",  "name": "setCursorYPos",  "code": "proc setCursorYPos*(y: int)",  "desc": "sets the terminal's cursor to the y position. The x position is not changed. <strong>Warning</strong>: This is not supported on UNIX!" },  { "module": "terminal",  "name": "cursorUp",  "code": "proc cursorUp*(count = 1)",  "desc": "Moves the cursor up by <cite>count</cite> rows." },  { "module": "terminal",  "name": "cursorDown",  "code": "proc cursorDown*(count = 1)",  "desc": "Moves the cursor down by <cite>count</cite> rows." },  { "module": "terminal",  "name": "cursorForward",  "code": "proc cursorForward*(count = 1)",  "desc": "Moves the cursor forward by <cite>count</cite> columns." },  { "module": "terminal",  "name": "cursorBackward",  "code": "proc cursorBackward*(count = 1)",  "desc": "Moves the cursor backward by <cite>count</cite> columns." },  { "module": "terminal",  "name": "eraseLine",  "code": "proc eraseLine*()",  "desc": "Erases the entire current line." },  { "module": "terminal",  "name": "eraseScreen",  "code": "proc eraseScreen*()",  "desc": "Erases the screen with the background colour and moves the cursor to home." },  { "module": "terminal",  "name": "resetAttributes",  "code": "proc resetAttributes*() {.noconv.}",  "desc": "resets all attributes; it is advisable to register this as a quit proc with <tt class=\"docutils literal\"><span class=\"pre\">system.addQuitProc(resetAttributes)</span></tt>." },  { "module": "terminal",  "name": "setStyle",  "code": "proc setStyle*(style: set[Style])",  "desc": "sets the terminal style" },  { "module": "terminal",  "name": "writeStyled",  "code": "proc writeStyled*(txt: string; style: set[Style] = {styleBright})",  "desc": "writes the text <cite>txt</cite> in a given <cite>style</cite>." },  { "module": "terminal",  "name": "setForegroundColor",  "code": "proc setForegroundColor*(fg: ForegroundColor; bright = false)",  "desc": "sets the terminal's foreground color" },  { "module": "terminal",  "name": "setBackgroundColor",  "code": "proc setBackgroundColor*(bg: BackgroundColor; bright = false)",  "desc": "sets the terminal's background color" },  { "module": "terminal",  "name": "isatty",  "code": "proc isatty*(f: File): bool",  "desc": "returns true if <cite>f</cite> is associated with a terminal device." },  { "module": "terminal",  "name": "styledEcho",  "code": "macro styledEcho*(m: varargs[expr]): stmt",  "desc": "to be documented." },  { "module": "threadpool",  "name": "await",  "code": "proc await*(fv: FlowVarBase)",  "desc": "waits until the value for the flowVar arrives. Usually it is not necessary to call this explicitly." },  { "module": "threadpool",  "name": "awaitAndThen",  "code": "proc awaitAndThen*[T](fv: FlowVar[T]; action: proc (x: T) {.closure.})",  "desc": "blocks until the <tt class=\"docutils literal\"><span class=\"pre\">fv</span></tt> is available and then passes its value to <tt class=\"docutils literal\"><span class=\"pre\">action</span></tt>. Note that due to Nim's parameter passing semantics this means that <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> doesn't need to be copied and so <tt class=\"docutils literal\"><span class=\"pre\">awaitAndThen</span></tt> can sometimes be more efficient than <tt class=\"docutils literal\"><span class=\"pre\">^</span></tt>." },  { "module": "threadpool",  "name": "`^`",  "code": "proc `^`*[T](fv: FlowVar[ref T]): foreign ptr T",  "desc": "blocks until the value is available and then returns this value." },  { "module": "threadpool",  "name": "`^`",  "code": "proc `^`*[T](fv: FlowVar[T]): T",  "desc": "blocks until the value is available and then returns this value." },  { "module": "threadpool",  "name": "awaitAny",  "code": "proc awaitAny*(flowVars: openArray[FlowVarBase]): int",  "desc": "awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived. A flowVar only supports one call to 'awaitAny' at the same time. That means if you await([a,b]) and await([b,c]) the second call will only await 'c'. If there is no flowVar left to be able to wait on, -1 is returned. <strong>Note</strong>: This results in non-deterministic behaviour and so should be avoided." },  { "module": "threadpool",  "name": "setMinPoolSize",  "code": "proc setMinPoolSize*(size: range[1 .. MaxThreadPoolSize])",  "desc": "sets the minimal thread pool size. The default value of this is 4." },  { "module": "threadpool",  "name": "setMaxPoolSize",  "code": "proc setMaxPoolSize*(size: range[1 .. MaxThreadPoolSize])",  "desc": "sets the minimal thread pool size. The default value of this is <tt class=\"docutils literal\"><span class=\"pre\">MaxThreadPoolSize</span></tt>." },  { "module": "threadpool",  "name": "preferSpawn",  "code": "proc preferSpawn*(): bool",  "desc": "Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead." },  { "module": "threadpool",  "name": "spawn",  "code": "proc spawn*(call: expr): expr {.magic: \"Spawn\".}",  "desc": "always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with <tt class=\"docutils literal\"><span class=\"pre\">FlowVar[T]</span></tt>." },  { "module": "threadpool",  "name": "spawnX",  "code": "template spawnX*(call: expr): expr",  "desc": "spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread. Usually it is advised to use 'spawn' in order to not block the producer for an unknown amount of time. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with <tt class=\"docutils literal\"><span class=\"pre\">FlowVar[T]</span></tt>." },  { "module": "threadpool",  "name": "parallel",  "code": "proc parallel*(body: stmt) {.magic: \"Parallel\".}",  "desc": "a parallel section can be used to execute a block in parallel. <tt class=\"docutils literal\"><span class=\"pre\">body</span></tt> has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information." },  { "module": "threadpool",  "name": "sync",  "code": "proc sync*()",  "desc": "a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier." },  { "module": "times",  "name": "getTime",  "code": "proc getTime*(): Time {.tags: [TimeEffect], gcsafe.}",  "desc": "gets the current calendar time as a UNIX epoch value (number of seconds elapsed since 1970) with integer precission. Use epochTime for higher resolution." },  { "module": "times",  "name": "getLocalTime",  "code": "proc getLocalTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], gcsafe.}",  "desc": "converts the calendar time <cite>t</cite> to broken-time representation, expressed relative to the user's specified time zone." },  { "module": "times",  "name": "getGMTime",  "code": "proc getGMTime*(t: Time): TimeInfo {.tags: [TimeEffect], raises: [], gcsafe.}",  "desc": "converts the calendar time <cite>t</cite> to broken-down time representation, expressed in Coordinated Universal Time (UTC)." },  { "module": "times",  "name": "timeInfoToTime",  "code": "proc timeInfoToTime*(timeInfo: TimeInfo): Time {.tags: [], gcsafe.}",  "desc": "converts a broken-down time structure to calendar time representation. The function ignores the specified contents of the structure members <cite>weekday</cite> and <cite>yearday</cite> and recomputes them from the other information in the broken-down time structure." },  { "module": "times",  "name": "fromSeconds",  "code": "proc fromSeconds*(since1970: float): Time {.tags: [], raises: [], gcsafe.}",  "desc": "Takes a float which contains the number of seconds since the unix epoch and returns a time object." },  { "module": "times",  "name": "fromSeconds",  "code": "proc fromSeconds*(since1970: int64): Time {.tags: [], raises: [], gcsafe.}",  "desc": "Takes an int which contains the number of seconds since the unix epoch and returns a time object." },  { "module": "times",  "name": "toSeconds",  "code": "proc toSeconds*(time: Time): float {.tags: [], raises: [], gcsafe.}",  "desc": "Returns the time in seconds since the unix epoch." },  { "module": "times",  "name": "`$`",  "code": "proc `$`*(timeInfo: TimeInfo): string {.tags: [], raises: [], gcsafe.}",  "desc": "converts a <cite>TimeInfo</cite> object to a string representation." },  { "module": "times",  "name": "`$`",  "code": "proc `$`*(time: Time): string {.tags: [], raises: [], gcsafe.}",  "desc": "converts a calendar time to a string representation." },  { "module": "times",  "name": "`-`",  "code": "proc `-`*(a, b: Time): int64 {.rtl, extern: \"ntDiffTime\", tags: [], raises: [].}",  "desc": "computes the difference of two calendar times. Result is in seconds." },  { "module": "times",  "name": "`&lt;`",  "code": "proc `<`*(a, b: Time): bool {.rtl, extern: \"ntLtTime\", tags: [], raises: [].}",  "desc": "returns true iff <tt class=\"docutils literal\"><span class=\"pre\">a &lt; b</span></tt>, that is iff a happened before b." },  { "module": "times",  "name": "`&lt;=`",  "code": "proc `<=`*(a, b: Time): bool {.rtl, extern: \"ntLeTime\", tags: [], raises: [].}",  "desc": "returns true iff <tt class=\"docutils literal\"><span class=\"pre\">a &lt;= b</span></tt>." },  { "module": "times",  "name": "`==`",  "code": "proc `==`*(a, b: Time): bool {.rtl, extern: \"ntEqTime\", tags: [], raises: [].}",  "desc": "returns true if <tt class=\"docutils literal\"><span class=\"pre\">a == b</span></tt>, that is if both times represent the same value" },  { "module": "times",  "name": "getTzname",  "code": "proc getTzname*(): tuple[nonDST, DST: string] {.tags: [TimeEffect], raises: [], \u000A    gcsafe.}",  "desc": "returns the local timezone; <tt class=\"docutils literal\"><span class=\"pre\">nonDST</span></tt> is the name of the local non-DST timezone, <tt class=\"docutils literal\"><span class=\"pre\">DST</span></tt> is the name of the local DST timezone." },  { "module": "times",  "name": "getTimezone",  "code": "proc getTimezone*(): int {.tags: [TimeEffect], raises: [], gcsafe.}",  "desc": "returns the offset of the local (non-DST) timezone in seconds west of UTC." },  { "module": "times",  "name": "getStartMilsecs",  "code": "proc getStartMilsecs*(): int {.deprecated, tags: [TimeEffect], gcsafe.}",  "desc": "get the miliseconds from the start of the program. <strong>Deprecated since version 0.8.10.</strong> Use <tt class=\"docutils literal\"><span class=\"pre\">epochTime</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">cpuTime</span></tt> instead." },  { "module": "times",  "name": "initInterval",  "code": "proc initInterval*(miliseconds, seconds, minutes, hours, days, months, years: int = 0): TimeInterval",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">TimeInterval</span></tt>." },  { "module": "times",  "name": "isLeapYear",  "code": "proc isLeapYear*(year: int): bool",  "desc": "returns true if <tt class=\"docutils literal\"><span class=\"pre\">year</span></tt> is a leap year" },  { "module": "times",  "name": "getDaysInMonth",  "code": "proc getDaysInMonth*(month: Month; year: int): int",  "desc": "gets the amount of days in a <tt class=\"docutils literal\"><span class=\"pre\">month</span></tt> of a <tt class=\"docutils literal\"><span class=\"pre\">year</span></tt>" },  { "module": "times",  "name": "`+`",  "code": "proc `+`*(a: TimeInfo; interval: TimeInterval): TimeInfo",  "desc": "<p>adds <tt class=\"docutils literal\"><span class=\"pre\">interval</span></tt> time.</p>\u000A<p><strong>Note:</strong> This has been only briefly tested and it may not be very accurate.</p>\u000A" },  { "module": "times",  "name": "`-`",  "code": "proc `-`*(a: TimeInfo; interval: TimeInterval): TimeInfo",  "desc": "<p>subtracts <tt class=\"docutils literal\"><span class=\"pre\">interval</span></tt> time.</p>\u000A<p><strong>Note:</strong> This has been only briefly tested, it is inaccurate especially when you subtract so much that you reach the Julian calendar.</p>\u000A" },  { "module": "times",  "name": "epochTime",  "code": "proc epochTime*(): float {.rtl, extern: \"nt$1\", tags: [TimeEffect].}",  "desc": "gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS)." },  { "module": "times",  "name": "cpuTime",  "code": "proc cpuTime*(): float {.rtl, extern: \"nt$1\", tags: [TimeEffect].}",  "desc": "gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than <tt class=\"docutils literal\"><span class=\"pre\">epochTime</span></tt>. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two <tt class=\"docutils literal\"><span class=\"pre\">cpuTime</span></tt> calls:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">t0</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">cpuTime</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">doWork</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;CPU time [s] &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">cpuTime</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">-</span> <span class=\"Identifier\">t0</span></pre>" },  { "module": "times",  "name": "unixTimeToWinTime",  "code": "proc unixTimeToWinTime*(t: Time): int64",  "desc": "converts a UNIX <cite>Time</cite> (<tt class=\"docutils literal\"><span class=\"pre\">time_t</span></tt>) to a Windows file time" },  { "module": "times",  "name": "winTimeToUnixTime",  "code": "proc winTimeToUnixTime*(t: int64): Time",  "desc": "converts a Windows time to a UNIX <cite>Time</cite> (<tt class=\"docutils literal\"><span class=\"pre\">time_t</span></tt>)" },  { "module": "times",  "name": "getDateStr",  "code": "proc getDateStr*(): string {.rtl, extern: \"nt$1\", tags: [TimeEffect].}",  "desc": "gets the current date as a string of the format <tt class=\"docutils literal\"><span class=\"pre\">YYYY-MM-DD</span></tt>." },  { "module": "times",  "name": "getClockStr",  "code": "proc getClockStr*(): string {.rtl, extern: \"nt$1\", tags: [TimeEffect].}",  "desc": "gets the current clock time as a string of the format <tt class=\"docutils literal\"><span class=\"pre\">HH:MM:SS</span></tt>." },  { "module": "times",  "name": "`$`",  "code": "proc `$`*(day: WeekDay): string",  "desc": "stingify operator for <tt class=\"docutils literal\"><span class=\"pre\">WeekDay</span></tt>." },  { "module": "times",  "name": "`$`",  "code": "proc `$`*(m: Month): string",  "desc": "stingify operator for <tt class=\"docutils literal\"><span class=\"pre\">TMonth</span></tt>." },  { "module": "times",  "name": "format",  "code": "proc format*(info: TimeInfo; f: string): string",  "desc": "This function formats <cite>info</cite> as specified by <cite>f</cite>. The following format specifiers are available:<table border=\"1\" class=\"docutils\"><tr><th>Specifier</th><th>Description</th><th>Example</th></tr>\u000A<tr><td>d</td><td>Numeric value of the day of the month, it will be one or two digits long.</td><td><tt class=\"docutils literal\"><span class=\"pre\">1/04/2012 -&gt; 1</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">21/04/2012 -&gt; 21</span></tt></td></tr>\u000A<tr><td>dd</td><td>Same as above, but always two digits.</td><td><tt class=\"docutils literal\"><span class=\"pre\">1/04/2012 -&gt; 01</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">21/04/2012 -&gt; 21</span></tt></td></tr>\u000A<tr><td>ddd</td><td>Three letter string which indicates the day of the week.</td><td><tt class=\"docutils literal\"><span class=\"pre\">Saturday -&gt; Sat</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">Monday -&gt; Mon</span></tt></td></tr>\u000A<tr><td>dddd</td><td>Full string for the day of the week.</td><td><tt class=\"docutils literal\"><span class=\"pre\">Saturday -&gt; Saturday</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">Monday -&gt; Monday</span></tt></td></tr>\u000A<tr><td>h</td><td>The hours in one digit if possible. Ranging from 0-12.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5pm -&gt; 5</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">2am -&gt; 2</span></tt></td></tr>\u000A<tr><td>hh</td><td>The hours in two digits always. If the hour is one digit 0 is prepended.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5pm -&gt; 05</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">11am -&gt; 11</span></tt></td></tr>\u000A<tr><td>H</td><td>The hours in one digit if possible, randing from 0-24.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5pm -&gt; 17</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">2am -&gt; 2</span></tt></td></tr>\u000A<tr><td>HH</td><td>The hours in two digits always. 0 is prepended if the hour is one digit.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5pm -&gt; 17</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">2am -&gt; 02</span></tt></td></tr>\u000A<tr><td>m</td><td>The minutes in 1 digit if possible.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5:30 -&gt; 30</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">2:01 -&gt; 1</span></tt></td></tr>\u000A<tr><td>mm</td><td>Same as above but always 2 digits, 0 is prepended if the minute is one digit.</td><td><tt class=\"docutils literal\"><span class=\"pre\">5:30 -&gt; 30</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">2:01 -&gt; 01</span></tt></td></tr>\u000A<tr><td>M</td><td>The month in one digit if possible.</td><td><tt class=\"docutils literal\"><span class=\"pre\">September -&gt; 9</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">December -&gt; 12</span></tt></td></tr>\u000A<tr><td>MM</td><td>The month in two digits always. 0 is prepended.</td><td><tt class=\"docutils literal\"><span class=\"pre\">September -&gt; 09</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">December -&gt; 12</span></tt></td></tr>\u000A<tr><td>MMM</td><td>Abbreviated three-letter form of the month.</td><td><tt class=\"docutils literal\"><span class=\"pre\">September -&gt; Sep</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">December -&gt; Dec</span></tt></td></tr>\u000A<tr><td>MMMM</td><td>Full month string, properly capitalized.</td><td><tt class=\"docutils literal\"><span class=\"pre\">September -&gt; September</span></tt></td></tr>\u000A<tr><td>s</td><td>Seconds as one digit if possible.</td><td><tt class=\"docutils literal\"><span class=\"pre\">00:00:06 -&gt; 6</span></tt></td></tr>\u000A<tr><td>ss</td><td>Same as above but always two digits. 0 is prepended.</td><td><tt class=\"docutils literal\"><span class=\"pre\">00:00:06 -&gt; 06</span></tt></td></tr>\u000A<tr><td>t</td><td><tt class=\"docutils literal\"><span class=\"pre\">A</span></tt> when time is in the AM. <tt class=\"docutils literal\"><span class=\"pre\">P</span></tt> when time is in the PM.</td><td></td></tr>\u000A<tr><td>tt</td><td>Same as above, but <tt class=\"docutils literal\"><span class=\"pre\">AM</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">PM</span></tt> instead of <tt class=\"docutils literal\"><span class=\"pre\">A</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">P</span></tt> respectively.</td><td></td></tr>\u000A<tr><td>y(yyyy)</td><td>This displays the year to different digits. You most likely only want 2 or 4 'y's</td><td></td></tr>\u000A<tr><td>yy</td><td>Displays the year to two digits.</td><td><tt class=\"docutils literal\"><span class=\"pre\">2012 -&gt; 12</span></tt></td></tr>\u000A<tr><td>yyyy</td><td>Displays the year to four digits.</td><td><tt class=\"docutils literal\"><span class=\"pre\">2012 -&gt; 2012</span></tt></td></tr>\u000A<tr><td>z</td><td>Displays the timezone offset from UTC.</td><td><tt class=\"docutils literal\"><span class=\"pre\">GMT+7 -&gt; +7</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">GMT-5 -&gt; -5</span></tt></td></tr>\u000A<tr><td>zz</td><td>Same as above but with leading 0.</td><td><tt class=\"docutils literal\"><span class=\"pre\">GMT+7 -&gt; +07</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">GMT-5 -&gt; -05</span></tt></td></tr>\u000A<tr><td>zzz</td><td>Same as above but with <tt class=\"docutils literal\"><span class=\"pre\">:00</span></tt>.</td><td><tt class=\"docutils literal\"><span class=\"pre\">GMT+7 -&gt; +07:00</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">GMT-5 -&gt; -05:00</span></tt></td></tr>\u000A<tr><td>ZZZ</td><td>Displays the name of the timezone.</td><td><tt class=\"docutils literal\"><span class=\"pre\">GMT -&gt; GMT</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">EST -&gt; EST</span></tt></td></tr>\u000A</table><p>Other strings can be inserted by putting them in <tt class=\"docutils literal\"><span class=\"pre\">''</span></tt>. For example <tt class=\"docutils literal\"><span class=\"pre\">hh'-&gt;'mm</span></tt> will give <tt class=\"docutils literal\"><span class=\"pre\">01-&gt;56</span></tt>.  The following characters can be inserted without quoting them: <tt class=\"docutils literal\"><span class=\"pre\">:</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">-</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">(</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">)</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">/</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">[</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">]</span></tt> <tt class=\"docutils literal\"><span class=\"pre\">,</span></tt>. However you don't need to necessarily separate format specifiers, a unambiguous format string like <tt class=\"docutils literal\"><span class=\"pre\">yyyyMMddhhmmss</span></tt> is valid too.</p>\u000A" },  { "module": "tinyc",  "name": "openCCState",  "code": "proc openCCState*(): PccState {.importc: \"tcc_new\", cdecl.}",  "desc": "create a new TCC compilation context" },  { "module": "tinyc",  "name": "closeCCState",  "code": "proc closeCCState*(s: PccState) {.importc: \"tcc_delete\", cdecl.}",  "desc": "free a TCC compilation context" },  { "module": "tinyc",  "name": "enableDebug",  "code": "proc enableDebug*(s: PccState) {.importc: \"tcc_enable_debug\", cdecl.}",  "desc": "add debug information in the generated code" },  { "module": "tinyc",  "name": "setErrorFunc",  "code": "proc setErrorFunc*(s: PccState; errorOpaque: pointer; errorFun: TErrorFunc) {.\u000A    cdecl, importc: \"tcc_set_error_func\".}",  "desc": "set error/warning display callback" },  { "module": "tinyc",  "name": "setWarning",  "code": "proc setWarning*(s: PccState; warningName: cstring; value: int) {.cdecl, \u000A    importc: \"tcc_set_warning\".}",  "desc": "set/reset a warning" },  { "module": "tinyc",  "name": "addIncludePath",  "code": "proc addIncludePath*(s: PccState; pathname: cstring) {.cdecl, \u000A    importc: \"tcc_add_include_path\".}",  "desc": "add include path" },  { "module": "tinyc",  "name": "addSysincludePath",  "code": "proc addSysincludePath*(s: PccState; pathname: cstring) {.cdecl, \u000A    importc: \"tcc_add_sysinclude_path\".}",  "desc": "add in system include path" },  { "module": "tinyc",  "name": "defineSymbol",  "code": "proc defineSymbol*(s: PccState; sym, value: cstring) {.cdecl, \u000A    importc: \"tcc_define_symbol\".}",  "desc": "define preprocessor symbol 'sym'. Can put optional value" },  { "module": "tinyc",  "name": "undefineSymbol",  "code": "proc undefineSymbol*(s: PccState; sym: cstring) {.cdecl, \u000A    importc: \"tcc_undefine_symbol\".}",  "desc": "undefine preprocess symbol 'sym'" },  { "module": "tinyc",  "name": "addFile",  "code": "proc addFile*(s: PccState; filename: cstring): cint {.cdecl, \u000A    importc: \"tcc_add_file\".}",  "desc": "add a file (either a C file, dll, an object, a library or an ld script). Return -1 if error." },  { "module": "tinyc",  "name": "compileString",  "code": "proc compileString*(s: PccState; buf: cstring): cint {.cdecl, \u000A    importc: \"tcc_compile_string\".}",  "desc": "compile a string containing a C source. Return non zero if error." },  { "module": "tinyc",  "name": "setOutputType",  "code": "proc setOutputType*(s: PCCState; outputType: cint): cint {.cdecl, \u000A    importc: \"tcc_set_output_type\".}",  "desc": "set output type. MUST BE CALLED before any compilation" },  { "module": "tinyc",  "name": "addLibraryPath",  "code": "proc addLibraryPath*(s: PccState; pathname: cstring): cint {.cdecl, \u000A    importc: \"tcc_add_library_path\".}",  "desc": "equivalent to -Lpath option" },  { "module": "tinyc",  "name": "addLibrary",  "code": "proc addLibrary*(s: PCCState; libraryname: cstring): cint {.cdecl, \u000A    importc: \"tcc_add_library\".}",  "desc": "the library name is the same as the argument of the '-l' option" },  { "module": "tinyc",  "name": "addSymbol",  "code": "proc addSymbol*(s: PccState; name: cstring; val: pointer): cint {.cdecl, \u000A    importc: \"tcc_add_symbol\".}",  "desc": "add a symbol to the compiled program" },  { "module": "tinyc",  "name": "outputFile",  "code": "proc outputFile*(s: PccState; filename: cstring): cint {.cdecl, \u000A    importc: \"tcc_output_file\".}",  "desc": "output an executable, library or object file. DO NOT call tcc_relocate() before." },  { "module": "tinyc",  "name": "run",  "code": "proc run*(s: PccState; argc: cint; argv: cstringArray): cint {.cdecl, \u000A    importc: \"tcc_run\".}",  "desc": "link and run main() function and return its value. DO NOT call tcc_relocate() before." },  { "module": "tinyc",  "name": "relocate",  "code": "proc relocate*(s: PccState; p: pointer): cint {.cdecl, importc: \"tcc_relocate\".}",  "desc": "copy code into memory passed in by the caller and do all relocations (needed before using tcc_get_symbol()). returns -1 on error and required size if ptr is NULL" },  { "module": "tinyc",  "name": "getSymbol",  "code": "proc getSymbol*(s: PccState; name: cstring): pointer {.cdecl, \u000A    importc: \"tcc_get_symbol\".}",  "desc": "return symbol value or NULL if not found" },  { "module": "tinyc",  "name": "setLibPath",  "code": "proc setLibPath*(s: PccState; path: cstring) {.cdecl, \u000A    importc: \"tcc_set_lib_path\".}",  "desc": "set CONFIG_TCCDIR at runtime" },  { "module": "tre",  "name": "regcomp",  "code": "proc regcomp*(preg: var TRegex; regex: cstring; cflags: cint): cint {.cdecl, \u000A    importc: \"tre_regcomp\", dynlib: treDll.}" },  { "module": "tre",  "name": "regexec",  "code": "proc regexec*(preg: var TRegex; string: cstring; nmatch: int; \u000A              pmatch: ptr TRegmatch; eflags: cint): cint {.cdecl, \u000A    importc: \"tre_regexec\", dynlib: treDll.}" },  { "module": "tre",  "name": "regerror",  "code": "proc regerror*(errcode: cint; preg: var TRegex; errbuf: cstring; \u000A               errbuf_size: int): int {.cdecl, importc: \"tre_regerror\", \u000A                                        dynlib: treDll.}" },  { "module": "tre",  "name": "regfree",  "code": "proc regfree*(preg: var TRegex) {.cdecl, importc: \"tre_regfree\", dynlib: treDll.}" },  { "module": "tre",  "name": "regncomp",  "code": "proc regncomp*(preg: var TRegex; regex: cstring; len: int; cflags: cint): cint {.\u000A    cdecl, importc: \"tre_regncomp\", dynlib: treDll.}" },  { "module": "tre",  "name": "regnexec",  "code": "proc regnexec*(preg: var TRegex; string: cstring; len: int; nmatch: int; \u000A               pmatch: ptr TRegmatch; eflags: cint): cint {.cdecl, \u000A    importc: \"tre_regnexec\", dynlib: treDll.}" },  { "module": "tre",  "name": "regaexec",  "code": "proc regaexec*(preg: var TRegex; string: cstring; match: ptr TRegamatch; \u000A               params: TRegaparams; eflags: cint): cint {.cdecl, \u000A    importc: \"tre_regaexec\", dynlib: treDll.}" },  { "module": "tre",  "name": "reganexec",  "code": "proc reganexec*(preg: var TRegex; string: cstring; len: int; \u000A                match: ptr TRegamatch; params: TRegaparams; eflags: cint): cint {.\u000A    cdecl, importc: \"tre_reganexec\", dynlib: treDll.}" },  { "module": "tre",  "name": "regaparams_default",  "code": "proc regaparams_default*(params: ptr TRegaparams) {.cdecl, \u000A    importc: \"tre_regaparams_default\", dynlib: treDll.}" },  { "module": "tre",  "name": "reguexec",  "code": "proc reguexec*(preg: var TRegex; string: ptr TStrSource; nmatch: int; \u000A               pmatch: ptr TRegmatch; eflags: cint): cint {.cdecl, \u000A    importc: \"tre_reguexec\", dynlib: treDll.}" },  { "module": "tre",  "name": "runtimeVersion",  "code": "proc runtimeVersion*(): cstring {.cdecl, importc: \"tre_version\", dynlib: treDll.}" },  { "module": "tre",  "name": "config",  "code": "proc config*(query: cint; result: pointer): cint {.cdecl, importc: \"tre_config\", \u000A    dynlib: treDll.}" },  { "module": "tre",  "name": "have_backrefs",  "code": "proc have_backrefs*(preg: var TRegex): cint {.cdecl, \u000A    importc: \"tre_have_backrefs\", dynlib: treDll.}" },  { "module": "tre",  "name": "have_approx",  "code": "proc have_approx*(preg: var TRegex): cint {.cdecl, importc: \"tre_have_approx\", \u000A    dynlib: treDll.}" },  { "module": "typeinfo",  "name": "toAny",  "code": "proc toAny*(x: TVarSlot): TAny {.inline.}",  "desc": "constructs a <tt class=\"docutils literal\"><span class=\"pre\">TAny</span></tt> object from a variable slot <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. This captures <cite>x</cite>'s address, so <cite>x</cite> can be modified with its <tt class=\"docutils literal\"><span class=\"pre\">TAny</span></tt> wrapper! The client needs to ensure that the wrapper <strong>does not</strong> live longer than <cite>x</cite>! This is provided for easier reflection capabilities of a debugger." },  { "module": "typeinfo",  "name": "toAny",  "code": "proc toAny*[T](x: var T): TAny {.inline.}",  "desc": "constructs a <tt class=\"docutils literal\"><span class=\"pre\">TAny</span></tt> object from <cite>x</cite>. This captures <cite>x</cite>'s address, so <cite>x</cite> can be modified with its <tt class=\"docutils literal\"><span class=\"pre\">TAny</span></tt> wrapper! The client needs to ensure that the wrapper <strong>does not</strong> live longer than <cite>x</cite>!" },  { "module": "typeinfo",  "name": "kind",  "code": "proc kind*(x: TAny): TAnyKind {.inline.}",  "desc": "get the type kind" },  { "module": "typeinfo",  "name": "size",  "code": "proc size*(x: TAny): int {.inline.}",  "desc": "returns the size of <cite>x</cite>'s type." },  { "module": "typeinfo",  "name": "baseTypeKind",  "code": "proc baseTypeKind*(x: TAny): TAnyKind {.inline.}",  "desc": "get the base type's kind; <tt class=\"docutils literal\"><span class=\"pre\">akNone</span></tt> is returned if <cite>x</cite> has no base type." },  { "module": "typeinfo",  "name": "baseTypeSize",  "code": "proc baseTypeSize*(x: TAny): int {.inline.}",  "desc": "returns the size of <cite>x</cite>'s basetype." },  { "module": "typeinfo",  "name": "invokeNew",  "code": "proc invokeNew*(x: TAny)",  "desc": "performs <tt class=\"docutils literal\"><span class=\"pre\">new(x)</span></tt>. <cite>x</cite> needs to represent a <tt class=\"docutils literal\"><span class=\"pre\">ref</span></tt>." },  { "module": "typeinfo",  "name": "invokeNewSeq",  "code": "proc invokeNewSeq*(x: TAny; len: int)",  "desc": "performs <tt class=\"docutils literal\"><span class=\"pre\">newSeq(x, len)</span></tt>. <cite>x</cite> needs to represent a <tt class=\"docutils literal\"><span class=\"pre\">seq</span></tt>." },  { "module": "typeinfo",  "name": "extendSeq",  "code": "proc extendSeq*(x: TAny)",  "desc": "performs <tt class=\"docutils literal\"><span class=\"pre\">setLen(x, x.len+1)</span></tt>. <cite>x</cite> needs to represent a <tt class=\"docutils literal\"><span class=\"pre\">seq</span></tt>." },  { "module": "typeinfo",  "name": "setObjectRuntimeType",  "code": "proc setObjectRuntimeType*(x: TAny)",  "desc": "this needs to be called to set <cite>x</cite>'s runtime object type field." },  { "module": "typeinfo",  "name": "`[]`",  "code": "proc `[]`*(x: TAny; i: int): TAny",  "desc": "accessor for an any <cite>x</cite> that represents an array or a sequence." },  { "module": "typeinfo",  "name": "`[]=`",  "code": "proc `[]=`*(x: TAny; i: int; y: TAny)",  "desc": "accessor for an any <cite>x</cite> that represents an array or a sequence." },  { "module": "typeinfo",  "name": "len",  "code": "proc len*(x: TAny): int",  "desc": "len for an any <cite>x</cite> that represents an array or a sequence." },  { "module": "typeinfo",  "name": "base",  "code": "proc base*(x: TAny): TAny",  "desc": "returns base TAny (useful for inherited object types)." },  { "module": "typeinfo",  "name": "isNil",  "code": "proc isNil*(x: TAny): bool",  "desc": "<cite>isNil</cite> for an any <cite>x</cite> that represents a sequence, string, cstring, proc or some pointer type." },  { "module": "typeinfo",  "name": "getPointer",  "code": "proc getPointer*(x: TAny): pointer",  "desc": "retrieve the pointer value out of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> needs to be of kind <tt class=\"docutils literal\"><span class=\"pre\">akString</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akCString</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akProc</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akRef</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akPtr</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akPointer</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akSequence</span></tt>." },  { "module": "typeinfo",  "name": "setPointer",  "code": "proc setPointer*(x: TAny; y: pointer)",  "desc": "sets the pointer value of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> needs to be of kind <tt class=\"docutils literal\"><span class=\"pre\">akString</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akCString</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akProc</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akRef</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akPtr</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akPointer</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">akSequence</span></tt>." },  { "module": "typeinfo",  "name": "fields",  "code": "iterator fields*(x: TAny): tuple[name: string, any: TAny]",  "desc": "iterates over every active field of the any <cite>x</cite> that represents an object or a tuple." },  { "module": "typeinfo",  "name": "`[]=`",  "code": "proc `[]=`*(x: TAny; fieldName: string; value: TAny)",  "desc": "sets a field of <cite>x</cite>; <cite>x</cite> represents an object or a tuple." },  { "module": "typeinfo",  "name": "`[]`",  "code": "proc `[]`*(x: TAny; fieldName: string): TAny",  "desc": "gets a field of <cite>x</cite>; <cite>x</cite> represents an object or a tuple." },  { "module": "typeinfo",  "name": "`[]`",  "code": "proc `[]`*(x: TAny): TAny",  "desc": "dereference operation for the any <cite>x</cite> that represents a ptr or a ref." },  { "module": "typeinfo",  "name": "`[]=`",  "code": "proc `[]=`*(x, y: TAny)",  "desc": "dereference operation for the any <cite>x</cite> that represents a ptr or a ref." },  { "module": "typeinfo",  "name": "getInt",  "code": "proc getInt*(x: TAny): int",  "desc": "retrieve the int value out of <cite>x</cite>. <cite>x</cite> needs to represent an int." },  { "module": "typeinfo",  "name": "getInt8",  "code": "proc getInt8*(x: TAny): int8",  "desc": "retrieve the int8 value out of <cite>x</cite>. <cite>x</cite> needs to represent an int8." },  { "module": "typeinfo",  "name": "getInt16",  "code": "proc getInt16*(x: TAny): int16",  "desc": "retrieve the int16 value out of <cite>x</cite>. <cite>x</cite> needs to represent an int16." },  { "module": "typeinfo",  "name": "getInt32",  "code": "proc getInt32*(x: TAny): int32",  "desc": "retrieve the int32 value out of <cite>x</cite>. <cite>x</cite> needs to represent an int32." },  { "module": "typeinfo",  "name": "getInt64",  "code": "proc getInt64*(x: TAny): int64",  "desc": "retrieve the int64 value out of <cite>x</cite>. <cite>x</cite> needs to represent an int64." },  { "module": "typeinfo",  "name": "getBiggestInt",  "code": "proc getBiggestInt*(x: TAny): BiggestInt",  "desc": "retrieve the integer value out of <cite>x</cite>. <cite>x</cite> needs to represent some integer, a bool, a char, an enum or a small enough bit set. The value might be sign-extended to <tt class=\"docutils literal\"><span class=\"pre\">BiggestInt</span></tt>." },  { "module": "typeinfo",  "name": "setBiggestInt",  "code": "proc setBiggestInt*(x: TAny; y: BiggestInt)",  "desc": "sets the integer value of <cite>x</cite>. <cite>x</cite> needs to represent some integer, a bool, a char, an enum or a small enough bit set." },  { "module": "typeinfo",  "name": "getUInt",  "code": "proc getUInt*(x: TAny): uint",  "desc": "retrieve the uint value out of <cite>x</cite>, <cite>x</cite> needs to represent an uint." },  { "module": "typeinfo",  "name": "getUInt8",  "code": "proc getUInt8*(x: TAny): uint8",  "desc": "retrieve the uint8 value out of <cite>x</cite>, <cite>x</cite> needs to represent an uint8." },  { "module": "typeinfo",  "name": "getUInt16",  "code": "proc getUInt16*(x: TAny): uint16",  "desc": "retrieve the uint16 value out of <cite>x</cite>, <cite>x</cite> needs to represent an uint16." },  { "module": "typeinfo",  "name": "getUInt32",  "code": "proc getUInt32*(x: TAny): uint32",  "desc": "retrieve the uint32 value out of <cite>x</cite>, <cite>x</cite> needs to represent an uint32." },  { "module": "typeinfo",  "name": "getUInt64",  "code": "proc getUInt64*(x: TAny): uint64",  "desc": "retrieve the uint64 value out of <cite>x</cite>, <cite>x</cite> needs to represent an uint64." },  { "module": "typeinfo",  "name": "getBiggestUint",  "code": "proc getBiggestUint*(x: TAny): uint64",  "desc": "retrieve the unsigned integer value out of <cite>x</cite>. <cite>x</cite> needs to represent an unsigned integer." },  { "module": "typeinfo",  "name": "setBiggestUint",  "code": "proc setBiggestUint*(x: TAny; y: uint64)",  "desc": "sets the unsigned integer value of <cite>c</cite>. <cite>c</cite> needs to represent an unsigned integer." },  { "module": "typeinfo",  "name": "getChar",  "code": "proc getChar*(x: TAny): char",  "desc": "retrieve the char value out of <cite>x</cite>. <cite>x</cite> needs to represent a char." },  { "module": "typeinfo",  "name": "getBool",  "code": "proc getBool*(x: TAny): bool",  "desc": "retrieve the bool value out of <cite>x</cite>. <cite>x</cite> needs to represent a bool." },  { "module": "typeinfo",  "name": "skipRange",  "code": "proc skipRange*(x: TAny): TAny",  "desc": "skips the range information of <cite>x</cite>." },  { "module": "typeinfo",  "name": "getEnumOrdinal",  "code": "proc getEnumOrdinal*(x: TAny; name: string): int",  "desc": "gets the enum field ordinal from <cite>name</cite>. <cite>x</cite> needs to represent an enum but is only used to access the type information. In case of an error <tt class=\"docutils literal\"><span class=\"pre\">low(int)</span></tt> is returned." },  { "module": "typeinfo",  "name": "getEnumField",  "code": "proc getEnumField*(x: TAny; ordinalValue: int): string",  "desc": "gets the enum field name as a string. <cite>x</cite> needs to represent an enum but is only used to access the type information. The field name of <cite>ordinalValue</cite> is returned. " },  { "module": "typeinfo",  "name": "getEnumField",  "code": "proc getEnumField*(x: TAny): string",  "desc": "gets the enum field name as a string. <cite>x</cite> needs to represent an enum." },  { "module": "typeinfo",  "name": "getFloat",  "code": "proc getFloat*(x: TAny): float",  "desc": "retrieve the float value out of <cite>x</cite>. <cite>x</cite> needs to represent an float.  " },  { "module": "typeinfo",  "name": "getFloat32",  "code": "proc getFloat32*(x: TAny): float32",  "desc": "retrieve the float32 value out of <cite>x</cite>. <cite>x</cite> needs to represent an float32." },  { "module": "typeinfo",  "name": "getFloat64",  "code": "proc getFloat64*(x: TAny): float64",  "desc": "retrieve the float64 value out of <cite>x</cite>. <cite>x</cite> needs to represent an float64." },  { "module": "typeinfo",  "name": "getBiggestFloat",  "code": "proc getBiggestFloat*(x: TAny): BiggestFloat",  "desc": "retrieve the float value out of <cite>x</cite>. <cite>x</cite> needs to represent some float. The value is extended to <tt class=\"docutils literal\"><span class=\"pre\">BiggestFloat</span></tt>." },  { "module": "typeinfo",  "name": "setBiggestFloat",  "code": "proc setBiggestFloat*(x: TAny; y: BiggestFloat)",  "desc": "sets the float value of <cite>x</cite>. <cite>x</cite> needs to represent some float." },  { "module": "typeinfo",  "name": "getString",  "code": "proc getString*(x: TAny): string",  "desc": "retrieve the string value out of <cite>x</cite>. <cite>x</cite> needs to represent a string." },  { "module": "typeinfo",  "name": "setString",  "code": "proc setString*(x: TAny; y: string)",  "desc": "sets the string value of <cite>x</cite>. <cite>x</cite> needs to represent a string." },  { "module": "typeinfo",  "name": "getCString",  "code": "proc getCString*(x: TAny): cstring",  "desc": "retrieve the cstring value out of <cite>x</cite>. <cite>x</cite> needs to represent a cstring." },  { "module": "typeinfo",  "name": "assign",  "code": "proc assign*(x, y: TAny)",  "desc": "copies the value of <cite>y</cite> to <cite>x</cite>. The assignment operator for <tt class=\"docutils literal\"><span class=\"pre\">TAny</span></tt> does NOT do this; it performs a shallow copy instead!" },  { "module": "typeinfo",  "name": "elements",  "code": "iterator elements*(x: TAny): int",  "desc": "iterates over every element of <cite>x</cite> that represents a Nim bitset." },  { "module": "typeinfo",  "name": "inclSetElement",  "code": "proc inclSetElement*(x: TAny; elem: int)",  "desc": "includes an element <cite>elem</cite> in <cite>x</cite>. <cite>x</cite> needs to represent a Nim bitset." },  { "module": "typetraits",  "name": "name",  "code": "proc name*(t: typedesc): string {.magic: \"TypeTrait\".}",  "desc": "<p>Returns the name of the given type.</p>\u000A<p>Example:</p>\u000A<pre><span class=\"Keyword\">import</span> <span class=\"Identifier\">typetraits</span>\u000A\u000A<span class=\"Keyword\">proc</span> <span class=\"Punctuation\">`</span><span class=\"Operator\">$</span><span class=\"Punctuation\">`</span><span class=\"Operator\">*</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">T</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">some</span><span class=\"Punctuation\">:</span><span class=\"Identifier\">typedesc</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">T</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">name</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">T</span><span class=\"Punctuation\">)</span>\u000A\u000A<span class=\"Keyword\">template</span> <span class=\"Identifier\">test</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">stmt</span> <span class=\"Operator\">=</span>\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;type: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Keyword\">type</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;, value: &quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">x</span>\u000A\u000A<span class=\"Identifier\">test</span> <span class=\"DecNumber\">42</span>\u000A<span class=\"Comment\"># --&gt; type: int, value: 42</span>\u000A<span class=\"Identifier\">test</span> <span class=\"StringLit\">&quot;Foo&quot;</span>\u000A<span class=\"Comment\"># --&gt; type: string, value: Foo</span>\u000A<span class=\"Identifier\">test</span><span class=\"Punctuation\">(</span><span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"CharLit\">'A'</span><span class=\"Punctuation\">,</span><span class=\"CharLit\">'B'</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Comment\"># --&gt; type: seq[char], value: @[A, B]</span></pre>" },  { "module": "typetraits",  "name": "arity",  "code": "proc arity*(t: typedesc): int {.magic: \"TypeTrait\".}",  "desc": "Returns the arity of the given type" },  { "module": "unicode",  "name": "`&lt;=%`",  "code": "proc `<=%`*(a, b: Rune): bool" },  { "module": "unicode",  "name": "`&lt;%`",  "code": "proc `<%`*(a, b: Rune): bool" },  { "module": "unicode",  "name": "`==`",  "code": "proc `==`*(a, b: Rune): bool" },  { "module": "unicode",  "name": "runeLen",  "code": "proc runeLen*(s: string): int {.rtl, extern: \"nuc$1\".}",  "desc": "returns the number of Unicode characters of the string <cite>s</cite>." },  { "module": "unicode",  "name": "runeLenAt",  "code": "proc runeLenAt*(s: string; i: int): int",  "desc": "returns the number of bytes the rune starting at <tt class=\"docutils literal\"><span class=\"pre\">s[i]</span></tt> takes." },  { "module": "unicode",  "name": "fastRuneAt",  "code": "template fastRuneAt*(s: string; i: int; result: expr; doInc = true)",  "desc": "Returns the unicode character <tt class=\"docutils literal\"><span class=\"pre\">s[i]</span></tt> in <cite>result</cite>. If <tt class=\"docutils literal\"><span class=\"pre\">doInc == true</span></tt> <cite>i</cite> is incremented by the number of bytes that have been processed." },  { "module": "unicode",  "name": "runeAt",  "code": "proc runeAt*(s: string; i: int): Rune",  "desc": "returns the unicode character in <cite>s</cite> at byte index <cite>i</cite>" },  { "module": "unicode",  "name": "toUTF8",  "code": "proc toUTF8*(c: Rune): string {.rtl, extern: \"nuc$1\".}",  "desc": "converts a rune into its UTF8 representation" },  { "module": "unicode",  "name": "`$`",  "code": "proc `$`*(rune: Rune): string",  "desc": "converts a rune to a string" },  { "module": "unicode",  "name": "`$`",  "code": "proc `$`*(runes: seq[Rune]): string",  "desc": "converts a sequence of runes to a string" },  { "module": "unicode",  "name": "toLower",  "code": "proc toLower*(c: Rune): Rune {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "Converts <cite>c</cite> into lower case. This works for any Unicode character. If possible, prefer <cite>toLower</cite> over <cite>toUpper</cite>. " },  { "module": "unicode",  "name": "toUpper",  "code": "proc toUpper*(c: Rune): Rune {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "Converts <cite>c</cite> into upper case. This works for any Unicode character. If possible, prefer <cite>toLower</cite> over <cite>toUpper</cite>. " },  { "module": "unicode",  "name": "toTitle",  "code": "proc toTitle*(c: Rune): Rune {.rtl, extern: \"nuc$1\", procvar.}" },  { "module": "unicode",  "name": "isLower",  "code": "proc isLower*(c: Rune): bool {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "returns true iff <cite>c</cite> is a lower case Unicode character If possible, prefer <cite>isLower</cite> over <cite>isUpper</cite>. " },  { "module": "unicode",  "name": "isUpper",  "code": "proc isUpper*(c: Rune): bool {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "returns true iff <cite>c</cite> is a upper case Unicode character If possible, prefer <cite>isLower</cite> over <cite>isUpper</cite>. " },  { "module": "unicode",  "name": "isAlpha",  "code": "proc isAlpha*(c: Rune): bool {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "returns true iff <cite>c</cite> is an <em>alpha</em> Unicode character (i.e. a letter)" },  { "module": "unicode",  "name": "isTitle",  "code": "proc isTitle*(c: Rune): bool {.rtl, extern: \"nuc$1\", procvar.}" },  { "module": "unicode",  "name": "isWhiteSpace",  "code": "proc isWhiteSpace*(c: Rune): bool {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "returns true iff <cite>c</cite> is a Unicode whitespace character" },  { "module": "unicode",  "name": "runes",  "code": "iterator runes*(s: string): Rune",  "desc": "iterates over any unicode character of the string <cite>s</cite>." },  { "module": "unicode",  "name": "cmpRunesIgnoreCase",  "code": "proc cmpRunesIgnoreCase*(a, b: string): int {.rtl, extern: \"nuc$1\", procvar.}",  "desc": "compares two UTF8 strings and ignores the case. Returns:<p>0 iff a == b<br />&lt; 0 iff a &lt; b<br />&gt; 0 iff a &gt; b<br /></p>" },  { "module": "unidecode",  "name": "loadUnidecodeTable",  "code": "proc loadUnidecodeTable*(datafile = \"unidecode.dat\")",  "desc": "loads the datafile that <cite>unidecode</cite> to work. Unless this module is compiled with the <tt class=\"docutils literal\"><span class=\"pre\">embedUnidecodeTable</span></tt> symbol defined, this needs to be called by the main thread before any thread can make a call to <cite>unidecode</cite>." },  { "module": "unidecode",  "name": "unidecode",  "code": "proc unidecode*(s: string): string",  "desc": "<p>Finds the sequence of ASCII characters that is the closest approximation to the UTF-8 string <cite>s</cite>.</p>\u000A<p>Example:</p>\u000A<blockquote><p>unidecode(&quot;x53x17x4ExB0&quot;)</p></blockquote>\u000A<p>Results in: &quot;Bei Jing&quot; </p>\u000A" },  { "module": "unittest",  "name": "testSetupIMPL",  "code": "template testSetupIMPL*(): stmt {.immediate, dirty.}" },  { "module": "unittest",  "name": "testTeardownIMPL",  "code": "template testTeardownIMPL*(): stmt {.immediate, dirty.}" },  { "module": "unittest",  "name": "suite",  "code": "template suite*(name: expr; body: stmt): stmt {.immediate, dirty.}" },  { "module": "unittest",  "name": "test",  "code": "template test*(name: expr; body: stmt): stmt {.immediate, dirty.}" },  { "module": "unittest",  "name": "checkpoint",  "code": "proc checkpoint*(msg: string)" },  { "module": "unittest",  "name": "fail",  "code": "template fail*()" },  { "module": "unittest",  "name": "check",  "code": "macro check*(conditions: stmt): stmt {.immediate.}" },  { "module": "unittest",  "name": "require",  "code": "template require*(conditions: stmt): stmt {.immediate, dirty.}" },  { "module": "unittest",  "name": "expect",  "code": "macro expect*(exceptions: varargs[expr]; body: stmt): stmt {.immediate.}" },  { "module": "unsigned",  "name": "`not`",  "code": "proc `not`*[T: SomeUInt](x: T): T {.magic: \"BitnotI\", noSideEffect.}",  "desc": "computes the <cite>bitwise complement</cite> of the integer <cite>x</cite>." },  { "module": "unsigned",  "name": "`shr`",  "code": "proc `shr`*[T: SomeUInt](x, y: T): T {.magic: \"ShrI\", noSideEffect.}",  "desc": "computes the <cite>shift right</cite> operation of <cite>x</cite> and <cite>y</cite>." },  { "module": "unsigned",  "name": "`shl`",  "code": "proc `shl`*[T: SomeUInt](x, y: T): T {.magic: \"ShlI\", noSideEffect.}",  "desc": "computes the <cite>shift left</cite> operation of <cite>x</cite> and <cite>y</cite>." },  { "module": "unsigned",  "name": "`and`",  "code": "proc `and`*[T: SomeUInt](x, y: T): T {.magic: \"BitandI\", noSideEffect.}",  "desc": "computes the <cite>bitwise and</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "unsigned",  "name": "`or`",  "code": "proc `or`*[T: SomeUInt](x, y: T): T {.magic: \"BitorI\", noSideEffect.}",  "desc": "computes the <cite>bitwise or</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "unsigned",  "name": "`xor`",  "code": "proc `xor`*[T: SomeUInt](x, y: T): T {.magic: \"BitxorI\", noSideEffect.}",  "desc": "computes the <cite>bitwise xor</cite> of numbers <cite>x</cite> and <cite>y</cite>." },  { "module": "unsigned",  "name": "`==`",  "code": "proc `==`*[T: SomeUInt](x, y: T): bool {.magic: \"EqI\", noSideEffect.}",  "desc": "Compares two unsigned integers for equality." },  { "module": "unsigned",  "name": "`+`",  "code": "proc `+`*[T: SomeUInt](x, y: T): T {.magic: \"AddU\", noSideEffect.}",  "desc": "Binary <cite>+</cite> operator for unsigned integers." },  { "module": "unsigned",  "name": "`-`",  "code": "proc `-`*[T: SomeUInt](x, y: T): T {.magic: \"SubU\", noSideEffect.}",  "desc": "Binary <cite>-</cite> operator for unsigned integers." },  { "module": "unsigned",  "name": "`*`",  "code": "proc `*`*[T: SomeUInt](x, y: T): T {.magic: \"MulU\", noSideEffect.}",  "desc": "Binary <cite>*</cite> operator for unsigned integers." },  { "module": "unsigned",  "name": "`div`",  "code": "proc `div`*[T: SomeUInt](x, y: T): T {.magic: \"DivU\", noSideEffect.}",  "desc": "computes the integer division. This is roughly the same as <tt class=\"docutils literal\"><span class=\"pre\">floor(x/y)</span></tt>." },  { "module": "unsigned",  "name": "`mod`",  "code": "proc `mod`*[T: SomeUInt](x, y: T): T {.magic: \"ModU\", noSideEffect.}",  "desc": "computes the integer modulo operation. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x - (x div y) * y</span></tt>." },  { "module": "unsigned",  "name": "`&lt;=`",  "code": "proc `<=`*[T: SomeUInt](x, y: T): bool {.magic: \"LeU\", noSideEffect.}",  "desc": "Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x &lt;= y</span></tt>." },  { "module": "unsigned",  "name": "`&lt;`",  "code": "proc `<`*[T: SomeUInt](x, y: T): bool {.magic: \"LtU\", noSideEffect.}",  "desc": "Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &lt; unsigned(y)</span></tt>." },  { "module": "uri",  "name": "`$`",  "code": "proc `$`*(url: TUrl): string {.deprecated.}",  "desc": "<strong>Deprecated since 0.9.6</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">TUri</span></tt> instead." },  { "module": "uri",  "name": "`/`",  "code": "proc `/`*(a, b: TUrl): TUrl {.deprecated.}",  "desc": "<p>Joins two URLs together, separating them with / if needed.</p>\u000A<p><strong>Deprecated since 0.9.6</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">TUri</span></tt> instead.</p>\u000A" },  { "module": "uri",  "name": "add",  "code": "proc add*(url: var TUrl; a: TUrl) {.deprecated.}",  "desc": "<p>Appends url to url.</p>\u000A<p><strong>Deprecated since 0.9.6</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">TUri</span></tt> instead.</p>\u000A" },  { "module": "uri",  "name": "parseUri",  "code": "proc parseUri*(uri: string): TUri",  "desc": "Parses a URI." },  { "module": "uri",  "name": "combine",  "code": "proc combine*(base: TUri; reference: TUri): TUri",  "desc": "<p>Combines a base URI with a reference URI.</p>\u000A<p>This uses the algorithm specified in <a class=\"reference external\" href=\"http://tools.ietf.org/html/rfc3986#section-5.2.2\">section 5.2.2 of RFC 3986</a>.</p>\u000A<p>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</p>\u000A<p>For building URIs you may wish to use `/` instead.</p>\u000A<p>Examples:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">foo</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">combine</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/baz&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/baz&quot;</span>\u000A\u000A<span class=\"Keyword\">let</span> <span class=\"Identifier\">bar</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">combine</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/foo/baz&quot;</span>\u000A\u000A<span class=\"Keyword\">let</span> <span class=\"Identifier\">bar</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">combine</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar/&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/foo/bar/baz&quot;</span></pre>" },  { "module": "uri",  "name": "combine",  "code": "proc combine*(uris: varargs[TUri]): TUri",  "desc": "Combines multiple URIs together." },  { "module": "uri",  "name": "`/`",  "code": "proc `/`*(x: TUri; path: string): TUri",  "desc": "<p>Concatenates the path specified to the specified URI's path.</p>\u000A<p>Contrary to the <tt class=\"docutils literal\"><span class=\"pre\">combine</span></tt> procedure you do not have to worry about the slashes at the beginning and end of the path and URI's path respectively.</p>\u000A<p>Examples:</p>\u000A<pre><span class=\"Keyword\">let</span> <span class=\"Identifier\">foo</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">/</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;/baz&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/foo/bar/baz&quot;</span>\u000A\u000A<span class=\"Keyword\">let</span> <span class=\"Identifier\">bar</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">/</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/foo/bar/baz&quot;</span>\u000A\u000A<span class=\"Keyword\">let</span> <span class=\"Identifier\">bar</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;http://example.com/foo/bar/&quot;</span><span class=\"Punctuation\">)</span> <span class=\"Operator\">/</span> <span class=\"Identifier\">parseUri</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;baz&quot;</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">foo</span><span class=\"Operator\">.</span><span class=\"Identifier\">path</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;/foo/bar/baz&quot;</span></pre>" },  { "module": "uri",  "name": "`$`",  "code": "proc `$`*(u: TUri): string",  "desc": "Returns the string representation of the specified URI object." },  { "module": "windows",  "name": "UNICODE_NULL",  "code": "proc UNICODE_NULL*(): WCHAR" },  { "module": "windows",  "name": "GetFirstChild",  "code": "proc GetFirstChild*(h: HWND): HWND" },  { "module": "windows",  "name": "GetNextSibling",  "code": "proc GetNextSibling*(h: HWND): HWND" },  { "module": "windows",  "name": "GetWindowID",  "code": "proc GetWindowID*(h: HWND): int32" },  { "module": "windows",  "name": "SubclassWindow",  "code": "proc SubclassWindow*(h: HWND; p: LONG): LONG" },  { "module": "windows",  "name": "GET_WM_COMMAND_CMD",  "code": "proc GET_WM_COMMAND_CMD*(w, L: int32): int32" },  { "module": "windows",  "name": "GET_WM_COMMAND_ID",  "code": "proc GET_WM_COMMAND_ID*(w, L: int32): int32" },  { "module": "windows",  "name": "GET_WM_CTLCOLOR_HDC",  "code": "proc GET_WM_CTLCOLOR_HDC*(w, L, msg: int32): HDC" },  { "module": "windows",  "name": "GET_WM_CTLCOLOR_HWND",  "code": "proc GET_WM_CTLCOLOR_HWND*(w, L, msg: int32): HWND" },  { "module": "windows",  "name": "GET_WM_HSCROLL_CODE",  "code": "proc GET_WM_HSCROLL_CODE*(w, L: int32): int32" },  { "module": "windows",  "name": "GET_WM_HSCROLL_HWND",  "code": "proc GET_WM_HSCROLL_HWND*(w, L: int32): HWND" },  { "module": "windows",  "name": "GET_WM_HSCROLL_POS",  "code": "proc GET_WM_HSCROLL_POS*(w, L: int32): int32" },  { "module": "windows",  "name": "GET_WM_MDIACTIVATE_FACTIVATE",  "code": "proc GET_WM_MDIACTIVATE_FACTIVATE*(h, a, b: int32): int32" },  { "module": "windows",  "name": "GET_WM_MDIACTIVATE_HWNDACTIVATE",  "code": "proc GET_WM_MDIACTIVATE_HWNDACTIVATE*(a, b: int32): HWND" },  { "module": "windows",  "name": "GET_WM_MDIACTIVATE_HWNDDEACT",  "code": "proc GET_WM_MDIACTIVATE_HWNDDEACT*(a, b: int32): HWND" },  { "module": "windows",  "name": "GET_WM_VSCROLL_CODE",  "code": "proc GET_WM_VSCROLL_CODE*(w, L: int32): int32" },  { "module": "windows",  "name": "GET_WM_VSCROLL_HWND",  "code": "proc GET_WM_VSCROLL_HWND*(w, L: int32): HWND" },  { "module": "windows",  "name": "GET_WM_VSCROLL_POS",  "code": "proc GET_WM_VSCROLL_POS*(w, L: int32): int32" },  { "module": "windows",  "name": "fBinary",  "code": "proc fBinary*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fBinary",  "code": "proc set_fBinary*(a: var DCB; fBinary: DWORD)" },  { "module": "windows",  "name": "fParity",  "code": "proc fParity*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fParity",  "code": "proc set_fParity*(a: var DCB; fParity: DWORD)" },  { "module": "windows",  "name": "fOutxCtsFlow",  "code": "proc fOutxCtsFlow*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fOutxCtsFlow",  "code": "proc set_fOutxCtsFlow*(a: var DCB; fOutxCtsFlow: DWORD)" },  { "module": "windows",  "name": "fOutxDsrFlow",  "code": "proc fOutxDsrFlow*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fOutxDsrFlow",  "code": "proc set_fOutxDsrFlow*(a: var DCB; fOutxDsrFlow: DWORD)" },  { "module": "windows",  "name": "fDtrControl",  "code": "proc fDtrControl*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fDtrControl",  "code": "proc set_fDtrControl*(a: var DCB; fDtrControl: DWORD)" },  { "module": "windows",  "name": "fDsrSensitivity",  "code": "proc fDsrSensitivity*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fDsrSensitivity",  "code": "proc set_fDsrSensitivity*(a: var DCB; fDsrSensitivity: DWORD)" },  { "module": "windows",  "name": "fTXContinueOnXoff",  "code": "proc fTXContinueOnXoff*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fTXContinueOnXoff",  "code": "proc set_fTXContinueOnXoff*(a: var DCB; fTXContinueOnXoff: DWORD)" },  { "module": "windows",  "name": "fOutX",  "code": "proc fOutX*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fOutX",  "code": "proc set_fOutX*(a: var DCB; fOutX: DWORD)" },  { "module": "windows",  "name": "fInX",  "code": "proc fInX*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fInX",  "code": "proc set_fInX*(a: var DCB; fInX: DWORD)" },  { "module": "windows",  "name": "fErrorChar",  "code": "proc fErrorChar*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fErrorChar",  "code": "proc set_fErrorChar*(a: var DCB; fErrorChar: DWORD)" },  { "module": "windows",  "name": "fNull",  "code": "proc fNull*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fNull",  "code": "proc set_fNull*(a: var DCB; fNull: DWORD)" },  { "module": "windows",  "name": "fRtsControl",  "code": "proc fRtsControl*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fRtsControl",  "code": "proc set_fRtsControl*(a: var DCB; fRtsControl: DWORD)" },  { "module": "windows",  "name": "fAbortOnError",  "code": "proc fAbortOnError*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fAbortOnError",  "code": "proc set_fAbortOnError*(a: var DCB; fAbortOnError: DWORD)" },  { "module": "windows",  "name": "fDummy2",  "code": "proc fDummy2*(a: var DCB): DWORD" },  { "module": "windows",  "name": "set_fDummy2",  "code": "proc set_fDummy2*(a: var DCB; fDummy2: DWORD)" },  { "module": "windows",  "name": "fCtsHold",  "code": "proc fCtsHold*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fCtsHold",  "code": "proc set_fCtsHold*(a: var COMSTAT; fCtsHold: DWORD)" },  { "module": "windows",  "name": "fDsrHold",  "code": "proc fDsrHold*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fDsrHold",  "code": "proc set_fDsrHold*(a: var COMSTAT; fDsrHold: DWORD)" },  { "module": "windows",  "name": "fRlsdHold",  "code": "proc fRlsdHold*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fRlsdHold",  "code": "proc set_fRlsdHold*(a: var COMSTAT; fRlsdHold: DWORD)" },  { "module": "windows",  "name": "fXoffHold",  "code": "proc fXoffHold*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fXoffHold",  "code": "proc set_fXoffHold*(a: var COMSTAT; fXoffHold: DWORD)" },  { "module": "windows",  "name": "fXoffSent",  "code": "proc fXoffSent*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fXoffSent",  "code": "proc set_fXoffSent*(a: var COMSTAT; fXoffSent: DWORD)" },  { "module": "windows",  "name": "fEof",  "code": "proc fEof*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fEof",  "code": "proc set_fEof*(a: var COMSTAT; fEof: DWORD)" },  { "module": "windows",  "name": "fTxim",  "code": "proc fTxim*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fTxim",  "code": "proc set_fTxim*(a: var COMSTAT; fTxim: DWORD)" },  { "module": "windows",  "name": "fReserved",  "code": "proc fReserved*(a: var COMSTAT): DWORD" },  { "module": "windows",  "name": "set_fReserved",  "code": "proc set_fReserved*(a: var COMSTAT; fReserved: DWORD)" },  { "module": "windows",  "name": "bAppReturnCode",  "code": "proc bAppReturnCode*(a: var DDEACK): int16" },  { "module": "windows",  "name": "set_bAppReturnCode",  "code": "proc set_bAppReturnCode*(a: var DDEACK; bAppReturnCode: int16)" },  { "module": "windows",  "name": "reserved",  "code": "proc reserved*(a: var DDEACK): int16" },  { "module": "windows",  "name": "set_reserved",  "code": "proc set_reserved*(a: var DDEACK; reserved: int16)" },  { "module": "windows",  "name": "fBusy",  "code": "proc fBusy*(a: var DDEACK): int16" },  { "module": "windows",  "name": "set_fBusy",  "code": "proc set_fBusy*(a: var DDEACK; fBusy: int16)" },  { "module": "windows",  "name": "fAck",  "code": "proc fAck*(a: var DDEACK): int16" },  { "module": "windows",  "name": "set_fAck",  "code": "proc set_fAck*(a: var DDEACK; fAck: int16)" },  { "module": "windows",  "name": "reserved",  "code": "proc reserved*(a: var DDEADVISE): int16" },  { "module": "windows",  "name": "set_reserved",  "code": "proc set_reserved*(a: var DDEADVISE; reserved: int16)" },  { "module": "windows",  "name": "fDeferUpd",  "code": "proc fDeferUpd*(a: var DDEADVISE): int16" },  { "module": "windows",  "name": "set_fDeferUpd",  "code": "proc set_fDeferUpd*(a: var DDEADVISE; fDeferUpd: int16)" },  { "module": "windows",  "name": "fAckReq",  "code": "proc fAckReq*(a: var DDEADVISE): int16" },  { "module": "windows",  "name": "set_fAckReq",  "code": "proc set_fAckReq*(a: var DDEADVISE; fAckReq: int16)" },  { "module": "windows",  "name": "unused",  "code": "proc unused*(a: var DDEDATA): int16" },  { "module": "windows",  "name": "set_unused",  "code": "proc set_unused*(a: var DDEDATA; unused: int16)" },  { "module": "windows",  "name": "fResponse",  "code": "proc fResponse*(a: var DDEDATA): int16" },  { "module": "windows",  "name": "set_fResponse",  "code": "proc set_fResponse*(a: var DDEDATA; fResponse: int16)" },  { "module": "windows",  "name": "fRelease",  "code": "proc fRelease*(a: var DDEDATA): int16" },  { "module": "windows",  "name": "set_fRelease",  "code": "proc set_fRelease*(a: var DDEDATA; fRelease: int16)" },  { "module": "windows",  "name": "reserved",  "code": "proc reserved*(a: var DDEDATA): int16" },  { "module": "windows",  "name": "set_reserved",  "code": "proc set_reserved*(a: var DDEDATA; reserved: int16)" },  { "module": "windows",  "name": "fAckReq",  "code": "proc fAckReq*(a: var DDEDATA): int16" },  { "module": "windows",  "name": "set_fAckReq",  "code": "proc set_fAckReq*(a: var DDEDATA; fAckReq: int16)" },  { "module": "windows",  "name": "unused",  "code": "proc unused*(a: var DDELN): int16" },  { "module": "windows",  "name": "set_unused",  "code": "proc set_unused*(a: var DDELN; unused: int16)" },  { "module": "windows",  "name": "fRelease",  "code": "proc fRelease*(a: var DDELN): int16" },  { "module": "windows",  "name": "set_fRelease",  "code": "proc set_fRelease*(a: var DDELN; fRelease: int16)" },  { "module": "windows",  "name": "fDeferUpd",  "code": "proc fDeferUpd*(a: var DDELN): int16" },  { "module": "windows",  "name": "set_fDeferUpd",  "code": "proc set_fDeferUpd*(a: var DDELN; fDeferUpd: int16)" },  { "module": "windows",  "name": "fAckReq",  "code": "proc fAckReq*(a: var DDELN): int16" },  { "module": "windows",  "name": "set_fAckReq",  "code": "proc set_fAckReq*(a: var DDELN; fAckReq: int16)" },  { "module": "windows",  "name": "unused",  "code": "proc unused*(a: var DDEPOKE): int16" },  { "module": "windows",  "name": "set_unused",  "code": "proc set_unused*(a: var DDEPOKE; unused: int16)" },  { "module": "windows",  "name": "fRelease",  "code": "proc fRelease*(a: var DDEPOKE): int16" },  { "module": "windows",  "name": "set_fRelease",  "code": "proc set_fRelease*(a: var DDEPOKE; fRelease: int16)" },  { "module": "windows",  "name": "fReserved",  "code": "proc fReserved*(a: var DDEPOKE): int16" },  { "module": "windows",  "name": "set_fReserved",  "code": "proc set_fReserved*(a: var DDEPOKE; fReserved: int16)" },  { "module": "windows",  "name": "unused",  "code": "proc unused*(a: var DDEUP): int16" },  { "module": "windows",  "name": "set_unused",  "code": "proc set_unused*(a: var DDEUP; unused: int16)" },  { "module": "windows",  "name": "fAck",  "code": "proc fAck*(a: var DDEUP): int16" },  { "module": "windows",  "name": "set_fAck",  "code": "proc set_fAck*(a: var DDEUP; fAck: int16)" },  { "module": "windows",  "name": "fRelease",  "code": "proc fRelease*(a: var DDEUP): int16" },  { "module": "windows",  "name": "set_fRelease",  "code": "proc set_fRelease*(a: var DDEUP; fRelease: int16)" },  { "module": "windows",  "name": "fReserved",  "code": "proc fReserved*(a: var DDEUP): int16" },  { "module": "windows",  "name": "set_fReserved",  "code": "proc set_fReserved*(a: var DDEUP; fReserved: int16)" },  { "module": "windows",  "name": "fAckReq",  "code": "proc fAckReq*(a: var DDEUP): int16" },  { "module": "windows",  "name": "set_fAckReq",  "code": "proc set_fAckReq*(a: var DDEUP; fAckReq: int16)" },  { "module": "windows",  "name": "GetBinaryTypeA",  "code": "proc GetBinaryTypeA*(lpApplicationName: LPCSTR; lpBinaryType: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeA\".}" },  { "module": "windows",  "name": "GetShortPathNameA",  "code": "proc GetShortPathNameA*(lpszLongPath: LPCSTR; lpszShortPath: LPSTR; \u000A                        cchBuffer: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "GetEnvironmentStringsA",  "code": "proc GetEnvironmentStringsA*(): LPSTR {.stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "FreeEnvironmentStringsA",  "code": "proc FreeEnvironmentStringsA*(para1: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "FormatMessageA",  "code": "proc FormatMessageA*(dwFlags: DWORD; lpSource: LPCVOID; dwMessageId: DWORD; \u000A                     dwLanguageId: DWORD; lpBuffer: LPSTR; nSize: DWORD; \u000A                     Arguments: va_list): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "CreateMailslotA",  "code": "proc CreateMailslotA*(lpName: LPCSTR; nMaxMessageSize: DWORD; \u000A                      lReadTimeout: DWORD; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "lstrcmpA",  "code": "proc lstrcmpA*(lpString1: LPCSTR; lpString2: LPCSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "lstrcmpiA",  "code": "proc lstrcmpiA*(lpString1: LPCSTR; lpString2: LPCSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "lstrcpynA",  "code": "proc lstrcpynA*(lpString1: LPSTR; lpString2: LPCSTR; iMaxLength: int32): LPSTR {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "CreateMutexA",  "code": "proc CreateMutexA*(lpMutexAttributes: LPSECURITY_ATTRIBUTES; \u000A                   bInitialOwner: WINBOOL; lpName: LPCSTR): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "OpenMutexA",  "code": "proc OpenMutexA*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; lpName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "CreateEventA",  "code": "proc CreateEventA*(lpEventAttributes: LPSECURITY_ATTRIBUTES; \u000A                   bManualReset: WINBOOL; bInitialState: WINBOOL; lpName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "OpenEventA",  "code": "proc OpenEventA*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; lpName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "CreateSemaphoreA",  "code": "proc CreateSemaphoreA*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES; \u000A                       lInitialCount: LONG; lMaximumCount: LONG; lpName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "OpenSemaphoreA",  "code": "proc OpenSemaphoreA*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                     lpName: LPCSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "CreateFileMappingA",  "code": "proc CreateFileMappingA*(hFile: HANDLE; \u000A                         lpFileMappingAttributes: LPSECURITY_ATTRIBUTES; \u000A                         flProtect: DWORD; dwMaximumSizeHigh: DWORD; \u000A                         dwMaximumSizeLow: DWORD; lpName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "OpenFileMappingA",  "code": "proc OpenFileMappingA*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                       lpName: LPCSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "GetLogicalDriveStringsA",  "code": "proc GetLogicalDriveStringsA*(nBufferLength: DWORD; lpBuffer: LPSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "LoadLibraryA",  "code": "proc LoadLibraryA*(lpLibFileName: LPCSTR): HINST {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "LoadLibraryExA",  "code": "proc LoadLibraryExA*(lpLibFileName: LPCSTR; hFile: HANDLE; dwFlags: DWORD): HINST {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "GetModuleFileNameA",  "code": "proc GetModuleFileNameA*(hModule: HINST; lpFilename: LPSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "GetModuleHandleA",  "code": "proc GetModuleHandleA*(lpModuleName: LPCSTR): HMODULE {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "FatalAppExitA",  "code": "proc FatalAppExitA*(uAction: WINUINT; lpMessageText: LPCSTR) {.stdcall, \u000A    dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "GetCommandLineA",  "code": "proc GetCommandLineA*(): LPSTR {.stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "GetEnvironmentVariableA",  "code": "proc GetEnvironmentVariableA*(lpName: LPCSTR; lpBuffer: LPSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "SetEnvironmentVariableA",  "code": "proc SetEnvironmentVariableA*(lpName: LPCSTR; lpValue: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "ExpandEnvironmentStringsA",  "code": "proc ExpandEnvironmentStringsA*(lpSrc: LPCSTR; lpDst: LPSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "OutputDebugStringA",  "code": "proc OutputDebugStringA*(lpOutputString: LPCSTR) {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "FindResourceA",  "code": "proc FindResourceA*(hModule: HINST; lpName: LPCSTR; lpType: LPCSTR): HRSRC {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "FindResourceExA",  "code": "proc FindResourceExA*(hModule: HINST; lpType: LPCSTR; lpName: LPCSTR; \u000A                      wLanguage: int16): HRSRC {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "EnumResourceTypesA",  "code": "proc EnumResourceTypesA*(hModule: HINST; lpEnumFunc: ENUMRESTYPEPROC; \u000A                         lParam: LONG): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc.}" },  { "module": "windows",  "name": "EnumResourceNamesA",  "code": "proc EnumResourceNamesA*(hModule: HINST; lpType: LPCSTR; \u000A                         lpEnumFunc: ENUMRESNAMEPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc.}" },  { "module": "windows",  "name": "EnumResourceLanguagesA",  "code": "proc EnumResourceLanguagesA*(hModule: HINST; lpType: LPCSTR; lpName: LPCSTR; \u000A                             lpEnumFunc: ENUMRESLANGPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumResourceLanguagesA\".}" },  { "module": "windows",  "name": "BeginUpdateResourceA",  "code": "proc BeginUpdateResourceA*(pFileName: LPCSTR; bDeleteExistingResources: WINBOOL): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BeginUpdateResourceA\".}" },  { "module": "windows",  "name": "UpdateResourceA",  "code": "proc UpdateResourceA*(hUpdate: HANDLE; lpType: LPCSTR; lpName: LPCSTR; \u000A                      wLanguage: int16; lpData: LPVOID; cbData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UpdateResourceA\".}" },  { "module": "windows",  "name": "EndUpdateResourceA",  "code": "proc EndUpdateResourceA*(hUpdate: HANDLE; fDiscard: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EndUpdateResourceA\".}" },  { "module": "windows",  "name": "GlobalAddAtomA",  "code": "proc GlobalAddAtomA*(lpString: LPCSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalAddAtomA\".}" },  { "module": "windows",  "name": "GlobalFindAtomA",  "code": "proc GlobalFindAtomA*(lpString: LPCSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalFindAtomA\".}" },  { "module": "windows",  "name": "GlobalGetAtomNameA",  "code": "proc GlobalGetAtomNameA*(nAtom: ATOM; lpBuffer: LPSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GlobalGetAtomNameA\".}" },  { "module": "windows",  "name": "AddAtomA",  "code": "proc AddAtomA*(lpString: LPCSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"AddAtomA\".}" },  { "module": "windows",  "name": "FindAtomA",  "code": "proc FindAtomA*(lpString: LPCSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindAtomA\".}" },  { "module": "windows",  "name": "GetAtomNameA",  "code": "proc GetAtomNameA*(nAtom: ATOM; lpBuffer: LPSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetAtomNameA\".}" },  { "module": "windows",  "name": "GetProfileIntA",  "code": "proc GetProfileIntA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; nDefault: WINT): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProfileIntA\".}" },  { "module": "windows",  "name": "GetProfileStringA",  "code": "proc GetProfileStringA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; lpDefault: LPCSTR; \u000A                        lpReturnedString: LPSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProfileStringA\".}" },  { "module": "windows",  "name": "WriteProfileStringA",  "code": "proc WriteProfileStringA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; lpString: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteProfileStringA\".}" },  { "module": "windows",  "name": "GetProfileSectionA",  "code": "proc GetProfileSectionA*(lpAppName: LPCSTR; lpReturnedString: LPSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProfileSectionA\".}" },  { "module": "windows",  "name": "WriteProfileSectionA",  "code": "proc WriteProfileSectionA*(lpAppName: LPCSTR; lpString: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteProfileSectionA\".}" },  { "module": "windows",  "name": "GetPrivateProfileIntA",  "code": "proc GetPrivateProfileIntA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; \u000A                            nDefault: WINT; lpFileName: LPCSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileIntA\".}" },  { "module": "windows",  "name": "GetPrivateProfileStringA",  "code": "proc GetPrivateProfileStringA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; \u000A                               lpDefault: LPCSTR; lpReturnedString: LPSTR; \u000A                               nSize: DWORD; lpFileName: LPCSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStringA\".}" },  { "module": "windows",  "name": "WritePrivateProfileStringA",  "code": "proc WritePrivateProfileStringA*(lpAppName: LPCSTR; lpKeyName: LPCSTR; \u000A                                 lpString: LPCSTR; lpFileName: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WritePrivateProfileStringA\".}" },  { "module": "windows",  "name": "GetPrivateProfileSectionA",  "code": "proc GetPrivateProfileSectionA*(lpAppName: LPCSTR; lpReturnedString: LPSTR; \u000A                                nSize: DWORD; lpFileName: LPCSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionA\".}" },  { "module": "windows",  "name": "WritePrivateProfileSectionA",  "code": "proc WritePrivateProfileSectionA*(lpAppName: LPCSTR; lpString: LPCSTR; \u000A                                  lpFileName: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WritePrivateProfileSectionA\".}" },  { "module": "windows",  "name": "GetDriveTypeA",  "code": "proc GetDriveTypeA*(lpRootPathName: LPCSTR): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDriveTypeA\".}" },  { "module": "windows",  "name": "GetSystemDirectoryA",  "code": "proc GetSystemDirectoryA*(lpBuffer: LPSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetSystemDirectoryA\".}" },  { "module": "windows",  "name": "GetTempPathA",  "code": "proc GetTempPathA*(nBufferLength: DWORD; lpBuffer: LPSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTempPathA\".}" },  { "module": "windows",  "name": "GetTempFileNameA",  "code": "proc GetTempFileNameA*(lpPathName: LPCSTR; lpPrefixString: LPCSTR; \u000A                       uUnique: WINUINT; lpTempFileName: LPSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTempFileNameA\".}" },  { "module": "windows",  "name": "GetWindowsDirectoryA",  "code": "proc GetWindowsDirectoryA*(lpBuffer: LPSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetWindowsDirectoryA\".}" },  { "module": "windows",  "name": "SetCurrentDirectoryA",  "code": "proc SetCurrentDirectoryA*(lpPathName: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCurrentDirectoryA\".}" },  { "module": "windows",  "name": "GetCurrentDirectoryA",  "code": "proc GetCurrentDirectoryA*(nBufferLength: DWORD; lpBuffer: LPSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCurrentDirectoryA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceA",  "code": "proc GetDiskFreeSpaceA*(lpRootPathName: LPCSTR; lpSectorsPerCluster: LPDWORD; \u000A                        lpBytesPerSector: LPDWORD; \u000A                        lpNumberOfFreeClusters: LPDWORD; \u000A                        lpTotalNumberOfClusters: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceA\".}" },  { "module": "windows",  "name": "CreateDirectoryA",  "code": "proc CreateDirectoryA*(lpPathName: LPCSTR; \u000A                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryA\".}" },  { "module": "windows",  "name": "CreateDirectoryExA",  "code": "proc CreateDirectoryExA*(lpTemplateDirectory: LPCSTR; lpNewDirectory: LPCSTR; \u000A                         lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryExA\".}" },  { "module": "windows",  "name": "RemoveDirectoryA",  "code": "proc RemoveDirectoryA*(lpPathName: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"RemoveDirectoryA\".}" },  { "module": "windows",  "name": "GetFullPathNameA",  "code": "proc GetFullPathNameA*(lpFileName: LPCSTR; nBufferLength: DWORD; \u000A                       lpBuffer: LPSTR; lpFilePart: var LPSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFullPathNameA\".}" },  { "module": "windows",  "name": "DefineDosDeviceA",  "code": "proc DefineDosDeviceA*(dwFlags: DWORD; lpDeviceName: LPCSTR; \u000A                       lpTargetPath: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DefineDosDeviceA\".}" },  { "module": "windows",  "name": "QueryDosDeviceA",  "code": "proc QueryDosDeviceA*(lpDeviceName: LPCSTR; lpTargetPath: LPSTR; ucchMax: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"QueryDosDeviceA\".}" },  { "module": "windows",  "name": "CreateFileA",  "code": "proc CreateFileA*(lpFileName: LPCSTR; dwDesiredAccess: DWORD; \u000A                  dwShareMode: DWORD; \u000A                  lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                  dwCreationDisposition: DWORD; dwFlagsAndAttributes: DWORD; \u000A                  hTemplateFile: HANDLE): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CreateFileA\".}" },  { "module": "windows",  "name": "SetFileAttributesA",  "code": "proc SetFileAttributesA*(lpFileName: LPCSTR; dwFileAttributes: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileAttributesA\".}" },  { "module": "windows",  "name": "GetFileAttributesA",  "code": "proc GetFileAttributesA*(lpFileName: LPCSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileAttributesA\".}" },  { "module": "windows",  "name": "GetCompressedFileSizeA",  "code": "proc GetCompressedFileSizeA*(lpFileName: LPCSTR; lpFileSizeHigh: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCompressedFileSizeA\".}" },  { "module": "windows",  "name": "DeleteFileA",  "code": "proc DeleteFileA*(lpFileName: LPCSTR): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"DeleteFileA\".}" },  { "module": "windows",  "name": "SearchPathA",  "code": "proc SearchPathA*(lpPath: LPCSTR; lpFileName: LPCSTR; lpExtension: LPCSTR; \u000A                  nBufferLength: DWORD; lpBuffer: LPSTR; lpFilePart: LPSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SearchPathA\".}" },  { "module": "windows",  "name": "CopyFileA",  "code": "proc CopyFileA*(lpExistingFileName: LPCSTR; lpNewFileName: LPCSTR; \u000A                bFailIfExists: WINBOOL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CopyFileA\".}" },  { "module": "windows",  "name": "MoveFileA",  "code": "proc MoveFileA*(lpExistingFileName: LPCSTR; lpNewFileName: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MoveFileA\".}" },  { "module": "windows",  "name": "MoveFileExA",  "code": "proc MoveFileExA*(lpExistingFileName: LPCSTR; lpNewFileName: LPCSTR; \u000A                  dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"MoveFileExA\".}" },  { "module": "windows",  "name": "CreateNamedPipeA",  "code": "proc CreateNamedPipeA*(lpName: LPCSTR; dwOpenMode: DWORD; dwPipeMode: DWORD; \u000A                       nMaxInstances: DWORD; nOutBufferSize: DWORD; \u000A                       nInBufferSize: DWORD; nDefaultTimeOut: DWORD; \u000A                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateNamedPipeA\".}" },  { "module": "windows",  "name": "GetNamedPipeHandleStateA",  "code": "proc GetNamedPipeHandleStateA*(hNamedPipe: HANDLE; lpState: LPDWORD; \u000A                               lpCurInstances: LPDWORD; \u000A                               lpMaxCollectionCount: LPDWORD; \u000A                               lpCollectDataTimeout: LPDWORD; lpUserName: LPSTR; \u000A                               nMaxUserNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetNamedPipeHandleStateA\".}" },  { "module": "windows",  "name": "CallNamedPipeA",  "code": "proc CallNamedPipeA*(lpNamedPipeName: LPCSTR; lpInBuffer: LPVOID; \u000A                     nInBufferSize: DWORD; lpOutBuffer: LPVOID; \u000A                     nOutBufferSize: DWORD; lpBytesRead: LPDWORD; \u000A                     nTimeOut: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CallNamedPipeA\".}" },  { "module": "windows",  "name": "WaitNamedPipeA",  "code": "proc WaitNamedPipeA*(lpNamedPipeName: LPCSTR; nTimeOut: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitNamedPipeA\".}" },  { "module": "windows",  "name": "SetVolumeLabelA",  "code": "proc SetVolumeLabelA*(lpRootPathName: LPCSTR; lpVolumeName: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetVolumeLabelA\".}" },  { "module": "windows",  "name": "GetVolumeInformationA",  "code": "proc GetVolumeInformationA*(lpRootPathName: LPCSTR; lpVolumeNameBuffer: LPSTR; \u000A                            nVolumeNameSize: DWORD; \u000A                            lpVolumeSerialNumber: LPDWORD; \u000A                            lpMaximumComponentLength: LPDWORD; \u000A                            lpFileSystemFlags: LPDWORD; \u000A                            lpFileSystemNameBuffer: LPSTR; \u000A                            nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationA\".}" },  { "module": "windows",  "name": "ClearEventLogA",  "code": "proc ClearEventLogA*(hEventLog: HANDLE; lpBackupFileName: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ClearEventLogA\".}" },  { "module": "windows",  "name": "BackupEventLogA",  "code": "proc BackupEventLogA*(hEventLog: HANDLE; lpBackupFileName: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"BackupEventLogA\".}" },  { "module": "windows",  "name": "OpenEventLogA",  "code": "proc OpenEventLogA*(lpUNCServerName: LPCSTR; lpSourceName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenEventLogA\".}" },  { "module": "windows",  "name": "RegisterEventSourceA",  "code": "proc RegisterEventSourceA*(lpUNCServerName: LPCSTR; lpSourceName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterEventSourceA\".}" },  { "module": "windows",  "name": "OpenBackupEventLogA",  "code": "proc OpenBackupEventLogA*(lpUNCServerName: LPCSTR; lpFileName: LPCSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenBackupEventLogA\".}" },  { "module": "windows",  "name": "ReadEventLogA",  "code": "proc ReadEventLogA*(hEventLog: HANDLE; dwReadFlags: DWORD; \u000A                    dwRecordOffset: DWORD; lpBuffer: LPVOID; \u000A                    nNumberOfBytesToRead: DWORD; pnBytesRead: LPDWORD; \u000A                    pnMinNumberOfBytesNeeded: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ReadEventLogA\".}" },  { "module": "windows",  "name": "ReportEventA",  "code": "proc ReportEventA*(hEventLog: HANDLE; wType: int16; wCategory: int16; \u000A                   dwEventID: DWORD; lpUserSid: PSID; wNumStrings: int16; \u000A                   dwDataSize: DWORD; lpStrings: LPPCSTR; lpRawData: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReportEventA\".}" },  { "module": "windows",  "name": "AccessCheckAndAuditAlarmA",  "code": "proc AccessCheckAndAuditAlarmA*(SubsystemName: LPCSTR; HandleId: LPVOID; \u000A                                ObjectTypeName: LPSTR; ObjectName: LPSTR; \u000A                                SecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                DesiredAccess: DWORD; \u000A                                GenericMapping: PGENERIC_MAPPING; \u000A                                ObjectCreation: WINBOOL; GrantedAccess: LPDWORD; \u000A                                AccessStatus: LPBOOL; pfGenerateOnClose: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AccessCheckAndAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarmA",  "code": "proc ObjectOpenAuditAlarmA*(SubsystemName: LPCSTR; HandleId: LPVOID; \u000A                            ObjectTypeName: LPSTR; ObjectName: LPSTR; \u000A                            pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                            ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                            GrantedAccess: DWORD; Privileges: PPRIVILEGE_SET; \u000A                            ObjectCreation: WINBOOL; AccessGranted: WINBOOL; \u000A                            GenerateOnClose: LPBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarmA",  "code": "proc ObjectPrivilegeAuditAlarmA*(SubsystemName: LPCSTR; HandleId: LPVOID; \u000A                                 ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                                 Privileges: PPRIVILEGE_SET; \u000A                                 AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectCloseAuditAlarmA",  "code": "proc ObjectCloseAuditAlarmA*(SubsystemName: LPCSTR; HandleId: LPVOID; \u000A                             GenerateOnClose: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectCloseAuditAlarmA\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarmA",  "code": "proc PrivilegedServiceAuditAlarmA*(SubsystemName: LPCSTR; ServiceName: LPCSTR; \u000A                                   ClientToken: HANDLE; \u000A                                   Privileges: PPRIVILEGE_SET; \u000A                                   AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmA\".}" },  { "module": "windows",  "name": "SetFileSecurityA",  "code": "proc SetFileSecurityA*(lpFileName: LPCSTR; \u000A                       SecurityInformation: SECURITY_INFORMATION; \u000A                       pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetFileSecurityA\".}" },  { "module": "windows",  "name": "GetFileSecurityA",  "code": "proc GetFileSecurityA*(lpFileName: LPCSTR; \u000A                       RequestedInformation: SECURITY_INFORMATION; \u000A                       pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                       nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetFileSecurityA\".}" },  { "module": "windows",  "name": "FindFirstChangeNotificationA",  "code": "proc FindFirstChangeNotificationA*(lpPathName: LPCSTR; bWatchSubtree: WINBOOL; \u000A                                   dwNotifyFilter: DWORD): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindFirstChangeNotificationA\".}" },  { "module": "windows",  "name": "IsBadStringPtrA",  "code": "proc IsBadStringPtrA*(lpsz: LPCSTR; ucchMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadStringPtrA\".}" },  { "module": "windows",  "name": "LookupAccountSidA",  "code": "proc LookupAccountSidA*(lpSystemName: LPCSTR; Sid: PSID; Name: LPSTR; \u000A                        cbName: LPDWORD; ReferencedDomainName: LPSTR; \u000A                        cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountSidA\".}" },  { "module": "windows",  "name": "LookupAccountNameA",  "code": "proc LookupAccountNameA*(lpSystemName: LPCSTR; lpAccountName: LPCSTR; Sid: PSID; \u000A                         cbSid: LPDWORD; ReferencedDomainName: LPSTR; \u000A                         cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeValueA",  "code": "proc LookupPrivilegeValueA*(lpSystemName: LPCSTR; lpName: LPCSTR; lpLuid: PLUID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeValueA\".}" },  { "module": "windows",  "name": "LookupPrivilegeNameA",  "code": "proc LookupPrivilegeNameA*(lpSystemName: LPCSTR; lpLuid: PLUID; lpName: LPSTR; \u000A                           cbName: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayNameA",  "code": "proc LookupPrivilegeDisplayNameA*(lpSystemName: LPCSTR; lpName: LPCSTR; \u000A                                  lpDisplayName: LPSTR; cbDisplayName: LPDWORD; \u000A                                  lpLanguageId: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameA\".}" },  { "module": "windows",  "name": "BuildCommDCBA",  "code": "proc BuildCommDCBA*(lpDef: LPCSTR; lpDCB: LPDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBA\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeoutsA",  "code": "proc BuildCommDCBAndTimeoutsA*(lpDef: LPCSTR; lpDCB: LPDCB; \u000A                               lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsA\".}" },  { "module": "windows",  "name": "CommConfigDialogA",  "code": "proc CommConfigDialogA*(lpszName: LPCSTR; wnd: HWND; lpCC: LPCOMMCONFIG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogA\".}" },  { "module": "windows",  "name": "GetDefaultCommConfigA",  "code": "proc GetDefaultCommConfigA*(lpszName: LPCSTR; lpCC: LPCOMMCONFIG; \u000A                            lpdwSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigA\".}" },  { "module": "windows",  "name": "SetDefaultCommConfigA",  "code": "proc SetDefaultCommConfigA*(lpszName: LPCSTR; lpCC: LPCOMMCONFIG; dwSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetDefaultCommConfigA\".}" },  { "module": "windows",  "name": "GetComputerNameA",  "code": "proc GetComputerNameA*(lpBuffer: LPSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameA\".}" },  { "module": "windows",  "name": "SetComputerNameA",  "code": "proc SetComputerNameA*(lpComputerName: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetComputerNameA\".}" },  { "module": "windows",  "name": "GetUserNameA",  "code": "proc GetUserNameA*(lpBuffer: LPSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameA\".}" },  { "module": "windows",  "name": "LoadKeyboardLayoutA",  "code": "proc LoadKeyboardLayoutA*(pwszKLID: LPCSTR; Flags: WINUINT): HKL {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadKeyboardLayoutA\".}" },  { "module": "windows",  "name": "GetKeyboardLayoutNameA",  "code": "proc GetKeyboardLayoutNameA*(pwszKLID: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetKeyboardLayoutNameA\".}" },  { "module": "windows",  "name": "CreateDesktopA",  "code": "proc CreateDesktopA*(lpszDesktop: LPSTR; lpszDevice: LPSTR; pDevmode: LPDEVMODE; \u000A                     dwFlags: DWORD; dwDesiredAccess: DWORD; \u000A                     lpsa: LPSECURITY_ATTRIBUTES): HDESK {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDesktopA\".}" },  { "module": "windows",  "name": "OpenDesktopA",  "code": "proc OpenDesktopA*(lpszDesktop: LPSTR; dwFlags: DWORD; fInherit: WINBOOL; \u000A                   dwDesiredAccess: DWORD): HDESK {.stdcall, dynlib: \"user32\", \u000A    importc: \"OpenDesktopA\".}" },  { "module": "windows",  "name": "EnumDesktopsA",  "code": "proc EnumDesktopsA*(hwinsta: HWINSTA; lpEnumFunc: DESKTOPENUMPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumDesktopsA\".}" },  { "module": "windows",  "name": "CreateWindowStationA",  "code": "proc CreateWindowStationA*(lpwinsta: LPSTR; dwReserved: DWORD; \u000A                           dwDesiredAccess: DWORD; lpsa: LPSECURITY_ATTRIBUTES): HWINSTA {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowStationA\".}" },  { "module": "windows",  "name": "OpenWindowStationA",  "code": "proc OpenWindowStationA*(lpszWinSta: LPSTR; fInherit: WINBOOL; \u000A                         dwDesiredAccess: DWORD): HWINSTA {.stdcall, \u000A    dynlib: \"user32\", importc: \"OpenWindowStationA\".}" },  { "module": "windows",  "name": "EnumWindowStationsA",  "code": "proc EnumWindowStationsA*(lpEnumFunc: ENUMWINDOWSTATIONPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumWindowStationsA\".}" },  { "module": "windows",  "name": "GetUserObjectInformationA",  "code": "proc GetUserObjectInformationA*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                                nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationA\".}" },  { "module": "windows",  "name": "SetUserObjectInformationA",  "code": "proc SetUserObjectInformationA*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                                nLength: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetUserObjectInformationA\".}" },  { "module": "windows",  "name": "RegisterWindowMessageA",  "code": "proc RegisterWindowMessageA*(lpString: LPCSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterWindowMessageA\".}" },  { "module": "windows",  "name": "GetMessageA",  "code": "proc GetMessageA*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                  wMsgFilterMax: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMessageA\".}" },  { "module": "windows",  "name": "DispatchMessageA",  "code": "proc DispatchMessageA*(lpMsg: LPMSG): LONG {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageA\".}" },  { "module": "windows",  "name": "PeekMessageA",  "code": "proc PeekMessageA*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                   wMsgFilterMax: WINUINT; wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageA\".}" },  { "module": "windows",  "name": "SendMessageA",  "code": "proc SendMessageA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageA\".}" },  { "module": "windows",  "name": "SendMessageTimeoutA",  "code": "proc SendMessageTimeoutA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                          fuFlags: WINUINT; uTimeout: WINUINT; \u000A                          lpdwResult: LPDWORD): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendMessageTimeoutA\".}" },  { "module": "windows",  "name": "SendNotifyMessageA",  "code": "proc SendNotifyMessageA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendNotifyMessageA\".}" },  { "module": "windows",  "name": "SendMessageCallbackA",  "code": "proc SendMessageCallbackA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                           lpResultCallBack: SENDASYNCPROC; dwData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageCallbackA\".}" },  { "module": "windows",  "name": "PostMessageA",  "code": "proc PostMessageA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostMessageA\".}" },  { "module": "windows",  "name": "PostThreadMessageA",  "code": "proc PostThreadMessageA*(idThread: DWORD; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostThreadMessageA\".}" },  { "module": "windows",  "name": "DefWindowProcA",  "code": "proc DefWindowProcA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefWindowProcA\".}" },  { "module": "windows",  "name": "CallWindowProcA",  "code": "proc CallWindowProcA*(lpPrevWndFunc: WNDPROC; wnd: HWND; Msg: WINUINT; \u000A                      wp: WPARAM; lp: LPARAM): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallWindowProcA\".}" },  { "module": "windows",  "name": "RegisterClassA",  "code": "proc RegisterClassA*(lpWndClass: LPWNDCLASS): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassA\".}" },  { "module": "windows",  "name": "UnregisterClassA",  "code": "proc UnregisterClassA*(lpClassName: LPCSTR; hInstance: HINST): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnregisterClassA\".}" },  { "module": "windows",  "name": "GetClassInfoA",  "code": "proc GetClassInfoA*(hInstance: HINST; lpClassName: LPCSTR; \u000A                    lpWndClass: LPWNDCLASS): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassInfoA\".}" },  { "module": "windows",  "name": "RegisterClassExA",  "code": "proc RegisterClassExA*(para1: LPWNDCLASSEX): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassExA\".}" },  { "module": "windows",  "name": "GetClassInfoExA",  "code": "proc GetClassInfoExA*(para1: HINST; para2: LPCSTR; para3: LPWNDCLASSEX): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassInfoExA\".}" },  { "module": "windows",  "name": "CreateWindowExA",  "code": "proc CreateWindowExA*(dwExStyle: DWORD; lpClassName: LPCSTR; \u000A                      lpWindowName: LPCSTR; dwStyle: DWORD; X: int32; Y: int32; \u000A                      nWidth: int32; nHeight: int32; hWndParent: HWND; \u000A                      menu: HMENU; hInstance: HINST; lpParam: LPVOID): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowExA\".}" },  { "module": "windows",  "name": "CreateDialogParamA",  "code": "proc CreateDialogParamA*(hInstance: HINST; lpTemplateName: LPCSTR; \u000A                         hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                         dwInitParam: LPARAM): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateDialogParamA\".}" },  { "module": "windows",  "name": "CreateDialogIndirectParamA",  "code": "proc CreateDialogIndirectParamA*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                                 hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                                 dwInitParam: LPARAM): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDialogIndirectParamA\".}" },  { "module": "windows",  "name": "DialogBoxParamA",  "code": "proc DialogBoxParamA*(hInstance: HINST; lpTemplateName: LPCSTR; \u000A                      hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                      dwInitParam: LPARAM): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DialogBoxParamA\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParamA",  "code": "proc DialogBoxIndirectParamA*(hInstance: HINST; hDialogTemplate: LPCDLGTEMPLATE; \u000A                              hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                              dwInitParam: LPARAM): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamA\".}" },  { "module": "windows",  "name": "SetDlgItemTextA",  "code": "proc SetDlgItemTextA*(hDlg: HWND; nIDDlgItem: int32; lpString: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetDlgItemTextA\".}" },  { "module": "windows",  "name": "GetDlgItemTextA",  "code": "proc GetDlgItemTextA*(hDlg: HWND; nIDDlgItem: int32; lpString: LPSTR; \u000A                      nMaxCount: int32): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetDlgItemTextA\".}" },  { "module": "windows",  "name": "SendDlgItemMessageA",  "code": "proc SendDlgItemMessageA*(hDlg: HWND; nIDDlgItem: int32; Msg: WINUINT; \u000A                          wp: WPARAM; lp: LPARAM): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendDlgItemMessageA\".}" },  { "module": "windows",  "name": "DefDlgProcA",  "code": "proc DefDlgProcA*(hDlg: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefDlgProcA\".}" },  { "module": "windows",  "name": "CallMsgFilterA",  "code": "proc CallMsgFilterA*(lpMsg: LPMSG; nCode: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterA\".}" },  { "module": "windows",  "name": "RegisterClipboardFormatA",  "code": "proc RegisterClipboardFormatA*(lpszFormat: LPCSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterClipboardFormatA\".}" },  { "module": "windows",  "name": "GetClipboardFormatNameA",  "code": "proc GetClipboardFormatNameA*(format: WINUINT; lpszFormatName: LPSTR; \u000A                              cchMaxCount: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClipboardFormatNameA\".}" },  { "module": "windows",  "name": "CharToOemA",  "code": "proc CharToOemA*(lpszSrc: LPCSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharToOemA\".}" },  { "module": "windows",  "name": "OemToCharA",  "code": "proc OemToCharA*(lpszSrc: LPCSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OemToCharA\".}" },  { "module": "windows",  "name": "CharToOemBuffA",  "code": "proc CharToOemBuffA*(lpszSrc: LPCSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CharToOemBuffA\".}" },  { "module": "windows",  "name": "OemToCharBuffA",  "code": "proc OemToCharBuffA*(lpszSrc: LPCSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"OemToCharBuffA\".}" },  { "module": "windows",  "name": "CharUpperA",  "code": "proc CharUpperA*(lpsz: LPSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"CharUpperA\".}" },  { "module": "windows",  "name": "CharUpperBuffA",  "code": "proc CharUpperBuffA*(lpsz: LPSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharUpperBuffA\".}" },  { "module": "windows",  "name": "CharLowerA",  "code": "proc CharLowerA*(lpsz: LPSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"CharLowerA\".}" },  { "module": "windows",  "name": "CharLowerBuffA",  "code": "proc CharLowerBuffA*(lpsz: LPSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharLowerBuffA\".}" },  { "module": "windows",  "name": "CharNextA",  "code": "proc CharNextA*(lpsz: LPCSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"CharNextA\".}" },  { "module": "windows",  "name": "CharPrevA",  "code": "proc CharPrevA*(lpszStart: LPCSTR; lpszCurrent: LPCSTR): LPSTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharPrevA\".}" },  { "module": "windows",  "name": "IsCharAlphaA",  "code": "proc IsCharAlphaA*(ch: char): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharAlphaA\".}" },  { "module": "windows",  "name": "IsCharAlphaNumericA",  "code": "proc IsCharAlphaNumericA*(ch: char): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharAlphaNumericA\".}" },  { "module": "windows",  "name": "IsCharUpperA",  "code": "proc IsCharUpperA*(ch: char): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharUpperA\".}" },  { "module": "windows",  "name": "IsCharLowerA",  "code": "proc IsCharLowerA*(ch: char): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharLowerA\".}" },  { "module": "windows",  "name": "GetKeyNameTextA",  "code": "proc GetKeyNameTextA*(lParam: LONG; lpString: LPSTR; nSize: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetKeyNameTextA\".}" },  { "module": "windows",  "name": "VkKeyScanA",  "code": "proc VkKeyScanA*(ch: char): SHORT {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"VkKeyScanA\".}" },  { "module": "windows",  "name": "VkKeyScanExA",  "code": "proc VkKeyScanExA*(ch: char; dwhkl: HKL): SHORT {.stdcall, dynlib: \"user32\", \u000A    importc: \"VkKeyScanExA\".}" },  { "module": "windows",  "name": "MapVirtualKeyA",  "code": "proc MapVirtualKeyA*(uCode: WINUINT; uMapType: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"MapVirtualKeyA\".}" },  { "module": "windows",  "name": "MapVirtualKeyExA",  "code": "proc MapVirtualKeyExA*(uCode: WINUINT; uMapType: WINUINT; dwhkl: HKL): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"MapVirtualKeyExA\".}" },  { "module": "windows",  "name": "LoadAcceleratorsA",  "code": "proc LoadAcceleratorsA*(hInstance: HINST; lpTableName: LPCSTR): HACCEL {.\u000A    stdcall, dynlib: \"user32\", importc: \"LoadAcceleratorsA\".}" },  { "module": "windows",  "name": "CreateAcceleratorTableA",  "code": "proc CreateAcceleratorTableA*(para1: LPACCEL; para2: int32): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableA\".}" },  { "module": "windows",  "name": "CopyAcceleratorTableA",  "code": "proc CopyAcceleratorTableA*(hAccelSrc: HACCEL; lpAccelDst: LPACCEL; \u000A                            cAccelEntries: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyAcceleratorTableA\".}" },  { "module": "windows",  "name": "TranslateAcceleratorA",  "code": "proc TranslateAcceleratorA*(wnd: HWND; hAccTable: HACCEL; lpMsg: LPMSG): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorA\".}" },  { "module": "windows",  "name": "LoadMenuA",  "code": "proc LoadMenuA*(hInstance: HINST; lpMenuName: LPCSTR): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuA\".}" },  { "module": "windows",  "name": "LoadMenuIndirectA",  "code": "proc LoadMenuIndirectA*(lpMenuTemplate: LPMENUTEMPLATE): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuIndirectA\".}" },  { "module": "windows",  "name": "ChangeMenuA",  "code": "proc ChangeMenuA*(menu: HMENU; cmd: WINUINT; lpszNewItem: LPCSTR; \u000A                  cmdInsert: WINUINT; flags: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ChangeMenuA\".}" },  { "module": "windows",  "name": "GetMenuStringA",  "code": "proc GetMenuStringA*(menu: HMENU; uIDItem: WINUINT; lpString: LPSTR; \u000A                     nMaxCount: int32; uFlag: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuStringA\".}" },  { "module": "windows",  "name": "InsertMenuA",  "code": "proc InsertMenuA*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                  uIDNewItem: WINUINT; lpNewItem: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuA\".}" },  { "module": "windows",  "name": "AppendMenuA",  "code": "proc AppendMenuA*(menu: HMENU; uFlags: WINUINT; uIDNewItem: WINUINT; \u000A                  lpNewItem: LPCSTR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"AppendMenuA\".}" },  { "module": "windows",  "name": "ModifyMenuA",  "code": "proc ModifyMenuA*(hMnu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                  uIDNewItem: WINUINT; lpNewItem: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ModifyMenuA\".}" },  { "module": "windows",  "name": "InsertMenuItemA",  "code": "proc InsertMenuItemA*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                      para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuItemA\".}" },  { "module": "windows",  "name": "GetMenuItemInfoA",  "code": "proc GetMenuItemInfoA*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                       para4: LPMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuItemInfoA\".}" },  { "module": "windows",  "name": "SetMenuItemInfoA",  "code": "proc SetMenuItemInfoA*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                       para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetMenuItemInfoA\".}" },  { "module": "windows",  "name": "DrawTextA",  "code": "proc DrawTextA*(hDC: HDC; lpString: LPCSTR; nCount: int32; lpRect: LPRECT; \u000A                uFormat: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawTextA\".}" },  { "module": "windows",  "name": "DrawTextExA",  "code": "proc DrawTextExA*(para1: HDC; para2: LPSTR; para3: int32; para4: LPRECT; \u000A                  para5: WINUINT; para6: LPDRAWTEXTPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawTextExA\".}" },  { "module": "windows",  "name": "GrayStringA",  "code": "proc GrayStringA*(hDC: HDC; hBrush: HBRUSH; lpOutputFunc: GRAYSTRINGPROC; \u000A                  lpData: LPARAM; nCount: int32; X: int32; Y: int32; \u000A                  nWidth: int32; nHeight: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GrayStringA\".}" },  { "module": "windows",  "name": "DrawStateA",  "code": "proc DrawStateA*(para1: HDC; para2: HBRUSH; para3: DRAWSTATEPROC; para4: LPARAM; \u000A                 para5: WPARAM; para6: int32; para7: int32; para8: int32; \u000A                 para9: int32; para10: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawStateA\".}" },  { "module": "windows",  "name": "TabbedTextOutA",  "code": "proc TabbedTextOutA*(hDC: HDC; X: int32; Y: int32; lpString: LPCSTR; \u000A                     nCount: int32; nTabPositions: int32; \u000A                     lpnTabStopPositions: LPINT; nTabOrigin: int32): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"TabbedTextOutA\".}" },  { "module": "windows",  "name": "GetTabbedTextExtentA",  "code": "proc GetTabbedTextExtentA*(hDC: HDC; lpString: LPCSTR; nCount: int32; \u000A                           nTabPositions: int32; lpnTabStopPositions: LPINT): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetTabbedTextExtentA\".}" },  { "module": "windows",  "name": "SetPropA",  "code": "proc SetPropA*(wnd: HWND; lpString: LPCSTR; hData: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetPropA\".}" },  { "module": "windows",  "name": "GetPropA",  "code": "proc GetPropA*(wnd: HWND; lpString: LPCSTR): HANDLE {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetPropA\".}" },  { "module": "windows",  "name": "RemovePropA",  "code": "proc RemovePropA*(wnd: HWND; lpString: LPCSTR): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"RemovePropA\".}" },  { "module": "windows",  "name": "EnumPropsExA",  "code": "proc EnumPropsExA*(wnd: HWND; lpEnumFunc: PROPENUMPROCEX; lp: LPARAM): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumPropsExA\".}" },  { "module": "windows",  "name": "EnumPropsA",  "code": "proc EnumPropsA*(wnd: HWND; lpEnumFunc: PROPENUMPROC): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumPropsA\".}" },  { "module": "windows",  "name": "SetWindowTextA",  "code": "proc SetWindowTextA*(wnd: HWND; lpString: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowTextA\".}" },  { "module": "windows",  "name": "GetWindowTextA",  "code": "proc GetWindowTextA*(wnd: HWND; lpString: LPSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowTextA\".}" },  { "module": "windows",  "name": "GetWindowTextLengthA",  "code": "proc GetWindowTextLengthA*(wnd: HWND): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowTextLengthA\".}" },  { "module": "windows",  "name": "MessageBoxA",  "code": "proc MessageBoxA*(wnd: HWND; lpText: LPCSTR; lpCaption: LPCSTR; uType: int): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"MessageBoxA\".}" },  { "module": "windows",  "name": "MessageBoxExA",  "code": "proc MessageBoxExA*(wnd: HWND; lpText: LPCSTR; lpCaption: LPCSTR; \u000A                    uType: WINUINT; wLanguageId: int16): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxExA\".}" },  { "module": "windows",  "name": "MessageBoxIndirectA",  "code": "proc MessageBoxIndirectA*(para1: LPMSGBOXPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxIndirectA\".}" },  { "module": "windows",  "name": "GetWindowLongA",  "code": "proc GetWindowLongA*(wnd: HWND; nIndex: int32): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowLongA\".}" },  { "module": "windows",  "name": "SetWindowLongA",  "code": "proc SetWindowLongA*(wnd: HWND; nIndex: int32; dwNewLong: LONG): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowLongA\".}" },  { "module": "windows",  "name": "GetClassLongA",  "code": "proc GetClassLongA*(wnd: HWND; nIndex: int32): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassLongA\".}" },  { "module": "windows",  "name": "SetClassLongA",  "code": "proc SetClassLongA*(wnd: HWND; nIndex: int32; dwNewLong: LONG): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetClassLongA\".}" },  { "module": "windows",  "name": "GetWindowLongPtrA",  "code": "proc GetWindowLongPtrA*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowLongPtrA\".}" },  { "module": "windows",  "name": "SetWindowLongPtrA",  "code": "proc SetWindowLongPtrA*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetWindowLongPtrA\".}" },  { "module": "windows",  "name": "GetClassLongPtrA",  "code": "proc GetClassLongPtrA*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassLongPtrA\".}" },  { "module": "windows",  "name": "SetClassLongPtrA",  "code": "proc SetClassLongPtrA*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetClassLongPtrA\".}" },  { "module": "windows",  "name": "FindWindowA",  "code": "proc FindWindowA*(lpClassName: LPCSTR; lpWindowName: LPCSTR): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"FindWindowA\".}" },  { "module": "windows",  "name": "FindWindowExA",  "code": "proc FindWindowExA*(para1: HWND; para2: HWND; para3: LPCSTR; para4: LPCSTR): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"FindWindowExA\".}" },  { "module": "windows",  "name": "GetClassNameA",  "code": "proc GetClassNameA*(wnd: HWND; lpClassName: LPSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassNameA\".}" },  { "module": "windows",  "name": "SetWindowsHookExA",  "code": "proc SetWindowsHookExA*(idHook: int32; lpfn: HOOKPROC; hmod: HINST; \u000A                        dwThreadId: DWORD): HHOOK {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetWindowsHookExA\".}" },  { "module": "windows",  "name": "LoadBitmapA",  "code": "proc LoadBitmapA*(hInstance: HINST; lpBitmapName: LPCSTR): HBITMAP {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadBitmapA\".}" },  { "module": "windows",  "name": "LoadCursorA",  "code": "proc LoadCursorA*(hInstance: HINST; lpCursorName: LPCSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorA\".}" },  { "module": "windows",  "name": "LoadCursorFromFileA",  "code": "proc LoadCursorFromFileA*(lpFileName: LPCSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorFromFileA\".}" },  { "module": "windows",  "name": "LoadIconA",  "code": "proc LoadIconA*(hInstance: HINST; lpIconName: LPCSTR): HICON {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadIconA\".}" },  { "module": "windows",  "name": "LoadImageA",  "code": "proc LoadImageA*(para1: HINST; para2: LPCSTR; para3: WINUINT; para4: int32; \u000A                 para5: int32; para6: WINUINT): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadImageA\".}" },  { "module": "windows",  "name": "LoadStringA",  "code": "proc LoadStringA*(hInstance: HINST; uID: WINUINT; lpBuffer: LPSTR; \u000A                  nBufferMax: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"LoadStringA\".}" },  { "module": "windows",  "name": "IsDialogMessageA",  "code": "proc IsDialogMessageA*(hDlg: HWND; lpMsg: LPMSG): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageA\".}" },  { "module": "windows",  "name": "DlgDirListA",  "code": "proc DlgDirListA*(hDlg: HWND; lpPathSpec: LPSTR; nIDListBox: int32; \u000A                  nIDStaticPath: int32; uFileType: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirListA\".}" },  { "module": "windows",  "name": "DlgDirSelectExA",  "code": "proc DlgDirSelectExA*(hDlg: HWND; lpString: LPSTR; nCount: int32; \u000A                      nIDListBox: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DlgDirSelectExA\".}" },  { "module": "windows",  "name": "DlgDirListComboBoxA",  "code": "proc DlgDirListComboBoxA*(hDlg: HWND; lpPathSpec: LPSTR; nIDComboBox: int32; \u000A                          nIDStaticPath: int32; uFiletype: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"DlgDirListComboBoxA\".}" },  { "module": "windows",  "name": "DlgDirSelectComboBoxExA",  "code": "proc DlgDirSelectComboBoxExA*(hDlg: HWND; lpString: LPSTR; nCount: int32; \u000A                              nIDComboBox: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirSelectComboBoxExA\".}" },  { "module": "windows",  "name": "DefFrameProcA",  "code": "proc DefFrameProcA*(wnd: HWND; hWndMDIClient: HWND; uMsg: WINUINT; wp: WPARAM; \u000A                    lp: LPARAM): LRESULT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DefFrameProcA\".}" },  { "module": "windows",  "name": "DefMDIChildProcA",  "code": "proc DefMDIChildProcA*(wnd: HWND; uMsg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefMDIChildProcA\".}" },  { "module": "windows",  "name": "CreateMDIWindowA",  "code": "proc CreateMDIWindowA*(lpClassName: LPSTR; lpWindowName: LPSTR; dwStyle: DWORD; \u000A                       X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                       hWndParent: HWND; hInstance: HINST; lp: LPARAM): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateMDIWindowA\".}" },  { "module": "windows",  "name": "WinHelpA",  "code": "proc WinHelpA*(hWndMain: HWND; lpszHelp: LPCSTR; uCommand: WINUINT; \u000A               dwData: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"WinHelpA\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsA",  "code": "proc ChangeDisplaySettingsA*(lpDevMode: LPDEVMODE; dwFlags: DWORD): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsA\".}" },  { "module": "windows",  "name": "EnumDisplaySettingsA",  "code": "proc EnumDisplaySettingsA*(lpszDeviceName: LPCSTR; iModeNum: DWORD; \u000A                           lpDevMode: LPDEVMODE): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsA\".}" },  { "module": "windows",  "name": "SystemParametersInfoA",  "code": "proc SystemParametersInfoA*(uiAction: WINUINT; uiParam: WINUINT; pvParam: PVOID; \u000A                            fWinIni: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SystemParametersInfoA\".}" },  { "module": "windows",  "name": "AddFontResourceA",  "code": "proc AddFontResourceA*(para1: LPCSTR): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"AddFontResourceA\".}" },  { "module": "windows",  "name": "CopyMetaFileA",  "code": "proc CopyMetaFileA*(para1: HMETAFILE; para2: LPCSTR): HMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CopyMetaFileA\".}" },  { "module": "windows",  "name": "CreateFontA",  "code": "proc CreateFontA*(para1: int32; para2: int32; para3: int32; para4: int32; \u000A                  para5: int32; para6: DWORD; para7: DWORD; para8: DWORD; \u000A                  para9: DWORD; para10: DWORD; para11: DWORD; para12: DWORD; \u000A                  para13: DWORD; para14: LPCSTR): HFONT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateFontA\".}" },  { "module": "windows",  "name": "CreateFontIndirectA",  "code": "proc CreateFontIndirectA*(para1: LPLOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectA\".}" },  { "module": "windows",  "name": "CreateFontIndirectA",  "code": "proc CreateFontIndirectA*(para1: var LOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectA\".}" },  { "module": "windows",  "name": "CreateICA",  "code": "proc CreateICA*(para1: LPCSTR; para2: LPCSTR; para3: LPCSTR; para4: LPDEVMODE): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateICA\".}" },  { "module": "windows",  "name": "CreateMetaFileA",  "code": "proc CreateMetaFileA*(para1: LPCSTR): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateMetaFileA\".}" },  { "module": "windows",  "name": "CreateScalableFontResourceA",  "code": "proc CreateScalableFontResourceA*(para1: DWORD; para2: LPCSTR; para3: LPCSTR; \u000A                                  para4: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateScalableFontResourceA\".}" },  { "module": "windows",  "name": "EnumFontFamiliesExA",  "code": "proc EnumFontFamiliesExA*(para1: HDC; para2: LPLOGFONT; para3: FONTENUMEXPROC; \u000A                          para4: LPARAM; para5: DWORD): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"EnumFontFamiliesExA\".}" },  { "module": "windows",  "name": "EnumFontFamiliesA",  "code": "proc EnumFontFamiliesA*(para1: HDC; para2: LPCSTR; para3: FONTENUMPROC; \u000A                        para4: LPARAM): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumFontFamiliesA\".}" },  { "module": "windows",  "name": "EnumFontsA",  "code": "proc EnumFontsA*(para1: HDC; para2: LPCSTR; para3: ENUMFONTSPROC; para4: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumFontsA\".}" },  { "module": "windows",  "name": "EnumFontsA",  "code": "proc EnumFontsA*(para1: HDC; para2: LPCSTR; para3: ENUMFONTSPROC; para4: pointer): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumFontsA\".}" },  { "module": "windows",  "name": "GetCharWidthA",  "code": "proc GetCharWidthA*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthA\".}" },  { "module": "windows",  "name": "GetCharWidth32A",  "code": "proc GetCharWidth32A*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32A\".}" },  { "module": "windows",  "name": "GetCharWidthFloatA",  "code": "proc GetCharWidthFloatA*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                         para4: ptr float32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharWidthFloatA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsA",  "code": "proc GetCharABCWidthsA*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPABC): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloatA",  "code": "proc GetCharABCWidthsFloatA*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                             para4: LPABCFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatA\".}" },  { "module": "windows",  "name": "GetGlyphOutlineA",  "code": "proc GetGlyphOutlineA*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                       para4: LPGLYPHMETRICS; para5: DWORD; para6: LPVOID; \u000A                       para7: PMAT2): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetGlyphOutlineA\".}" },  { "module": "windows",  "name": "GetMetaFileA",  "code": "proc GetMetaFileA*(para1: LPCSTR): HMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetMetaFileA\".}" },  { "module": "windows",  "name": "GetOutlineTextMetricsA",  "code": "proc GetOutlineTextMetricsA*(para1: HDC; para2: WINUINT; \u000A                             para3: LPOUTLINETEXTMETRIC): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetOutlineTextMetricsA\".}" },  { "module": "windows",  "name": "GetTextExtentPointA",  "code": "proc GetTextExtentPointA*(para1: HDC; para2: LPCSTR; para3: int32; para4: LPSIZE): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPointA\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32A",  "code": "proc GetTextExtentPoint32A*(para1: HDC; para2: LPCSTR; para3: int32; \u000A                            para4: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentPoint32A\".}" },  { "module": "windows",  "name": "GetTextExtentExPointA",  "code": "proc GetTextExtentExPointA*(para1: HDC; para2: LPCSTR; para3: int32; \u000A                            para4: int32; para5: LPINT; para6: LPINT; \u000A                            para7: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointA\".}" },  { "module": "windows",  "name": "GetCharacterPlacementA",  "code": "proc GetCharacterPlacementA*(para1: HDC; para2: LPCSTR; para3: int32; \u000A                             para4: int32; para5: LPGCP_RESULTS; para6: DWORD): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharacterPlacementA\".}" },  { "module": "windows",  "name": "ResetDCA",  "code": "proc ResetDCA*(para1: HDC; para2: LPDEVMODE): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ResetDCA\".}" },  { "module": "windows",  "name": "RemoveFontResourceA",  "code": "proc RemoveFontResourceA*(para1: LPCSTR): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"RemoveFontResourceA\".}" },  { "module": "windows",  "name": "CopyEnhMetaFileA",  "code": "proc CopyEnhMetaFileA*(para1: HENHMETAFILE; para2: LPCSTR): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CopyEnhMetaFileA\".}" },  { "module": "windows",  "name": "CreateEnhMetaFileA",  "code": "proc CreateEnhMetaFileA*(para1: HDC; para2: LPCSTR; para3: LPRECT; para4: LPCSTR): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateEnhMetaFileA\".}" },  { "module": "windows",  "name": "GetEnhMetaFileA",  "code": "proc GetEnhMetaFileA*(para1: LPCSTR): HENHMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetEnhMetaFileA\".}" },  { "module": "windows",  "name": "GetEnhMetaFileDescriptionA",  "code": "proc GetEnhMetaFileDescriptionA*(para1: HENHMETAFILE; para2: WINUINT; \u000A                                 para3: LPSTR): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetEnhMetaFileDescriptionA\".}" },  { "module": "windows",  "name": "GetTextMetricsA",  "code": "proc GetTextMetricsA*(para1: HDC; para2: LPTEXTMETRIC): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextMetricsA\".}" },  { "module": "windows",  "name": "StartDocA",  "code": "proc StartDocA*(para1: HDC; para2: PDOCINFO): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StartDocA\".}" },  { "module": "windows",  "name": "GetObjectA",  "code": "proc GetObjectA*(para1: HGDIOBJ; para2: int32; para3: LPVOID): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetObjectA\".}" },  { "module": "windows",  "name": "TextOutA",  "code": "proc TextOutA*(para1: HDC; para2: int32; para3: int32; para4: LPCSTR; \u000A               para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                        importc: \"TextOutA\".}" },  { "module": "windows",  "name": "ExtTextOutA",  "code": "proc ExtTextOutA*(para1: HDC; para2: int32; para3: int32; para4: WINUINT; \u000A                  para5: LPRECT; para6: LPCSTR; para7: WINUINT; para8: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ExtTextOutA\".}" },  { "module": "windows",  "name": "PolyTextOutA",  "code": "proc PolyTextOutA*(para1: HDC; para2: PPOLYTEXT; para3: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutA\".}" },  { "module": "windows",  "name": "GetTextFaceA",  "code": "proc GetTextFaceA*(para1: HDC; para2: int32; para3: LPSTR): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextFaceA\".}" },  { "module": "windows",  "name": "GetKerningPairsA",  "code": "proc GetKerningPairsA*(para1: HDC; para2: DWORD; para3: LPKERNINGPAIR): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetKerningPairsA\".}" },  { "module": "windows",  "name": "CreateColorSpaceA",  "code": "proc CreateColorSpaceA*(para1: LPLOGCOLORSPACE): HCOLORSPACE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateColorSpaceA\".}" },  { "module": "windows",  "name": "GetLogColorSpaceA",  "code": "proc GetLogColorSpaceA*(para1: HCOLORSPACE; para2: LPLOGCOLORSPACE; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetLogColorSpaceA\".}" },  { "module": "windows",  "name": "GetICMProfileA",  "code": "proc GetICMProfileA*(para1: HDC; para2: DWORD; para3: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetICMProfileA\".}" },  { "module": "windows",  "name": "SetICMProfileA",  "code": "proc SetICMProfileA*(para1: HDC; para2: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetICMProfileA\".}" },  { "module": "windows",  "name": "UpdateICMRegKeyA",  "code": "proc UpdateICMRegKeyA*(para1: DWORD; para2: DWORD; para3: LPSTR; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"UpdateICMRegKeyA\".}" },  { "module": "windows",  "name": "EnumICMProfilesA",  "code": "proc EnumICMProfilesA*(para1: HDC; para2: ICMENUMPROC; para3: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumICMProfilesA\".}" },  { "module": "windows",  "name": "PropertySheetA",  "code": "proc PropertySheetA*(lppsph: LPCPROPSHEETHEADER): int32 {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"PropertySheetA\".}" },  { "module": "windows",  "name": "ImageList_LoadImageA",  "code": "proc ImageList_LoadImageA*(hi: HINST; lpbmp: LPCSTR; cx: int32; cGrow: int32; \u000A                           crMask: COLORREF; uType: WINUINT; uFlags: WINUINT): HIMAGELIST {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_LoadImageA\".}" },  { "module": "windows",  "name": "CreateStatusWindowA",  "code": "proc CreateStatusWindowA*(style: LONG; lpszText: LPCSTR; hwndParent: HWND; \u000A                          wID: WINUINT): HWND {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"CreateStatusWindowA\".}" },  { "module": "windows",  "name": "DrawStatusTextA",  "code": "proc DrawStatusTextA*(hDC: HDC; lprc: LPRECT; pszText: LPCSTR; uFlags: WINUINT) {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"DrawStatusTextA\".}" },  { "module": "windows",  "name": "GetOpenFileNameA",  "code": "proc GetOpenFileNameA*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetOpenFileNameA\".}" },  { "module": "windows",  "name": "GetSaveFileNameA",  "code": "proc GetSaveFileNameA*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetSaveFileNameA\".}" },  { "module": "windows",  "name": "GetFileTitleA",  "code": "proc GetFileTitleA*(para1: LPCSTR; para2: LPSTR; para3: int16): int {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetFileTitleA\".}" },  { "module": "windows",  "name": "ChooseColorA",  "code": "proc ChooseColorA*(para1: LPCHOOSECOLOR): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseColorA\".}" },  { "module": "windows",  "name": "FindTextA",  "code": "proc FindTextA*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"FindTextA\".}" },  { "module": "windows",  "name": "ReplaceTextA",  "code": "proc ReplaceTextA*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ReplaceTextA\".}" },  { "module": "windows",  "name": "ChooseFontA",  "code": "proc ChooseFontA*(para1: LPCHOOSEFONT): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseFontA\".}" },  { "module": "windows",  "name": "PrintDlgA",  "code": "proc PrintDlgA*(para1: LPPRINTDLG): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"PrintDlgA\".}" },  { "module": "windows",  "name": "PageSetupDlgA",  "code": "proc PageSetupDlgA*(para1: LPPAGESETUPDLG): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"PageSetupDlgA\".}" },  { "module": "windows",  "name": "CreateProcessA",  "code": "proc CreateProcessA*(lpApplicationName: LPCSTR; lpCommandLine: LPSTR; \u000A                     lpProcessAttributes: LPSECURITY_ATTRIBUTES; \u000A                     lpThreadAttributes: LPSECURITY_ATTRIBUTES; \u000A                     bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                     lpEnvironment: LPVOID; lpCurrentDirectory: LPCSTR; \u000A                     lpStartupInfo: LPSTARTUPINFO; \u000A                     lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessA\".}" },  { "module": "windows",  "name": "GetStartupInfoA",  "code": "proc GetStartupInfoA*(lpStartupInfo: LPSTARTUPINFO) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStartupInfoA\".}" },  { "module": "windows",  "name": "FindFirstFileA",  "code": "proc FindFirstFileA*(lpFileName: LPCSTR; lpFindFileData: LPWIN32_FIND_DATA): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileA\".}" },  { "module": "windows",  "name": "FindNextFileA",  "code": "proc FindNextFileA*(hFindFile: HANDLE; lpFindFileData: LPWIN32_FIND_DATA): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileA\".}" },  { "module": "windows",  "name": "GetVersionExA",  "code": "proc GetVersionExA*(VersionInformation: LPOSVERSIONINFO): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVersionExA\".}" },  { "module": "windows",  "name": "CreateWindowA",  "code": "proc CreateWindowA*(lpClassName: LPCSTR; lpWindowName: LPCSTR; dwStyle: DWORD; \u000A                    X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                    hWndParent: HWND; menu: HMENU; hInstance: HINST; \u000A                    lpParam: LPVOID): HWND" },  { "module": "windows",  "name": "CreateDialogA",  "code": "proc CreateDialogA*(hInstance: HINST; lpTemplateName: LPCSTR; hWndParent: HWND; \u000A                    lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "CreateDialogIndirectA",  "code": "proc CreateDialogIndirectA*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                            hWndParent: HWND; lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "DialogBoxA",  "code": "proc DialogBoxA*(hInstance: HINST; lpTemplateName: LPCSTR; hWndParent: HWND; \u000A                 lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "DialogBoxIndirectA",  "code": "proc DialogBoxIndirectA*(hInstance: HINST; hDialogTemplate: LPCDLGTEMPLATE; \u000A                         hWndParent: HWND; lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "CreateDCA",  "code": "proc CreateDCA*(para1: LPCSTR; para2: LPCSTR; para3: LPCSTR; para4: PDEVMODE): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDCA\".}" },  { "module": "windows",  "name": "VerInstallFileA",  "code": "proc VerInstallFileA*(uFlags: DWORD; szSrcFileName: LPSTR; \u000A                      szDestFileName: LPSTR; szSrcDir: LPSTR; szDestDir: LPSTR; \u000A                      szCurDir: LPSTR; szTmpFile: LPSTR; lpuTmpFileLen: PUINT): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"VerInstallFileA\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSizeA",  "code": "proc GetFileVersionInfoSizeA*(lptstrFilename: LPSTR; lpdwHandle: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeA\".}" },  { "module": "windows",  "name": "GetFileVersionInfoA",  "code": "proc GetFileVersionInfoA*(lptstrFilename: LPSTR; dwHandle: DWORD; dwLen: DWORD; \u000A                          lpData: LPVOID): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"GetFileVersionInfoA\".}" },  { "module": "windows",  "name": "VerLanguageNameA",  "code": "proc VerLanguageNameA*(wLang: DWORD; szLang: LPSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VerLanguageNameA\".}" },  { "module": "windows",  "name": "VerQueryValueA",  "code": "proc VerQueryValueA*(pBlock: LPVOID; lpSubBlock: LPSTR; lplpBuffer: LPVOID; \u000A                     puLen: PUINT): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"VerQueryValueA\".}" },  { "module": "windows",  "name": "VerFindFileA",  "code": "proc VerFindFileA*(uFlags: DWORD; szFileName: LPSTR; szWinDir: LPSTR; \u000A                   szAppDir: LPSTR; szCurDir: LPSTR; lpuCurDirLen: PUINT; \u000A                   szDestDir: LPSTR; lpuDestDirLen: PUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileA\".}" },  { "module": "windows",  "name": "RegConnectRegistryA",  "code": "proc RegConnectRegistryA*(lpMachineName: LPSTR; key: HKEY; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryA\".}" },  { "module": "windows",  "name": "RegCreateKeyA",  "code": "proc RegCreateKeyA*(key: HKEY; lpSubKey: LPCSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyA\".}" },  { "module": "windows",  "name": "RegCreateKeyExA",  "code": "proc RegCreateKeyExA*(key: HKEY; lpSubKey: LPCSTR; Reserved: DWORD; \u000A                      lpClass: LPSTR; dwOptions: DWORD; samDesired: REGSAM; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                      phkResult: PHKEY; lpdwDisposition: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExA\".}" },  { "module": "windows",  "name": "RegDeleteKeyA",  "code": "proc RegDeleteKeyA*(key: HKEY; lpSubKey: LPCSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteKeyA\".}" },  { "module": "windows",  "name": "RegDeleteValueA",  "code": "proc RegDeleteValueA*(key: HKEY; lpValueName: LPCSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteValueA\".}" },  { "module": "windows",  "name": "RegEnumKeyA",  "code": "proc RegEnumKeyA*(key: HKEY; dwIndex: DWORD; lpName: LPSTR; cbName: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyA\".}" },  { "module": "windows",  "name": "RegEnumKeyExA",  "code": "proc RegEnumKeyExA*(key: HKEY; dwIndex: DWORD; lpName: LPSTR; lpcbName: LPDWORD; \u000A                    lpReserved: LPDWORD; lpClass: LPSTR; lpcbClass: LPDWORD; \u000A                    lpftLastWriteTime: PFILETIME): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegEnumKeyExA\".}" },  { "module": "windows",  "name": "RegEnumValueA",  "code": "proc RegEnumValueA*(key: HKEY; dwIndex: DWORD; lpValueName: LPSTR; \u000A                    lpcbValueName: LPDWORD; lpReserved: LPDWORD; \u000A                    lpType: LPDWORD; lpData: LPBYTE; lpcbData: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumValueA\".}" },  { "module": "windows",  "name": "RegLoadKeyA",  "code": "proc RegLoadKeyA*(key: HKEY; lpSubKey: LPCSTR; lpFile: LPCSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegLoadKeyA\".}" },  { "module": "windows",  "name": "RegOpenKeyA",  "code": "proc RegOpenKeyA*(key: HKEY; lpSubKey: LPCSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyA\".}" },  { "module": "windows",  "name": "RegOpenKeyExA",  "code": "proc RegOpenKeyExA*(key: HKEY; lpSubKey: LPCSTR; ulOptions: DWORD; \u000A                    samDesired: REGSAM; phkResult: PHKEY): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExA\".}" },  { "module": "windows",  "name": "RegQueryInfoKeyA",  "code": "proc RegQueryInfoKeyA*(key: HKEY; lpClass: LPSTR; lpcbClass: LPDWORD; \u000A                       lpReserved: LPDWORD; lpcSubKeys: LPDWORD; \u000A                       lpcbMaxSubKeyLen: LPDWORD; lpcbMaxClassLen: LPDWORD; \u000A                       lpcValues: LPDWORD; lpcbMaxValueNameLen: LPDWORD; \u000A                       lpcbMaxValueLen: LPDWORD; \u000A                       lpcbSecurityDescriptor: LPDWORD; \u000A                       lpftLastWriteTime: PFILETIME): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegQueryInfoKeyA\".}" },  { "module": "windows",  "name": "RegQueryValueA",  "code": "proc RegQueryValueA*(key: HKEY; lpSubKey: LPCSTR; lpValue: LPSTR; \u000A                     lpcbValue: PLONG): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueA\".}" },  { "module": "windows",  "name": "RegQueryMultipleValuesA",  "code": "proc RegQueryMultipleValuesA*(key: HKEY; val_list: PVALENT; num_vals: DWORD; \u000A                              lpValueBuf: LPSTR; ldwTotsize: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesA\".}" },  { "module": "windows",  "name": "RegQueryValueExA",  "code": "proc RegQueryValueExA*(key: HKEY; lpValueName: LPCSTR; lpReserved: LPDWORD; \u000A                       lpType: LPDWORD; lpData: LPBYTE; lpcbData: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryValueExA\".}" },  { "module": "windows",  "name": "RegReplaceKeyA",  "code": "proc RegReplaceKeyA*(key: HKEY; lpSubKey: LPCSTR; lpNewFile: LPCSTR; \u000A                     lpOldFile: LPCSTR): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegReplaceKeyA\".}" },  { "module": "windows",  "name": "RegRestoreKeyA",  "code": "proc RegRestoreKeyA*(key: HKEY; lpFile: LPCSTR; dwFlags: DWORD): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegRestoreKeyA\".}" },  { "module": "windows",  "name": "RegSaveKeyA",  "code": "proc RegSaveKeyA*(key: HKEY; lpFile: LPCSTR; \u000A                  lpSecurityAttributes: LPSECURITY_ATTRIBUTES): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegSaveKeyA\".}" },  { "module": "windows",  "name": "RegSetValueA",  "code": "proc RegSetValueA*(key: HKEY; lpSubKey: LPCSTR; dwType: DWORD; lpData: LPCSTR; \u000A                   cbData: DWORD): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegSetValueA\".}" },  { "module": "windows",  "name": "RegSetValueExA",  "code": "proc RegSetValueExA*(key: HKEY; lpValueName: LPCSTR; Reserved: DWORD; \u000A                     dwType: DWORD; lpData: LPBYTE; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExA\".}" },  { "module": "windows",  "name": "RegUnLoadKeyA",  "code": "proc RegUnLoadKeyA*(key: HKEY; lpSubKey: LPCSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegUnLoadKeyA\".}" },  { "module": "windows",  "name": "InitiateSystemShutdownA",  "code": "proc InitiateSystemShutdownA*(lpMachineName: LPSTR; lpMessage: LPSTR; \u000A                              dwTimeout: DWORD; bForceAppsClosed: WINBOOL; \u000A                              bRebootAfterShutdown: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitiateSystemShutdownA\".}" },  { "module": "windows",  "name": "AbortSystemShutdownA",  "code": "proc AbortSystemShutdownA*(lpMachineName: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AbortSystemShutdownA\".}" },  { "module": "windows",  "name": "CompareStringA",  "code": "proc CompareStringA*(Locale: LCID; dwCmpFlags: DWORD; lpString1: LPCSTR; \u000A                     cchCount1: int32; lpString2: LPCSTR; cchCount2: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CompareStringA\".}" },  { "module": "windows",  "name": "LCMapStringA",  "code": "proc LCMapStringA*(Locale: LCID; dwMapFlags: DWORD; lpSrcStr: LPCSTR; \u000A                   cchSrc: int32; lpDestStr: LPSTR; cchDest: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LCMapStringA\".}" },  { "module": "windows",  "name": "GetLocaleInfoA",  "code": "proc GetLocaleInfoA*(Locale: LCID; LCType: LCTYPE; lpLCData: LPSTR; \u000A                     cchData: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetLocaleInfoA\".}" },  { "module": "windows",  "name": "SetLocaleInfoA",  "code": "proc SetLocaleInfoA*(Locale: LCID; LCType: LCTYPE; lpLCData: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetLocaleInfoA\".}" },  { "module": "windows",  "name": "GetTimeFormatA",  "code": "proc GetTimeFormatA*(Locale: LCID; dwFlags: DWORD; lpTime: LPSYSTEMTIME; \u000A                     lpFormat: LPCSTR; lpTimeStr: LPSTR; cchTime: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTimeFormatA\".}" },  { "module": "windows",  "name": "GetDateFormatA",  "code": "proc GetDateFormatA*(Locale: LCID; dwFlags: DWORD; lpDate: LPSYSTEMTIME; \u000A                     lpFormat: LPCSTR; lpDateStr: LPSTR; cchDate: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDateFormatA\".}" },  { "module": "windows",  "name": "GetNumberFormatA",  "code": "proc GetNumberFormatA*(Locale: LCID; dwFlags: DWORD; lpValue: LPCSTR; \u000A                       lpFormat: PNUMBERFMT; lpNumberStr: LPSTR; \u000A                       cchNumber: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetNumberFormatA\".}" },  { "module": "windows",  "name": "GetCurrencyFormatA",  "code": "proc GetCurrencyFormatA*(Locale: LCID; dwFlags: DWORD; lpValue: LPCSTR; \u000A                         lpFormat: PCURRENCYFMT; lpCurrencyStr: LPSTR; \u000A                         cchCurrency: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCurrencyFormatA\".}" },  { "module": "windows",  "name": "EnumCalendarInfoA",  "code": "proc EnumCalendarInfoA*(lpCalInfoEnumProc: CALINFO_ENUMPROC; Locale: LCID; \u000A                        Calendar: CALID; CalType: CALTYPE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EnumCalendarInfoA\".}" },  { "module": "windows",  "name": "EnumTimeFormatsA",  "code": "proc EnumTimeFormatsA*(lpTimeFmtEnumProc: TIMEFMT_ENUMPROC; Locale: LCID; \u000A                       dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumTimeFormatsA\".}" },  { "module": "windows",  "name": "EnumDateFormatsA",  "code": "proc EnumDateFormatsA*(lpDateFmtEnumProc: DATEFMT_ENUMPROC; Locale: LCID; \u000A                       dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumDateFormatsA\".}" },  { "module": "windows",  "name": "GetStringTypeExA",  "code": "proc GetStringTypeExA*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCSTR; \u000A                       cchSrc: int32; lpCharType: LPWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExA\".}" },  { "module": "windows",  "name": "GetStringTypeA",  "code": "proc GetStringTypeA*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCSTR; \u000A                     cchSrc: int32; lpCharType: LPWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeA\".}" },  { "module": "windows",  "name": "FoldStringA",  "code": "proc FoldStringA*(dwMapFlags: DWORD; lpSrcStr: LPCSTR; cchSrc: int32; \u000A                  lpDestStr: LPSTR; cchDest: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FoldStringA\".}" },  { "module": "windows",  "name": "EnumSystemLocalesA",  "code": "proc EnumSystemLocalesA*(lpLocaleEnumProc: LOCALE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemLocalesA\".}" },  { "module": "windows",  "name": "EnumSystemCodePagesA",  "code": "proc EnumSystemCodePagesA*(lpCodePageEnumProc: CODEPAGE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemCodePagesA\".}" },  { "module": "windows",  "name": "PeekConsoleInputA",  "code": "proc PeekConsoleInputA*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                        nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputA\".}" },  { "module": "windows",  "name": "ReadConsoleInputA",  "code": "proc ReadConsoleInputA*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                        nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputA\".}" },  { "module": "windows",  "name": "WriteConsoleInputA",  "code": "proc WriteConsoleInputA*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                         nLength: DWORD; lpNumberOfEventsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputA",  "code": "proc ReadConsoleOutputA*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                         dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                         lpReadRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputA",  "code": "proc WriteConsoleOutputA*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                          dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                          lpWriteRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacterA",  "code": "proc ReadConsoleOutputCharacterA*(hConsoleOutput: HANDLE; lpCharacter: LPSTR; \u000A                                  nLength: DWORD; dwReadCoord: COORD; \u000A                                  lpNumberOfCharsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacterA",  "code": "proc WriteConsoleOutputCharacterA*(hConsoleOutput: HANDLE; lpCharacter: LPCSTR; \u000A                                   nLength: DWORD; dwWriteCoord: COORD; \u000A                                   lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacterA",  "code": "proc FillConsoleOutputCharacterA*(hConsoleOutput: HANDLE; cCharacter: char; \u000A                                  nLength: DWORD; dwWriteCoord: COORD; \u000A                                  lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBufferA",  "code": "proc ScrollConsoleScreenBufferA*(hConsoleOutput: HANDLE; \u000A                                 lpScrollRectangle: PSMALL_RECT; \u000A                                 lpClipRectangle: PSMALL_RECT; \u000A                                 dwDestinationOrigin: COORD; lpFill: PCHAR_INFO): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferA\".}" },  { "module": "windows",  "name": "GetConsoleTitleA",  "code": "proc GetConsoleTitleA*(lpConsoleTitle: LPSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetConsoleTitleA\".}" },  { "module": "windows",  "name": "SetConsoleTitleA",  "code": "proc SetConsoleTitleA*(lpConsoleTitle: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleTitleA\".}" },  { "module": "windows",  "name": "ReadConsoleA",  "code": "proc ReadConsoleA*(hConsoleInput: HANDLE; lpBuffer: LPVOID; \u000A                   nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: LPDWORD; \u000A                   lpReserved: LPVOID): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleA\".}" },  { "module": "windows",  "name": "WriteConsoleA",  "code": "proc WriteConsoleA*(hConsoleOutput: HANDLE; lpBuffer: pointer; \u000A                    nNumberOfCharsToWrite: DWORD; \u000A                    lpNumberOfCharsWritten: LPDWORD; lpReserved: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleA\".}" },  { "module": "windows",  "name": "WNetAddConnectionA",  "code": "proc WNetAddConnectionA*(lpRemoteName: LPCSTR; lpPassword: LPCSTR; \u000A                         lpLocalName: LPCSTR): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetAddConnectionA\".}" },  { "module": "windows",  "name": "WNetAddConnection2A",  "code": "proc WNetAddConnection2A*(lpNetResource: LPNETRESOURCE; lpPassword: LPCSTR; \u000A                          lpUserName: LPCSTR; dwFlags: DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetAddConnection2A\".}" },  { "module": "windows",  "name": "WNetAddConnection3A",  "code": "proc WNetAddConnection3A*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                          lpPassword: LPCSTR; lpUserName: LPCSTR; dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetAddConnection3A\".}" },  { "module": "windows",  "name": "WNetCancelConnectionA",  "code": "proc WNetCancelConnectionA*(lpName: LPCSTR; fForce: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetCancelConnectionA\".}" },  { "module": "windows",  "name": "WNetCancelConnection2A",  "code": "proc WNetCancelConnection2A*(lpName: LPCSTR; dwFlags: DWORD; fForce: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetCancelConnection2A\".}" },  { "module": "windows",  "name": "WNetGetConnectionA",  "code": "proc WNetGetConnectionA*(lpLocalName: LPCSTR; lpRemoteName: LPSTR; \u000A                         lpnLength: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionA\".}" },  { "module": "windows",  "name": "WNetUseConnectionA",  "code": "proc WNetUseConnectionA*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                         lpUserID: LPCSTR; lpPassword: LPCSTR; dwFlags: DWORD; \u000A                         lpAccessName: LPSTR; lpBufferSize: LPDWORD; \u000A                         lpResult: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetUseConnectionA\".}" },  { "module": "windows",  "name": "WNetSetConnectionA",  "code": "proc WNetSetConnectionA*(lpName: LPCSTR; dwProperties: DWORD; pvValues: LPVOID): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetSetConnectionA\".}" },  { "module": "windows",  "name": "WNetConnectionDialog1A",  "code": "proc WNetConnectionDialog1A*(lpConnDlgStruct: LPCONNECTDLGSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetConnectionDialog1A\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog1A",  "code": "proc WNetDisconnectDialog1A*(lpConnDlgStruct: LPDISCDLGSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetDisconnectDialog1A\".}" },  { "module": "windows",  "name": "WNetOpenEnumA",  "code": "proc WNetOpenEnumA*(dwScope: DWORD; dwType: DWORD; dwUsage: DWORD; \u000A                    lpNetResource: LPNETRESOURCE; lphEnum: LPHANDLE): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetOpenEnumA\".}" },  { "module": "windows",  "name": "WNetEnumResourceA",  "code": "proc WNetEnumResourceA*(hEnum: HANDLE; lpcCount: LPDWORD; lpBuffer: LPVOID; \u000A                        lpBufferSize: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetEnumResourceA\".}" },  { "module": "windows",  "name": "WNetGetUniversalNameA",  "code": "proc WNetGetUniversalNameA*(lpLocalPath: LPCSTR; dwInfoLevel: DWORD; \u000A                            lpBuffer: LPVOID; lpBufferSize: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameA\".}" },  { "module": "windows",  "name": "WNetGetUserA",  "code": "proc WNetGetUserA*(lpName: LPCSTR; lpUserName: LPSTR; lpnLength: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserA\".}" },  { "module": "windows",  "name": "WNetGetProviderNameA",  "code": "proc WNetGetProviderNameA*(dwNetType: DWORD; lpProviderName: LPSTR; \u000A                           lpBufferSize: LPDWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameA\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformationA",  "code": "proc WNetGetNetworkInformationA*(lpProvider: LPCSTR; \u000A                                 lpNetInfoStruct: LPNETINFOSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationA\".}" },  { "module": "windows",  "name": "WNetGetLastErrorA",  "code": "proc WNetGetLastErrorA*(lpError: LPDWORD; lpErrorBuf: LPSTR; \u000A                        nErrorBufSize: DWORD; lpNameBuf: LPSTR; \u000A                        nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorA\".}" },  { "module": "windows",  "name": "MultinetGetConnectionPerformanceA",  "code": "proc MultinetGetConnectionPerformanceA*(lpNetResource: LPNETRESOURCE; \u000A    lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"MultinetGetConnectionPerformanceA\".}" },  { "module": "windows",  "name": "ChangeServiceConfigA",  "code": "proc ChangeServiceConfigA*(hService: SC_HANDLE; dwServiceType: DWORD; \u000A                           dwStartType: DWORD; dwErrorControl: DWORD; \u000A                           lpBinaryPathName: LPCSTR; lpLoadOrderGroup: LPCSTR; \u000A                           lpdwTagId: LPDWORD; lpDependencies: LPCSTR; \u000A                           lpServiceStartName: LPCSTR; lpPassword: LPCSTR; \u000A                           lpDisplayName: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ChangeServiceConfigA\".}" },  { "module": "windows",  "name": "CreateServiceA",  "code": "proc CreateServiceA*(hSCManager: SC_HANDLE; lpServiceName: LPCSTR; \u000A                     lpDisplayName: LPCSTR; dwDesiredAccess: DWORD; \u000A                     dwServiceType: DWORD; dwStartType: DWORD; \u000A                     dwErrorControl: DWORD; lpBinaryPathName: LPCSTR; \u000A                     lpLoadOrderGroup: LPCSTR; lpdwTagId: LPDWORD; \u000A                     lpDependencies: LPCSTR; lpServiceStartName: LPCSTR; \u000A                     lpPassword: LPCSTR): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"CreateServiceA\".}" },  { "module": "windows",  "name": "EnumDependentServicesA",  "code": "proc EnumDependentServicesA*(hService: SC_HANDLE; dwServiceState: DWORD; \u000A                             lpServices: LPENUM_SERVICE_STATUS; \u000A                             cbBufSize: DWORD; pcbBytesNeeded: LPDWORD; \u000A                             lpServicesReturned: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EnumDependentServicesA\".}" },  { "module": "windows",  "name": "EnumServicesStatusA",  "code": "proc EnumServicesStatusA*(hSCManager: SC_HANDLE; dwServiceType: DWORD; \u000A                          dwServiceState: DWORD; \u000A                          lpServices: LPENUM_SERVICE_STATUS; cbBufSize: DWORD; \u000A                          pcbBytesNeeded: LPDWORD; lpServicesReturned: LPDWORD; \u000A                          lpResumeHandle: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EnumServicesStatusA\".}" },  { "module": "windows",  "name": "GetServiceKeyNameA",  "code": "proc GetServiceKeyNameA*(hSCManager: SC_HANDLE; lpDisplayName: LPCSTR; \u000A                         lpServiceName: LPSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceKeyNameA\".}" },  { "module": "windows",  "name": "GetServiceDisplayNameA",  "code": "proc GetServiceDisplayNameA*(hSCManager: SC_HANDLE; lpServiceName: LPCSTR; \u000A                             lpDisplayName: LPSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceDisplayNameA\".}" },  { "module": "windows",  "name": "OpenSCManagerA",  "code": "proc OpenSCManagerA*(lpMachineName: LPCSTR; lpDatabaseName: LPCSTR; \u000A                     dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenSCManagerA\".}" },  { "module": "windows",  "name": "OpenServiceA",  "code": "proc OpenServiceA*(hSCManager: SC_HANDLE; lpServiceName: LPCSTR; \u000A                   dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenServiceA\".}" },  { "module": "windows",  "name": "QueryServiceConfigA",  "code": "proc QueryServiceConfigA*(hService: SC_HANDLE; \u000A                          lpServiceConfig: LPQUERY_SERVICE_CONFIG; \u000A                          cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceConfigA\".}" },  { "module": "windows",  "name": "QueryServiceLockStatusA",  "code": "proc QueryServiceLockStatusA*(hSCManager: SC_HANDLE; \u000A                              lpLockStatus: LPQUERY_SERVICE_LOCK_STATUS; \u000A                              cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceLockStatusA\".}" },  { "module": "windows",  "name": "RegisterServiceCtrlHandlerA",  "code": "proc RegisterServiceCtrlHandlerA*(lpServiceName: LPCSTR; \u000A                                  lpHandlerProc: LPHANDLER_FUNCTION): SERVICE_STATUS_HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterServiceCtrlHandlerA\".}" },  { "module": "windows",  "name": "StartServiceCtrlDispatcherA",  "code": "proc StartServiceCtrlDispatcherA*(lpServiceStartTable: LPSERVICE_TABLE_ENTRY): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"StartServiceCtrlDispatcherA\".}" },  { "module": "windows",  "name": "StartServiceA",  "code": "proc StartServiceA*(hService: SC_HANDLE; dwNumServiceArgs: DWORD; \u000A                    lpServiceArgVectors: LPCSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"StartServiceA\".}" },  { "module": "windows",  "name": "DragQueryFileA",  "code": "proc DragQueryFileA*(para1: HDROP; para2: int; para3: cstring; para4: int): int {.\u000A    stdcall, dynlib: \"shell32\", importc: \"DragQueryFileA\".}" },  { "module": "windows",  "name": "ExtractAssociatedIconA",  "code": "proc ExtractAssociatedIconA*(para1: HINST; para2: cstring; para3: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ExtractAssociatedIconA\".}" },  { "module": "windows",  "name": "ExtractIconA",  "code": "proc ExtractIconA*(para1: HINST; para2: cstring; para3: int): HICON {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ExtractIconA\".}" },  { "module": "windows",  "name": "FindExecutableA",  "code": "proc FindExecutableA*(para1: cstring; para2: cstring; para3: cstring): HINST {.\u000A    stdcall, dynlib: \"shell32\", importc: \"FindExecutableA\".}" },  { "module": "windows",  "name": "ShellAboutA",  "code": "proc ShellAboutA*(para1: HWND; para2: cstring; para3: cstring; para4: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ShellAboutA\".}" },  { "module": "windows",  "name": "ShellExecuteA",  "code": "proc ShellExecuteA*(para1: HWND; para2: cstring; para3: cstring; para4: cstring; \u000A                    para5: cstring; para6: int32): HINST {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ShellExecuteA\".}" },  { "module": "windows",  "name": "Shell_NotifyIconA",  "code": "proc Shell_NotifyIconA*(dwMessage: DWORD; lpData: PNotifyIconDataA): WINBOOL {.\u000A    stdcall, dynlib: \"shell32\", importc: \"Shell_NotifyIconA\".}" },  { "module": "windows",  "name": "DdeCreateStringHandleA",  "code": "proc DdeCreateStringHandleA*(para1: DWORD; para2: cstring; para3: int32): HSZ {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeCreateStringHandleA\".}" },  { "module": "windows",  "name": "DdeInitializeA",  "code": "proc DdeInitializeA*(para1: LPDWORD; para2: PFNCALLBACK; para3: DWORD; \u000A                     para4: DWORD): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeInitializeA\".}" },  { "module": "windows",  "name": "DdeQueryStringA",  "code": "proc DdeQueryStringA*(para1: DWORD; para2: HSZ; para3: cstring; para4: DWORD; \u000A                      para5: int32): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeQueryStringA\".}" },  { "module": "windows",  "name": "LogonUserA",  "code": "proc LogonUserA*(para1: LPSTR; para2: LPSTR; para3: LPSTR; para4: DWORD; \u000A                 para5: DWORD; para6: PHANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LogonUserA\".}" },  { "module": "windows",  "name": "CreateProcessAsUserA",  "code": "proc CreateProcessAsUserA*(para1: HANDLE; para2: LPCTSTR; para3: LPTSTR; \u000A                           para4: LPSECURITY_ATTRIBUTES; \u000A                           para5: LPSECURITY_ATTRIBUTES; para6: WINBOOL; \u000A                           para7: DWORD; para8: LPVOID; para9: LPCTSTR; \u000A                           para10: LPSTARTUPINFO; para11: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"CreateProcessAsUserA\".}" },  { "module": "windows",  "name": "GetBinaryTypeW",  "code": "proc GetBinaryTypeW*(lpApplicationName: LPCWSTR; lpBinaryType: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeW\".}" },  { "module": "windows",  "name": "GetShortPathNameW",  "code": "proc GetShortPathNameW*(lpszLongPath: LPCWSTR; lpszShortPath: LPWSTR; \u000A                        cchBuffer: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetShortPathNameW\".}" },  { "module": "windows",  "name": "GetEnvironmentStringsW",  "code": "proc GetEnvironmentStringsW*(): LPWSTR {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetEnvironmentStringsW\".}" },  { "module": "windows",  "name": "FreeEnvironmentStringsW",  "code": "proc FreeEnvironmentStringsW*(para1: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FreeEnvironmentStringsW\".}" },  { "module": "windows",  "name": "FormatMessageW",  "code": "proc FormatMessageW*(dwFlags: DWORD; lpSource: LPCVOID; dwMessageId: DWORD; \u000A                     dwLanguageId: DWORD; lpBuffer: LPWSTR; nSize: DWORD; \u000A                     Arguments: va_list): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FormatMessageW\".}" },  { "module": "windows",  "name": "CreateMailslotW",  "code": "proc CreateMailslotW*(lpName: LPCWSTR; nMaxMessageSize: DWORD; \u000A                      lReadTimeout: DWORD; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateMailslotW\".}" },  { "module": "windows",  "name": "lstrcmpW",  "code": "proc lstrcmpW*(lpString1: LPCWSTR; lpString2: LPCWSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcmpW\".}" },  { "module": "windows",  "name": "lstrcmpiW",  "code": "proc lstrcmpiW*(lpString1: LPCWSTR; lpString2: LPCWSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcmpiW\".}" },  { "module": "windows",  "name": "lstrcpynW",  "code": "proc lstrcpynW*(lpString1: LPWSTR; lpString2: LPCWSTR; iMaxLength: int32): LPWSTR {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"lstrcpynW\".}" },  { "module": "windows",  "name": "lstrcpyW",  "code": "proc lstrcpyW*(lpString1: LPWSTR; lpString2: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcpyW\".}" },  { "module": "windows",  "name": "lstrcatW",  "code": "proc lstrcatW*(lpString1: LPWSTR; lpString2: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcatW\".}" },  { "module": "windows",  "name": "lstrlenW",  "code": "proc lstrlenW*(lpString: LPCWSTR): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"lstrlenW\".}" },  { "module": "windows",  "name": "CreateMutexW",  "code": "proc CreateMutexW*(lpMutexAttributes: LPSECURITY_ATTRIBUTES; \u000A                   bInitialOwner: WINBOOL; lpName: LPCWSTR): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateMutexW\".}" },  { "module": "windows",  "name": "OpenMutexW",  "code": "proc OpenMutexW*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                 lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenMutexW\".}" },  { "module": "windows",  "name": "CreateEventW",  "code": "proc CreateEventW*(lpEventAttributes: LPSECURITY_ATTRIBUTES; \u000A                   bManualReset: WINBOOL; bInitialState: WINBOOL; \u000A                   lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CreateEventW\".}" },  { "module": "windows",  "name": "OpenEventW",  "code": "proc OpenEventW*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                 lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenEventW\".}" },  { "module": "windows",  "name": "CreateSemaphoreW",  "code": "proc CreateSemaphoreW*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES; \u000A                       lInitialCount: LONG; lMaximumCount: LONG; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateSemaphoreW\".}" },  { "module": "windows",  "name": "OpenSemaphoreW",  "code": "proc OpenSemaphoreW*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                     lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenSemaphoreW\".}" },  { "module": "windows",  "name": "CreateFileMappingW",  "code": "proc CreateFileMappingW*(hFile: HANDLE; \u000A                         lpFileMappingAttributes: LPSECURITY_ATTRIBUTES; \u000A                         flProtect: DWORD; dwMaximumSizeHigh: DWORD; \u000A                         dwMaximumSizeLow: DWORD; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateFileMappingW\".}" },  { "module": "windows",  "name": "OpenFileMappingW",  "code": "proc OpenFileMappingW*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                       lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenFileMappingW\".}" },  { "module": "windows",  "name": "GetLogicalDriveStringsW",  "code": "proc GetLogicalDriveStringsW*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetLogicalDriveStringsW\".}" },  { "module": "windows",  "name": "LoadLibraryW",  "code": "proc LoadLibraryW*(lpLibFileName: LPCWSTR): HINST {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LoadLibraryW\".}" },  { "module": "windows",  "name": "LoadLibraryExW",  "code": "proc LoadLibraryExW*(lpLibFileName: LPCWSTR; hFile: HANDLE; dwFlags: DWORD): HINST {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LoadLibraryExW\".}" },  { "module": "windows",  "name": "GetModuleFileNameW",  "code": "proc GetModuleFileNameW*(hModule: HINST; lpFilename: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetModuleFileNameW\".}" },  { "module": "windows",  "name": "GetModuleHandleW",  "code": "proc GetModuleHandleW*(lpModuleName: LPCWSTR): HMODULE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetModuleHandleW\".}" },  { "module": "windows",  "name": "FatalAppExitW",  "code": "proc FatalAppExitW*(uAction: WINUINT; lpMessageText: LPCWSTR) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FatalAppExitW\".}" },  { "module": "windows",  "name": "GetCommandLineW",  "code": "proc GetCommandLineW*(): LPWSTR {.stdcall, dynlib: \"kernel32\", \u000A                                  importc: \"GetCommandLineW\".}" },  { "module": "windows",  "name": "GetEnvironmentVariableW",  "code": "proc GetEnvironmentVariableW*(lpName: LPCWSTR; lpBuffer: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetEnvironmentVariableW\".}" },  { "module": "windows",  "name": "SetEnvironmentVariableW",  "code": "proc SetEnvironmentVariableW*(lpName: LPCWSTR; lpValue: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetEnvironmentVariableW\".}" },  { "module": "windows",  "name": "ExpandEnvironmentStringsW",  "code": "proc ExpandEnvironmentStringsW*(lpSrc: LPCWSTR; lpDst: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ExpandEnvironmentStringsW\".}" },  { "module": "windows",  "name": "OutputDebugStringW",  "code": "proc OutputDebugStringW*(lpOutputString: LPCWSTR) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OutputDebugStringW\".}" },  { "module": "windows",  "name": "FindResourceW",  "code": "proc FindResourceW*(hModule: HINST; lpName: LPCWSTR; lpType: LPCWSTR): HRSRC {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindResourceW\".}" },  { "module": "windows",  "name": "FindResourceExW",  "code": "proc FindResourceExW*(hModule: HINST; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                      wLanguage: int16): HRSRC {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindResourceExW\".}" },  { "module": "windows",  "name": "EnumResourceTypesW",  "code": "proc EnumResourceTypesW*(hModule: HINST; lpEnumFunc: ENUMRESTYPEPROC; \u000A                         lParam: LONG): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumResourceTypesW\".}" },  { "module": "windows",  "name": "EnumResourceNamesW",  "code": "proc EnumResourceNamesW*(hModule: HINST; lpType: LPCWSTR; \u000A                         lpEnumFunc: ENUMRESNAMEPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumResourceNamesW\".}" },  { "module": "windows",  "name": "EnumResourceLanguagesW",  "code": "proc EnumResourceLanguagesW*(hModule: HINST; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                             lpEnumFunc: ENUMRESLANGPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumResourceLanguagesW\".}" },  { "module": "windows",  "name": "BeginUpdateResourceW",  "code": "proc BeginUpdateResourceW*(pFileName: LPCWSTR; bDeleteExistingResources: WINBOOL): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BeginUpdateResourceW\".}" },  { "module": "windows",  "name": "UpdateResourceW",  "code": "proc UpdateResourceW*(hUpdate: HANDLE; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                      wLanguage: int16; lpData: LPVOID; cbData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UpdateResourceW\".}" },  { "module": "windows",  "name": "EndUpdateResourceW",  "code": "proc EndUpdateResourceW*(hUpdate: HANDLE; fDiscard: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EndUpdateResourceW\".}" },  { "module": "windows",  "name": "GlobalAddAtomW",  "code": "proc GlobalAddAtomW*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalAddAtomW\".}" },  { "module": "windows",  "name": "GlobalFindAtomW",  "code": "proc GlobalFindAtomW*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalFindAtomW\".}" },  { "module": "windows",  "name": "GlobalGetAtomNameW",  "code": "proc GlobalGetAtomNameW*(nAtom: ATOM; lpBuffer: LPWSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GlobalGetAtomNameW\".}" },  { "module": "windows",  "name": "AddAtomW",  "code": "proc AddAtomW*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"AddAtomW\".}" },  { "module": "windows",  "name": "FindAtomW",  "code": "proc FindAtomW*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindAtomW\".}" },  { "module": "windows",  "name": "GetAtomNameW",  "code": "proc GetAtomNameW*(nAtom: ATOM; lpBuffer: LPWSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetAtomNameW\".}" },  { "module": "windows",  "name": "GetProfileIntW",  "code": "proc GetProfileIntW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; nDefault: WINT): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProfileIntW\".}" },  { "module": "windows",  "name": "GetProfileStringW",  "code": "proc GetProfileStringW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                        lpDefault: LPCWSTR; lpReturnedString: LPWSTR; \u000A                        nSize: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProfileStringW\".}" },  { "module": "windows",  "name": "WriteProfileStringW",  "code": "proc WriteProfileStringW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                          lpString: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteProfileStringW\".}" },  { "module": "windows",  "name": "GetProfileSectionW",  "code": "proc GetProfileSectionW*(lpAppName: LPCWSTR; lpReturnedString: LPWSTR; \u000A                         nSize: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProfileSectionW\".}" },  { "module": "windows",  "name": "WriteProfileSectionW",  "code": "proc WriteProfileSectionW*(lpAppName: LPCWSTR; lpString: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteProfileSectionW\".}" },  { "module": "windows",  "name": "GetPrivateProfileIntW",  "code": "proc GetPrivateProfileIntW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                            nDefault: WINT; lpFileName: LPCWSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileIntW\".}" },  { "module": "windows",  "name": "GetPrivateProfileStringW",  "code": "proc GetPrivateProfileStringW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                               lpDefault: LPCWSTR; lpReturnedString: LPWSTR; \u000A                               nSize: DWORD; lpFileName: LPCWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStringW\".}" },  { "module": "windows",  "name": "WritePrivateProfileStringW",  "code": "proc WritePrivateProfileStringW*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                                 lpString: LPCWSTR; lpFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WritePrivateProfileStringW\".}" },  { "module": "windows",  "name": "GetPrivateProfileSectionW",  "code": "proc GetPrivateProfileSectionW*(lpAppName: LPCWSTR; lpReturnedString: LPWSTR; \u000A                                nSize: DWORD; lpFileName: LPCWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionW\".}" },  { "module": "windows",  "name": "WritePrivateProfileSectionW",  "code": "proc WritePrivateProfileSectionW*(lpAppName: LPCWSTR; lpString: LPCWSTR; \u000A                                  lpFileName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WritePrivateProfileSectionW\".}" },  { "module": "windows",  "name": "GetDriveTypeW",  "code": "proc GetDriveTypeW*(lpRootPathName: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDriveTypeW\".}" },  { "module": "windows",  "name": "GetSystemDirectoryW",  "code": "proc GetSystemDirectoryW*(lpBuffer: LPWSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetSystemDirectoryW\".}" },  { "module": "windows",  "name": "GetTempPathW",  "code": "proc GetTempPathW*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTempPathW\".}" },  { "module": "windows",  "name": "GetTempFileNameW",  "code": "proc GetTempFileNameW*(lpPathName: LPCWSTR; lpPrefixString: LPCWSTR; \u000A                       uUnique: WINUINT; lpTempFileName: LPWSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTempFileNameW\".}" },  { "module": "windows",  "name": "GetWindowsDirectoryW",  "code": "proc GetWindowsDirectoryW*(lpBuffer: LPWSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetWindowsDirectoryW\".}" },  { "module": "windows",  "name": "SetCurrentDirectoryW",  "code": "proc SetCurrentDirectoryW*(lpPathName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCurrentDirectoryW\".}" },  { "module": "windows",  "name": "GetCurrentDirectoryW",  "code": "proc GetCurrentDirectoryW*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCurrentDirectoryW\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceW",  "code": "proc GetDiskFreeSpaceW*(lpRootPathName: LPCWSTR; lpSectorsPerCluster: LPDWORD; \u000A                        lpBytesPerSector: LPDWORD; \u000A                        lpNumberOfFreeClusters: LPDWORD; \u000A                        lpTotalNumberOfClusters: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceW\".}" },  { "module": "windows",  "name": "CreateDirectoryW",  "code": "proc CreateDirectoryW*(lpPathName: LPCWSTR; \u000A                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryW\".}" },  { "module": "windows",  "name": "CreateDirectoryExW",  "code": "proc CreateDirectoryExW*(lpTemplateDirectory: LPCWSTR; lpNewDirectory: LPCWSTR; \u000A                         lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryExW\".}" },  { "module": "windows",  "name": "RemoveDirectoryW",  "code": "proc RemoveDirectoryW*(lpPathName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"RemoveDirectoryW\".}" },  { "module": "windows",  "name": "GetFullPathNameW",  "code": "proc GetFullPathNameW*(lpFileName: LPCWSTR; nBufferLength: DWORD; \u000A                       lpBuffer: LPWSTR; lpFilePart: var LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFullPathNameW\".}" },  { "module": "windows",  "name": "DefineDosDeviceW",  "code": "proc DefineDosDeviceW*(dwFlags: DWORD; lpDeviceName: LPCWSTR; \u000A                       lpTargetPath: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DefineDosDeviceW\".}" },  { "module": "windows",  "name": "QueryDosDeviceW",  "code": "proc QueryDosDeviceW*(lpDeviceName: LPCWSTR; lpTargetPath: LPWSTR; \u000A                      ucchMax: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"QueryDosDeviceW\".}" },  { "module": "windows",  "name": "CreateFileW",  "code": "proc CreateFileW*(lpFileName: LPCWSTR; dwDesiredAccess: DWORD; \u000A                  dwShareMode: DWORD; \u000A                  lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                  dwCreationDisposition: DWORD; dwFlagsAndAttributes: DWORD; \u000A                  hTemplateFile: HANDLE): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CreateFileW\".}" },  { "module": "windows",  "name": "SetFileAttributesW",  "code": "proc SetFileAttributesW*(lpFileName: LPCWSTR; dwFileAttributes: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileAttributesW\".}" },  { "module": "windows",  "name": "GetFileAttributesW",  "code": "proc GetFileAttributesW*(lpFileName: LPCWSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileAttributesW\".}" },  { "module": "windows",  "name": "GetCompressedFileSizeW",  "code": "proc GetCompressedFileSizeW*(lpFileName: LPCWSTR; lpFileSizeHigh: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCompressedFileSizeW\".}" },  { "module": "windows",  "name": "DeleteFileW",  "code": "proc DeleteFileW*(lpFileName: LPCWSTR): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"DeleteFileW\".}" },  { "module": "windows",  "name": "SearchPathW",  "code": "proc SearchPathW*(lpPath: LPCWSTR; lpFileName: LPCWSTR; lpExtension: LPCWSTR; \u000A                  nBufferLength: DWORD; lpBuffer: LPWSTR; lpFilePart: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SearchPathW\".}" },  { "module": "windows",  "name": "CopyFileW",  "code": "proc CopyFileW*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR; \u000A                bFailIfExists: WINBOOL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CopyFileW\".}" },  { "module": "windows",  "name": "MoveFileW",  "code": "proc MoveFileW*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MoveFileW\".}" },  { "module": "windows",  "name": "MoveFileExW",  "code": "proc MoveFileExW*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR; \u000A                  dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"MoveFileExW\".}" },  { "module": "windows",  "name": "CreateNamedPipeW",  "code": "proc CreateNamedPipeW*(lpName: LPCWSTR; dwOpenMode: DWORD; dwPipeMode: DWORD; \u000A                       nMaxInstances: DWORD; nOutBufferSize: DWORD; \u000A                       nInBufferSize: DWORD; nDefaultTimeOut: DWORD; \u000A                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateNamedPipeW\".}" },  { "module": "windows",  "name": "GetNamedPipeHandleStateW",  "code": "proc GetNamedPipeHandleStateW*(hNamedPipe: HANDLE; lpState: LPDWORD; \u000A                               lpCurInstances: LPDWORD; \u000A                               lpMaxCollectionCount: LPDWORD; \u000A                               lpCollectDataTimeout: LPDWORD; \u000A                               lpUserName: LPWSTR; nMaxUserNameSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNamedPipeHandleStateW\".}" },  { "module": "windows",  "name": "CallNamedPipeW",  "code": "proc CallNamedPipeW*(lpNamedPipeName: LPCWSTR; lpInBuffer: LPVOID; \u000A                     nInBufferSize: DWORD; lpOutBuffer: LPVOID; \u000A                     nOutBufferSize: DWORD; lpBytesRead: LPDWORD; \u000A                     nTimeOut: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CallNamedPipeW\".}" },  { "module": "windows",  "name": "WaitNamedPipeW",  "code": "proc WaitNamedPipeW*(lpNamedPipeName: LPCWSTR; nTimeOut: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitNamedPipeW\".}" },  { "module": "windows",  "name": "SetVolumeLabelW",  "code": "proc SetVolumeLabelW*(lpRootPathName: LPCWSTR; lpVolumeName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetVolumeLabelW\".}" },  { "module": "windows",  "name": "GetVolumeInformationW",  "code": "proc GetVolumeInformationW*(lpRootPathName: LPCWSTR; lpVolumeNameBuffer: LPWSTR; \u000A                            nVolumeNameSize: DWORD; \u000A                            lpVolumeSerialNumber: LPDWORD; \u000A                            lpMaximumComponentLength: LPDWORD; \u000A                            lpFileSystemFlags: LPDWORD; \u000A                            lpFileSystemNameBuffer: LPWSTR; \u000A                            nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationW\".}" },  { "module": "windows",  "name": "ClearEventLogW",  "code": "proc ClearEventLogW*(hEventLog: HANDLE; lpBackupFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ClearEventLogW\".}" },  { "module": "windows",  "name": "BackupEventLogW",  "code": "proc BackupEventLogW*(hEventLog: HANDLE; lpBackupFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"BackupEventLogW\".}" },  { "module": "windows",  "name": "OpenEventLogW",  "code": "proc OpenEventLogW*(lpUNCServerName: LPCWSTR; lpSourceName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenEventLogW\".}" },  { "module": "windows",  "name": "RegisterEventSourceW",  "code": "proc RegisterEventSourceW*(lpUNCServerName: LPCWSTR; lpSourceName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterEventSourceW\".}" },  { "module": "windows",  "name": "OpenBackupEventLogW",  "code": "proc OpenBackupEventLogW*(lpUNCServerName: LPCWSTR; lpFileName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenBackupEventLogW\".}" },  { "module": "windows",  "name": "ReadEventLogW",  "code": "proc ReadEventLogW*(hEventLog: HANDLE; dwReadFlags: DWORD; \u000A                    dwRecordOffset: DWORD; lpBuffer: LPVOID; \u000A                    nNumberOfBytesToRead: DWORD; pnBytesRead: LPDWORD; \u000A                    pnMinNumberOfBytesNeeded: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ReadEventLogW\".}" },  { "module": "windows",  "name": "ReportEventW",  "code": "proc ReportEventW*(hEventLog: HANDLE; wType: int16; wCategory: int16; \u000A                   dwEventID: DWORD; lpUserSid: PSID; wNumStrings: int16; \u000A                   dwDataSize: DWORD; lpStrings: LPPCWSTR; lpRawData: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReportEventW\".}" },  { "module": "windows",  "name": "AccessCheckAndAuditAlarmW",  "code": "proc AccessCheckAndAuditAlarmW*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                                ObjectTypeName: LPWSTR; ObjectName: LPWSTR; \u000A                                SecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                DesiredAccess: DWORD; \u000A                                GenericMapping: PGENERIC_MAPPING; \u000A                                ObjectCreation: WINBOOL; GrantedAccess: LPDWORD; \u000A                                AccessStatus: LPBOOL; pfGenerateOnClose: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AccessCheckAndAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarmW",  "code": "proc ObjectOpenAuditAlarmW*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                            ObjectTypeName: LPWSTR; ObjectName: LPWSTR; \u000A                            pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                            ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                            GrantedAccess: DWORD; Privileges: PPRIVILEGE_SET; \u000A                            ObjectCreation: WINBOOL; AccessGranted: WINBOOL; \u000A                            GenerateOnClose: LPBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarmW",  "code": "proc ObjectPrivilegeAuditAlarmW*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                                 ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                                 Privileges: PPRIVILEGE_SET; \u000A                                 AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectCloseAuditAlarmW",  "code": "proc ObjectCloseAuditAlarmW*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                             GenerateOnClose: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectCloseAuditAlarmW\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarmW",  "code": "proc PrivilegedServiceAuditAlarmW*(SubsystemName: LPCWSTR; ServiceName: LPCWSTR; \u000A                                   ClientToken: HANDLE; \u000A                                   Privileges: PPRIVILEGE_SET; \u000A                                   AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmW\".}" },  { "module": "windows",  "name": "SetFileSecurityW",  "code": "proc SetFileSecurityW*(lpFileName: LPCWSTR; \u000A                       SecurityInformation: SECURITY_INFORMATION; \u000A                       pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetFileSecurityW\".}" },  { "module": "windows",  "name": "GetFileSecurityW",  "code": "proc GetFileSecurityW*(lpFileName: LPCWSTR; \u000A                       RequestedInformation: SECURITY_INFORMATION; \u000A                       pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                       nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetFileSecurityW\".}" },  { "module": "windows",  "name": "FindFirstChangeNotificationW",  "code": "proc FindFirstChangeNotificationW*(lpPathName: LPCWSTR; bWatchSubtree: WINBOOL; \u000A                                   dwNotifyFilter: DWORD): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindFirstChangeNotificationW\".}" },  { "module": "windows",  "name": "IsBadStringPtrW",  "code": "proc IsBadStringPtrW*(lpsz: LPCWSTR; ucchMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadStringPtrW\".}" },  { "module": "windows",  "name": "LookupAccountSidW",  "code": "proc LookupAccountSidW*(lpSystemName: LPCWSTR; Sid: PSID; Name: LPWSTR; \u000A                        cbName: LPDWORD; ReferencedDomainName: LPWSTR; \u000A                        cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountSidW\".}" },  { "module": "windows",  "name": "LookupAccountNameW",  "code": "proc LookupAccountNameW*(lpSystemName: LPCWSTR; lpAccountName: LPCWSTR; \u000A                         Sid: PSID; cbSid: LPDWORD; \u000A                         ReferencedDomainName: LPWSTR; \u000A                         cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeValueW",  "code": "proc LookupPrivilegeValueW*(lpSystemName: LPCWSTR; lpName: LPCWSTR; \u000A                            lpLuid: PLUID): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeValueW\".}" },  { "module": "windows",  "name": "LookupPrivilegeNameW",  "code": "proc LookupPrivilegeNameW*(lpSystemName: LPCWSTR; lpLuid: PLUID; lpName: LPWSTR; \u000A                           cbName: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayNameW",  "code": "proc LookupPrivilegeDisplayNameW*(lpSystemName: LPCWSTR; lpName: LPCWSTR; \u000A                                  lpDisplayName: LPWSTR; cbDisplayName: LPDWORD; \u000A                                  lpLanguageId: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameW\".}" },  { "module": "windows",  "name": "BuildCommDCBW",  "code": "proc BuildCommDCBW*(lpDef: LPCWSTR; lpDCB: LPDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBW\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeoutsW",  "code": "proc BuildCommDCBAndTimeoutsW*(lpDef: LPCWSTR; lpDCB: LPDCB; \u000A                               lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsW\".}" },  { "module": "windows",  "name": "CommConfigDialogW",  "code": "proc CommConfigDialogW*(lpszName: LPCWSTR; wnd: HWND; lpCC: LPCOMMCONFIG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogW\".}" },  { "module": "windows",  "name": "GetDefaultCommConfigW",  "code": "proc GetDefaultCommConfigW*(lpszName: LPCWSTR; lpCC: LPCOMMCONFIG; \u000A                            lpdwSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigW\".}" },  { "module": "windows",  "name": "SetDefaultCommConfigW",  "code": "proc SetDefaultCommConfigW*(lpszName: LPCWSTR; lpCC: LPCOMMCONFIG; dwSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetDefaultCommConfigW\".}" },  { "module": "windows",  "name": "GetComputerNameW",  "code": "proc GetComputerNameW*(lpBuffer: LPWSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameW\".}" },  { "module": "windows",  "name": "SetComputerNameW",  "code": "proc SetComputerNameW*(lpComputerName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetComputerNameW\".}" },  { "module": "windows",  "name": "GetUserNameW",  "code": "proc GetUserNameW*(lpBuffer: LPWSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameW\".}" },  { "module": "windows",  "name": "LoadKeyboardLayoutW",  "code": "proc LoadKeyboardLayoutW*(pwszKLID: LPCWSTR; Flags: WINUINT): HKL {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadKeyboardLayoutW\".}" },  { "module": "windows",  "name": "GetKeyboardLayoutNameW",  "code": "proc GetKeyboardLayoutNameW*(pwszKLID: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetKeyboardLayoutNameW\".}" },  { "module": "windows",  "name": "CreateDesktopW",  "code": "proc CreateDesktopW*(lpszDesktop: LPWSTR; lpszDevice: LPWSTR; \u000A                     pDevmodew: LPDEVMODEw; dwFlags: DWORD; \u000A                     dwDesiredAccess: DWORD; lpsa: LPSECURITY_ATTRIBUTES): HDESK {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateDesktopW\".}" },  { "module": "windows",  "name": "OpenDesktopW",  "code": "proc OpenDesktopW*(lpszDesktop: LPWSTR; dwFlags: DWORD; fInherit: WINBOOL; \u000A                   dwDesiredAccess: DWORD): HDESK {.stdcall, dynlib: \"user32\", \u000A    importc: \"OpenDesktopW\".}" },  { "module": "windows",  "name": "EnumDesktopsW",  "code": "proc EnumDesktopsW*(hwinsta: HWINSTA; lpEnumFunc: DESKTOPENUMPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumDesktopsW\".}" },  { "module": "windows",  "name": "CreateWindowStationW",  "code": "proc CreateWindowStationW*(lpwinsta: LPWSTR; dwReserved: DWORD; \u000A                           dwDesiredAccess: DWORD; lpsa: LPSECURITY_ATTRIBUTES): HWINSTA {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowStationW\".}" },  { "module": "windows",  "name": "OpenWindowStationW",  "code": "proc OpenWindowStationW*(lpszWinSta: LPWSTR; fInherit: WINBOOL; \u000A                         dwDesiredAccess: DWORD): HWINSTA {.stdcall, \u000A    dynlib: \"user32\", importc: \"OpenWindowStationW\".}" },  { "module": "windows",  "name": "EnumWindowStationsW",  "code": "proc EnumWindowStationsW*(lpEnumFunc: ENUMWINDOWSTATIONPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumWindowStationsW\".}" },  { "module": "windows",  "name": "GetUserObjectInformationW",  "code": "proc GetUserObjectInformationW*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                                nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationW\".}" },  { "module": "windows",  "name": "SetUserObjectInformationW",  "code": "proc SetUserObjectInformationW*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                                nLength: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetUserObjectInformationW\".}" },  { "module": "windows",  "name": "RegisterWindowMessageW",  "code": "proc RegisterWindowMessageW*(lpString: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterWindowMessageW\".}" },  { "module": "windows",  "name": "GetMessageW",  "code": "proc GetMessageW*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                  wMsgFilterMax: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMessageW\".}" },  { "module": "windows",  "name": "DispatchMessageW",  "code": "proc DispatchMessageW*(lpMsg: LPMSG): LONG {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageW\".}" },  { "module": "windows",  "name": "PeekMessageW",  "code": "proc PeekMessageW*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                   wMsgFilterMax: WINUINT; wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageW\".}" },  { "module": "windows",  "name": "SendMessageW",  "code": "proc SendMessageW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageW\".}" },  { "module": "windows",  "name": "SendMessageTimeoutW",  "code": "proc SendMessageTimeoutW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                          fuFlags: WINUINT; uTimeout: WINUINT; \u000A                          lpdwResult: LPDWORD): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendMessageTimeoutW\".}" },  { "module": "windows",  "name": "SendNotifyMessageW",  "code": "proc SendNotifyMessageW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendNotifyMessageW\".}" },  { "module": "windows",  "name": "SendMessageCallbackW",  "code": "proc SendMessageCallbackW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                           lpResultCallBack: SENDASYNCPROC; dwData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageCallbackW\".}" },  { "module": "windows",  "name": "PostMessageW",  "code": "proc PostMessageW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostMessageW\".}" },  { "module": "windows",  "name": "PostThreadMessageW",  "code": "proc PostThreadMessageW*(idThread: DWORD; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostThreadMessageW\".}" },  { "module": "windows",  "name": "DefWindowProcW",  "code": "proc DefWindowProcW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefWindowProcW\".}" },  { "module": "windows",  "name": "CallWindowProcW",  "code": "proc CallWindowProcW*(lpPrevWndFunc: WNDPROC; wnd: HWND; Msg: WINUINT; \u000A                      wp: WPARAM; lp: LPARAM): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallWindowProcW\".}" },  { "module": "windows",  "name": "RegisterClassW",  "code": "proc RegisterClassW*(lpWndClass: LPWNDCLASSW): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassW\".}" },  { "module": "windows",  "name": "UnregisterClassW",  "code": "proc UnregisterClassW*(lpClassName: LPCWSTR; hInstance: HINST): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnregisterClassW\".}" },  { "module": "windows",  "name": "GetClassInfoW",  "code": "proc GetClassInfoW*(hInstance: HINST; lpClassName: LPCWSTR; \u000A                    lpWndClass: LPWNDCLASS): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassInfoW\".}" },  { "module": "windows",  "name": "RegisterClassExW",  "code": "proc RegisterClassExW*(para1: LPWNDCLASSEXW): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassExW\".}" },  { "module": "windows",  "name": "GetClassInfoExW",  "code": "proc GetClassInfoExW*(para1: HINST; para2: LPCWSTR; para3: LPWNDCLASSEX): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassInfoExW\".}" },  { "module": "windows",  "name": "CreateWindowExW",  "code": "proc CreateWindowExW*(dwExStyle: DWORD; lpClassName: LPCWSTR; \u000A                      lpWindowName: LPCWSTR; dwStyle: DWORD; X: int32; Y: int32; \u000A                      nWidth: int32; nHeight: int32; hWndParent: HWND; \u000A                      menu: HMENU; hInstance: HINST; lpParam: LPVOID): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowExW\".}" },  { "module": "windows",  "name": "CreateDialogParamW",  "code": "proc CreateDialogParamW*(hInstance: HINST; lpTemplateName: LPCWSTR; \u000A                         hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                         dwInitParam: LPARAM): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateDialogParamW\".}" },  { "module": "windows",  "name": "CreateDialogIndirectParamW",  "code": "proc CreateDialogIndirectParamW*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                                 hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                                 dwInitParam: LPARAM): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDialogIndirectParamW\".}" },  { "module": "windows",  "name": "DialogBoxParamW",  "code": "proc DialogBoxParamW*(hInstance: HINST; lpTemplateName: LPCWSTR; \u000A                      hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                      dwInitParam: LPARAM): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DialogBoxParamW\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParamW",  "code": "proc DialogBoxIndirectParamW*(hInstance: HINST; hDialogTemplate: LPCDLGTEMPLATE; \u000A                              hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                              dwInitParam: LPARAM): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamW\".}" },  { "module": "windows",  "name": "SetDlgItemTextW",  "code": "proc SetDlgItemTextW*(hDlg: HWND; nIDDlgItem: int32; lpString: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetDlgItemTextW\".}" },  { "module": "windows",  "name": "GetDlgItemTextW",  "code": "proc GetDlgItemTextW*(hDlg: HWND; nIDDlgItem: int32; lpString: LPWSTR; \u000A                      nMaxCount: int32): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetDlgItemTextW\".}" },  { "module": "windows",  "name": "SendDlgItemMessageW",  "code": "proc SendDlgItemMessageW*(hDlg: HWND; nIDDlgItem: int32; Msg: WINUINT; \u000A                          wp: WPARAM; lp: LPARAM): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendDlgItemMessageW\".}" },  { "module": "windows",  "name": "DefDlgProcW",  "code": "proc DefDlgProcW*(hDlg: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefDlgProcW\".}" },  { "module": "windows",  "name": "CallMsgFilterW",  "code": "proc CallMsgFilterW*(lpMsg: LPMSG; nCode: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterW\".}" },  { "module": "windows",  "name": "RegisterClipboardFormatW",  "code": "proc RegisterClipboardFormatW*(lpszFormat: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterClipboardFormatW\".}" },  { "module": "windows",  "name": "GetClipboardFormatNameW",  "code": "proc GetClipboardFormatNameW*(format: WINUINT; lpszFormatName: LPWSTR; \u000A                              cchMaxCount: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClipboardFormatNameW\".}" },  { "module": "windows",  "name": "CharToOemW",  "code": "proc CharToOemW*(lpszSrc: LPCWSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharToOemW\".}" },  { "module": "windows",  "name": "OemToCharW",  "code": "proc OemToCharW*(lpszSrc: LPCSTR; lpszDst: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OemToCharW\".}" },  { "module": "windows",  "name": "CharToOemBuffW",  "code": "proc CharToOemBuffW*(lpszSrc: LPCWSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CharToOemBuffW\".}" },  { "module": "windows",  "name": "OemToCharBuffW",  "code": "proc OemToCharBuffW*(lpszSrc: LPCSTR; lpszDst: LPWSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"OemToCharBuffW\".}" },  { "module": "windows",  "name": "CharUpperW",  "code": "proc CharUpperW*(lpsz: LPWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A    importc: \"CharUpperW\".}" },  { "module": "windows",  "name": "CharUpperBuffW",  "code": "proc CharUpperBuffW*(lpsz: LPWSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharUpperBuffW\".}" },  { "module": "windows",  "name": "CharLowerW",  "code": "proc CharLowerW*(lpsz: LPWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A    importc: \"CharLowerW\".}" },  { "module": "windows",  "name": "CharLowerBuffW",  "code": "proc CharLowerBuffW*(lpsz: LPWSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharLowerBuffW\".}" },  { "module": "windows",  "name": "CharNextW",  "code": "proc CharNextW*(lpsz: LPCWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A    importc: \"CharNextW\".}" },  { "module": "windows",  "name": "CharPrevW",  "code": "proc CharPrevW*(lpszStart: LPCWSTR; lpszCurrent: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharPrevW\".}" },  { "module": "windows",  "name": "IsCharAlphaW",  "code": "proc IsCharAlphaW*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharAlphaW\".}" },  { "module": "windows",  "name": "IsCharAlphaNumericW",  "code": "proc IsCharAlphaNumericW*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharAlphaNumericW\".}" },  { "module": "windows",  "name": "IsCharUpperW",  "code": "proc IsCharUpperW*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharUpperW\".}" },  { "module": "windows",  "name": "IsCharLowerW",  "code": "proc IsCharLowerW*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharLowerW\".}" },  { "module": "windows",  "name": "GetKeyNameTextW",  "code": "proc GetKeyNameTextW*(lParam: LONG; lpString: LPWSTR; nSize: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetKeyNameTextW\".}" },  { "module": "windows",  "name": "VkKeyScanW",  "code": "proc VkKeyScanW*(ch: WCHAR): SHORT {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"VkKeyScanW\".}" },  { "module": "windows",  "name": "VkKeyScanExW",  "code": "proc VkKeyScanExW*(ch: WCHAR; dwhkl: HKL): SHORT {.stdcall, dynlib: \"user32\", \u000A    importc: \"VkKeyScanExW\".}" },  { "module": "windows",  "name": "MapVirtualKeyW",  "code": "proc MapVirtualKeyW*(uCode: WINUINT; uMapType: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"MapVirtualKeyW\".}" },  { "module": "windows",  "name": "MapVirtualKeyExW",  "code": "proc MapVirtualKeyExW*(uCode: WINUINT; uMapType: WINUINT; dwhkl: HKL): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"MapVirtualKeyExW\".}" },  { "module": "windows",  "name": "LoadAcceleratorsW",  "code": "proc LoadAcceleratorsW*(hInstance: HINST; lpTableName: LPCWSTR): HACCEL {.\u000A    stdcall, dynlib: \"user32\", importc: \"LoadAcceleratorsW\".}" },  { "module": "windows",  "name": "CreateAcceleratorTableW",  "code": "proc CreateAcceleratorTableW*(para1: LPACCEL; para2: int32): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableW\".}" },  { "module": "windows",  "name": "CopyAcceleratorTableW",  "code": "proc CopyAcceleratorTableW*(hAccelSrc: HACCEL; lpAccelDst: LPACCEL; \u000A                            cAccelEntries: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyAcceleratorTableW\".}" },  { "module": "windows",  "name": "TranslateAcceleratorW",  "code": "proc TranslateAcceleratorW*(wnd: HWND; hAccTable: HACCEL; lpMsg: LPMSG): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorW\".}" },  { "module": "windows",  "name": "LoadMenuW",  "code": "proc LoadMenuW*(hInstance: HINST; lpMenuName: LPCWSTR): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuW\".}" },  { "module": "windows",  "name": "LoadMenuIndirectW",  "code": "proc LoadMenuIndirectW*(lpMenuTemplate: LPMENUTEMPLATE): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuIndirectW\".}" },  { "module": "windows",  "name": "ChangeMenuW",  "code": "proc ChangeMenuW*(menu: HMENU; cmd: WINUINT; lpszNewItem: LPCWSTR; \u000A                  cmdInsert: WINUINT; flags: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ChangeMenuW\".}" },  { "module": "windows",  "name": "GetMenuStringW",  "code": "proc GetMenuStringW*(menu: HMENU; uIDItem: WINUINT; lpString: LPWSTR; \u000A                     nMaxCount: int32; uFlag: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuStringW\".}" },  { "module": "windows",  "name": "InsertMenuW",  "code": "proc InsertMenuW*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                  uIDNewItem: WINUINT; lpNewItem: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuW\".}" },  { "module": "windows",  "name": "AppendMenuW",  "code": "proc AppendMenuW*(menu: HMENU; uFlags: WINUINT; uIDNewItem: WINUINT; \u000A                  lpNewItem: LPCWSTR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"AppendMenuW\".}" },  { "module": "windows",  "name": "ModifyMenuW",  "code": "proc ModifyMenuW*(hMnu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                  uIDNewItem: WINUINT; lpNewItem: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ModifyMenuW\".}" },  { "module": "windows",  "name": "InsertMenuItemW",  "code": "proc InsertMenuItemW*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                      para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuItemW\".}" },  { "module": "windows",  "name": "GetMenuItemInfoW",  "code": "proc GetMenuItemInfoW*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                       para4: LPMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuItemInfoW\".}" },  { "module": "windows",  "name": "SetMenuItemInfoW",  "code": "proc SetMenuItemInfoW*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                       para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetMenuItemInfoW\".}" },  { "module": "windows",  "name": "DrawTextW",  "code": "proc DrawTextW*(hDC: HDC; lpString: LPCWSTR; nCount: int32; lpRect: LPRECT; \u000A                uFormat: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawTextW\".}" },  { "module": "windows",  "name": "DrawTextExW",  "code": "proc DrawTextExW*(para1: HDC; para2: LPWSTR; para3: int32; para4: LPRECT; \u000A                  para5: WINUINT; para6: LPDRAWTEXTPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawTextExW\".}" },  { "module": "windows",  "name": "GrayStringW",  "code": "proc GrayStringW*(hDC: HDC; hBrush: HBRUSH; lpOutputFunc: GRAYSTRINGPROC; \u000A                  lpData: LPARAM; nCount: int32; X: int32; Y: int32; \u000A                  nWidth: int32; nHeight: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GrayStringW\".}" },  { "module": "windows",  "name": "DrawStateW",  "code": "proc DrawStateW*(para1: HDC; para2: HBRUSH; para3: DRAWSTATEPROC; para4: LPARAM; \u000A                 para5: WPARAM; para6: int32; para7: int32; para8: int32; \u000A                 para9: int32; para10: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawStateW\".}" },  { "module": "windows",  "name": "TabbedTextOutW",  "code": "proc TabbedTextOutW*(hDC: HDC; X: int32; Y: int32; lpString: LPCWSTR; \u000A                     nCount: int32; nTabPositions: int32; \u000A                     lpnTabStopPositions: LPINT; nTabOrigin: int32): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"TabbedTextOutW\".}" },  { "module": "windows",  "name": "GetTabbedTextExtentW",  "code": "proc GetTabbedTextExtentW*(hDC: HDC; lpString: LPCWSTR; nCount: int32; \u000A                           nTabPositions: int32; lpnTabStopPositions: LPINT): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetTabbedTextExtentW\".}" },  { "module": "windows",  "name": "SetPropW",  "code": "proc SetPropW*(wnd: HWND; lpString: LPCWSTR; hData: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetPropW\".}" },  { "module": "windows",  "name": "GetPropW",  "code": "proc GetPropW*(wnd: HWND; lpString: LPCWSTR): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetPropW\".}" },  { "module": "windows",  "name": "RemovePropW",  "code": "proc RemovePropW*(wnd: HWND; lpString: LPCWSTR): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"RemovePropW\".}" },  { "module": "windows",  "name": "EnumPropsExW",  "code": "proc EnumPropsExW*(wnd: HWND; lpEnumFunc: PROPENUMPROCEX; lp: LPARAM): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumPropsExW\".}" },  { "module": "windows",  "name": "EnumPropsW",  "code": "proc EnumPropsW*(wnd: HWND; lpEnumFunc: PROPENUMPROC): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumPropsW\".}" },  { "module": "windows",  "name": "SetWindowTextW",  "code": "proc SetWindowTextW*(wnd: HWND; lpString: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowTextW\".}" },  { "module": "windows",  "name": "GetWindowTextW",  "code": "proc GetWindowTextW*(wnd: HWND; lpString: LPWSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowTextW\".}" },  { "module": "windows",  "name": "GetWindowTextLengthW",  "code": "proc GetWindowTextLengthW*(wnd: HWND): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowTextLengthW\".}" },  { "module": "windows",  "name": "MessageBoxW",  "code": "proc MessageBoxW*(wnd: HWND; lpText: LPCWSTR; lpCaption: LPCWSTR; uType: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"MessageBoxW\".}" },  { "module": "windows",  "name": "MessageBoxExW",  "code": "proc MessageBoxExW*(wnd: HWND; lpText: LPCWSTR; lpCaption: LPCWSTR; \u000A                    uType: WINUINT; wLanguageId: int16): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxExW\".}" },  { "module": "windows",  "name": "MessageBoxIndirectW",  "code": "proc MessageBoxIndirectW*(para1: LPMSGBOXPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxIndirectW\".}" },  { "module": "windows",  "name": "GetWindowLongW",  "code": "proc GetWindowLongW*(wnd: HWND; nIndex: int32): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowLongW\".}" },  { "module": "windows",  "name": "SetWindowLongW",  "code": "proc SetWindowLongW*(wnd: HWND; nIndex: int32; dwNewLong: LONG): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowLongW\".}" },  { "module": "windows",  "name": "GetClassLongW",  "code": "proc GetClassLongW*(wnd: HWND; nIndex: int32): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassLongW\".}" },  { "module": "windows",  "name": "SetClassLongW",  "code": "proc SetClassLongW*(wnd: HWND; nIndex: int32; dwNewLong: LONG): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetClassLongW\".}" },  { "module": "windows",  "name": "GetWindowLongPtrW",  "code": "proc GetWindowLongPtrW*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowLongPtrW\".}" },  { "module": "windows",  "name": "SetWindowLongPtrW",  "code": "proc SetWindowLongPtrW*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetWindowLongPtrW\".}" },  { "module": "windows",  "name": "GetClassLongPtrW",  "code": "proc GetClassLongPtrW*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassLongPtrW\".}" },  { "module": "windows",  "name": "SetClassLongPtrW",  "code": "proc SetClassLongPtrW*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetClassLongPtrW\".}" },  { "module": "windows",  "name": "FindWindowW",  "code": "proc FindWindowW*(lpClassName: LPCWSTR; lpWindowName: LPCWSTR): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"FindWindowW\".}" },  { "module": "windows",  "name": "FindWindowExW",  "code": "proc FindWindowExW*(para1: HWND; para2: HWND; para3: LPCWSTR; para4: LPCWSTR): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"FindWindowExW\".}" },  { "module": "windows",  "name": "GetClassNameW",  "code": "proc GetClassNameW*(wnd: HWND; lpClassName: LPWSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassNameW\".}" },  { "module": "windows",  "name": "SetWindowsHookExW",  "code": "proc SetWindowsHookExW*(idHook: int32; lpfn: HOOKPROC; hmod: HINST; \u000A                        dwThreadId: DWORD): HHOOK {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetWindowsHookExW\".}" },  { "module": "windows",  "name": "LoadBitmapW",  "code": "proc LoadBitmapW*(hInstance: HINST; lpBitmapName: LPCWSTR): HBITMAP {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadBitmapW\".}" },  { "module": "windows",  "name": "LoadCursorW",  "code": "proc LoadCursorW*(hInstance: HINST; lpCursorName: LPCWSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorW\".}" },  { "module": "windows",  "name": "LoadCursorFromFileW",  "code": "proc LoadCursorFromFileW*(lpFileName: LPCWSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorFromFileW\".}" },  { "module": "windows",  "name": "LoadIconW",  "code": "proc LoadIconW*(hInstance: HINST; lpIconName: LPCWSTR): HICON {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadIconW\".}" },  { "module": "windows",  "name": "LoadImageW",  "code": "proc LoadImageW*(para1: HINST; para2: LPCWSTR; para3: WINUINT; para4: int32; \u000A                 para5: int32; para6: WINUINT): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadImageW\".}" },  { "module": "windows",  "name": "LoadStringW",  "code": "proc LoadStringW*(hInstance: HINST; uID: WINUINT; lpBuffer: LPWSTR; \u000A                  nBufferMax: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"LoadStringW\".}" },  { "module": "windows",  "name": "IsDialogMessageW",  "code": "proc IsDialogMessageW*(hDlg: HWND; lpMsg: LPMSG): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageW\".}" },  { "module": "windows",  "name": "DlgDirListW",  "code": "proc DlgDirListW*(hDlg: HWND; lpPathSpec: LPWSTR; nIDListBox: int32; \u000A                  nIDStaticPath: int32; uFileType: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirListW\".}" },  { "module": "windows",  "name": "DlgDirSelectExW",  "code": "proc DlgDirSelectExW*(hDlg: HWND; lpString: LPWSTR; nCount: int32; \u000A                      nIDListBox: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DlgDirSelectExW\".}" },  { "module": "windows",  "name": "DlgDirListComboBoxW",  "code": "proc DlgDirListComboBoxW*(hDlg: HWND; lpPathSpec: LPWSTR; nIDComboBox: int32; \u000A                          nIDStaticPath: int32; uFiletype: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"DlgDirListComboBoxW\".}" },  { "module": "windows",  "name": "DlgDirSelectComboBoxExW",  "code": "proc DlgDirSelectComboBoxExW*(hDlg: HWND; lpString: LPWSTR; nCount: int32; \u000A                              nIDComboBox: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirSelectComboBoxExW\".}" },  { "module": "windows",  "name": "DefFrameProcW",  "code": "proc DefFrameProcW*(wnd: HWND; hWndMDIClient: HWND; uMsg: WINUINT; w: WPARAM; \u000A                    lp: LPARAM): LRESULT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DefFrameProcW\".}" },  { "module": "windows",  "name": "DefMDIChildProcW",  "code": "proc DefMDIChildProcW*(wnd: HWND; uMsg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefMDIChildProcW\".}" },  { "module": "windows",  "name": "CreateMDIWindowW",  "code": "proc CreateMDIWindowW*(lpClassName: LPWSTR; lpWindowName: LPWSTR; \u000A                       dwStyle: DWORD; X: int32; Y: int32; nWidth: int32; \u000A                       nHeight: int32; hWndParent: HWND; hInstance: HINST; \u000A                       lp: LPARAM): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateMDIWindowW\".}" },  { "module": "windows",  "name": "WinHelpW",  "code": "proc WinHelpW*(hWndMain: HWND; lpszHelp: LPCWSTR; uCommand: WINUINT; \u000A               dwData: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"WinHelpW\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsW",  "code": "proc ChangeDisplaySettingsW*(lpDevMode: LPDEVMODEW; dwFlags: DWORD): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsW\".}" },  { "module": "windows",  "name": "EnumDisplaySettingsW",  "code": "proc EnumDisplaySettingsW*(lpszDeviceName: LPCWSTR; iModeNum: DWORD; \u000A                           lpDevMode: LPDEVMODEW): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsW\".}" },  { "module": "windows",  "name": "SystemParametersInfoW",  "code": "proc SystemParametersInfoW*(uiAction: WINUINT; uiParam: WINUINT; pvParam: PVOID; \u000A                            fWinIni: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SystemParametersInfoW\".}" },  { "module": "windows",  "name": "AddFontResourceW",  "code": "proc AddFontResourceW*(para1: LPCWSTR): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"AddFontResourceW\".}" },  { "module": "windows",  "name": "CopyMetaFileW",  "code": "proc CopyMetaFileW*(para1: HMETAFILE; para2: LPCWSTR): HMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CopyMetaFileW\".}" },  { "module": "windows",  "name": "CreateFontIndirectW",  "code": "proc CreateFontIndirectW*(para1: PLOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectW\".}" },  { "module": "windows",  "name": "CreateFontIndirectW",  "code": "proc CreateFontIndirectW*(para1: var LOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectW\".}" },  { "module": "windows",  "name": "CreateFontW",  "code": "proc CreateFontW*(para1: int32; para2: int32; para3: int32; para4: int32; \u000A                  para5: int32; para6: DWORD; para7: DWORD; para8: DWORD; \u000A                  para9: DWORD; para10: DWORD; para11: DWORD; para12: DWORD; \u000A                  para13: DWORD; para14: LPCWSTR): HFONT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateFontW\".}" },  { "module": "windows",  "name": "CreateICW",  "code": "proc CreateICW*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR; \u000A                para4: LPDEVMODEw): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateICW\".}" },  { "module": "windows",  "name": "CreateMetaFileW",  "code": "proc CreateMetaFileW*(para1: LPCWSTR): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateMetaFileW\".}" },  { "module": "windows",  "name": "CreateScalableFontResourceW",  "code": "proc CreateScalableFontResourceW*(para1: DWORD; para2: LPCWSTR; para3: LPCWSTR; \u000A                                  para4: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateScalableFontResourceW\".}" },  { "module": "windows",  "name": "EnumFontFamiliesExW",  "code": "proc EnumFontFamiliesExW*(para1: HDC; para2: LPLOGFONT; para3: FONTENUMEXPROC; \u000A                          para4: LPARAM; para5: DWORD): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"EnumFontFamiliesExW\".}" },  { "module": "windows",  "name": "EnumFontFamiliesW",  "code": "proc EnumFontFamiliesW*(para1: HDC; para2: LPCWSTR; para3: FONTENUMPROC; \u000A                        para4: LPARAM): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumFontFamiliesW\".}" },  { "module": "windows",  "name": "EnumFontsW",  "code": "proc EnumFontsW*(para1: HDC; para2: LPCWSTR; para3: ENUMFONTSPROC; para4: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumFontsW\".}" },  { "module": "windows",  "name": "EnumFontsW",  "code": "proc EnumFontsW*(para1: HDC; para2: LPCWSTR; para3: ENUMFONTSPROC; \u000A                 para4: pointer): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumFontsW\".}" },  { "module": "windows",  "name": "GetCharWidthW",  "code": "proc GetCharWidthW*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthW\".}" },  { "module": "windows",  "name": "GetCharWidth32W",  "code": "proc GetCharWidth32W*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32W\".}" },  { "module": "windows",  "name": "GetCharWidthFloatW",  "code": "proc GetCharWidthFloatW*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                         para4: ptr float32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharWidthFloatW\".}" },  { "module": "windows",  "name": "GetCharABCWidthsW",  "code": "proc GetCharABCWidthsW*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPABC): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsW\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloatW",  "code": "proc GetCharABCWidthsFloatW*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                             para4: LPABCFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatW\".}" },  { "module": "windows",  "name": "GetGlyphOutlineW",  "code": "proc GetGlyphOutlineW*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                       para4: LPGLYPHMETRICS; para5: DWORD; para6: LPVOID; \u000A                       para7: PMAT2): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetGlyphOutlineW\".}" },  { "module": "windows",  "name": "GetMetaFileW",  "code": "proc GetMetaFileW*(para1: LPCWSTR): HMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetMetaFileW\".}" },  { "module": "windows",  "name": "GetOutlineTextMetricsW",  "code": "proc GetOutlineTextMetricsW*(para1: HDC; para2: WINUINT; \u000A                             para3: LPOUTLINETEXTMETRIC): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetOutlineTextMetricsW\".}" },  { "module": "windows",  "name": "GetTextExtentPointW",  "code": "proc GetTextExtentPointW*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                          para4: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentPointW\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32W",  "code": "proc GetTextExtentPoint32W*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                            para4: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentPoint32W\".}" },  { "module": "windows",  "name": "GetTextExtentExPointW",  "code": "proc GetTextExtentExPointW*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                            para4: int32; para5: LPINT; para6: LPINT; \u000A                            para7: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointW\".}" },  { "module": "windows",  "name": "GetCharacterPlacementW",  "code": "proc GetCharacterPlacementW*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                             para4: int32; para5: LPGCP_RESULTS; para6: DWORD): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharacterPlacementW\".}" },  { "module": "windows",  "name": "ResetDCW",  "code": "proc ResetDCW*(para1: HDC; para2: LPDEVMODEW): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ResetDCW\".}" },  { "module": "windows",  "name": "RemoveFontResourceW",  "code": "proc RemoveFontResourceW*(para1: LPCWSTR): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"RemoveFontResourceW\".}" },  { "module": "windows",  "name": "CopyEnhMetaFileW",  "code": "proc CopyEnhMetaFileW*(para1: HENHMETAFILE; para2: LPCWSTR): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CopyEnhMetaFileW\".}" },  { "module": "windows",  "name": "CreateEnhMetaFileW",  "code": "proc CreateEnhMetaFileW*(para1: HDC; para2: LPCWSTR; para3: LPRECT; \u000A                         para4: LPCWSTR): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateEnhMetaFileW\".}" },  { "module": "windows",  "name": "GetEnhMetaFileW",  "code": "proc GetEnhMetaFileW*(para1: LPCWSTR): HENHMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetEnhMetaFileW\".}" },  { "module": "windows",  "name": "GetEnhMetaFileDescriptionW",  "code": "proc GetEnhMetaFileDescriptionW*(para1: HENHMETAFILE; para2: WINUINT; \u000A                                 para3: LPWSTR): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetEnhMetaFileDescriptionW\".}" },  { "module": "windows",  "name": "GetTextMetricsW",  "code": "proc GetTextMetricsW*(para1: HDC; para2: LPTEXTMETRIC): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextMetricsW\".}" },  { "module": "windows",  "name": "StartDocW",  "code": "proc StartDocW*(para1: HDC; para2: PDOCINFO): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StartDocW\".}" },  { "module": "windows",  "name": "GetObjectW",  "code": "proc GetObjectW*(para1: HGDIOBJ; para2: int32; para3: LPVOID): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetObjectW\".}" },  { "module": "windows",  "name": "TextOutW",  "code": "proc TextOutW*(para1: HDC; para2: int32; para3: int32; para4: LPCWSTR; \u000A               para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                        importc: \"TextOutW\".}" },  { "module": "windows",  "name": "ExtTextOutW",  "code": "proc ExtTextOutW*(para1: HDC; para2: int32; para3: int32; para4: WINUINT; \u000A                  para5: LPRECT; para6: LPCWSTR; para7: WINUINT; para8: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ExtTextOutW\".}" },  { "module": "windows",  "name": "PolyTextOutW",  "code": "proc PolyTextOutW*(para1: HDC; para2: PPOLYTEXT; para3: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutW\".}" },  { "module": "windows",  "name": "GetTextFaceW",  "code": "proc GetTextFaceW*(para1: HDC; para2: int32; para3: LPWSTR): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextFaceW\".}" },  { "module": "windows",  "name": "GetKerningPairsW",  "code": "proc GetKerningPairsW*(para1: HDC; para2: DWORD; para3: LPKERNINGPAIR): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetKerningPairsW\".}" },  { "module": "windows",  "name": "GetLogColorSpaceW",  "code": "proc GetLogColorSpaceW*(para1: HCOLORSPACE; para2: LPLOGCOLORSPACE; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetLogColorSpaceW\".}" },  { "module": "windows",  "name": "CreateColorSpaceW",  "code": "proc CreateColorSpaceW*(para1: LPLOGCOLORSPACE): HCOLORSPACE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateColorSpaceW\".}" },  { "module": "windows",  "name": "GetICMProfileW",  "code": "proc GetICMProfileW*(para1: HDC; para2: DWORD; para3: LPWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetICMProfileW\".}" },  { "module": "windows",  "name": "SetICMProfileW",  "code": "proc SetICMProfileW*(para1: HDC; para2: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetICMProfileW\".}" },  { "module": "windows",  "name": "UpdateICMRegKeyW",  "code": "proc UpdateICMRegKeyW*(para1: DWORD; para2: DWORD; para3: LPWSTR; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"UpdateICMRegKeyW\".}" },  { "module": "windows",  "name": "EnumICMProfilesW",  "code": "proc EnumICMProfilesW*(para1: HDC; para2: ICMENUMPROC; para3: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumICMProfilesW\".}" },  { "module": "windows",  "name": "CreatePropertySheetPageW",  "code": "proc CreatePropertySheetPageW*(lppsp: LPCPROPSHEETPAGE): HPROPSHEETPAGE {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"CreatePropertySheetPageW\".}" },  { "module": "windows",  "name": "PropertySheetW",  "code": "proc PropertySheetW*(lppsph: LPCPROPSHEETHEADER): int32 {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"PropertySheetW\".}" },  { "module": "windows",  "name": "ImageList_LoadImageW",  "code": "proc ImageList_LoadImageW*(hi: HINST; lpbmp: LPCWSTR; cx: int32; cGrow: int32; \u000A                           crMask: COLORREF; uType: WINUINT; uFlags: WINUINT): HIMAGELIST {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_LoadImageW\".}" },  { "module": "windows",  "name": "CreateStatusWindowW",  "code": "proc CreateStatusWindowW*(style: LONG; lpszText: LPCWSTR; hwndParent: HWND; \u000A                          wID: WINUINT): HWND {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"CreateStatusWindowW\".}" },  { "module": "windows",  "name": "DrawStatusTextW",  "code": "proc DrawStatusTextW*(hDC: HDC; lprc: LPRECT; pszText: LPCWSTR; uFlags: WINUINT) {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"DrawStatusTextW\".}" },  { "module": "windows",  "name": "GetOpenFileNameW",  "code": "proc GetOpenFileNameW*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetOpenFileNameW\".}" },  { "module": "windows",  "name": "GetSaveFileNameW",  "code": "proc GetSaveFileNameW*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetSaveFileNameW\".}" },  { "module": "windows",  "name": "GetFileTitleW",  "code": "proc GetFileTitleW*(para1: LPCWSTR; para2: LPWSTR; para3: int16): int {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetFileTitleW\".}" },  { "module": "windows",  "name": "ChooseColorW",  "code": "proc ChooseColorW*(para1: LPCHOOSECOLOR): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseColorW\".}" },  { "module": "windows",  "name": "ReplaceTextW",  "code": "proc ReplaceTextW*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ReplaceTextW\".}" },  { "module": "windows",  "name": "ChooseFontW",  "code": "proc ChooseFontW*(para1: LPCHOOSEFONT): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseFontW\".}" },  { "module": "windows",  "name": "FindTextW",  "code": "proc FindTextW*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"FindTextW\".}" },  { "module": "windows",  "name": "PrintDlgW",  "code": "proc PrintDlgW*(para1: LPPRINTDLG): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"PrintDlgW\".}" },  { "module": "windows",  "name": "PageSetupDlgW",  "code": "proc PageSetupDlgW*(para1: LPPAGESETUPDLG): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"PageSetupDlgW\".}" },  { "module": "windows",  "name": "CreateProcessW",  "code": "proc CreateProcessW*(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; \u000A                     lpProcessAttributes: LPSECURITY_ATTRIBUTES; \u000A                     lpThreadAttributes: LPSECURITY_ATTRIBUTES; \u000A                     bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                     lpEnvironment: LPVOID; lpCurrentDirectory: LPCWSTR; \u000A                     lpStartupInfo: LPSTARTUPINFO; \u000A                     lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessW\".}" },  { "module": "windows",  "name": "GetStartupInfoW",  "code": "proc GetStartupInfoW*(lpStartupInfo: LPSTARTUPINFO) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStartupInfoW\".}" },  { "module": "windows",  "name": "FindFirstFileW",  "code": "proc FindFirstFileW*(lpFileName: LPCWSTR; lpFindFileData: LPWIN32_FIND_DATAW): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileW\".}" },  { "module": "windows",  "name": "FindNextFileW",  "code": "proc FindNextFileW*(hFindFile: HANDLE; lpFindFileData: LPWIN32_FIND_DATAW): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileW\".}" },  { "module": "windows",  "name": "GetVersionExW",  "code": "proc GetVersionExW*(VersionInformation: LPOSVERSIONINFOW): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVersionExW\".}" },  { "module": "windows",  "name": "CreateWindowW",  "code": "proc CreateWindowW*(lpClassName: LPCWSTR; lpWindowName: LPCWSTR; dwStyle: DWORD; \u000A                    X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                    hWndParent: HWND; menu: HMENU; hInstance: HINST; \u000A                    lpParam: LPVOID): HWND" },  { "module": "windows",  "name": "CreateDialogW",  "code": "proc CreateDialogW*(hInstance: HINST; lpName: LPCWSTR; hWndParent: HWND; \u000A                    lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "CreateDialogIndirectW",  "code": "proc CreateDialogIndirectW*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                            hWndParent: HWND; lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "DialogBoxW",  "code": "proc DialogBoxW*(hInstance: HINST; lpTemplate: LPCWSTR; hWndParent: HWND; \u000A                 lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "DialogBoxIndirectW",  "code": "proc DialogBoxIndirectW*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                         hWndParent: HWND; lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "CreateDCW",  "code": "proc CreateDCW*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR; para4: PDEVMODEW): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDCW\".}" },  { "module": "windows",  "name": "VerInstallFileW",  "code": "proc VerInstallFileW*(uFlags: DWORD; szSrcFileName: LPWSTR; \u000A                      szDestFileName: LPWSTR; szSrcDir: LPWSTR; \u000A                      szDestDir: LPWSTR; szCurDir: LPWSTR; szTmpFile: LPWSTR; \u000A                      lpuTmpFileLen: PUINT): DWORD {.stdcall, dynlib: \"version\", \u000A    importc: \"VerInstallFileW\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSizeW",  "code": "proc GetFileVersionInfoSizeW*(lptstrFilename: LPWSTR; lpdwHandle: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeW\".}" },  { "module": "windows",  "name": "GetFileVersionInfoW",  "code": "proc GetFileVersionInfoW*(lptstrFilename: LPWSTR; dwHandle: DWORD; dwLen: DWORD; \u000A                          lpData: LPVOID): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"GetFileVersionInfoW\".}" },  { "module": "windows",  "name": "VerLanguageNameW",  "code": "proc VerLanguageNameW*(wLang: DWORD; szLang: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VerLanguageNameW\".}" },  { "module": "windows",  "name": "VerQueryValueW",  "code": "proc VerQueryValueW*(pBlock: LPVOID; lpSubBlock: LPWSTR; lplpBuffer: LPVOID; \u000A                     puLen: PUINT): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"VerQueryValueW\".}" },  { "module": "windows",  "name": "VerFindFileW",  "code": "proc VerFindFileW*(uFlags: DWORD; szFileName: LPWSTR; szWinDir: LPWSTR; \u000A                   szAppDir: LPWSTR; szCurDir: LPWSTR; lpuCurDirLen: PUINT; \u000A                   szDestDir: LPWSTR; lpuDestDirLen: PUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileW\".}" },  { "module": "windows",  "name": "RegSetValueExW",  "code": "proc RegSetValueExW*(key: HKEY; lpValueName: LPCWSTR; Reserved: DWORD; \u000A                     dwType: DWORD; lpData: LPBYTE; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExW\".}" },  { "module": "windows",  "name": "RegUnLoadKeyW",  "code": "proc RegUnLoadKeyW*(key: HKEY; lpSubKey: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegUnLoadKeyW\".}" },  { "module": "windows",  "name": "InitiateSystemShutdownW",  "code": "proc InitiateSystemShutdownW*(lpMachineName: LPWSTR; lpMessage: LPWSTR; \u000A                              dwTimeout: DWORD; bForceAppsClosed: WINBOOL; \u000A                              bRebootAfterShutdown: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitiateSystemShutdownW\".}" },  { "module": "windows",  "name": "AbortSystemShutdownW",  "code": "proc AbortSystemShutdownW*(lpMachineName: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AbortSystemShutdownW\".}" },  { "module": "windows",  "name": "RegRestoreKeyW",  "code": "proc RegRestoreKeyW*(key: HKEY; lpFile: LPCWSTR; dwFlags: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegRestoreKeyW\".}" },  { "module": "windows",  "name": "RegSaveKeyW",  "code": "proc RegSaveKeyW*(key: HKEY; lpFile: LPCWSTR; \u000A                  lpSecurityAttributes: LPSECURITY_ATTRIBUTES): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegSaveKeyW\".}" },  { "module": "windows",  "name": "RegSetValueW",  "code": "proc RegSetValueW*(key: HKEY; lpSubKey: LPCWSTR; dwType: DWORD; lpData: LPCWSTR; \u000A                   cbData: DWORD): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegSetValueW\".}" },  { "module": "windows",  "name": "RegQueryValueW",  "code": "proc RegQueryValueW*(key: HKEY; lpSubKey: LPCWSTR; lpValue: LPWSTR; \u000A                     lpcbValue: PLONG): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueW\".}" },  { "module": "windows",  "name": "RegQueryMultipleValuesW",  "code": "proc RegQueryMultipleValuesW*(key: HKEY; val_list: PVALENT; num_vals: DWORD; \u000A                              lpValueBuf: LPWSTR; ldwTotsize: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesW\".}" },  { "module": "windows",  "name": "RegQueryValueExW",  "code": "proc RegQueryValueExW*(key: HKEY; lpValueName: LPCWSTR; lpReserved: LPDWORD; \u000A                       lpType: LPDWORD; lpData: LPBYTE; lpcbData: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryValueExW\".}" },  { "module": "windows",  "name": "RegReplaceKeyW",  "code": "proc RegReplaceKeyW*(key: HKEY; lpSubKey: LPCWSTR; lpNewFile: LPCWSTR; \u000A                     lpOldFile: LPCWSTR): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegReplaceKeyW\".}" },  { "module": "windows",  "name": "RegConnectRegistryW",  "code": "proc RegConnectRegistryW*(lpMachineName: LPWSTR; key: HKEY; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryW\".}" },  { "module": "windows",  "name": "RegCreateKeyW",  "code": "proc RegCreateKeyW*(key: HKEY; lpSubKey: LPCWSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyW\".}" },  { "module": "windows",  "name": "RegCreateKeyExW",  "code": "proc RegCreateKeyExW*(key: HKEY; lpSubKey: LPCWSTR; Reserved: DWORD; \u000A                      lpClass: LPWSTR; dwOptions: DWORD; samDesired: REGSAM; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                      phkResult: PHKEY; lpdwDisposition: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExW\".}" },  { "module": "windows",  "name": "RegDeleteKeyW",  "code": "proc RegDeleteKeyW*(key: HKEY; lpSubKey: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteKeyW\".}" },  { "module": "windows",  "name": "RegDeleteValueW",  "code": "proc RegDeleteValueW*(key: HKEY; lpValueName: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteValueW\".}" },  { "module": "windows",  "name": "RegEnumKeyW",  "code": "proc RegEnumKeyW*(key: HKEY; dwIndex: DWORD; lpName: LPWSTR; cbName: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyW\".}" },  { "module": "windows",  "name": "RegEnumKeyExW",  "code": "proc RegEnumKeyExW*(key: HKEY; dwIndex: DWORD; lpName: LPWSTR; \u000A                    lpcbName: LPDWORD; lpReserved: LPDWORD; lpClass: LPWSTR; \u000A                    lpcbClass: LPDWORD; lpftLastWriteTime: PFILETIME): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyExW\".}" },  { "module": "windows",  "name": "RegEnumValueW",  "code": "proc RegEnumValueW*(key: HKEY; dwIndex: DWORD; lpValueName: LPWSTR; \u000A                    lpcbValueName: LPDWORD; lpReserved: LPDWORD; \u000A                    lpType: LPDWORD; lpData: LPBYTE; lpcbData: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumValueW\".}" },  { "module": "windows",  "name": "RegLoadKeyW",  "code": "proc RegLoadKeyW*(key: HKEY; lpSubKey: LPCWSTR; lpFile: LPCWSTR): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegLoadKeyW\".}" },  { "module": "windows",  "name": "RegOpenKeyW",  "code": "proc RegOpenKeyW*(key: HKEY; lpSubKey: LPCWSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyW\".}" },  { "module": "windows",  "name": "RegOpenKeyExW",  "code": "proc RegOpenKeyExW*(key: HKEY; lpSubKey: LPCWSTR; ulOptions: DWORD; \u000A                    samDesired: REGSAM; phkResult: PHKEY): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExW\".}" },  { "module": "windows",  "name": "RegQueryInfoKeyW",  "code": "proc RegQueryInfoKeyW*(key: HKEY; lpClass: LPWSTR; lpcbClass: LPDWORD; \u000A                       lpReserved: LPDWORD; lpcSubKeys: LPDWORD; \u000A                       lpcbMaxSubKeyLen: LPDWORD; lpcbMaxClassLen: LPDWORD; \u000A                       lpcValues: LPDWORD; lpcbMaxValueNameLen: LPDWORD; \u000A                       lpcbMaxValueLen: LPDWORD; \u000A                       lpcbSecurityDescriptor: LPDWORD; \u000A                       lpftLastWriteTime: PFILETIME): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegQueryInfoKeyW\".}" },  { "module": "windows",  "name": "CompareStringW",  "code": "proc CompareStringW*(Locale: LCID; dwCmpFlags: DWORD; lpString1: LPCWSTR; \u000A                     cchCount1: int32; lpString2: LPCWSTR; cchCount2: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CompareStringW\".}" },  { "module": "windows",  "name": "LCMapStringW",  "code": "proc LCMapStringW*(Locale: LCID; dwMapFlags: DWORD; lpSrcStr: LPCWSTR; \u000A                   cchSrc: int32; lpDestStr: LPWSTR; cchDest: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LCMapStringW\".}" },  { "module": "windows",  "name": "GetLocaleInfoW",  "code": "proc GetLocaleInfoW*(Locale: LCID; LCType: LCTYPE; lpLCData: LPWSTR; \u000A                     cchData: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetLocaleInfoW\".}" },  { "module": "windows",  "name": "SetLocaleInfoW",  "code": "proc SetLocaleInfoW*(Locale: LCID; LCType: LCTYPE; lpLCData: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetLocaleInfoW\".}" },  { "module": "windows",  "name": "GetTimeFormatW",  "code": "proc GetTimeFormatW*(Locale: LCID; dwFlags: DWORD; lpTime: LPSYSTEMTIME; \u000A                     lpFormat: LPCWSTR; lpTimeStr: LPWSTR; cchTime: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTimeFormatW\".}" },  { "module": "windows",  "name": "GetDateFormatW",  "code": "proc GetDateFormatW*(Locale: LCID; dwFlags: DWORD; lpDate: LPSYSTEMTIME; \u000A                     lpFormat: LPCWSTR; lpDateStr: LPWSTR; cchDate: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDateFormatW\".}" },  { "module": "windows",  "name": "GetNumberFormatW",  "code": "proc GetNumberFormatW*(Locale: LCID; dwFlags: DWORD; lpValue: LPCWSTR; \u000A                       lpFormat: PNUMBERFMT; lpNumberStr: LPWSTR; \u000A                       cchNumber: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetNumberFormatW\".}" },  { "module": "windows",  "name": "GetCurrencyFormatW",  "code": "proc GetCurrencyFormatW*(Locale: LCID; dwFlags: DWORD; lpValue: LPCWSTR; \u000A                         lpFormat: PCURRENCYFMT; lpCurrencyStr: LPWSTR; \u000A                         cchCurrency: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCurrencyFormatW\".}" },  { "module": "windows",  "name": "EnumCalendarInfoW",  "code": "proc EnumCalendarInfoW*(lpCalInfoEnumProc: CALINFO_ENUMPROC; Locale: LCID; \u000A                        Calendar: CALID; CalType: CALTYPE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EnumCalendarInfoW\".}" },  { "module": "windows",  "name": "EnumTimeFormatsW",  "code": "proc EnumTimeFormatsW*(lpTimeFmtEnumProc: TIMEFMT_ENUMPROC; Locale: LCID; \u000A                       dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumTimeFormatsW\".}" },  { "module": "windows",  "name": "EnumDateFormatsW",  "code": "proc EnumDateFormatsW*(lpDateFmtEnumProc: DATEFMT_ENUMPROC; Locale: LCID; \u000A                       dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumDateFormatsW\".}" },  { "module": "windows",  "name": "GetStringTypeExW",  "code": "proc GetStringTypeExW*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCWSTR; \u000A                       cchSrc: int32; lpCharType: LPWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExW\".}" },  { "module": "windows",  "name": "GetStringTypeW",  "code": "proc GetStringTypeW*(dwInfoType: DWORD; lpSrcStr: LPCWSTR; cchSrc: int32; \u000A                     lpCharType: LPWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetStringTypeW\".}" },  { "module": "windows",  "name": "FoldStringW",  "code": "proc FoldStringW*(dwMapFlags: DWORD; lpSrcStr: LPCWSTR; cchSrc: int32; \u000A                  lpDestStr: LPWSTR; cchDest: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FoldStringW\".}" },  { "module": "windows",  "name": "EnumSystemLocalesW",  "code": "proc EnumSystemLocalesW*(lpLocaleEnumProc: LOCALE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemLocalesW\".}" },  { "module": "windows",  "name": "EnumSystemCodePagesW",  "code": "proc EnumSystemCodePagesW*(lpCodePageEnumProc: CODEPAGE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemCodePagesW\".}" },  { "module": "windows",  "name": "PeekConsoleInputW",  "code": "proc PeekConsoleInputW*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                        nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputW\".}" },  { "module": "windows",  "name": "ReadConsoleInputW",  "code": "proc ReadConsoleInputW*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                        nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputW\".}" },  { "module": "windows",  "name": "WriteConsoleInputW",  "code": "proc WriteConsoleInputW*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                         nLength: DWORD; lpNumberOfEventsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputW\".}" },  { "module": "windows",  "name": "ReadConsoleOutputW",  "code": "proc ReadConsoleOutputW*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                         dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                         lpReadRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputW\".}" },  { "module": "windows",  "name": "WriteConsoleOutputW",  "code": "proc WriteConsoleOutputW*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                          dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                          lpWriteRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputW\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacterW",  "code": "proc ReadConsoleOutputCharacterW*(hConsoleOutput: HANDLE; lpCharacter: LPWSTR; \u000A                                  nLength: DWORD; dwReadCoord: COORD; \u000A                                  lpNumberOfCharsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacterW",  "code": "proc WriteConsoleOutputCharacterW*(hConsoleOutput: HANDLE; lpCharacter: LPCWSTR; \u000A                                   nLength: DWORD; dwWriteCoord: COORD; \u000A                                   lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacterW",  "code": "proc FillConsoleOutputCharacterW*(hConsoleOutput: HANDLE; cCharacter: WCHAR; \u000A                                  nLength: DWORD; dwWriteCoord: COORD; \u000A                                  lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBufferW",  "code": "proc ScrollConsoleScreenBufferW*(hConsoleOutput: HANDLE; \u000A                                 lpScrollRectangle: PSMALL_RECT; \u000A                                 lpClipRectangle: PSMALL_RECT; \u000A                                 dwDestinationOrigin: COORD; lpFill: PCHAR_INFO): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferW\".}" },  { "module": "windows",  "name": "GetConsoleTitleW",  "code": "proc GetConsoleTitleW*(lpConsoleTitle: LPWSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetConsoleTitleW\".}" },  { "module": "windows",  "name": "SetConsoleTitleW",  "code": "proc SetConsoleTitleW*(lpConsoleTitle: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleTitleW\".}" },  { "module": "windows",  "name": "ReadConsoleW",  "code": "proc ReadConsoleW*(hConsoleInput: HANDLE; lpBuffer: LPVOID; \u000A                   nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: LPDWORD; \u000A                   lpReserved: LPVOID): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleW\".}" },  { "module": "windows",  "name": "WriteConsoleW",  "code": "proc WriteConsoleW*(hConsoleOutput: HANDLE; lpBuffer: pointer; \u000A                    nNumberOfCharsToWrite: DWORD; \u000A                    lpNumberOfCharsWritten: LPDWORD; lpReserved: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleW\".}" },  { "module": "windows",  "name": "WNetAddConnectionW",  "code": "proc WNetAddConnectionW*(lpRemoteName: LPCWSTR; lpPassword: LPCWSTR; \u000A                         lpLocalName: LPCWSTR): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetAddConnectionW\".}" },  { "module": "windows",  "name": "WNetAddConnection2W",  "code": "proc WNetAddConnection2W*(lpNetResource: LPNETRESOURCE; lpPassword: LPCWSTR; \u000A                          lpUserName: LPCWSTR; dwFlags: DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetAddConnection2W\".}" },  { "module": "windows",  "name": "WNetAddConnection3W",  "code": "proc WNetAddConnection3W*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                          lpPassword: LPCWSTR; lpUserName: LPCWSTR; \u000A                          dwFlags: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetAddConnection3W\".}" },  { "module": "windows",  "name": "WNetCancelConnectionW",  "code": "proc WNetCancelConnectionW*(lpName: LPCWSTR; fForce: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetCancelConnectionW\".}" },  { "module": "windows",  "name": "WNetCancelConnection2W",  "code": "proc WNetCancelConnection2W*(lpName: LPCWSTR; dwFlags: DWORD; fForce: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetCancelConnection2W\".}" },  { "module": "windows",  "name": "WNetGetConnectionW",  "code": "proc WNetGetConnectionW*(lpLocalName: LPCWSTR; lpRemoteName: LPWSTR; \u000A                         lpnLength: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionW\".}" },  { "module": "windows",  "name": "WNetUseConnectionW",  "code": "proc WNetUseConnectionW*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                         lpUserID: LPCWSTR; lpPassword: LPCWSTR; dwFlags: DWORD; \u000A                         lpAccessName: LPWSTR; lpBufferSize: LPDWORD; \u000A                         lpResult: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetUseConnectionW\".}" },  { "module": "windows",  "name": "WNetSetConnectionW",  "code": "proc WNetSetConnectionW*(lpName: LPCWSTR; dwProperties: DWORD; pvValues: LPVOID): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetSetConnectionW\".}" },  { "module": "windows",  "name": "WNetConnectionDialog1W",  "code": "proc WNetConnectionDialog1W*(lpConnDlgStruct: LPCONNECTDLGSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetConnectionDialog1W\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog1W",  "code": "proc WNetDisconnectDialog1W*(lpConnDlgStruct: LPDISCDLGSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetDisconnectDialog1W\".}" },  { "module": "windows",  "name": "WNetOpenEnumW",  "code": "proc WNetOpenEnumW*(dwScope: DWORD; dwType: DWORD; dwUsage: DWORD; \u000A                    lpNetResource: LPNETRESOURCE; lphEnum: LPHANDLE): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetOpenEnumW\".}" },  { "module": "windows",  "name": "WNetEnumResourceW",  "code": "proc WNetEnumResourceW*(hEnum: HANDLE; lpcCount: LPDWORD; lpBuffer: LPVOID; \u000A                        lpBufferSize: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetEnumResourceW\".}" },  { "module": "windows",  "name": "WNetGetUniversalNameW",  "code": "proc WNetGetUniversalNameW*(lpLocalPath: LPCWSTR; dwInfoLevel: DWORD; \u000A                            lpBuffer: LPVOID; lpBufferSize: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameW\".}" },  { "module": "windows",  "name": "WNetGetUserW",  "code": "proc WNetGetUserW*(lpName: LPCWSTR; lpUserName: LPWSTR; lpnLength: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserW\".}" },  { "module": "windows",  "name": "WNetGetProviderNameW",  "code": "proc WNetGetProviderNameW*(dwNetType: DWORD; lpProviderName: LPWSTR; \u000A                           lpBufferSize: LPDWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameW\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformationW",  "code": "proc WNetGetNetworkInformationW*(lpProvider: LPCWSTR; \u000A                                 lpNetInfoStruct: LPNETINFOSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationW\".}" },  { "module": "windows",  "name": "WNetGetLastErrorW",  "code": "proc WNetGetLastErrorW*(lpError: LPDWORD; lpErrorBuf: LPWSTR; \u000A                        nErrorBufSize: DWORD; lpNameBuf: LPWSTR; \u000A                        nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorW\".}" },  { "module": "windows",  "name": "MultinetGetConnectionPerformanceW",  "code": "proc MultinetGetConnectionPerformanceW*(lpNetResource: LPNETRESOURCE; \u000A    lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"MultinetGetConnectionPerformanceW\".}" },  { "module": "windows",  "name": "ChangeServiceConfigW",  "code": "proc ChangeServiceConfigW*(hService: SC_HANDLE; dwServiceType: DWORD; \u000A                           dwStartType: DWORD; dwErrorControl: DWORD; \u000A                           lpBinaryPathName: LPCWSTR; lpLoadOrderGroup: LPCWSTR; \u000A                           lpdwTagId: LPDWORD; lpDependencies: LPCWSTR; \u000A                           lpServiceStartName: LPCWSTR; lpPassword: LPCWSTR; \u000A                           lpDisplayName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ChangeServiceConfigW\".}" },  { "module": "windows",  "name": "CreateServiceW",  "code": "proc CreateServiceW*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                     lpDisplayName: LPCWSTR; dwDesiredAccess: DWORD; \u000A                     dwServiceType: DWORD; dwStartType: DWORD; \u000A                     dwErrorControl: DWORD; lpBinaryPathName: LPCWSTR; \u000A                     lpLoadOrderGroup: LPCWSTR; lpdwTagId: LPDWORD; \u000A                     lpDependencies: LPCWSTR; lpServiceStartName: LPCWSTR; \u000A                     lpPassword: LPCWSTR): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"CreateServiceW\".}" },  { "module": "windows",  "name": "EnumDependentServicesW",  "code": "proc EnumDependentServicesW*(hService: SC_HANDLE; dwServiceState: DWORD; \u000A                             lpServices: LPENUM_SERVICE_STATUS; \u000A                             cbBufSize: DWORD; pcbBytesNeeded: LPDWORD; \u000A                             lpServicesReturned: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EnumDependentServicesW\".}" },  { "module": "windows",  "name": "EnumServicesStatusW",  "code": "proc EnumServicesStatusW*(hSCManager: SC_HANDLE; dwServiceType: DWORD; \u000A                          dwServiceState: DWORD; \u000A                          lpServices: LPENUM_SERVICE_STATUS; cbBufSize: DWORD; \u000A                          pcbBytesNeeded: LPDWORD; lpServicesReturned: LPDWORD; \u000A                          lpResumeHandle: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EnumServicesStatusW\".}" },  { "module": "windows",  "name": "GetServiceKeyNameW",  "code": "proc GetServiceKeyNameW*(hSCManager: SC_HANDLE; lpDisplayName: LPCWSTR; \u000A                         lpServiceName: LPWSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceKeyNameW\".}" },  { "module": "windows",  "name": "GetServiceDisplayNameW",  "code": "proc GetServiceDisplayNameW*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                             lpDisplayName: LPWSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceDisplayNameW\".}" },  { "module": "windows",  "name": "OpenSCManagerW",  "code": "proc OpenSCManagerW*(lpMachineName: LPCWSTR; lpDatabaseName: LPCWSTR; \u000A                     dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenSCManagerW\".}" },  { "module": "windows",  "name": "OpenServiceW",  "code": "proc OpenServiceW*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                   dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenServiceW\".}" },  { "module": "windows",  "name": "QueryServiceConfigW",  "code": "proc QueryServiceConfigW*(hService: SC_HANDLE; \u000A                          lpServiceConfig: LPQUERY_SERVICE_CONFIG; \u000A                          cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceConfigW\".}" },  { "module": "windows",  "name": "QueryServiceLockStatusW",  "code": "proc QueryServiceLockStatusW*(hSCManager: SC_HANDLE; \u000A                              lpLockStatus: LPQUERY_SERVICE_LOCK_STATUS; \u000A                              cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceLockStatusW\".}" },  { "module": "windows",  "name": "RegisterServiceCtrlHandlerW",  "code": "proc RegisterServiceCtrlHandlerW*(lpServiceName: LPCWSTR; \u000A                                  lpHandlerProc: LPHANDLER_FUNCTION): SERVICE_STATUS_HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterServiceCtrlHandlerW\".}" },  { "module": "windows",  "name": "StartServiceCtrlDispatcherW",  "code": "proc StartServiceCtrlDispatcherW*(lpServiceStartTable: LPSERVICE_TABLE_ENTRY): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"StartServiceCtrlDispatcherW\".}" },  { "module": "windows",  "name": "StartServiceW",  "code": "proc StartServiceW*(hService: SC_HANDLE; dwNumServiceArgs: DWORD; \u000A                    lpServiceArgVectors: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"StartServiceW\".}" },  { "module": "windows",  "name": "DragQueryFileW",  "code": "proc DragQueryFileW*(para1: HDROP; para2: int; para3: LPCWSTR; para4: int): int {.\u000A    stdcall, dynlib: \"shell32\", importc: \"DragQueryFileW\".}" },  { "module": "windows",  "name": "ExtractAssociatedIconW",  "code": "proc ExtractAssociatedIconW*(para1: HINST; para2: LPCWSTR; para3: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ExtractAssociatedIconW\".}" },  { "module": "windows",  "name": "ExtractIconW",  "code": "proc ExtractIconW*(para1: HINST; para2: LPCWSTR; para3: int): HICON {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ExtractIconW\".}" },  { "module": "windows",  "name": "FindExecutableW",  "code": "proc FindExecutableW*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR): HINST {.\u000A    stdcall, dynlib: \"shell32\", importc: \"FindExecutableW\".}" },  { "module": "windows",  "name": "ShellAboutW",  "code": "proc ShellAboutW*(para1: HWND; para2: LPCWSTR; para3: LPCWSTR; para4: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ShellAboutW\".}" },  { "module": "windows",  "name": "ShellExecuteW",  "code": "proc ShellExecuteW*(para1: HWND; para2: LPCWSTR; para3: LPCWSTR; para4: LPCWSTR; \u000A                    para5: LPCWSTR; para6: int32): HINST {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ShellExecuteW\".}" },  { "module": "windows",  "name": "Shell_NotifyIconW",  "code": "proc Shell_NotifyIconW*(dwMessage: DWORD; lpData: PNotifyIconDataA): WINBOOL {.\u000A    stdcall, dynlib: \"shell32\", importc: \"Shell_NotifyIconW\".}" },  { "module": "windows",  "name": "DdeCreateStringHandleW",  "code": "proc DdeCreateStringHandleW*(para1: DWORD; para2: LPCWSTR; para3: int32): HSZ {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeCreateStringHandleW\".}" },  { "module": "windows",  "name": "DdeInitializeW",  "code": "proc DdeInitializeW*(para1: LPDWORD; para2: PFNCALLBACK; para3: DWORD; \u000A                     para4: DWORD): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeInitializeW\".}" },  { "module": "windows",  "name": "DdeQueryStringW",  "code": "proc DdeQueryStringW*(para1: DWORD; para2: HSZ; para3: LPCWSTR; para4: DWORD; \u000A                      para5: int32): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeQueryStringW\".}" },  { "module": "windows",  "name": "LogonUserW",  "code": "proc LogonUserW*(para1: LPWSTR; para2: LPWSTR; para3: LPWSTR; para4: DWORD; \u000A                 para5: DWORD; para6: PHANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LogonUserW\".}" },  { "module": "windows",  "name": "CreateProcessAsUserW",  "code": "proc CreateProcessAsUserW*(para1: HANDLE; para2: LPCWSTR; para3: LPWSTR; \u000A                           para4: LPSECURITY_ATTRIBUTES; \u000A                           para5: LPSECURITY_ATTRIBUTES; para6: WINBOOL; \u000A                           para7: DWORD; para8: LPVOID; para9: LPCWSTR; \u000A                           para10: LPSTARTUPINFO; para11: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"CreateProcessAsUserW\".}" },  { "module": "windows",  "name": "GetBinaryType",  "code": "proc GetBinaryType*(lpApplicationName: LPCWSTR; lpBinaryType: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeW\".}" },  { "module": "windows",  "name": "GetShortPathName",  "code": "proc GetShortPathName*(lpszLongPath: LPCWSTR; lpszShortPath: LPWSTR; \u000A                       cchBuffer: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetShortPathNameW\".}" },  { "module": "windows",  "name": "GetEnvironmentStrings",  "code": "proc GetEnvironmentStrings*(): LPWSTR {.stdcall, dynlib: \"kernel32\", \u000A                                        importc: \"GetEnvironmentStringsW\".}" },  { "module": "windows",  "name": "FreeEnvironmentStrings",  "code": "proc FreeEnvironmentStrings*(para1: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FreeEnvironmentStringsW\".}" },  { "module": "windows",  "name": "FormatMessage",  "code": "proc FormatMessage*(dwFlags: DWORD; lpSource: LPCVOID; dwMessageId: DWORD; \u000A                    dwLanguageId: DWORD; lpBuffer: LPWSTR; nSize: DWORD; \u000A                    Arguments: va_list): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FormatMessageW\".}" },  { "module": "windows",  "name": "CreateMailslot",  "code": "proc CreateMailslot*(lpName: LPCWSTR; nMaxMessageSize: DWORD; \u000A                     lReadTimeout: DWORD; \u000A                     lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateMailslotW\".}" },  { "module": "windows",  "name": "lstrcmp",  "code": "proc lstrcmp*(lpString1: LPCWSTR; lpString2: LPCWSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcmpW\".}" },  { "module": "windows",  "name": "lstrcmpi",  "code": "proc lstrcmpi*(lpString1: LPCWSTR; lpString2: LPCWSTR): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcmpiW\".}" },  { "module": "windows",  "name": "lstrcpyn",  "code": "proc lstrcpyn*(lpString1: LPWSTR; lpString2: LPCWSTR; iMaxLength: int32): LPWSTR {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"lstrcpynW\".}" },  { "module": "windows",  "name": "lstrcpy",  "code": "proc lstrcpy*(lpString1: LPWSTR; lpString2: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcpyW\".}" },  { "module": "windows",  "name": "lstrcat",  "code": "proc lstrcat*(lpString1: LPWSTR; lpString2: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"lstrcatW\".}" },  { "module": "windows",  "name": "lstrlen",  "code": "proc lstrlen*(lpString: LPCWSTR): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"lstrlenW\".}" },  { "module": "windows",  "name": "CreateMutex",  "code": "proc CreateMutex*(lpMutexAttributes: LPSECURITY_ATTRIBUTES; \u000A                  bInitialOwner: WINBOOL; lpName: LPCWSTR): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateMutexW\".}" },  { "module": "windows",  "name": "OpenMutex",  "code": "proc OpenMutex*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"OpenMutexW\".}" },  { "module": "windows",  "name": "CreateEvent",  "code": "proc CreateEvent*(lpEventAttributes: LPSECURITY_ATTRIBUTES; \u000A                  bManualReset: WINBOOL; bInitialState: WINBOOL; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateEventW\".}" },  { "module": "windows",  "name": "OpenEvent",  "code": "proc OpenEvent*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"OpenEventW\".}" },  { "module": "windows",  "name": "CreateSemaphore",  "code": "proc CreateSemaphore*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES; \u000A                      lInitialCount: LONG; lMaximumCount: LONG; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateSemaphoreW\".}" },  { "module": "windows",  "name": "OpenSemaphore",  "code": "proc OpenSemaphore*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                    lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenSemaphoreW\".}" },  { "module": "windows",  "name": "CreateFileMapping",  "code": "proc CreateFileMapping*(hFile: HANDLE; \u000A                        lpFileMappingAttributes: LPSECURITY_ATTRIBUTES; \u000A                        flProtect: DWORD; dwMaximumSizeHigh: DWORD; \u000A                        dwMaximumSizeLow: DWORD; lpName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateFileMappingW\".}" },  { "module": "windows",  "name": "OpenFileMapping",  "code": "proc OpenFileMapping*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                      lpName: LPCWSTR): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenFileMappingW\".}" },  { "module": "windows",  "name": "GetLogicalDriveStrings",  "code": "proc GetLogicalDriveStrings*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetLogicalDriveStringsW\".}" },  { "module": "windows",  "name": "LoadLibrary",  "code": "proc LoadLibrary*(lpLibFileName: LPCWSTR): HINST {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LoadLibraryW\".}" },  { "module": "windows",  "name": "LoadLibraryEx",  "code": "proc LoadLibraryEx*(lpLibFileName: LPCWSTR; hFile: HANDLE; dwFlags: DWORD): HINST {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LoadLibraryExW\".}" },  { "module": "windows",  "name": "GetModuleFileName",  "code": "proc GetModuleFileName*(hModule: HINST; lpFilename: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetModuleFileNameW\".}" },  { "module": "windows",  "name": "GetModuleHandle",  "code": "proc GetModuleHandle*(lpModuleName: LPCWSTR): HMODULE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetModuleHandleW\".}" },  { "module": "windows",  "name": "FatalAppExit",  "code": "proc FatalAppExit*(uAction: WINUINT; lpMessageText: LPCWSTR) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FatalAppExitW\".}" },  { "module": "windows",  "name": "GetCommandLine",  "code": "proc GetCommandLine*(): LPWSTR {.stdcall, dynlib: \"kernel32\", \u000A                                 importc: \"GetCommandLineW\".}" },  { "module": "windows",  "name": "GetEnvironmentVariable",  "code": "proc GetEnvironmentVariable*(lpName: LPCWSTR; lpBuffer: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetEnvironmentVariableW\".}" },  { "module": "windows",  "name": "SetEnvironmentVariable",  "code": "proc SetEnvironmentVariable*(lpName: LPCWSTR; lpValue: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetEnvironmentVariableW\".}" },  { "module": "windows",  "name": "ExpandEnvironmentStrings",  "code": "proc ExpandEnvironmentStrings*(lpSrc: LPCWSTR; lpDst: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ExpandEnvironmentStringsW\".}" },  { "module": "windows",  "name": "OutputDebugString",  "code": "proc OutputDebugString*(lpOutputString: LPCWSTR) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OutputDebugStringW\".}" },  { "module": "windows",  "name": "FindResource",  "code": "proc FindResource*(hModule: HINST; lpName: LPCWSTR; lpType: LPCWSTR): HRSRC {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindResourceW\".}" },  { "module": "windows",  "name": "FindResourceEx",  "code": "proc FindResourceEx*(hModule: HINST; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                     wLanguage: int16): HRSRC {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindResourceExW\".}" },  { "module": "windows",  "name": "EnumResourceTypes",  "code": "proc EnumResourceTypes*(hModule: HINST; lpEnumFunc: ENUMRESTYPEPROC; \u000A                        lParam: LONG): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumResourceTypesW\".}" },  { "module": "windows",  "name": "EnumResourceNames",  "code": "proc EnumResourceNames*(hModule: HINST; lpType: LPCWSTR; \u000A                        lpEnumFunc: ENUMRESNAMEPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumResourceNamesW\".}" },  { "module": "windows",  "name": "EnumResourceLanguages",  "code": "proc EnumResourceLanguages*(hModule: HINST; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                            lpEnumFunc: ENUMRESLANGPROC; lParam: LONG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumResourceLanguagesW\".}" },  { "module": "windows",  "name": "BeginUpdateResource",  "code": "proc BeginUpdateResource*(pFileName: LPCWSTR; bDeleteExistingResources: WINBOOL): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BeginUpdateResourceW\".}" },  { "module": "windows",  "name": "UpdateResource",  "code": "proc UpdateResource*(hUpdate: HANDLE; lpType: LPCWSTR; lpName: LPCWSTR; \u000A                     wLanguage: int16; lpData: LPVOID; cbData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UpdateResourceW\".}" },  { "module": "windows",  "name": "EndUpdateResource",  "code": "proc EndUpdateResource*(hUpdate: HANDLE; fDiscard: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EndUpdateResourceW\".}" },  { "module": "windows",  "name": "GlobalAddAtom",  "code": "proc GlobalAddAtom*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalAddAtomW\".}" },  { "module": "windows",  "name": "GlobalFindAtom",  "code": "proc GlobalFindAtom*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalFindAtomW\".}" },  { "module": "windows",  "name": "GlobalGetAtomName",  "code": "proc GlobalGetAtomName*(nAtom: ATOM; lpBuffer: LPWSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GlobalGetAtomNameW\".}" },  { "module": "windows",  "name": "AddAtom",  "code": "proc AddAtom*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"AddAtomW\".}" },  { "module": "windows",  "name": "FindAtom",  "code": "proc FindAtom*(lpString: LPCWSTR): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindAtomW\".}" },  { "module": "windows",  "name": "GetAtomName",  "code": "proc GetAtomName*(nAtom: ATOM; lpBuffer: LPWSTR; nSize: int32): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetAtomNameW\".}" },  { "module": "windows",  "name": "GetProfileInt",  "code": "proc GetProfileInt*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; nDefault: WINT): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProfileIntW\".}" },  { "module": "windows",  "name": "GetProfileString",  "code": "proc GetProfileString*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                       lpDefault: LPCWSTR; lpReturnedString: LPWSTR; \u000A                       nSize: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProfileStringW\".}" },  { "module": "windows",  "name": "WriteProfileString",  "code": "proc WriteProfileString*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                         lpString: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteProfileStringW\".}" },  { "module": "windows",  "name": "GetProfileSection",  "code": "proc GetProfileSection*(lpAppName: LPCWSTR; lpReturnedString: LPWSTR; \u000A                        nSize: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProfileSectionW\".}" },  { "module": "windows",  "name": "WriteProfileSection",  "code": "proc WriteProfileSection*(lpAppName: LPCWSTR; lpString: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteProfileSectionW\".}" },  { "module": "windows",  "name": "GetPrivateProfileInt",  "code": "proc GetPrivateProfileInt*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                           nDefault: WINT; lpFileName: LPCWSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileIntW\".}" },  { "module": "windows",  "name": "GetPrivateProfileString",  "code": "proc GetPrivateProfileString*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                              lpDefault: LPCWSTR; lpReturnedString: LPWSTR; \u000A                              nSize: DWORD; lpFileName: LPCWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStringW\".}" },  { "module": "windows",  "name": "WritePrivateProfileString",  "code": "proc WritePrivateProfileString*(lpAppName: LPCWSTR; lpKeyName: LPCWSTR; \u000A                                lpString: LPCWSTR; lpFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WritePrivateProfileStringW\".}" },  { "module": "windows",  "name": "GetPrivateProfileSection",  "code": "proc GetPrivateProfileSection*(lpAppName: LPCWSTR; lpReturnedString: LPWSTR; \u000A                               nSize: DWORD; lpFileName: LPCWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionW\".}" },  { "module": "windows",  "name": "WritePrivateProfileSection",  "code": "proc WritePrivateProfileSection*(lpAppName: LPCWSTR; lpString: LPCWSTR; \u000A                                 lpFileName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WritePrivateProfileSectionW\".}" },  { "module": "windows",  "name": "GetDriveType",  "code": "proc GetDriveType*(lpRootPathName: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDriveTypeW\".}" },  { "module": "windows",  "name": "GetSystemDirectory",  "code": "proc GetSystemDirectory*(lpBuffer: LPWSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetSystemDirectoryW\".}" },  { "module": "windows",  "name": "GetTempPath",  "code": "proc GetTempPath*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTempPathW\".}" },  { "module": "windows",  "name": "GetTempFileName",  "code": "proc GetTempFileName*(lpPathName: LPCWSTR; lpPrefixString: LPCWSTR; \u000A                      uUnique: WINUINT; lpTempFileName: LPWSTR): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTempFileNameW\".}" },  { "module": "windows",  "name": "GetWindowsDirectory",  "code": "proc GetWindowsDirectory*(lpBuffer: LPWSTR; uSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetWindowsDirectoryW\".}" },  { "module": "windows",  "name": "SetCurrentDirectory",  "code": "proc SetCurrentDirectory*(lpPathName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCurrentDirectoryW\".}" },  { "module": "windows",  "name": "GetCurrentDirectory",  "code": "proc GetCurrentDirectory*(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCurrentDirectoryW\".}" },  { "module": "windows",  "name": "GetDiskFreeSpace",  "code": "proc GetDiskFreeSpace*(lpRootPathName: LPCWSTR; lpSectorsPerCluster: LPDWORD; \u000A                       lpBytesPerSector: LPDWORD; \u000A                       lpNumberOfFreeClusters: LPDWORD; \u000A                       lpTotalNumberOfClusters: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceW\".}" },  { "module": "windows",  "name": "CreateDirectory",  "code": "proc CreateDirectory*(lpPathName: LPCWSTR; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryW\".}" },  { "module": "windows",  "name": "CreateDirectoryEx",  "code": "proc CreateDirectoryEx*(lpTemplateDirectory: LPCWSTR; lpNewDirectory: LPCWSTR; \u000A                        lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateDirectoryExW\".}" },  { "module": "windows",  "name": "RemoveDirectory",  "code": "proc RemoveDirectory*(lpPathName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"RemoveDirectoryW\".}" },  { "module": "windows",  "name": "GetFullPathName",  "code": "proc GetFullPathName*(lpFileName: LPCWSTR; nBufferLength: DWORD; \u000A                      lpBuffer: LPWSTR; lpFilePart: var LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFullPathNameW\".}" },  { "module": "windows",  "name": "DefineDosDevice",  "code": "proc DefineDosDevice*(dwFlags: DWORD; lpDeviceName: LPCWSTR; \u000A                      lpTargetPath: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DefineDosDeviceW\".}" },  { "module": "windows",  "name": "QueryDosDevice",  "code": "proc QueryDosDevice*(lpDeviceName: LPCWSTR; lpTargetPath: LPWSTR; ucchMax: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"QueryDosDeviceW\".}" },  { "module": "windows",  "name": "CreateFile",  "code": "proc CreateFile*(lpFileName: LPCWSTR; dwDesiredAccess: DWORD; \u000A                 dwShareMode: DWORD; \u000A                 lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                 dwCreationDisposition: DWORD; dwFlagsAndAttributes: DWORD; \u000A                 hTemplateFile: HANDLE): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CreateFileW\".}" },  { "module": "windows",  "name": "SetFileAttributes",  "code": "proc SetFileAttributes*(lpFileName: LPCWSTR; dwFileAttributes: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileAttributesW\".}" },  { "module": "windows",  "name": "GetFileAttributes",  "code": "proc GetFileAttributes*(lpFileName: LPCWSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileAttributesW\".}" },  { "module": "windows",  "name": "GetCompressedFileSize",  "code": "proc GetCompressedFileSize*(lpFileName: LPCWSTR; lpFileSizeHigh: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCompressedFileSizeW\".}" },  { "module": "windows",  "name": "DeleteFile",  "code": "proc DeleteFile*(lpFileName: LPCWSTR): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"DeleteFileW\".}" },  { "module": "windows",  "name": "SearchPath",  "code": "proc SearchPath*(lpPath: LPCWSTR; lpFileName: LPCWSTR; lpExtension: LPCWSTR; \u000A                 nBufferLength: DWORD; lpBuffer: LPWSTR; lpFilePart: LPWSTR): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SearchPathW\".}" },  { "module": "windows",  "name": "CopyFile",  "code": "proc CopyFile*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR; \u000A               bFailIfExists: WINBOOL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CopyFileW\".}" },  { "module": "windows",  "name": "MoveFile",  "code": "proc MoveFile*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MoveFileW\".}" },  { "module": "windows",  "name": "MoveFileEx",  "code": "proc MoveFileEx*(lpExistingFileName: LPCWSTR; lpNewFileName: LPCWSTR; \u000A                 dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"MoveFileExW\".}" },  { "module": "windows",  "name": "CreateNamedPipe",  "code": "proc CreateNamedPipe*(lpName: LPCWSTR; dwOpenMode: DWORD; dwPipeMode: DWORD; \u000A                      nMaxInstances: DWORD; nOutBufferSize: DWORD; \u000A                      nInBufferSize: DWORD; nDefaultTimeOut: DWORD; \u000A                      lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateNamedPipeW\".}" },  { "module": "windows",  "name": "GetNamedPipeHandleState",  "code": "proc GetNamedPipeHandleState*(hNamedPipe: HANDLE; lpState: LPDWORD; \u000A                              lpCurInstances: LPDWORD; \u000A                              lpMaxCollectionCount: LPDWORD; \u000A                              lpCollectDataTimeout: LPDWORD; lpUserName: LPWSTR; \u000A                              nMaxUserNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetNamedPipeHandleStateW\".}" },  { "module": "windows",  "name": "CallNamedPipe",  "code": "proc CallNamedPipe*(lpNamedPipeName: LPCWSTR; lpInBuffer: LPVOID; \u000A                    nInBufferSize: DWORD; lpOutBuffer: LPVOID; \u000A                    nOutBufferSize: DWORD; lpBytesRead: LPDWORD; nTimeOut: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CallNamedPipeW\".}" },  { "module": "windows",  "name": "WaitNamedPipe",  "code": "proc WaitNamedPipe*(lpNamedPipeName: LPCWSTR; nTimeOut: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitNamedPipeW\".}" },  { "module": "windows",  "name": "SetVolumeLabel",  "code": "proc SetVolumeLabel*(lpRootPathName: LPCWSTR; lpVolumeName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetVolumeLabelW\".}" },  { "module": "windows",  "name": "GetVolumeInformation",  "code": "proc GetVolumeInformation*(lpRootPathName: LPCWSTR; lpVolumeNameBuffer: LPWSTR; \u000A                           nVolumeNameSize: DWORD; \u000A                           lpVolumeSerialNumber: LPDWORD; \u000A                           lpMaximumComponentLength: LPDWORD; \u000A                           lpFileSystemFlags: LPDWORD; \u000A                           lpFileSystemNameBuffer: LPWSTR; \u000A                           nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationW\".}" },  { "module": "windows",  "name": "ClearEventLog",  "code": "proc ClearEventLog*(hEventLog: HANDLE; lpBackupFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ClearEventLogW\".}" },  { "module": "windows",  "name": "BackupEventLog",  "code": "proc BackupEventLog*(hEventLog: HANDLE; lpBackupFileName: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"BackupEventLogW\".}" },  { "module": "windows",  "name": "OpenEventLog",  "code": "proc OpenEventLog*(lpUNCServerName: LPCWSTR; lpSourceName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenEventLogW\".}" },  { "module": "windows",  "name": "RegisterEventSource",  "code": "proc RegisterEventSource*(lpUNCServerName: LPCWSTR; lpSourceName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterEventSourceW\".}" },  { "module": "windows",  "name": "OpenBackupEventLog",  "code": "proc OpenBackupEventLog*(lpUNCServerName: LPCWSTR; lpFileName: LPCWSTR): HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenBackupEventLogW\".}" },  { "module": "windows",  "name": "ReadEventLog",  "code": "proc ReadEventLog*(hEventLog: HANDLE; dwReadFlags: DWORD; dwRecordOffset: DWORD; \u000A                   lpBuffer: LPVOID; nNumberOfBytesToRead: DWORD; \u000A                   pnBytesRead: LPDWORD; pnMinNumberOfBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReadEventLogW\".}" },  { "module": "windows",  "name": "ReportEvent",  "code": "proc ReportEvent*(hEventLog: HANDLE; wType: int16; wCategory: int16; \u000A                  dwEventID: DWORD; lpUserSid: PSID; wNumStrings: int16; \u000A                  dwDataSize: DWORD; lpStrings: LPPCWSTR; lpRawData: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReportEventW\".}" },  { "module": "windows",  "name": "AccessCheckAndAuditAlarm",  "code": "proc AccessCheckAndAuditAlarm*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                               ObjectTypeName: LPWSTR; ObjectName: LPWSTR; \u000A                               SecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                               DesiredAccess: DWORD; \u000A                               GenericMapping: PGENERIC_MAPPING; \u000A                               ObjectCreation: WINBOOL; GrantedAccess: LPDWORD; \u000A                               AccessStatus: LPBOOL; pfGenerateOnClose: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AccessCheckAndAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarm",  "code": "proc ObjectOpenAuditAlarm*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                           ObjectTypeName: LPWSTR; ObjectName: LPWSTR; \u000A                           pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                           ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                           GrantedAccess: DWORD; Privileges: PPRIVILEGE_SET; \u000A                           ObjectCreation: WINBOOL; AccessGranted: WINBOOL; \u000A                           GenerateOnClose: LPBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarm",  "code": "proc ObjectPrivilegeAuditAlarm*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                                ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                                Privileges: PPRIVILEGE_SET; \u000A                                AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectCloseAuditAlarm",  "code": "proc ObjectCloseAuditAlarm*(SubsystemName: LPCWSTR; HandleId: LPVOID; \u000A                            GenerateOnClose: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectCloseAuditAlarmW\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarm",  "code": "proc PrivilegedServiceAuditAlarm*(SubsystemName: LPCWSTR; ServiceName: LPCWSTR; \u000A                                  ClientToken: HANDLE; \u000A                                  Privileges: PPRIVILEGE_SET; \u000A                                  AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmW\".}" },  { "module": "windows",  "name": "SetFileSecurity",  "code": "proc SetFileSecurity*(lpFileName: LPCWSTR; \u000A                      SecurityInformation: SECURITY_INFORMATION; \u000A                      pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetFileSecurityW\".}" },  { "module": "windows",  "name": "GetFileSecurity",  "code": "proc GetFileSecurity*(lpFileName: LPCWSTR; \u000A                      RequestedInformation: SECURITY_INFORMATION; \u000A                      pSecurityDescriptor: PSECURITY_DESCRIPTOR; nLength: DWORD; \u000A                      lpnLengthNeeded: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetFileSecurityW\".}" },  { "module": "windows",  "name": "FindFirstChangeNotification",  "code": "proc FindFirstChangeNotification*(lpPathName: LPCWSTR; bWatchSubtree: WINBOOL; \u000A                                  dwNotifyFilter: DWORD): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindFirstChangeNotificationW\".}" },  { "module": "windows",  "name": "IsBadStringPtr",  "code": "proc IsBadStringPtr*(lpsz: LPCWSTR; ucchMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadStringPtrW\".}" },  { "module": "windows",  "name": "LookupAccountSid",  "code": "proc LookupAccountSid*(lpSystemName: LPCWSTR; Sid: PSID; Name: LPWSTR; \u000A                       cbName: LPDWORD; ReferencedDomainName: LPWSTR; \u000A                       cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountSidW\".}" },  { "module": "windows",  "name": "LookupAccountName",  "code": "proc LookupAccountName*(lpSystemName: LPCWSTR; lpAccountName: LPCWSTR; \u000A                        Sid: PSID; cbSid: LPDWORD; ReferencedDomainName: LPWSTR; \u000A                        cbReferencedDomainName: LPDWORD; peUse: PSID_NAME_USE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupAccountNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeValue",  "code": "proc LookupPrivilegeValue*(lpSystemName: LPCWSTR; lpName: LPCWSTR; lpLuid: PLUID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeValueW\".}" },  { "module": "windows",  "name": "LookupPrivilegeName",  "code": "proc LookupPrivilegeName*(lpSystemName: LPCWSTR; lpLuid: PLUID; lpName: LPWSTR; \u000A                          cbName: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayName",  "code": "proc LookupPrivilegeDisplayName*(lpSystemName: LPCWSTR; lpName: LPCWSTR; \u000A                                 lpDisplayName: LPWSTR; cbDisplayName: LPDWORD; \u000A                                 lpLanguageId: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameW\".}" },  { "module": "windows",  "name": "BuildCommDCB",  "code": "proc BuildCommDCB*(lpDef: LPCWSTR; lpDCB: LPDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBW\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeouts",  "code": "proc BuildCommDCBAndTimeouts*(lpDef: LPCWSTR; lpDCB: LPDCB; \u000A                              lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsW\".}" },  { "module": "windows",  "name": "CommConfigDialog",  "code": "proc CommConfigDialog*(lpszName: LPCWSTR; wnd: HWND; lpCC: LPCOMMCONFIG): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogW\".}" },  { "module": "windows",  "name": "GetDefaultCommConfig",  "code": "proc GetDefaultCommConfig*(lpszName: LPCWSTR; lpCC: LPCOMMCONFIG; \u000A                           lpdwSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigW\".}" },  { "module": "windows",  "name": "SetDefaultCommConfig",  "code": "proc SetDefaultCommConfig*(lpszName: LPCWSTR; lpCC: LPCOMMCONFIG; dwSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetDefaultCommConfigW\".}" },  { "module": "windows",  "name": "GetComputerName",  "code": "proc GetComputerName*(lpBuffer: LPWSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameW\".}" },  { "module": "windows",  "name": "SetComputerName",  "code": "proc SetComputerName*(lpComputerName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetComputerNameW\".}" },  { "module": "windows",  "name": "GetUserName",  "code": "proc GetUserName*(lpBuffer: LPWSTR; nSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameW\".}" },  { "module": "windows",  "name": "LoadKeyboardLayout",  "code": "proc LoadKeyboardLayout*(pwszKLID: LPCWSTR; Flags: WINUINT): HKL {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadKeyboardLayoutW\".}" },  { "module": "windows",  "name": "GetKeyboardLayoutName",  "code": "proc GetKeyboardLayoutName*(pwszKLID: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetKeyboardLayoutNameW\".}" },  { "module": "windows",  "name": "CreateDesktop",  "code": "proc CreateDesktop*(lpszDesktop: LPWSTR; lpszDevice: LPWSTR; \u000A                    pDevmode: LPDEVMODE; dwFlags: DWORD; dwDesiredAccess: DWORD; \u000A                    lpsa: LPSECURITY_ATTRIBUTES): HDESK {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDesktopW\".}" },  { "module": "windows",  "name": "OpenDesktop",  "code": "proc OpenDesktop*(lpszDesktop: LPWSTR; dwFlags: DWORD; fInherit: WINBOOL; \u000A                  dwDesiredAccess: DWORD): HDESK {.stdcall, dynlib: \"user32\", \u000A    importc: \"OpenDesktopW\".}" },  { "module": "windows",  "name": "EnumDesktops",  "code": "proc EnumDesktops*(hwinsta: HWINSTA; lpEnumFunc: DESKTOPENUMPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumDesktopsW\".}" },  { "module": "windows",  "name": "CreateWindowStation",  "code": "proc CreateWindowStation*(lpwinsta: LPWSTR; dwReserved: DWORD; \u000A                          dwDesiredAccess: DWORD; lpsa: LPSECURITY_ATTRIBUTES): HWINSTA {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowStationW\".}" },  { "module": "windows",  "name": "OpenWindowStation",  "code": "proc OpenWindowStation*(lpszWinSta: LPWSTR; fInherit: WINBOOL; \u000A                        dwDesiredAccess: DWORD): HWINSTA {.stdcall, \u000A    dynlib: \"user32\", importc: \"OpenWindowStationW\".}" },  { "module": "windows",  "name": "EnumWindowStations",  "code": "proc EnumWindowStations*(lpEnumFunc: ENUMWINDOWSTATIONPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumWindowStationsW\".}" },  { "module": "windows",  "name": "GetUserObjectInformation",  "code": "proc GetUserObjectInformation*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                               nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationW\".}" },  { "module": "windows",  "name": "SetUserObjectInformation",  "code": "proc SetUserObjectInformation*(hObj: HANDLE; nIndex: int32; pvInfo: PVOID; \u000A                               nLength: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetUserObjectInformationW\".}" },  { "module": "windows",  "name": "RegisterWindowMessage",  "code": "proc RegisterWindowMessage*(lpString: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterWindowMessageW\".}" },  { "module": "windows",  "name": "GetMessage",  "code": "proc GetMessage*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                 wMsgFilterMax: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMessageW\".}" },  { "module": "windows",  "name": "DispatchMessage",  "code": "proc DispatchMessage*(lpMsg: LPMSG): LONG {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageW\".}" },  { "module": "windows",  "name": "PeekMessage",  "code": "proc PeekMessage*(lpMsg: LPMSG; wnd: HWND; wMsgFilterMin: WINUINT; \u000A                  wMsgFilterMax: WINUINT; wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageW\".}" },  { "module": "windows",  "name": "SendMessage",  "code": "proc SendMessage*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageW\".}" },  { "module": "windows",  "name": "SendMessageTimeout",  "code": "proc SendMessageTimeout*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                         fuFlags: WINUINT; uTimeout: WINUINT; \u000A                         lpdwResult: LPDWORD): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendMessageTimeoutW\".}" },  { "module": "windows",  "name": "SendNotifyMessage",  "code": "proc SendNotifyMessage*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendNotifyMessageW\".}" },  { "module": "windows",  "name": "SendMessageCallback",  "code": "proc SendMessageCallback*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                          lpResultCallBack: SENDASYNCPROC; dwData: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageCallbackW\".}" },  { "module": "windows",  "name": "PostMessage",  "code": "proc PostMessage*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostMessageW\".}" },  { "module": "windows",  "name": "PostThreadMessage",  "code": "proc PostThreadMessage*(idThread: DWORD; Msg: WINUINT; wp: WPARAM; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PostThreadMessageW\".}" },  { "module": "windows",  "name": "DefWindowProc",  "code": "proc DefWindowProc*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefWindowProcW\".}" },  { "module": "windows",  "name": "CallWindowProc",  "code": "proc CallWindowProc*(lpPrevWndFunc: WNDPROC; wnd: HWND; Msg: WINUINT; \u000A                     wp: WPARAM; lp: LPARAM): LRESULT {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallWindowProcW\".}" },  { "module": "windows",  "name": "RegisterClass",  "code": "proc RegisterClass*(lpWndClass: LPWNDCLASS): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassW\".}" },  { "module": "windows",  "name": "UnregisterClass",  "code": "proc UnregisterClass*(lpClassName: LPCWSTR; hInstance: HINST): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnregisterClassW\".}" },  { "module": "windows",  "name": "GetClassInfo",  "code": "proc GetClassInfo*(hInstance: HINST; lpClassName: LPCWSTR; \u000A                   lpWndClass: LPWNDCLASS): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClassInfoW\".}" },  { "module": "windows",  "name": "RegisterClassEx",  "code": "proc RegisterClassEx*(para1: LPWNDCLASSEXW): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassExW\".}" },  { "module": "windows",  "name": "GetClassInfoEx",  "code": "proc GetClassInfoEx*(para1: HINST; para2: LPCWSTR; para3: LPWNDCLASSEX): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassInfoExW\".}" },  { "module": "windows",  "name": "CreateWindowEx",  "code": "proc CreateWindowEx*(dwExStyle: DWORD; lpClassName: LPCWSTR; \u000A                     lpWindowName: LPCWSTR; dwStyle: DWORD; X: int32; Y: int32; \u000A                     nWidth: int32; nHeight: int32; hWndParent: HWND; \u000A                     menu: HMENU; hInstance: HINST; lpParam: LPVOID): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateWindowExW\".}" },  { "module": "windows",  "name": "CreateDialogParam",  "code": "proc CreateDialogParam*(hInstance: HINST; lpTemplateName: LPCWSTR; \u000A                        hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                        dwInitParam: LPARAM): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateDialogParamW\".}" },  { "module": "windows",  "name": "CreateDialogIndirectParam",  "code": "proc CreateDialogIndirectParam*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                                hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                                dwInitParam: LPARAM): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDialogIndirectParamW\".}" },  { "module": "windows",  "name": "DialogBoxParam",  "code": "proc DialogBoxParam*(hInstance: HINST; lpTemplateName: LPCWSTR; \u000A                     hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                     dwInitParam: LPARAM): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DialogBoxParamW\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParam",  "code": "proc DialogBoxIndirectParam*(hInstance: HINST; hDialogTemplate: LPCDLGTEMPLATE; \u000A                             hWndParent: HWND; lpDialogFunc: DLGPROC; \u000A                             dwInitParam: LPARAM): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamW\".}" },  { "module": "windows",  "name": "SetDlgItemText",  "code": "proc SetDlgItemText*(hDlg: HWND; nIDDlgItem: int32; lpString: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetDlgItemTextW\".}" },  { "module": "windows",  "name": "GetDlgItemText",  "code": "proc GetDlgItemText*(hDlg: HWND; nIDDlgItem: int32; lpString: LPWSTR; \u000A                     nMaxCount: int32): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetDlgItemTextW\".}" },  { "module": "windows",  "name": "SendDlgItemMessage",  "code": "proc SendDlgItemMessage*(hDlg: HWND; nIDDlgItem: int32; Msg: WINUINT; \u000A                         wp: WPARAM; lp: LPARAM): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SendDlgItemMessageW\".}" },  { "module": "windows",  "name": "DefDlgProc",  "code": "proc DefDlgProc*(hDlg: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefDlgProcW\".}" },  { "module": "windows",  "name": "CallMsgFilter",  "code": "proc CallMsgFilter*(lpMsg: LPMSG; nCode: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterW\".}" },  { "module": "windows",  "name": "RegisterClipboardFormat",  "code": "proc RegisterClipboardFormat*(lpszFormat: LPCWSTR): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterClipboardFormatW\".}" },  { "module": "windows",  "name": "GetClipboardFormatName",  "code": "proc GetClipboardFormatName*(format: WINUINT; lpszFormatName: LPWSTR; \u000A                             cchMaxCount: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClipboardFormatNameW\".}" },  { "module": "windows",  "name": "CharToOem",  "code": "proc CharToOem*(lpszSrc: LPCWSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharToOemW\".}" },  { "module": "windows",  "name": "OemToChar",  "code": "proc OemToChar*(lpszSrc: LPCSTR; lpszDst: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OemToCharW\".}" },  { "module": "windows",  "name": "CharToOemBuff",  "code": "proc CharToOemBuff*(lpszSrc: LPCWSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CharToOemBuffW\".}" },  { "module": "windows",  "name": "OemToCharBuff",  "code": "proc OemToCharBuff*(lpszSrc: LPCSTR; lpszDst: LPWSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"OemToCharBuffW\".}" },  { "module": "windows",  "name": "CharUpper",  "code": "proc CharUpper*(lpsz: LPWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"CharUpperW\".}" },  { "module": "windows",  "name": "CharUpperBuff",  "code": "proc CharUpperBuff*(lpsz: LPWSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharUpperBuffW\".}" },  { "module": "windows",  "name": "CharLower",  "code": "proc CharLower*(lpsz: LPWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"CharLowerW\".}" },  { "module": "windows",  "name": "CharLowerBuff",  "code": "proc CharLowerBuff*(lpsz: LPWSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharLowerBuffW\".}" },  { "module": "windows",  "name": "CharNext",  "code": "proc CharNext*(lpsz: LPCWSTR): LPWSTR {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"CharNextW\".}" },  { "module": "windows",  "name": "CharPrev",  "code": "proc CharPrev*(lpszStart: LPCWSTR; lpszCurrent: LPCWSTR): LPWSTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharPrevW\".}" },  { "module": "windows",  "name": "IsCharAlpha",  "code": "proc IsCharAlpha*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharAlphaW\".}" },  { "module": "windows",  "name": "IsCharAlphaNumeric",  "code": "proc IsCharAlphaNumeric*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsCharAlphaNumericW\".}" },  { "module": "windows",  "name": "IsCharUpper",  "code": "proc IsCharUpper*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharUpperW\".}" },  { "module": "windows",  "name": "IsCharLower",  "code": "proc IsCharLower*(ch: WCHAR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"IsCharLowerW\".}" },  { "module": "windows",  "name": "GetKeyNameText",  "code": "proc GetKeyNameText*(lParam: LONG; lpString: LPWSTR; nSize: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetKeyNameTextW\".}" },  { "module": "windows",  "name": "VkKeyScan",  "code": "proc VkKeyScan*(ch: WCHAR): SHORT {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"VkKeyScanW\".}" },  { "module": "windows",  "name": "VkKeyScanEx",  "code": "proc VkKeyScanEx*(ch: WCHAR; dwhkl: HKL): SHORT {.stdcall, dynlib: \"user32\", \u000A    importc: \"VkKeyScanExW\".}" },  { "module": "windows",  "name": "MapVirtualKey",  "code": "proc MapVirtualKey*(uCode: WINUINT; uMapType: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"MapVirtualKeyW\".}" },  { "module": "windows",  "name": "MapVirtualKeyEx",  "code": "proc MapVirtualKeyEx*(uCode: WINUINT; uMapType: WINUINT; dwhkl: HKL): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"MapVirtualKeyExW\".}" },  { "module": "windows",  "name": "LoadAccelerators",  "code": "proc LoadAccelerators*(hInstance: HINST; lpTableName: LPCWSTR): HACCEL {.\u000A    stdcall, dynlib: \"user32\", importc: \"LoadAcceleratorsW\".}" },  { "module": "windows",  "name": "CreateAcceleratorTable",  "code": "proc CreateAcceleratorTable*(para1: LPACCEL; para2: int32): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableW\".}" },  { "module": "windows",  "name": "CopyAcceleratorTable",  "code": "proc CopyAcceleratorTable*(hAccelSrc: HACCEL; lpAccelDst: LPACCEL; \u000A                           cAccelEntries: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyAcceleratorTableW\".}" },  { "module": "windows",  "name": "TranslateAccelerator",  "code": "proc TranslateAccelerator*(wnd: HWND; hAccTable: HACCEL; lpMsg: LPMSG): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorW\".}" },  { "module": "windows",  "name": "LoadMenu",  "code": "proc LoadMenu*(hInstance: HINST; lpMenuName: LPCWSTR): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuW\".}" },  { "module": "windows",  "name": "LoadMenuIndirect",  "code": "proc LoadMenuIndirect*(lpMenuTemplate: LPMENUTEMPLATE): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadMenuIndirectW\".}" },  { "module": "windows",  "name": "ChangeMenu",  "code": "proc ChangeMenu*(menu: HMENU; cmd: WINUINT; lpszNewItem: LPCWSTR; \u000A                 cmdInsert: WINUINT; flags: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ChangeMenuW\".}" },  { "module": "windows",  "name": "GetMenuString",  "code": "proc GetMenuString*(menu: HMENU; uIDItem: WINUINT; lpString: LPWSTR; \u000A                    nMaxCount: int32; uFlag: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuStringW\".}" },  { "module": "windows",  "name": "InsertMenu",  "code": "proc InsertMenu*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                 uIDNewItem: WINUINT; lpNewItem: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuW\".}" },  { "module": "windows",  "name": "AppendMenu",  "code": "proc AppendMenu*(menu: HMENU; uFlags: WINUINT; uIDNewItem: WINUINT; \u000A                 lpNewItem: LPCWSTR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"AppendMenuW\".}" },  { "module": "windows",  "name": "ModifyMenu",  "code": "proc ModifyMenu*(hMnu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                 uIDNewItem: WINUINT; lpNewItem: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ModifyMenuW\".}" },  { "module": "windows",  "name": "InsertMenuItem",  "code": "proc InsertMenuItem*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                     para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InsertMenuItemW\".}" },  { "module": "windows",  "name": "GetMenuItemInfo",  "code": "proc GetMenuItemInfo*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                      para4: LPMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuItemInfoW\".}" },  { "module": "windows",  "name": "SetMenuItemInfo",  "code": "proc SetMenuItemInfo*(para1: HMENU; para2: WINUINT; para3: WINBOOL; \u000A                      para4: LPCMENUITEMINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetMenuItemInfoW\".}" },  { "module": "windows",  "name": "DrawText",  "code": "proc DrawText*(hDC: HDC; lpString: LPCWSTR; nCount: int32; lpRect: LPRECT; \u000A               uFormat: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawTextW\".}" },  { "module": "windows",  "name": "DrawTextEx",  "code": "proc DrawTextEx*(para1: HDC; para2: LPWSTR; para3: int32; para4: LPRECT; \u000A                 para5: WINUINT; para6: LPDRAWTEXTPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawTextExW\".}" },  { "module": "windows",  "name": "GrayString",  "code": "proc GrayString*(hDC: HDC; hBrush: HBRUSH; lpOutputFunc: GRAYSTRINGPROC; \u000A                 lpData: LPARAM; nCount: int32; X: int32; Y: int32; \u000A                 nWidth: int32; nHeight: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GrayStringW\".}" },  { "module": "windows",  "name": "DrawState",  "code": "proc DrawState*(para1: HDC; para2: HBRUSH; para3: DRAWSTATEPROC; para4: LPARAM; \u000A                para5: WPARAM; para6: int32; para7: int32; para8: int32; \u000A                para9: int32; para10: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawStateW\".}" },  { "module": "windows",  "name": "TabbedTextOut",  "code": "proc TabbedTextOut*(hDC: HDC; X: int32; Y: int32; lpString: LPCWSTR; \u000A                    nCount: int32; nTabPositions: int32; \u000A                    lpnTabStopPositions: LPINT; nTabOrigin: int32): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"TabbedTextOutW\".}" },  { "module": "windows",  "name": "GetTabbedTextExtent",  "code": "proc GetTabbedTextExtent*(hDC: HDC; lpString: LPCWSTR; nCount: int32; \u000A                          nTabPositions: int32; lpnTabStopPositions: LPINT): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetTabbedTextExtentW\".}" },  { "module": "windows",  "name": "SetProp",  "code": "proc SetProp*(wnd: HWND; lpString: LPCWSTR; hData: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetPropW\".}" },  { "module": "windows",  "name": "GetProp",  "code": "proc GetProp*(wnd: HWND; lpString: LPCWSTR): HANDLE {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetPropW\".}" },  { "module": "windows",  "name": "RemoveProp",  "code": "proc RemoveProp*(wnd: HWND; lpString: LPCWSTR): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"RemovePropW\".}" },  { "module": "windows",  "name": "EnumPropsEx",  "code": "proc EnumPropsEx*(wnd: HWND; lpEnumFunc: PROPENUMPROCEX; lp: LPARAM): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumPropsExW\".}" },  { "module": "windows",  "name": "EnumProps",  "code": "proc EnumProps*(wnd: HWND; lpEnumFunc: PROPENUMPROC): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumPropsW\".}" },  { "module": "windows",  "name": "SetWindowText",  "code": "proc SetWindowText*(wnd: HWND; lpString: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowTextW\".}" },  { "module": "windows",  "name": "GetWindowText",  "code": "proc GetWindowText*(wnd: HWND; lpString: LPWSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowTextW\".}" },  { "module": "windows",  "name": "GetWindowTextLength",  "code": "proc GetWindowTextLength*(wnd: HWND): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowTextLengthW\".}" },  { "module": "windows",  "name": "MessageBox",  "code": "proc MessageBox*(wnd: HWND; lpText: LPCWSTR; lpCaption: LPCWSTR; uType: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"MessageBoxW\".}" },  { "module": "windows",  "name": "MessageBoxEx",  "code": "proc MessageBoxEx*(wnd: HWND; lpText: LPCWSTR; lpCaption: LPCWSTR; \u000A                   uType: WINUINT; wLanguageId: int16): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxExW\".}" },  { "module": "windows",  "name": "MessageBoxIndirect",  "code": "proc MessageBoxIndirect*(para1: LPMSGBOXPARAMS): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxIndirectW\".}" },  { "module": "windows",  "name": "GetWindowLong",  "code": "proc GetWindowLong*(wnd: HWND; nIndex: int32): LONG {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowLongW\".}" },  { "module": "windows",  "name": "SetWindowLong",  "code": "proc SetWindowLong*(wnd: HWND; nIndex: int32; dwNewLong: LONG): LONG {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowLongW\".}" },  { "module": "windows",  "name": "GetClassLong",  "code": "proc GetClassLong*(wnd: HWND; nIndex: int32): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClassLongW\".}" },  { "module": "windows",  "name": "SetClassLong",  "code": "proc SetClassLong*(wnd: HWND; nIndex: int32; dwNewLong: LONG): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetClassLongW\".}" },  { "module": "windows",  "name": "GetWindowLongPtr",  "code": "proc GetWindowLongPtr*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowLongPtrW\".}" },  { "module": "windows",  "name": "SetWindowLongPtr",  "code": "proc SetWindowLongPtr*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetWindowLongPtrW\".}" },  { "module": "windows",  "name": "GetClassLongPtr",  "code": "proc GetClassLongPtr*(wnd: HWND; nIndex: int32): LONG_PTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassLongPtrW\".}" },  { "module": "windows",  "name": "SetClassLongPtr",  "code": "proc SetClassLongPtr*(wnd: HWND; nIndex: int32; dwNewLong: LONG_PTR): LONG_PTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetClassLongPtrW\".}" },  { "module": "windows",  "name": "FindWindow",  "code": "proc FindWindow*(lpClassName: LPCWSTR; lpWindowName: LPCWSTR): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"FindWindowW\".}" },  { "module": "windows",  "name": "FindWindowEx",  "code": "proc FindWindowEx*(para1: HWND; para2: HWND; para3: LPCWSTR; para4: LPCWSTR): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"FindWindowExW\".}" },  { "module": "windows",  "name": "GetClassName",  "code": "proc GetClassName*(wnd: HWND; lpClassName: LPWSTR; nMaxCount: int32): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetClassNameW\".}" },  { "module": "windows",  "name": "SetWindowsHookEx",  "code": "proc SetWindowsHookEx*(idHook: int32; lpfn: HOOKPROC; hmod: HINST; \u000A                       dwThreadId: DWORD): HHOOK {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetWindowsHookExW\".}" },  { "module": "windows",  "name": "LoadBitmap",  "code": "proc LoadBitmap*(hInstance: HINST; lpBitmapName: LPCWSTR): HBITMAP {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadBitmapW\".}" },  { "module": "windows",  "name": "LoadCursor",  "code": "proc LoadCursor*(hInstance: HINST; lpCursorName: LPCWSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorW\".}" },  { "module": "windows",  "name": "LoadCursorFromFile",  "code": "proc LoadCursorFromFile*(lpFileName: LPCWSTR): HCURSOR {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadCursorFromFileW\".}" },  { "module": "windows",  "name": "LoadIcon",  "code": "proc LoadIcon*(hInstance: HINST; lpIconName: LPCWSTR): HICON {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadIconW\".}" },  { "module": "windows",  "name": "LoadImage",  "code": "proc LoadImage*(para1: HINST; para2: LPCWSTR; para3: WINUINT; para4: int32; \u000A                para5: int32; para6: WINUINT): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"LoadImageW\".}" },  { "module": "windows",  "name": "LoadString",  "code": "proc LoadString*(hInstance: HINST; uID: WINUINT; lpBuffer: LPWSTR; \u000A                 nBufferMax: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"LoadStringW\".}" },  { "module": "windows",  "name": "IsDialogMessage",  "code": "proc IsDialogMessage*(hDlg: HWND; lpMsg: LPMSG): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageW\".}" },  { "module": "windows",  "name": "DlgDirList",  "code": "proc DlgDirList*(hDlg: HWND; lpPathSpec: LPWSTR; nIDListBox: int32; \u000A                 nIDStaticPath: int32; uFileType: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirListW\".}" },  { "module": "windows",  "name": "DlgDirSelectEx",  "code": "proc DlgDirSelectEx*(hDlg: HWND; lpString: LPWSTR; nCount: int32; \u000A                     nIDListBox: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DlgDirSelectExW\".}" },  { "module": "windows",  "name": "DlgDirListComboBox",  "code": "proc DlgDirListComboBox*(hDlg: HWND; lpPathSpec: LPWSTR; nIDComboBox: int32; \u000A                         nIDStaticPath: int32; uFiletype: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"DlgDirListComboBoxW\".}" },  { "module": "windows",  "name": "DlgDirSelectComboBoxEx",  "code": "proc DlgDirSelectComboBoxEx*(hDlg: HWND; lpString: LPWSTR; nCount: int32; \u000A                             nIDComboBox: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DlgDirSelectComboBoxExW\".}" },  { "module": "windows",  "name": "DefFrameProc",  "code": "proc DefFrameProc*(wnd: HWND; hWndMDIClient: HWND; uMsg: WINUINT; wp: WPARAM; \u000A                   lp: LPARAM): LRESULT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DefFrameProcW\".}" },  { "module": "windows",  "name": "DefMDIChildProc",  "code": "proc DefMDIChildProc*(wnd: HWND; uMsg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DefMDIChildProcW\".}" },  { "module": "windows",  "name": "CreateMDIWindow",  "code": "proc CreateMDIWindow*(lpClassName: LPWSTR; lpWindowName: LPWSTR; dwStyle: DWORD; \u000A                      X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                      hWndParent: HWND; hInstance: HINST; lp: LPARAM): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateMDIWindowW\".}" },  { "module": "windows",  "name": "WinHelp",  "code": "proc WinHelp*(hWndMain: HWND; lpszHelp: LPCWSTR; uCommand: WINUINT; \u000A              dwData: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"WinHelpW\".}" },  { "module": "windows",  "name": "ChangeDisplaySettings",  "code": "proc ChangeDisplaySettings*(lpDevMode: LPDEVMODE; dwFlags: DWORD): LONG {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsW\".}" },  { "module": "windows",  "name": "EnumDisplaySettings",  "code": "proc EnumDisplaySettings*(lpszDeviceName: LPCWSTR; iModeNum: DWORD; \u000A                          lpDevMode: LPDEVMODEW): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsW\".}" },  { "module": "windows",  "name": "SystemParametersInfo",  "code": "proc SystemParametersInfo*(uiAction: WINUINT; uiParam: WINUINT; pvParam: PVOID; \u000A                           fWinIni: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SystemParametersInfoW\".}" },  { "module": "windows",  "name": "AddFontResource",  "code": "proc AddFontResource*(para1: LPCWSTR): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"AddFontResourceW\".}" },  { "module": "windows",  "name": "CopyMetaFile",  "code": "proc CopyMetaFile*(para1: HMETAFILE; para2: LPCWSTR): HMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CopyMetaFileW\".}" },  { "module": "windows",  "name": "CreateFontIndirect",  "code": "proc CreateFontIndirect*(para1: PLOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectW\".}" },  { "module": "windows",  "name": "CreateFontIndirect",  "code": "proc CreateFontIndirect*(para1: var LOGFONT): HFONT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateFontIndirectW\".}" },  { "module": "windows",  "name": "CreateFont",  "code": "proc CreateFont*(para1: int32; para2: int32; para3: int32; para4: int32; \u000A                 para5: int32; para6: DWORD; para7: DWORD; para8: DWORD; \u000A                 para9: DWORD; para10: DWORD; para11: DWORD; para12: DWORD; \u000A                 para13: DWORD; para14: LPCWSTR): HFONT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateFontW\".}" },  { "module": "windows",  "name": "CreateIC",  "code": "proc CreateIC*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR; para4: LPDEVMODE): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateICW\".}" },  { "module": "windows",  "name": "CreateMetaFile",  "code": "proc CreateMetaFile*(para1: LPCWSTR): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateMetaFileW\".}" },  { "module": "windows",  "name": "CreateScalableFontResource",  "code": "proc CreateScalableFontResource*(para1: DWORD; para2: LPCWSTR; para3: LPCWSTR; \u000A                                 para4: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateScalableFontResourceW\".}" },  { "module": "windows",  "name": "EnumFontFamiliesEx",  "code": "proc EnumFontFamiliesEx*(para1: HDC; para2: LPLOGFONT; para3: FONTENUMEXPROC; \u000A                         para4: LPARAM; para5: DWORD): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"EnumFontFamiliesExW\".}" },  { "module": "windows",  "name": "EnumFontFamilies",  "code": "proc EnumFontFamilies*(para1: HDC; para2: LPCWSTR; para3: FONTENUMPROC; \u000A                       para4: LPARAM): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumFontFamiliesW\".}" },  { "module": "windows",  "name": "EnumFonts",  "code": "proc EnumFonts*(para1: HDC; para2: LPCWSTR; para3: ENUMFONTSPROC; para4: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumFontsW\".}" },  { "module": "windows",  "name": "EnumFonts",  "code": "proc EnumFonts*(para1: HDC; para2: LPCWSTR; para3: ENUMFONTSPROC; para4: pointer): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumFontsW\".}" },  { "module": "windows",  "name": "GetCharWidth",  "code": "proc GetCharWidth*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthW\".}" },  { "module": "windows",  "name": "GetCharWidth32",  "code": "proc GetCharWidth32*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32W\".}" },  { "module": "windows",  "name": "GetCharWidthFloat",  "code": "proc GetCharWidthFloat*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                        para4: ptr float32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetCharWidthFloatW\".}" },  { "module": "windows",  "name": "GetCharABCWidths",  "code": "proc GetCharABCWidths*(para1: HDC; para2: WINUINT; para3: WINUINT; para4: LPABC): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsW\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloat",  "code": "proc GetCharABCWidthsFloat*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                            para4: LPABCFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatW\".}" },  { "module": "windows",  "name": "GetGlyphOutline",  "code": "proc GetGlyphOutline*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                      para4: LPGLYPHMETRICS; para5: DWORD; para6: LPVOID; \u000A                      para7: PMAT2): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetGlyphOutlineW\".}" },  { "module": "windows",  "name": "GetMetaFile",  "code": "proc GetMetaFile*(para1: LPCWSTR): HMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetMetaFileW\".}" },  { "module": "windows",  "name": "GetOutlineTextMetrics",  "code": "proc GetOutlineTextMetrics*(para1: HDC; para2: WINUINT; \u000A                            para3: LPOUTLINETEXTMETRIC): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetOutlineTextMetricsW\".}" },  { "module": "windows",  "name": "GetTextExtentPoint",  "code": "proc GetTextExtentPoint*(para1: HDC; para2: LPCWSTR; para3: int32; para4: LPSIZE): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPointW\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32",  "code": "proc GetTextExtentPoint32*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                           para4: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentPoint32W\".}" },  { "module": "windows",  "name": "GetTextExtentExPoint",  "code": "proc GetTextExtentExPoint*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                           para4: int32; para5: LPINT; para6: LPINT; \u000A                           para7: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointW\".}" },  { "module": "windows",  "name": "GetCharacterPlacement",  "code": "proc GetCharacterPlacement*(para1: HDC; para2: LPCWSTR; para3: int32; \u000A                            para4: int32; para5: LPGCP_RESULTS; para6: DWORD): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharacterPlacementW\".}" },  { "module": "windows",  "name": "ResetDC",  "code": "proc ResetDC*(para1: HDC; para2: LPDEVMODE): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ResetDCW\".}" },  { "module": "windows",  "name": "RemoveFontResource",  "code": "proc RemoveFontResource*(para1: LPCWSTR): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"RemoveFontResourceW\".}" },  { "module": "windows",  "name": "CopyEnhMetaFile",  "code": "proc CopyEnhMetaFile*(para1: HENHMETAFILE; para2: LPCWSTR): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CopyEnhMetaFileW\".}" },  { "module": "windows",  "name": "CreateEnhMetaFile",  "code": "proc CreateEnhMetaFile*(para1: HDC; para2: LPCWSTR; para3: LPRECT; \u000A                        para4: LPCWSTR): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateEnhMetaFileW\".}" },  { "module": "windows",  "name": "GetEnhMetaFile",  "code": "proc GetEnhMetaFile*(para1: LPCWSTR): HENHMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetEnhMetaFileW\".}" },  { "module": "windows",  "name": "GetEnhMetaFileDescription",  "code": "proc GetEnhMetaFileDescription*(para1: HENHMETAFILE; para2: WINUINT; \u000A                                para3: LPWSTR): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetEnhMetaFileDescriptionW\".}" },  { "module": "windows",  "name": "GetTextMetrics",  "code": "proc GetTextMetrics*(para1: HDC; para2: LPTEXTMETRIC): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextMetricsW\".}" },  { "module": "windows",  "name": "StartDoc",  "code": "proc StartDoc*(para1: HDC; para2: PDOCINFO): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StartDocW\".}" },  { "module": "windows",  "name": "GetObject",  "code": "proc GetObject*(para1: HGDIOBJ; para2: int32; para3: LPVOID): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetObjectW\".}" },  { "module": "windows",  "name": "TextOut",  "code": "proc TextOut*(para1: HDC; para2: int32; para3: int32; para4: LPCWSTR; \u000A              para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                       importc: \"TextOutW\".}" },  { "module": "windows",  "name": "ExtTextOut",  "code": "proc ExtTextOut*(para1: HDC; para2: int32; para3: int32; para4: WINUINT; \u000A                 para5: LPRECT; para6: LPCWSTR; para7: WINUINT; para8: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ExtTextOutW\".}" },  { "module": "windows",  "name": "PolyTextOut",  "code": "proc PolyTextOut*(para1: HDC; para2: PPOLYTEXT; para3: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutW\".}" },  { "module": "windows",  "name": "GetTextFace",  "code": "proc GetTextFace*(para1: HDC; para2: int32; para3: LPWSTR): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextFaceW\".}" },  { "module": "windows",  "name": "GetKerningPairs",  "code": "proc GetKerningPairs*(para1: HDC; para2: DWORD; para3: LPKERNINGPAIR): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetKerningPairsW\".}" },  { "module": "windows",  "name": "GetLogColorSpace",  "code": "proc GetLogColorSpace*(para1: HCOLORSPACE; para2: LPLOGCOLORSPACE; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetLogColorSpaceW\".}" },  { "module": "windows",  "name": "CreateColorSpace",  "code": "proc CreateColorSpace*(para1: LPLOGCOLORSPACE): HCOLORSPACE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateColorSpaceW\".}" },  { "module": "windows",  "name": "GetICMProfile",  "code": "proc GetICMProfile*(para1: HDC; para2: DWORD; para3: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetICMProfileW\".}" },  { "module": "windows",  "name": "SetICMProfile",  "code": "proc SetICMProfile*(para1: HDC; para2: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetICMProfileW\".}" },  { "module": "windows",  "name": "UpdateICMRegKey",  "code": "proc UpdateICMRegKey*(para1: DWORD; para2: DWORD; para3: LPWSTR; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"UpdateICMRegKeyW\".}" },  { "module": "windows",  "name": "EnumICMProfiles",  "code": "proc EnumICMProfiles*(para1: HDC; para2: ICMENUMPROC; para3: LPARAM): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"EnumICMProfilesW\".}" },  { "module": "windows",  "name": "CreatePropertySheetPage",  "code": "proc CreatePropertySheetPage*(lppsp: LPCPROPSHEETPAGE): HPROPSHEETPAGE {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"CreatePropertySheetPageW\".}" },  { "module": "windows",  "name": "PropertySheet",  "code": "proc PropertySheet*(lppsph: LPCPROPSHEETHEADER): int32 {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"PropertySheetW\".}" },  { "module": "windows",  "name": "ImageList_LoadImage",  "code": "proc ImageList_LoadImage*(hi: HINST; lpbmp: LPCWSTR; cx: int32; cGrow: int32; \u000A                          crMask: COLORREF; uType: WINUINT; uFlags: WINUINT): HIMAGELIST {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_LoadImageW\".}" },  { "module": "windows",  "name": "CreateStatusWindow",  "code": "proc CreateStatusWindow*(style: LONG; lpszText: LPCWSTR; hwndParent: HWND; \u000A                         wID: WINUINT): HWND {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"CreateStatusWindowW\".}" },  { "module": "windows",  "name": "DrawStatusText",  "code": "proc DrawStatusText*(hDC: HDC; lprc: LPRECT; pszText: LPCWSTR; uFlags: WINUINT) {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"DrawStatusTextW\".}" },  { "module": "windows",  "name": "GetOpenFileName",  "code": "proc GetOpenFileName*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetOpenFileNameW\".}" },  { "module": "windows",  "name": "GetSaveFileName",  "code": "proc GetSaveFileName*(para1: LPOPENFILENAME): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetSaveFileNameW\".}" },  { "module": "windows",  "name": "GetFileTitle",  "code": "proc GetFileTitle*(para1: LPCWSTR; para2: LPWSTR; para3: int16): int {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"GetFileTitleW\".}" },  { "module": "windows",  "name": "ChooseColor",  "code": "proc ChooseColor*(para1: LPCHOOSECOLOR): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseColorW\".}" },  { "module": "windows",  "name": "ReplaceText",  "code": "proc ReplaceText*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ReplaceTextW\".}" },  { "module": "windows",  "name": "ChooseFont",  "code": "proc ChooseFont*(para1: LPCHOOSEFONT): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"ChooseFontW\".}" },  { "module": "windows",  "name": "FindText",  "code": "proc FindText*(para1: LPFINDREPLACE): HWND {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"FindTextW\".}" },  { "module": "windows",  "name": "PrintDlg",  "code": "proc PrintDlg*(para1: LPPRINTDLG): WINBOOL {.stdcall, dynlib: \"comdlg32\", \u000A    importc: \"PrintDlgW\".}" },  { "module": "windows",  "name": "PageSetupDlg",  "code": "proc PageSetupDlg*(para1: LPPAGESETUPDLG): WINBOOL {.stdcall, \u000A    dynlib: \"comdlg32\", importc: \"PageSetupDlgW\".}" },  { "module": "windows",  "name": "CreateProcess",  "code": "proc CreateProcess*(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; \u000A                    lpProcessAttributes: LPSECURITY_ATTRIBUTES; \u000A                    lpThreadAttributes: LPSECURITY_ATTRIBUTES; \u000A                    bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                    lpEnvironment: LPVOID; lpCurrentDirectory: LPCWSTR; \u000A                    lpStartupInfo: LPSTARTUPINFO; \u000A                    lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessW\".}" },  { "module": "windows",  "name": "GetStartupInfo",  "code": "proc GetStartupInfo*(lpStartupInfo: LPSTARTUPINFO) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStartupInfoW\".}" },  { "module": "windows",  "name": "FindFirstFile",  "code": "proc FindFirstFile*(lpFileName: LPCWSTR; lpFindFileData: LPWIN32_FIND_DATA): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileW\".}" },  { "module": "windows",  "name": "FindNextFile",  "code": "proc FindNextFile*(hFindFile: HANDLE; lpFindFileData: LPWIN32_FIND_DATA): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileW\".}" },  { "module": "windows",  "name": "GetVersionEx",  "code": "proc GetVersionEx*(VersionInformation: LPOSVERSIONINFOW): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVersionExW\".}" },  { "module": "windows",  "name": "GetVersionExW",  "code": "proc GetVersionExW*(VersionInformation: LPOSVERSIONINFOW): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVersionExW\".}" },  { "module": "windows",  "name": "CreateWindow",  "code": "proc CreateWindow*(lpClassName: LPCWSTR; lpWindowName: LPCWSTR; dwStyle: DWORD; \u000A                   X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                   hWndParent: HWND; menu: HMENU; hInstance: HINST; \u000A                   lpParam: LPVOID): HWND" },  { "module": "windows",  "name": "CreateDialog",  "code": "proc CreateDialog*(hInstance: HINST; lpName: LPCWSTR; hWndParent: HWND; \u000A                   lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "CreateDialogIndirect",  "code": "proc CreateDialogIndirect*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                           hWndParent: HWND; lpDialogFunc: DLGPROC): HWND" },  { "module": "windows",  "name": "DialogBox",  "code": "proc DialogBox*(hInstance: HINST; lpTemplate: LPCWSTR; hWndParent: HWND; \u000A                lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "DialogBoxIndirect",  "code": "proc DialogBoxIndirect*(hInstance: HINST; lpTemplate: LPCDLGTEMPLATE; \u000A                        hWndParent: HWND; lpDialogFunc: DLGPROC): int32" },  { "module": "windows",  "name": "CreateDC",  "code": "proc CreateDC*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR; para4: PDEVMODE): HDC {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDCW\".}" },  { "module": "windows",  "name": "VerInstallFile",  "code": "proc VerInstallFile*(uFlags: DWORD; szSrcFileName: LPWSTR; \u000A                     szDestFileName: LPWSTR; szSrcDir: LPWSTR; \u000A                     szDestDir: LPWSTR; szCurDir: LPWSTR; szTmpFile: LPWSTR; \u000A                     lpuTmpFileLen: PUINT): DWORD {.stdcall, dynlib: \"version\", \u000A    importc: \"VerInstallFileW\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSize",  "code": "proc GetFileVersionInfoSize*(lptstrFilename: LPWSTR; lpdwHandle: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeW\".}" },  { "module": "windows",  "name": "GetFileVersionInfo",  "code": "proc GetFileVersionInfo*(lptstrFilename: LPWSTR; dwHandle: DWORD; dwLen: DWORD; \u000A                         lpData: LPVOID): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"GetFileVersionInfoW\".}" },  { "module": "windows",  "name": "VerLanguageName",  "code": "proc VerLanguageName*(wLang: DWORD; szLang: LPWSTR; nSize: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VerLanguageNameW\".}" },  { "module": "windows",  "name": "VerQueryValue",  "code": "proc VerQueryValue*(pBlock: LPVOID; lpSubBlock: LPWSTR; lplpBuffer: LPVOID; \u000A                    puLen: PUINT): WINBOOL {.stdcall, dynlib: \"version\", \u000A    importc: \"VerQueryValueW\".}" },  { "module": "windows",  "name": "VerFindFile",  "code": "proc VerFindFile*(uFlags: DWORD; szFileName: LPWSTR; szWinDir: LPWSTR; \u000A                  szAppDir: LPWSTR; szCurDir: LPWSTR; lpuCurDirLen: PUINT; \u000A                  szDestDir: LPWSTR; lpuDestDirLen: PUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileW\".}" },  { "module": "windows",  "name": "RegSetValueEx",  "code": "proc RegSetValueEx*(key: HKEY; lpValueName: LPCWSTR; Reserved: DWORD; \u000A                    dwType: DWORD; lpData: LPBYTE; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExW\".}" },  { "module": "windows",  "name": "RegUnLoadKey",  "code": "proc RegUnLoadKey*(key: HKEY; lpSubKey: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegUnLoadKeyW\".}" },  { "module": "windows",  "name": "InitiateSystemShutdown",  "code": "proc InitiateSystemShutdown*(lpMachineName: LPWSTR; lpMessage: LPWSTR; \u000A                             dwTimeout: DWORD; bForceAppsClosed: WINBOOL; \u000A                             bRebootAfterShutdown: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitiateSystemShutdownW\".}" },  { "module": "windows",  "name": "AbortSystemShutdown",  "code": "proc AbortSystemShutdown*(lpMachineName: LPWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AbortSystemShutdownW\".}" },  { "module": "windows",  "name": "RegRestoreKey",  "code": "proc RegRestoreKey*(key: HKEY; lpFile: LPCWSTR; dwFlags: DWORD): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegRestoreKeyW\".}" },  { "module": "windows",  "name": "RegSaveKey",  "code": "proc RegSaveKey*(key: HKEY; lpFile: LPCWSTR; \u000A                 lpSecurityAttributes: LPSECURITY_ATTRIBUTES): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegSaveKeyW\".}" },  { "module": "windows",  "name": "RegSetValue",  "code": "proc RegSetValue*(key: HKEY; lpSubKey: LPCWSTR; dwType: DWORD; lpData: LPCWSTR; \u000A                  cbData: DWORD): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegSetValueW\".}" },  { "module": "windows",  "name": "RegQueryValue",  "code": "proc RegQueryValue*(key: HKEY; lpSubKey: LPCWSTR; lpValue: LPWSTR; \u000A                    lpcbValue: PLONG): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueW\".}" },  { "module": "windows",  "name": "RegQueryMultipleValues",  "code": "proc RegQueryMultipleValues*(key: HKEY; val_list: PVALENT; num_vals: DWORD; \u000A                             lpValueBuf: LPWSTR; ldwTotsize: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesW\".}" },  { "module": "windows",  "name": "RegQueryValueEx",  "code": "proc RegQueryValueEx*(key: HKEY; lpValueName: LPCWSTR; lpReserved: LPDWORD; \u000A                      lpType: LPDWORD; lpData: LPBYTE; lpcbData: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryValueExW\".}" },  { "module": "windows",  "name": "RegReplaceKey",  "code": "proc RegReplaceKey*(key: HKEY; lpSubKey: LPCWSTR; lpNewFile: LPCWSTR; \u000A                    lpOldFile: LPCWSTR): LONG {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegReplaceKeyW\".}" },  { "module": "windows",  "name": "RegConnectRegistry",  "code": "proc RegConnectRegistry*(lpMachineName: LPWSTR; key: HKEY; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryW\".}" },  { "module": "windows",  "name": "RegCreateKey",  "code": "proc RegCreateKey*(key: HKEY; lpSubKey: LPCWSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyW\".}" },  { "module": "windows",  "name": "RegCreateKeyEx",  "code": "proc RegCreateKeyEx*(key: HKEY; lpSubKey: LPCWSTR; Reserved: DWORD; \u000A                     lpClass: LPWSTR; dwOptions: DWORD; samDesired: REGSAM; \u000A                     lpSecurityAttributes: LPSECURITY_ATTRIBUTES; \u000A                     phkResult: PHKEY; lpdwDisposition: LPDWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExW\".}" },  { "module": "windows",  "name": "RegDeleteKey",  "code": "proc RegDeleteKey*(key: HKEY; lpSubKey: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteKeyW\".}" },  { "module": "windows",  "name": "RegDeleteValue",  "code": "proc RegDeleteValue*(key: HKEY; lpValueName: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegDeleteValueW\".}" },  { "module": "windows",  "name": "RegEnumKey",  "code": "proc RegEnumKey*(key: HKEY; dwIndex: DWORD; lpName: LPWSTR; cbName: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyW\".}" },  { "module": "windows",  "name": "RegEnumKeyEx",  "code": "proc RegEnumKeyEx*(key: HKEY; dwIndex: DWORD; lpName: LPWSTR; lpcbName: LPDWORD; \u000A                   lpReserved: LPDWORD; lpClass: LPWSTR; lpcbClass: LPDWORD; \u000A                   lpftLastWriteTime: PFILETIME): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegEnumKeyExW\".}" },  { "module": "windows",  "name": "RegEnumValue",  "code": "proc RegEnumValue*(key: HKEY; dwIndex: DWORD; lpValueName: LPWSTR; \u000A                   lpcbValueName: LPDWORD; lpReserved: LPDWORD; lpType: LPDWORD; \u000A                   lpData: LPBYTE; lpcbData: LPDWORD): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegEnumValueW\".}" },  { "module": "windows",  "name": "RegLoadKey",  "code": "proc RegLoadKey*(key: HKEY; lpSubKey: LPCWSTR; lpFile: LPCWSTR): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegLoadKeyW\".}" },  { "module": "windows",  "name": "RegOpenKey",  "code": "proc RegOpenKey*(key: HKEY; lpSubKey: LPCWSTR; phkResult: PHKEY): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyW\".}" },  { "module": "windows",  "name": "RegOpenKeyEx",  "code": "proc RegOpenKeyEx*(key: HKEY; lpSubKey: LPCWSTR; ulOptions: DWORD; \u000A                   samDesired: REGSAM; phkResult: PHKEY): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExW\".}" },  { "module": "windows",  "name": "RegQueryInfoKey",  "code": "proc RegQueryInfoKey*(key: HKEY; lpClass: LPWSTR; lpcbClass: LPDWORD; \u000A                      lpReserved: LPDWORD; lpcSubKeys: LPDWORD; \u000A                      lpcbMaxSubKeyLen: LPDWORD; lpcbMaxClassLen: LPDWORD; \u000A                      lpcValues: LPDWORD; lpcbMaxValueNameLen: LPDWORD; \u000A                      lpcbMaxValueLen: LPDWORD; lpcbSecurityDescriptor: LPDWORD; \u000A                      lpftLastWriteTime: PFILETIME): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegQueryInfoKeyW\".}" },  { "module": "windows",  "name": "CompareString",  "code": "proc CompareString*(Locale: LCID; dwCmpFlags: DWORD; lpString1: LPCWSTR; \u000A                    cchCount1: int32; lpString2: LPCWSTR; cchCount2: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CompareStringW\".}" },  { "module": "windows",  "name": "LCMapString",  "code": "proc LCMapString*(Locale: LCID; dwMapFlags: DWORD; lpSrcStr: LPCWSTR; \u000A                  cchSrc: int32; lpDestStr: LPWSTR; cchDest: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LCMapStringW\".}" },  { "module": "windows",  "name": "GetLocaleInfo",  "code": "proc GetLocaleInfo*(Locale: LCID; LCType: LCTYPE; lpLCData: LPWSTR; \u000A                    cchData: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetLocaleInfoW\".}" },  { "module": "windows",  "name": "SetLocaleInfo",  "code": "proc SetLocaleInfo*(Locale: LCID; LCType: LCTYPE; lpLCData: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetLocaleInfoW\".}" },  { "module": "windows",  "name": "GetTimeFormat",  "code": "proc GetTimeFormat*(Locale: LCID; dwFlags: DWORD; lpTime: LPSYSTEMTIME; \u000A                    lpFormat: LPCWSTR; lpTimeStr: LPWSTR; cchTime: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTimeFormatW\".}" },  { "module": "windows",  "name": "GetDateFormat",  "code": "proc GetDateFormat*(Locale: LCID; dwFlags: DWORD; lpDate: LPSYSTEMTIME; \u000A                    lpFormat: LPCWSTR; lpDateStr: LPWSTR; cchDate: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDateFormatW\".}" },  { "module": "windows",  "name": "GetNumberFormat",  "code": "proc GetNumberFormat*(Locale: LCID; dwFlags: DWORD; lpValue: LPCWSTR; \u000A                      lpFormat: PNUMBERFMT; lpNumberStr: LPWSTR; \u000A                      cchNumber: int32): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetNumberFormatW\".}" },  { "module": "windows",  "name": "GetCurrencyFormat",  "code": "proc GetCurrencyFormat*(Locale: LCID; dwFlags: DWORD; lpValue: LPCWSTR; \u000A                        lpFormat: PCURRENCYFMT; lpCurrencyStr: LPWSTR; \u000A                        cchCurrency: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCurrencyFormatW\".}" },  { "module": "windows",  "name": "EnumCalendarInfo",  "code": "proc EnumCalendarInfo*(lpCalInfoEnumProc: CALINFO_ENUMPROC; Locale: LCID; \u000A                       Calendar: CALID; CalType: CALTYPE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EnumCalendarInfoW\".}" },  { "module": "windows",  "name": "EnumTimeFormats",  "code": "proc EnumTimeFormats*(lpTimeFmtEnumProc: TIMEFMT_ENUMPROC; Locale: LCID; \u000A                      dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumTimeFormatsW\".}" },  { "module": "windows",  "name": "EnumDateFormats",  "code": "proc EnumDateFormats*(lpDateFmtEnumProc: DATEFMT_ENUMPROC; Locale: LCID; \u000A                      dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"EnumDateFormatsW\".}" },  { "module": "windows",  "name": "GetStringTypeEx",  "code": "proc GetStringTypeEx*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCWSTR; \u000A                      cchSrc: int32; lpCharType: LPWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExW\".}" },  { "module": "windows",  "name": "GetStringType",  "code": "proc GetStringType*(dwInfoType: DWORD; lpSrcStr: LPCWSTR; cchSrc: int32; \u000A                    lpCharType: LPWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetStringTypeW\".}" },  { "module": "windows",  "name": "FoldString",  "code": "proc FoldString*(dwMapFlags: DWORD; lpSrcStr: LPCWSTR; cchSrc: int32; \u000A                 lpDestStr: LPWSTR; cchDest: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FoldStringW\".}" },  { "module": "windows",  "name": "EnumSystemLocales",  "code": "proc EnumSystemLocales*(lpLocaleEnumProc: LOCALE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemLocalesW\".}" },  { "module": "windows",  "name": "EnumSystemCodePages",  "code": "proc EnumSystemCodePages*(lpCodePageEnumProc: CODEPAGE_ENUMPROC; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EnumSystemCodePagesW\".}" },  { "module": "windows",  "name": "PeekConsoleInput",  "code": "proc PeekConsoleInput*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                       nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputW\".}" },  { "module": "windows",  "name": "ReadConsoleInput",  "code": "proc ReadConsoleInput*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                       nLength: DWORD; lpNumberOfEventsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputW\".}" },  { "module": "windows",  "name": "WriteConsoleInput",  "code": "proc WriteConsoleInput*(hConsoleInput: HANDLE; lpBuffer: PINPUTRECORD; \u000A                        nLength: DWORD; lpNumberOfEventsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputW\".}" },  { "module": "windows",  "name": "ReadConsoleOutput",  "code": "proc ReadConsoleOutput*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                        dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                        lpReadRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputW\".}" },  { "module": "windows",  "name": "WriteConsoleOutput",  "code": "proc WriteConsoleOutput*(hConsoleOutput: HANDLE; lpBuffer: PCHAR_INFO; \u000A                         dwBufferSize: COORD; dwBufferCoord: COORD; \u000A                         lpWriteRegion: PSMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputW\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacter",  "code": "proc ReadConsoleOutputCharacter*(hConsoleOutput: HANDLE; lpCharacter: LPWSTR; \u000A                                 nLength: DWORD; dwReadCoord: COORD; \u000A                                 lpNumberOfCharsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacter",  "code": "proc WriteConsoleOutputCharacter*(hConsoleOutput: HANDLE; lpCharacter: LPCWSTR; \u000A                                  nLength: DWORD; dwWriteCoord: COORD; \u000A                                  lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacter",  "code": "proc FillConsoleOutputCharacter*(hConsoleOutput: HANDLE; cCharacter: WCHAR; \u000A                                 nLength: DWORD; dwWriteCoord: COORD; \u000A                                 lpNumberOfCharsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBuffer",  "code": "proc ScrollConsoleScreenBuffer*(hConsoleOutput: HANDLE; \u000A                                lpScrollRectangle: PSMALL_RECT; \u000A                                lpClipRectangle: PSMALL_RECT; \u000A                                dwDestinationOrigin: COORD; lpFill: PCHAR_INFO): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferW\".}" },  { "module": "windows",  "name": "GetConsoleTitle",  "code": "proc GetConsoleTitle*(lpConsoleTitle: LPWSTR; nSize: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetConsoleTitleW\".}" },  { "module": "windows",  "name": "SetConsoleTitle",  "code": "proc SetConsoleTitle*(lpConsoleTitle: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleTitleW\".}" },  { "module": "windows",  "name": "ReadConsole",  "code": "proc ReadConsole*(hConsoleInput: HANDLE; lpBuffer: LPVOID; \u000A                  nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: LPDWORD; \u000A                  lpReserved: LPVOID): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleW\".}" },  { "module": "windows",  "name": "WriteConsole",  "code": "proc WriteConsole*(hConsoleOutput: HANDLE; lpBuffer: pointer; \u000A                   nNumberOfCharsToWrite: DWORD; \u000A                   lpNumberOfCharsWritten: LPDWORD; lpReserved: LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleW\".}" },  { "module": "windows",  "name": "WNetAddConnection",  "code": "proc WNetAddConnection*(lpRemoteName: LPCWSTR; lpPassword: LPCWSTR; \u000A                        lpLocalName: LPCWSTR): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetAddConnectionW\".}" },  { "module": "windows",  "name": "WNetAddConnection2",  "code": "proc WNetAddConnection2*(lpNetResource: LPNETRESOURCE; lpPassword: LPCWSTR; \u000A                         lpUserName: LPCWSTR; dwFlags: DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetAddConnection2W\".}" },  { "module": "windows",  "name": "WNetAddConnection3",  "code": "proc WNetAddConnection3*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                         lpPassword: LPCWSTR; lpUserName: LPCWSTR; \u000A                         dwFlags: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetAddConnection3W\".}" },  { "module": "windows",  "name": "WNetCancelConnection",  "code": "proc WNetCancelConnection*(lpName: LPCWSTR; fForce: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetCancelConnectionW\".}" },  { "module": "windows",  "name": "WNetCancelConnection2",  "code": "proc WNetCancelConnection2*(lpName: LPCWSTR; dwFlags: DWORD; fForce: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetCancelConnection2W\".}" },  { "module": "windows",  "name": "WNetGetConnection",  "code": "proc WNetGetConnection*(lpLocalName: LPCWSTR; lpRemoteName: LPWSTR; \u000A                        lpnLength: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionW\".}" },  { "module": "windows",  "name": "WNetUseConnection",  "code": "proc WNetUseConnection*(hwndOwner: HWND; lpNetResource: LPNETRESOURCE; \u000A                        lpUserID: LPCWSTR; lpPassword: LPCWSTR; dwFlags: DWORD; \u000A                        lpAccessName: LPWSTR; lpBufferSize: LPDWORD; \u000A                        lpResult: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetUseConnectionW\".}" },  { "module": "windows",  "name": "WNetSetConnection",  "code": "proc WNetSetConnection*(lpName: LPCWSTR; dwProperties: DWORD; pvValues: LPVOID): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetSetConnectionW\".}" },  { "module": "windows",  "name": "WNetConnectionDialog1",  "code": "proc WNetConnectionDialog1*(lpConnDlgStruct: LPCONNECTDLGSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetConnectionDialog1W\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog1",  "code": "proc WNetDisconnectDialog1*(lpConnDlgStruct: LPDISCDLGSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetDisconnectDialog1W\".}" },  { "module": "windows",  "name": "WNetOpenEnum",  "code": "proc WNetOpenEnum*(dwScope: DWORD; dwType: DWORD; dwUsage: DWORD; \u000A                   lpNetResource: LPNETRESOURCE; lphEnum: LPHANDLE): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetOpenEnumW\".}" },  { "module": "windows",  "name": "WNetEnumResource",  "code": "proc WNetEnumResource*(hEnum: HANDLE; lpcCount: LPDWORD; lpBuffer: LPVOID; \u000A                       lpBufferSize: LPDWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetEnumResourceW\".}" },  { "module": "windows",  "name": "WNetGetUniversalName",  "code": "proc WNetGetUniversalName*(lpLocalPath: LPCWSTR; dwInfoLevel: DWORD; \u000A                           lpBuffer: LPVOID; lpBufferSize: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameW\".}" },  { "module": "windows",  "name": "WNetGetUser",  "code": "proc WNetGetUser*(lpName: LPCWSTR; lpUserName: LPWSTR; lpnLength: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserW\".}" },  { "module": "windows",  "name": "WNetGetProviderName",  "code": "proc WNetGetProviderName*(dwNetType: DWORD; lpProviderName: LPWSTR; \u000A                          lpBufferSize: LPDWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameW\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformation",  "code": "proc WNetGetNetworkInformation*(lpProvider: LPCWSTR; \u000A                                lpNetInfoStruct: LPNETINFOSTRUCT): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationW\".}" },  { "module": "windows",  "name": "WNetGetLastError",  "code": "proc WNetGetLastError*(lpError: LPDWORD; lpErrorBuf: LPWSTR; \u000A                       nErrorBufSize: DWORD; lpNameBuf: LPWSTR; \u000A                       nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorW\".}" },  { "module": "windows",  "name": "MultinetGetConnectionPerformance",  "code": "proc MultinetGetConnectionPerformance*(lpNetResource: LPNETRESOURCE; \u000A    lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"MultinetGetConnectionPerformanceW\".}" },  { "module": "windows",  "name": "ChangeServiceConfig",  "code": "proc ChangeServiceConfig*(hService: SC_HANDLE; dwServiceType: DWORD; \u000A                          dwStartType: DWORD; dwErrorControl: DWORD; \u000A                          lpBinaryPathName: LPCWSTR; lpLoadOrderGroup: LPCWSTR; \u000A                          lpdwTagId: LPDWORD; lpDependencies: LPCWSTR; \u000A                          lpServiceStartName: LPCWSTR; lpPassword: LPCWSTR; \u000A                          lpDisplayName: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ChangeServiceConfigW\".}" },  { "module": "windows",  "name": "CreateService",  "code": "proc CreateService*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                    lpDisplayName: LPCWSTR; dwDesiredAccess: DWORD; \u000A                    dwServiceType: DWORD; dwStartType: DWORD; \u000A                    dwErrorControl: DWORD; lpBinaryPathName: LPCWSTR; \u000A                    lpLoadOrderGroup: LPCWSTR; lpdwTagId: LPDWORD; \u000A                    lpDependencies: LPCWSTR; lpServiceStartName: LPCWSTR; \u000A                    lpPassword: LPCWSTR): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"CreateServiceW\".}" },  { "module": "windows",  "name": "EnumDependentServices",  "code": "proc EnumDependentServices*(hService: SC_HANDLE; dwServiceState: DWORD; \u000A                            lpServices: LPENUM_SERVICE_STATUS; cbBufSize: DWORD; \u000A                            pcbBytesNeeded: LPDWORD; lpServicesReturned: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"EnumDependentServicesW\".}" },  { "module": "windows",  "name": "EnumServicesStatus",  "code": "proc EnumServicesStatus*(hSCManager: SC_HANDLE; dwServiceType: DWORD; \u000A                         dwServiceState: DWORD; \u000A                         lpServices: LPENUM_SERVICE_STATUS; cbBufSize: DWORD; \u000A                         pcbBytesNeeded: LPDWORD; lpServicesReturned: LPDWORD; \u000A                         lpResumeHandle: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EnumServicesStatusW\".}" },  { "module": "windows",  "name": "GetServiceKeyName",  "code": "proc GetServiceKeyName*(hSCManager: SC_HANDLE; lpDisplayName: LPCWSTR; \u000A                        lpServiceName: LPWSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceKeyNameW\".}" },  { "module": "windows",  "name": "GetServiceDisplayName",  "code": "proc GetServiceDisplayName*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                            lpDisplayName: LPWSTR; lpcchBuffer: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetServiceDisplayNameW\".}" },  { "module": "windows",  "name": "OpenSCManager",  "code": "proc OpenSCManager*(lpMachineName: LPCWSTR; lpDatabaseName: LPCWSTR; \u000A                    dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenSCManagerW\".}" },  { "module": "windows",  "name": "OpenService",  "code": "proc OpenService*(hSCManager: SC_HANDLE; lpServiceName: LPCWSTR; \u000A                  dwDesiredAccess: DWORD): SC_HANDLE {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenServiceW\".}" },  { "module": "windows",  "name": "QueryServiceConfig",  "code": "proc QueryServiceConfig*(hService: SC_HANDLE; \u000A                         lpServiceConfig: LPQUERY_SERVICE_CONFIG; \u000A                         cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceConfigW\".}" },  { "module": "windows",  "name": "QueryServiceLockStatus",  "code": "proc QueryServiceLockStatus*(hSCManager: SC_HANDLE; \u000A                             lpLockStatus: LPQUERY_SERVICE_LOCK_STATUS; \u000A                             cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceLockStatusW\".}" },  { "module": "windows",  "name": "RegisterServiceCtrlHandler",  "code": "proc RegisterServiceCtrlHandler*(lpServiceName: LPCWSTR; \u000A                                 lpHandlerProc: LPHANDLER_FUNCTION): SERVICE_STATUS_HANDLE {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegisterServiceCtrlHandlerW\".}" },  { "module": "windows",  "name": "StartServiceCtrlDispatcher",  "code": "proc StartServiceCtrlDispatcher*(lpServiceStartTable: LPSERVICE_TABLE_ENTRY): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"StartServiceCtrlDispatcherW\".}" },  { "module": "windows",  "name": "StartService",  "code": "proc StartService*(hService: SC_HANDLE; dwNumServiceArgs: DWORD; \u000A                   lpServiceArgVectors: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"StartServiceW\".}" },  { "module": "windows",  "name": "DragQueryFile",  "code": "proc DragQueryFile*(para1: HDROP; para2: int; para3: LPCWSTR; para4: int): int {.\u000A    stdcall, dynlib: \"shell32\", importc: \"DragQueryFileW\".}" },  { "module": "windows",  "name": "ExtractAssociatedIcon",  "code": "proc ExtractAssociatedIcon*(para1: HINST; para2: LPCWSTR; para3: LPWORD): HICON {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ExtractAssociatedIconW\".}" },  { "module": "windows",  "name": "ExtractIcon",  "code": "proc ExtractIcon*(para1: HINST; para2: LPCWSTR; para3: int): HICON {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ExtractIconW\".}" },  { "module": "windows",  "name": "FindExecutable",  "code": "proc FindExecutable*(para1: LPCWSTR; para2: LPCWSTR; para3: LPCWSTR): HINST {.\u000A    stdcall, dynlib: \"shell32\", importc: \"FindExecutableW\".}" },  { "module": "windows",  "name": "ShellAbout",  "code": "proc ShellAbout*(para1: HWND; para2: LPCWSTR; para3: LPCWSTR; para4: HICON): int32 {.\u000A    stdcall, dynlib: \"shell32\", importc: \"ShellAboutW\".}" },  { "module": "windows",  "name": "ShellExecute",  "code": "proc ShellExecute*(para1: HWND; para2: LPCWSTR; para3: LPCWSTR; para4: LPCWSTR; \u000A                   para5: LPCWSTR; para6: int32): HINST {.stdcall, \u000A    dynlib: \"shell32\", importc: \"ShellExecuteW\".}" },  { "module": "windows",  "name": "Shell_NotifyIcon",  "code": "proc Shell_NotifyIcon*(dwMessage: DWORD; lpData: PNotifyIconDataA): WINBOOL {.\u000A    stdcall, dynlib: \"shell32\", importc: \"Shell_NotifyIconW\".}" },  { "module": "windows",  "name": "DdeCreateStringHandle",  "code": "proc DdeCreateStringHandle*(para1: DWORD; para2: LPCWSTR; para3: int32): HSZ {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeCreateStringHandleW\".}" },  { "module": "windows",  "name": "DdeInitialize",  "code": "proc DdeInitialize*(para1: LPDWORD; para2: PFNCALLBACK; para3: DWORD; \u000A                    para4: DWORD): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeInitializeW\".}" },  { "module": "windows",  "name": "DdeQueryString",  "code": "proc DdeQueryString*(para1: DWORD; para2: HSZ; para3: LPCWSTR; para4: DWORD; \u000A                     para5: int32): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeQueryStringW\".}" },  { "module": "windows",  "name": "LogonUser",  "code": "proc LogonUser*(para1: LPWSTR; para2: LPWSTR; para3: LPWSTR; para4: DWORD; \u000A                para5: DWORD; para6: PHANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LogonUserW\".}" },  { "module": "windows",  "name": "CreateProcessAsUser",  "code": "proc CreateProcessAsUser*(para1: HANDLE; para2: LPCWSTR; para3: LPWSTR; \u000A                          para4: LPSECURITY_ATTRIBUTES; \u000A                          para5: LPSECURITY_ATTRIBUTES; para6: WINBOOL; \u000A                          para7: DWORD; para8: LPVOID; para9: LPCWSTR; \u000A                          para10: LPSTARTUPINFO; para11: LPPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"CreateProcessAsUserW\".}" },  { "module": "windows",  "name": "GetRandomRgn",  "code": "proc GetRandomRgn*(aHDC: HDC; aHRGN: HRGN; iNum: WINT): WINT {.stdcall, importc, \u000A    dynlib: \"gdi32\".}" },  { "module": "windows",  "name": "AccessCheck",  "code": "proc AccessCheck*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                  ClientToken: HANDLE; DesiredAccess: DWORD; \u000A                  GenericMapping: PGENERIC_MAPPING; \u000A                  PrivilegeSet: PPRIVILEGE_SET; PrivilegeSetLength: LPDWORD; \u000A                  GrantedAccess: LPDWORD; AccessStatus: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AccessCheck\".}" },  { "module": "windows",  "name": "FreeResource",  "code": "proc FreeResource*(hResData: HGLOBAL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FreeResource\".}" },  { "module": "windows",  "name": "LockResource",  "code": "proc LockResource*(hResData: HGLOBAL): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LockResource\".}" },  { "module": "windows",  "name": "FreeLibrary",  "code": "proc FreeLibrary*(hLibModule: HINST): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FreeLibrary\".}" },  { "module": "windows",  "name": "FreeLibraryAndExitThread",  "code": "proc FreeLibraryAndExitThread*(hLibModule: HMODULE; dwExitCode: DWORD) {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FreeLibraryAndExitThread\".}" },  { "module": "windows",  "name": "DisableThreadLibraryCalls",  "code": "proc DisableThreadLibraryCalls*(hLibModule: HMODULE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DisableThreadLibraryCalls\".}" },  { "module": "windows",  "name": "GetProcAddress",  "code": "proc GetProcAddress*(hModule: HINST; lpProcName: LPCSTR): FARPROC {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcAddress\".}" },  { "module": "windows",  "name": "GetVersion",  "code": "proc GetVersion*(): DWORD {.stdcall, dynlib: \"kernel32\", importc: \"GetVersion\".}" },  { "module": "windows",  "name": "GlobalAlloc",  "code": "proc GlobalAlloc*(uFlags: int32; dwBytes: DWORD): HGLOBAL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GlobalAlloc\".}" },  { "module": "windows",  "name": "GlobalReAlloc",  "code": "proc GlobalReAlloc*(hMem: HGLOBAL; dwBytes: DWORD; uFlags: int32): HGLOBAL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GlobalReAlloc\".}" },  { "module": "windows",  "name": "GlobalSize",  "code": "proc GlobalSize*(hMem: HGLOBAL): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalSize\".}" },  { "module": "windows",  "name": "GlobalFlags",  "code": "proc GlobalFlags*(hMem: HGLOBAL): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalFlags\".}" },  { "module": "windows",  "name": "GlobalLock",  "code": "proc GlobalLock*(hMem: HGLOBAL): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalLock\".}" },  { "module": "windows",  "name": "GlobalHandle",  "code": "proc GlobalHandle*(pMem: LPCVOID): HGLOBAL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalHandle\".}" },  { "module": "windows",  "name": "GlobalUnlock",  "code": "proc GlobalUnlock*(hMem: HGLOBAL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalUnlock\".}" },  { "module": "windows",  "name": "GlobalFree",  "code": "proc GlobalFree*(hMem: HGLOBAL): HGLOBAL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalFree\".}" },  { "module": "windows",  "name": "GlobalCompact",  "code": "proc GlobalCompact*(dwMinFree: DWORD): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalCompact\".}" },  { "module": "windows",  "name": "GlobalFix",  "code": "proc GlobalFix*(hMem: HGLOBAL) {.stdcall, dynlib: \"kernel32\", \u000A                                 importc: \"GlobalFix\".}" },  { "module": "windows",  "name": "GlobalUnfix",  "code": "proc GlobalUnfix*(hMem: HGLOBAL) {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"GlobalUnfix\".}" },  { "module": "windows",  "name": "GlobalWire",  "code": "proc GlobalWire*(hMem: HGLOBAL): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalWire\".}" },  { "module": "windows",  "name": "GlobalUnWire",  "code": "proc GlobalUnWire*(hMem: HGLOBAL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalUnWire\".}" },  { "module": "windows",  "name": "GlobalMemoryStatus",  "code": "proc GlobalMemoryStatus*(lpBuffer: LPMEMORYSTATUS) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GlobalMemoryStatus\".}" },  { "module": "windows",  "name": "LocalAlloc",  "code": "proc LocalAlloc*(uFlags: WINUINT; uBytes: WINUINT): HLOCAL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LocalAlloc\".}" },  { "module": "windows",  "name": "LocalReAlloc",  "code": "proc LocalReAlloc*(hMem: HLOCAL; uBytes: WINUINT; uFlags: WINUINT): HLOCAL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LocalReAlloc\".}" },  { "module": "windows",  "name": "LocalLock",  "code": "proc LocalLock*(hMem: HLOCAL): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A                                        importc: \"LocalLock\".}" },  { "module": "windows",  "name": "LocalHandle",  "code": "proc LocalHandle*(pMem: LPCVOID): HLOCAL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LocalHandle\".}" },  { "module": "windows",  "name": "LocalUnlock",  "code": "proc LocalUnlock*(hMem: HLOCAL): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LocalUnlock\".}" },  { "module": "windows",  "name": "LocalSize",  "code": "proc LocalSize*(hMem: HLOCAL): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LocalSize\".}" },  { "module": "windows",  "name": "LocalFlags",  "code": "proc LocalFlags*(hMem: HLOCAL): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LocalFlags\".}" },  { "module": "windows",  "name": "LocalFree",  "code": "proc LocalFree*(hMem: HLOCAL): HLOCAL {.stdcall, dynlib: \"kernel32\", \u000A                                        importc: \"LocalFree\".}" },  { "module": "windows",  "name": "LocalShrink",  "code": "proc LocalShrink*(hMem: HLOCAL; cbNewSize: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LocalShrink\".}" },  { "module": "windows",  "name": "LocalCompact",  "code": "proc LocalCompact*(uMinFree: WINUINT): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"LocalCompact\".}" },  { "module": "windows",  "name": "FlushInstructionCache",  "code": "proc FlushInstructionCache*(hProcess: HANDLE; lpBaseAddress: LPCVOID; \u000A                            dwSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FlushInstructionCache\".}" },  { "module": "windows",  "name": "VirtualAlloc",  "code": "proc VirtualAlloc*(lpAddress: LPVOID; dwSize: DWORD; flAllocationType: DWORD; \u000A                   flProtect: DWORD): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"VirtualAlloc\".}" },  { "module": "windows",  "name": "VirtualFree",  "code": "proc VirtualFree*(lpAddress: LPVOID; dwSize: DWORD; dwFreeType: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VirtualFree\".}" },  { "module": "windows",  "name": "VirtualProtect",  "code": "proc VirtualProtect*(lpAddress: LPVOID; dwSize: DWORD; flNewProtect: DWORD; \u000A                     lpflOldProtect: PDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"VirtualProtect\".}" },  { "module": "windows",  "name": "VirtualQuery",  "code": "proc VirtualQuery*(lpAddress: LPCVOID; lpBuffer: PMEMORY_BASIC_INFORMATION; \u000A                   dwLength: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"VirtualQuery\".}" },  { "module": "windows",  "name": "VirtualProtectEx",  "code": "proc VirtualProtectEx*(hProcess: HANDLE; lpAddress: LPVOID; dwSize: DWORD; \u000A                       flNewProtect: DWORD; lpflOldProtect: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VirtualProtectEx\".}" },  { "module": "windows",  "name": "VirtualQueryEx",  "code": "proc VirtualQueryEx*(hProcess: HANDLE; lpAddress: LPCVOID; \u000A                     lpBuffer: PMEMORY_BASIC_INFORMATION; dwLength: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VirtualQueryEx\".}" },  { "module": "windows",  "name": "HeapCreate",  "code": "proc HeapCreate*(flOptions: DWORD; dwInitialSize: DWORD; dwMaximumSize: DWORD): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"HeapCreate\".}" },  { "module": "windows",  "name": "HeapDestroy",  "code": "proc HeapDestroy*(hHeap: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"HeapDestroy\".}" },  { "module": "windows",  "name": "HeapAlloc",  "code": "proc HeapAlloc*(hHeap: HANDLE; dwFlags: DWORD; dwBytes: DWORD): LPVOID {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"HeapAlloc\".}" },  { "module": "windows",  "name": "HeapReAlloc",  "code": "proc HeapReAlloc*(hHeap: HANDLE; dwFlags: DWORD; lpMem: LPVOID; dwBytes: DWORD): LPVOID {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"HeapReAlloc\".}" },  { "module": "windows",  "name": "HeapFree",  "code": "proc HeapFree*(hHeap: HANDLE; dwFlags: DWORD; lpMem: LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"HeapFree\".}" },  { "module": "windows",  "name": "HeapSize",  "code": "proc HeapSize*(hHeap: HANDLE; dwFlags: DWORD; lpMem: LPCVOID): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"HeapSize\".}" },  { "module": "windows",  "name": "HeapValidate",  "code": "proc HeapValidate*(hHeap: HANDLE; dwFlags: DWORD; lpMem: LPCVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"HeapValidate\".}" },  { "module": "windows",  "name": "HeapCompact",  "code": "proc HeapCompact*(hHeap: HANDLE; dwFlags: DWORD): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"HeapCompact\".}" },  { "module": "windows",  "name": "GetProcessHeap",  "code": "proc GetProcessHeap*(): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A                                 importc: \"GetProcessHeap\".}" },  { "module": "windows",  "name": "GetProcessHeaps",  "code": "proc GetProcessHeaps*(NumberOfHeaps: DWORD; ProcessHeaps: PHANDLE): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessHeaps\".}" },  { "module": "windows",  "name": "HeapLock",  "code": "proc HeapLock*(hHeap: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"HeapLock\".}" },  { "module": "windows",  "name": "HeapUnlock",  "code": "proc HeapUnlock*(hHeap: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"HeapUnlock\".}" },  { "module": "windows",  "name": "HeapWalk",  "code": "proc HeapWalk*(hHeap: HANDLE; lpEntry: LPPROCESS_HEAP_ENTRY): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"HeapWalk\".}" },  { "module": "windows",  "name": "GetProcessAffinityMask",  "code": "proc GetProcessAffinityMask*(hProcess: HANDLE; lpProcessAffinityMask: LPDWORD; \u000A                             lpSystemAffinityMask: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcessAffinityMask\".}" },  { "module": "windows",  "name": "GetProcessTimes",  "code": "proc GetProcessTimes*(hProcess: HANDLE; lpCreationTime: LPFILETIME; \u000A                      lpExitTime: LPFILETIME; lpKernelTime: LPFILETIME; \u000A                      lpUserTime: LPFILETIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcessTimes\".}" },  { "module": "windows",  "name": "GetProcessWorkingSetSize",  "code": "proc GetProcessWorkingSetSize*(hProcess: HANDLE; \u000A                               lpMinimumWorkingSetSize: LPDWORD; \u000A                               lpMaximumWorkingSetSize: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessWorkingSetSize\".}" },  { "module": "windows",  "name": "SetProcessWorkingSetSize",  "code": "proc SetProcessWorkingSetSize*(hProcess: HANDLE; dwMinimumWorkingSetSize: DWORD; \u000A                               dwMaximumWorkingSetSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetProcessWorkingSetSize\".}" },  { "module": "windows",  "name": "OpenProcess",  "code": "proc OpenProcess*(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                  dwProcessId: DWORD): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"OpenProcess\".}" },  { "module": "windows",  "name": "GetCurrentProcess",  "code": "proc GetCurrentProcess*(): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A                                    importc: \"GetCurrentProcess\".}" },  { "module": "windows",  "name": "GetCurrentProcessId",  "code": "proc GetCurrentProcessId*(): DWORD {.stdcall, dynlib: \"kernel32\", \u000A                                     importc: \"GetCurrentProcessId\".}" },  { "module": "windows",  "name": "ExitProcess",  "code": "proc ExitProcess*(uExitCode: WINUINT) {.stdcall, dynlib: \"kernel32\", \u000A                                        importc: \"ExitProcess\".}" },  { "module": "windows",  "name": "TerminateProcess",  "code": "proc TerminateProcess*(hProcess: HANDLE; uExitCode: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TerminateProcess\".}" },  { "module": "windows",  "name": "SetProcessAffinityMask",  "code": "proc SetProcessAffinityMask*(hProcess: THandle; dwProcessAffinityMask: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetProcessAffinityMask\".}" },  { "module": "windows",  "name": "GetExitCodeProcess",  "code": "proc GetExitCodeProcess*(hProcess: HANDLE; lpExitCode: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetExitCodeProcess\".}" },  { "module": "windows",  "name": "FatalExit",  "code": "proc FatalExit*(ExitCode: int32) {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"FatalExit\".}" },  { "module": "windows",  "name": "RaiseException",  "code": "proc RaiseException*(dwExceptionCode: DWORD; dwExceptionFlags: DWORD; \u000A                     nNumberOfArguments: DWORD; lpArguments: LPDWORD) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"RaiseException\".}" },  { "module": "windows",  "name": "UnhandledExceptionFilter",  "code": "proc UnhandledExceptionFilter*(ExceptionInfo: lpemptyrecord): LONG {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"UnhandledExceptionFilter\".}" },  { "module": "windows",  "name": "CreateRemoteThread",  "code": "proc CreateRemoteThread*(hProcess: HANDLE; \u000A                         lpThreadAttributes: LPSECURITY_ATTRIBUTES; \u000A                         dwStackSize: DWORD; \u000A                         lpStartAddress: LPTHREAD_START_ROUTINE; \u000A                         lpParameter: LPVOID; dwCreationFlags: DWORD; \u000A                         lpThreadId: LPDWORD): HANDLE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateRemoteThread\".}" },  { "module": "windows",  "name": "GetCurrentThread",  "code": "proc GetCurrentThread*(): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"GetCurrentThread\".}" },  { "module": "windows",  "name": "GetCurrentThreadId",  "code": "proc GetCurrentThreadId*(): DWORD {.stdcall, dynlib: \"kernel32\", \u000A                                    importc: \"GetCurrentThreadId\".}" },  { "module": "windows",  "name": "SetThreadAffinityMask",  "code": "proc SetThreadAffinityMask*(hThread: HANDLE; dwThreadAffinityMask: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetThreadAffinityMask\".}" },  { "module": "windows",  "name": "SetThreadPriority",  "code": "proc SetThreadPriority*(hThread: HANDLE; nPriority: int32): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetThreadPriority\".}" },  { "module": "windows",  "name": "GetThreadPriority",  "code": "proc GetThreadPriority*(hThread: HANDLE): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetThreadPriority\".}" },  { "module": "windows",  "name": "GetThreadTimes",  "code": "proc GetThreadTimes*(hThread: HANDLE; lpCreationTime: LPFILETIME; \u000A                     lpExitTime: LPFILETIME; lpKernelTime: LPFILETIME; \u000A                     lpUserTime: LPFILETIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetThreadTimes\".}" },  { "module": "windows",  "name": "ExitThread",  "code": "proc ExitThread*(dwExitCode: DWORD) {.stdcall, dynlib: \"kernel32\", \u000A                                      importc: \"ExitThread\".}" },  { "module": "windows",  "name": "TerminateThread",  "code": "proc TerminateThread*(hThread: HANDLE; dwExitCode: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TerminateThread\".}" },  { "module": "windows",  "name": "GetExitCodeThread",  "code": "proc GetExitCodeThread*(hThread: HANDLE; lpExitCode: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetExitCodeThread\".}" },  { "module": "windows",  "name": "GetThreadSelectorEntry",  "code": "proc GetThreadSelectorEntry*(hThread: HANDLE; dwSelector: DWORD; \u000A                             lpSelectorEntry: LPLDT_ENTRY): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetThreadSelectorEntry\".}" },  { "module": "windows",  "name": "GetLastError",  "code": "proc GetLastError*(): DWORD {.stdcall, dynlib: \"kernel32\", \u000A                              importc: \"GetLastError\".}" },  { "module": "windows",  "name": "SetLastError",  "code": "proc SetLastError*(dwErrCode: DWORD) {.stdcall, dynlib: \"kernel32\", \u000A                                       importc: \"SetLastError\".}" },  { "module": "windows",  "name": "CreateIoCompletionPort",  "code": "proc CreateIoCompletionPort*(FileHandle: HANDLE; ExistingCompletionPort: HANDLE; \u000A                             CompletionKey: DWORD; \u000A                             NumberOfConcurrentThreads: DWORD): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateIoCompletionPort\".}" },  { "module": "windows",  "name": "SetErrorMode",  "code": "proc SetErrorMode*(uMode: WINUINT): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetErrorMode\".}" },  { "module": "windows",  "name": "ReadProcessMemory",  "code": "proc ReadProcessMemory*(hProcess: HANDLE; lpBaseAddress: LPCVOID; \u000A                        lpBuffer: LPVOID; nSize: DWORD; \u000A                        lpNumberOfBytesRead: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadProcessMemory\".}" },  { "module": "windows",  "name": "WriteProcessMemory",  "code": "proc WriteProcessMemory*(hProcess: HANDLE; lpBaseAddress: LPVOID; \u000A                         lpBuffer: LPVOID; nSize: DWORD; \u000A                         lpNumberOfBytesWritten: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteProcessMemory\".}" },  { "module": "windows",  "name": "GetThreadContext",  "code": "proc GetThreadContext*(hThread: HANDLE; lpContext: LPCONTEXT): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetThreadContext\".}" },  { "module": "windows",  "name": "SuspendThread",  "code": "proc SuspendThread*(hThread: HANDLE): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SuspendThread\".}" },  { "module": "windows",  "name": "ResumeThread",  "code": "proc ResumeThread*(hThread: HANDLE): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ResumeThread\".}" },  { "module": "windows",  "name": "DebugBreak",  "code": "proc DebugBreak*() {.stdcall, dynlib: \"kernel32\", importc: \"DebugBreak\".}" },  { "module": "windows",  "name": "WaitForDebugEvent",  "code": "proc WaitForDebugEvent*(lpDebugEvent: LPDEBUG_EVENT; dwMilliseconds: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitForDebugEvent\".}" },  { "module": "windows",  "name": "ContinueDebugEvent",  "code": "proc ContinueDebugEvent*(dwProcessId: DWORD; dwThreadId: DWORD; \u000A                         dwContinueStatus: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ContinueDebugEvent\".}" },  { "module": "windows",  "name": "DebugActiveProcess",  "code": "proc DebugActiveProcess*(dwProcessId: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DebugActiveProcess\".}" },  { "module": "windows",  "name": "InitializeCriticalSection",  "code": "proc InitializeCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION) {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"InitializeCriticalSection\".}" },  { "module": "windows",  "name": "EnterCriticalSection",  "code": "proc EnterCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EnterCriticalSection\".}" },  { "module": "windows",  "name": "LeaveCriticalSection",  "code": "proc LeaveCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LeaveCriticalSection\".}" },  { "module": "windows",  "name": "DeleteCriticalSection",  "code": "proc DeleteCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DeleteCriticalSection\".}" },  { "module": "windows",  "name": "TryEnterCriticalSection",  "code": "proc TryEnterCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"TryEnterCriticalSection\".}" },  { "module": "windows",  "name": "SetEvent",  "code": "proc SetEvent*(hEvent: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetEvent\".}" },  { "module": "windows",  "name": "ResetEvent",  "code": "proc ResetEvent*(hEvent: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ResetEvent\".}" },  { "module": "windows",  "name": "PulseEvent",  "code": "proc PulseEvent*(hEvent: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"PulseEvent\".}" },  { "module": "windows",  "name": "ReleaseSemaphore",  "code": "proc ReleaseSemaphore*(hSemaphore: HANDLE; lReleaseCount: LONG; \u000A                       lpPreviousCount: LPLONG): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReleaseSemaphore\".}" },  { "module": "windows",  "name": "ReleaseMutex",  "code": "proc ReleaseMutex*(hMutex: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReleaseMutex\".}" },  { "module": "windows",  "name": "WaitForSingleObject",  "code": "proc WaitForSingleObject*(hHandle: HANDLE; dwMilliseconds: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitForSingleObject\".}" },  { "module": "windows",  "name": "Sleep",  "code": "proc Sleep*(dwMilliseconds: DWORD) {.stdcall, dynlib: \"kernel32\", \u000A                                     importc: \"Sleep\".}" },  { "module": "windows",  "name": "LoadResource",  "code": "proc LoadResource*(hModule: HINST; hResInfo: HRSRC): HGLOBAL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LoadResource\".}" },  { "module": "windows",  "name": "SizeofResource",  "code": "proc SizeofResource*(hModule: HINST; hResInfo: HRSRC): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SizeofResource\".}" },  { "module": "windows",  "name": "GlobalDeleteAtom",  "code": "proc GlobalDeleteAtom*(nAtom: ATOM): ATOM {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GlobalDeleteAtom\".}" },  { "module": "windows",  "name": "InitAtomTable",  "code": "proc InitAtomTable*(nSize: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"InitAtomTable\".}" },  { "module": "windows",  "name": "DeleteAtom",  "code": "proc DeleteAtom*(nAtom: ATOM): ATOM {.stdcall, dynlib: \"kernel32\", \u000A                                      importc: \"DeleteAtom\".}" },  { "module": "windows",  "name": "SetHandleCount",  "code": "proc SetHandleCount*(uNumber: WINUINT): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetHandleCount\".}" },  { "module": "windows",  "name": "GetLogicalDrives",  "code": "proc GetLogicalDrives*(): DWORD {.stdcall, dynlib: \"kernel32\", \u000A                                  importc: \"GetLogicalDrives\".}" },  { "module": "windows",  "name": "LockFile",  "code": "proc LockFile*(hFile: HANDLE; dwFileOffsetLow: DWORD; dwFileOffsetHigh: DWORD; \u000A               nNumberOfBytesToLockLow: DWORD; nNumberOfBytesToLockHigh: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LockFile\".}" },  { "module": "windows",  "name": "UnlockFile",  "code": "proc UnlockFile*(hFile: HANDLE; dwFileOffsetLow: DWORD; dwFileOffsetHigh: DWORD; \u000A                 nNumberOfBytesToUnlockLow: DWORD; \u000A                 nNumberOfBytesToUnlockHigh: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"UnlockFile\".}" },  { "module": "windows",  "name": "LockFileEx",  "code": "proc LockFileEx*(hFile: HANDLE; dwFlags: DWORD; dwReserved: DWORD; \u000A                 nNumberOfBytesToLockLow: DWORD; \u000A                 nNumberOfBytesToLockHigh: DWORD; lpOverlapped: LPOVERLAPPED): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LockFileEx\".}" },  { "module": "windows",  "name": "UnlockFileEx",  "code": "proc UnlockFileEx*(hFile: HANDLE; dwReserved: DWORD; \u000A                   nNumberOfBytesToUnlockLow: DWORD; \u000A                   nNumberOfBytesToUnlockHigh: DWORD; lpOverlapped: LPOVERLAPPED): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UnlockFileEx\".}" },  { "module": "windows",  "name": "GetFileInformationByHandle",  "code": "proc GetFileInformationByHandle*(hFile: HANDLE; lpFileInformation: LPBY_HANDLE_FILE_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFileInformationByHandle\".}" },  { "module": "windows",  "name": "GetFileType",  "code": "proc GetFileType*(hFile: HANDLE): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetFileType\".}" },  { "module": "windows",  "name": "GetFileSize",  "code": "proc GetFileSize*(hFile: HANDLE; lpFileSizeHigh: LPDWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileSize\".}" },  { "module": "windows",  "name": "GetStdHandle",  "code": "proc GetStdHandle*(nStdHandle: DWORD): HANDLE {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetStdHandle\".}" },  { "module": "windows",  "name": "SetStdHandle",  "code": "proc SetStdHandle*(nStdHandle: DWORD; hHandle: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetStdHandle\".}" },  { "module": "windows",  "name": "FlushFileBuffers",  "code": "proc FlushFileBuffers*(hFile: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FlushFileBuffers\".}" },  { "module": "windows",  "name": "DeviceIoControl",  "code": "proc DeviceIoControl*(hDevice: HANDLE; dwIoControlCode: DWORD; \u000A                      lpInBuffer: LPVOID; nInBufferSize: DWORD; \u000A                      lpOutBuffer: LPVOID; nOutBufferSize: DWORD; \u000A                      lpBytesReturned: LPDWORD; lpOverlapped: LPOVERLAPPED): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"DeviceIoControl\".}" },  { "module": "windows",  "name": "SetEndOfFile",  "code": "proc SetEndOfFile*(hFile: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetEndOfFile\".}" },  { "module": "windows",  "name": "SetFilePointer",  "code": "proc SetFilePointer*(hFile: HANDLE; lDistanceToMove: LONG; \u000A                     lpDistanceToMoveHigh: PLONG; dwMoveMethod: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFilePointer\".}" },  { "module": "windows",  "name": "FindClose",  "code": "proc FindClose*(hFindFile: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FindClose\".}" },  { "module": "windows",  "name": "GetFileTime",  "code": "proc GetFileTime*(hFile: HANDLE; lpCreationTime: LPFILETIME; \u000A                  lpLastAccessTime: LPFILETIME; lpLastWriteTime: LPFILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFileTime\".}" },  { "module": "windows",  "name": "SetFileTime",  "code": "proc SetFileTime*(hFile: HANDLE; lpCreationTime: LPFILETIME; \u000A                  lpLastAccessTime: LPFILETIME; lpLastWriteTime: LPFILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileTime\".}" },  { "module": "windows",  "name": "CloseHandle",  "code": "proc CloseHandle*(hObject: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CloseHandle\".}" },  { "module": "windows",  "name": "DuplicateHandle",  "code": "proc DuplicateHandle*(hSourceProcessHandle: HANDLE; hSourceHandle: HANDLE; \u000A                      hTargetProcessHandle: HANDLE; lpTargetHandle: LPHANDLE; \u000A                      dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; \u000A                      dwOptions: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"DuplicateHandle\".}" },  { "module": "windows",  "name": "GetHandleInformation",  "code": "proc GetHandleInformation*(hObject: HANDLE; lpdwFlags: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetHandleInformation\".}" },  { "module": "windows",  "name": "SetHandleInformation",  "code": "proc SetHandleInformation*(hObject: HANDLE; dwMask: DWORD; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetHandleInformation\".}" },  { "module": "windows",  "name": "LoadModule",  "code": "proc LoadModule*(lpModuleName: LPCSTR; lpParameterBlock: LPVOID): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"LoadModule\".}" },  { "module": "windows",  "name": "WinExec",  "code": "proc WinExec*(lpCmdLine: LPCSTR; uCmdShow: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WinExec\".}" },  { "module": "windows",  "name": "ClearCommBreak",  "code": "proc ClearCommBreak*(hFile: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ClearCommBreak\".}" },  { "module": "windows",  "name": "ClearCommError",  "code": "proc ClearCommError*(hFile: HANDLE; lpErrors: LPDWORD; lpStat: LPCOMSTAT): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ClearCommError\".}" },  { "module": "windows",  "name": "SetupComm",  "code": "proc SetupComm*(hFile: HANDLE; dwInQueue: DWORD; dwOutQueue: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetupComm\".}" },  { "module": "windows",  "name": "EscapeCommFunction",  "code": "proc EscapeCommFunction*(hFile: HANDLE; dwFunc: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EscapeCommFunction\".}" },  { "module": "windows",  "name": "GetCommConfig",  "code": "proc GetCommConfig*(hCommDev: HANDLE; lpCC: LPCOMMCONFIG; lpdwSize: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommConfig\".}" },  { "module": "windows",  "name": "GetCommProperties",  "code": "proc GetCommProperties*(hFile: HANDLE; lpCommProp: LPCOMMPROP): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommProperties\".}" },  { "module": "windows",  "name": "GetCommModemStatus",  "code": "proc GetCommModemStatus*(hFile: HANDLE; lpModemStat: PDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCommModemStatus\".}" },  { "module": "windows",  "name": "GetCommState",  "code": "proc GetCommState*(hFile: HANDLE; lpDCB: PDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCommState\".}" },  { "module": "windows",  "name": "GetCommTimeouts",  "code": "proc GetCommTimeouts*(hFile: HANDLE; lpCommTimeouts: PCOMMTIMEOUTS): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommTimeouts\".}" },  { "module": "windows",  "name": "PurgeComm",  "code": "proc PurgeComm*(hFile: HANDLE; dwFlags: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"PurgeComm\".}" },  { "module": "windows",  "name": "SetCommBreak",  "code": "proc SetCommBreak*(hFile: HANDLE): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetCommBreak\".}" },  { "module": "windows",  "name": "SetCommConfig",  "code": "proc SetCommConfig*(hCommDev: HANDLE; lpCC: LPCOMMCONFIG; dwSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetCommConfig\".}" },  { "module": "windows",  "name": "SetCommMask",  "code": "proc SetCommMask*(hFile: HANDLE; dwEvtMask: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCommMask\".}" },  { "module": "windows",  "name": "SetCommState",  "code": "proc SetCommState*(hFile: HANDLE; lpDCB: LPDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCommState\".}" },  { "module": "windows",  "name": "SetCommTimeouts",  "code": "proc SetCommTimeouts*(hFile: HANDLE; lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetCommTimeouts\".}" },  { "module": "windows",  "name": "TransmitCommChar",  "code": "proc TransmitCommChar*(hFile: HANDLE; cChar: char): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TransmitCommChar\".}" },  { "module": "windows",  "name": "WaitCommEvent",  "code": "proc WaitCommEvent*(hFile: HANDLE; lpEvtMask: LPDWORD; \u000A                    lpOverlapped: LPOVERLAPPED): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WaitCommEvent\".}" },  { "module": "windows",  "name": "SetTapePosition",  "code": "proc SetTapePosition*(hDevice: HANDLE; dwPositionMethod: DWORD; \u000A                      dwPartition: DWORD; dwOffsetLow: DWORD; \u000A                      dwOffsetHigh: DWORD; bImmediate: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetTapePosition\".}" },  { "module": "windows",  "name": "GetTapePosition",  "code": "proc GetTapePosition*(hDevice: HANDLE; dwPositionType: DWORD; \u000A                      lpdwPartition: LPDWORD; lpdwOffsetLow: LPDWORD; \u000A                      lpdwOffsetHigh: LPDWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTapePosition\".}" },  { "module": "windows",  "name": "PrepareTape",  "code": "proc PrepareTape*(hDevice: HANDLE; dwOperation: DWORD; bImmediate: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PrepareTape\".}" },  { "module": "windows",  "name": "EraseTape",  "code": "proc EraseTape*(hDevice: HANDLE; dwEraseType: DWORD; bImmediate: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"EraseTape\".}" },  { "module": "windows",  "name": "CreateTapePartition",  "code": "proc CreateTapePartition*(hDevice: HANDLE; dwPartitionMethod: DWORD; \u000A                          dwCount: DWORD; dwSize: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateTapePartition\".}" },  { "module": "windows",  "name": "WriteTapemark",  "code": "proc WriteTapemark*(hDevice: HANDLE; dwTapemarkType: DWORD; \u000A                    dwTapemarkCount: DWORD; bImmediate: WINBOOL): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteTapemark\".}" },  { "module": "windows",  "name": "GetTapeStatus",  "code": "proc GetTapeStatus*(hDevice: HANDLE): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetTapeStatus\".}" },  { "module": "windows",  "name": "GetTapeParameters",  "code": "proc GetTapeParameters*(hDevice: HANDLE; dwOperation: DWORD; lpdwSize: LPDWORD; \u000A                        lpTapeInformation: LPVOID): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTapeParameters\".}" },  { "module": "windows",  "name": "SetTapeParameters",  "code": "proc SetTapeParameters*(hDevice: HANDLE; dwOperation: DWORD; \u000A                        lpTapeInformation: LPVOID): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetTapeParameters\".}" },  { "module": "windows",  "name": "Beep",  "code": "proc Beep*(dwFreq: DWORD; dwDuration: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"Beep\".}" },  { "module": "windows",  "name": "MulDiv",  "code": "proc MulDiv*(nNumber: int32; nNumerator: int32; nDenominator: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MulDiv\".}" },  { "module": "windows",  "name": "GetSystemTime",  "code": "proc GetSystemTime*(lpSystemTime: LPSYSTEMTIME) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemTime\".}" },  { "module": "windows",  "name": "GetSystemTimeAsFileTime",  "code": "proc GetSystemTimeAsFileTime*(lpSystemTimeAsFileTime: LPFILETIME) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetSystemTimeAsFileTime\".}" },  { "module": "windows",  "name": "SetSystemTime",  "code": "proc SetSystemTime*(lpSystemTime: LPSYSTEMTIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetSystemTime\".}" },  { "module": "windows",  "name": "GetLocalTime",  "code": "proc GetLocalTime*(lpSystemTime: LPSYSTEMTIME) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetLocalTime\".}" },  { "module": "windows",  "name": "SetLocalTime",  "code": "proc SetLocalTime*(lpSystemTime: LPSYSTEMTIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetLocalTime\".}" },  { "module": "windows",  "name": "GetSystemInfo",  "code": "proc GetSystemInfo*(lpSystemInfo: LPSYSTEM_INFO) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemInfo\".}" },  { "module": "windows",  "name": "SystemTimeToTzSpecificLocalTime",  "code": "proc SystemTimeToTzSpecificLocalTime*(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION; \u000A                                      lpUniversalTime: LPSYSTEMTIME; \u000A                                      lpLocalTime: LPSYSTEMTIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SystemTimeToTzSpecificLocalTime\".}" },  { "module": "windows",  "name": "GetTimeZoneInformation",  "code": "proc GetTimeZoneInformation*(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTimeZoneInformation\".}" },  { "module": "windows",  "name": "SetTimeZoneInformation",  "code": "proc SetTimeZoneInformation*(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetTimeZoneInformation\".}" },  { "module": "windows",  "name": "SystemTimeToFileTime",  "code": "proc SystemTimeToFileTime*(lpSystemTime: LPSYSTEMTIME; lpFileTime: LPFILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SystemTimeToFileTime\".}" },  { "module": "windows",  "name": "FileTimeToLocalFileTime",  "code": "proc FileTimeToLocalFileTime*(FileTime: LPFILETIME; lpLocalFileTime: LPFILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FileTimeToLocalFileTime\".}" },  { "module": "windows",  "name": "LocalFileTimeToFileTime",  "code": "proc LocalFileTimeToFileTime*(lpLocalFileTime: LPFILETIME; \u000A                              lpFileTime: LPFILETIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LocalFileTimeToFileTime\".}" },  { "module": "windows",  "name": "FileTimeToSystemTime",  "code": "proc FileTimeToSystemTime*(lpFileTime: LPFILETIME; lpSystemTime: LPSYSTEMTIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FileTimeToSystemTime\".}" },  { "module": "windows",  "name": "CompareFileTime",  "code": "proc CompareFileTime*(lpFileTime1: LPFILETIME; lpFileTime2: LPFILETIME): LONG {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CompareFileTime\".}" },  { "module": "windows",  "name": "FileTimeToDosDateTime",  "code": "proc FileTimeToDosDateTime*(lpFileTime: LPFILETIME; lpFatDate: LPWORD; \u000A                            lpFatTime: LPWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FileTimeToDosDateTime\".}" },  { "module": "windows",  "name": "DosDateTimeToFileTime",  "code": "proc DosDateTimeToFileTime*(wFatDate: int16; wFatTime: int16; \u000A                            lpFileTime: LPFILETIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DosDateTimeToFileTime\".}" },  { "module": "windows",  "name": "GetTickCount",  "code": "proc GetTickCount*(): DWORD {.stdcall, dynlib: \"kernel32\", \u000A                              importc: \"GetTickCount\".}" },  { "module": "windows",  "name": "SetSystemTimeAdjustment",  "code": "proc SetSystemTimeAdjustment*(dwTimeAdjustment: DWORD; \u000A                              bTimeAdjustmentDisabled: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetSystemTimeAdjustment\".}" },  { "module": "windows",  "name": "GetSystemTimeAdjustment",  "code": "proc GetSystemTimeAdjustment*(lpTimeAdjustment: PDWORD; lpTimeIncrement: PDWORD; \u000A                              lpTimeAdjustmentDisabled: PWINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetSystemTimeAdjustment\".}" },  { "module": "windows",  "name": "CreatePipe",  "code": "proc CreatePipe*(hReadPipe: PHANDLE; hWritePipe: PHANDLE; \u000A                 lpPipeAttributes: LPSECURITY_ATTRIBUTES; nSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreatePipe\".}" },  { "module": "windows",  "name": "ConnectNamedPipe",  "code": "proc ConnectNamedPipe*(hNamedPipe: HANDLE; lpOverlapped: LPOVERLAPPED): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ConnectNamedPipe\".}" },  { "module": "windows",  "name": "DisconnectNamedPipe",  "code": "proc DisconnectNamedPipe*(hNamedPipe: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DisconnectNamedPipe\".}" },  { "module": "windows",  "name": "SetNamedPipeHandleState",  "code": "proc SetNamedPipeHandleState*(hNamedPipe: HANDLE; lpMode: LPDWORD; \u000A                              lpMaxCollectionCount: LPDWORD; \u000A                              lpCollectDataTimeout: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetNamedPipeHandleState\".}" },  { "module": "windows",  "name": "GetNamedPipeInfo",  "code": "proc GetNamedPipeInfo*(hNamedPipe: HANDLE; lpFlags: LPDWORD; \u000A                       lpOutBufferSize: LPDWORD; lpInBufferSize: LPDWORD; \u000A                       lpMaxInstances: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetNamedPipeInfo\".}" },  { "module": "windows",  "name": "PeekNamedPipe",  "code": "proc PeekNamedPipe*(hNamedPipe: HANDLE; lpBuffer: LPVOID; nBufferSize: DWORD; \u000A                    lpBytesRead: LPDWORD; lpTotalBytesAvail: LPDWORD; \u000A                    lpBytesLeftThisMessage: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"PeekNamedPipe\".}" },  { "module": "windows",  "name": "TransactNamedPipe",  "code": "proc TransactNamedPipe*(hNamedPipe: HANDLE; lpInBuffer: LPVOID; \u000A                        nInBufferSize: DWORD; lpOutBuffer: LPVOID; \u000A                        nOutBufferSize: DWORD; lpBytesRead: LPDWORD; \u000A                        lpOverlapped: LPOVERLAPPED): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TransactNamedPipe\".}" },  { "module": "windows",  "name": "GetMailslotInfo",  "code": "proc GetMailslotInfo*(hMailslot: HANDLE; lpMaxMessageSize: LPDWORD; \u000A                      lpNextSize: LPDWORD; lpMessageCount: LPDWORD; \u000A                      lpReadTimeout: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetMailslotInfo\".}" },  { "module": "windows",  "name": "SetMailslotInfo",  "code": "proc SetMailslotInfo*(hMailslot: HANDLE; lReadTimeout: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetMailslotInfo\".}" },  { "module": "windows",  "name": "MapViewOfFile",  "code": "proc MapViewOfFile*(hFileMappingObject: HANDLE; dwDesiredAccess: DWORD; \u000A                    dwFileOffsetHigh: DWORD; dwFileOffsetLow: DWORD; \u000A                    dwNumberOfBytesToMap: DWORD): LPVOID {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"MapViewOfFile\".}" },  { "module": "windows",  "name": "FlushViewOfFile",  "code": "proc FlushViewOfFile*(lpBaseAddress: LPCVOID; dwNumberOfBytesToFlush: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FlushViewOfFile\".}" },  { "module": "windows",  "name": "UnmapViewOfFile",  "code": "proc UnmapViewOfFile*(lpBaseAddress: LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"UnmapViewOfFile\".}" },  { "module": "windows",  "name": "OpenFile",  "code": "proc OpenFile*(lpFileName: LPCSTR; lpReOpenBuff: LPOFSTRUCT; uStyle: WINUINT): HFILE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"OpenFile\".}" },  { "module": "windows",  "name": "lopen",  "code": "proc lopen*(lpPathName: LPCSTR; iReadWrite: int32): HFILE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_lopen\".}" },  { "module": "windows",  "name": "lcreat",  "code": "proc lcreat*(lpPathName: LPCSTR; iAttribute: int32): HFILE {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_lcreat\".}" },  { "module": "windows",  "name": "lread",  "code": "proc lread*(hFile: HFILE; lpBuffer: LPVOID; uBytes: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_lread\".}" },  { "module": "windows",  "name": "lwrite",  "code": "proc lwrite*(hFile: HFILE; lpBuffer: LPCSTR; uBytes: WINUINT): WINUINT {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"_lwrite\".}" },  { "module": "windows",  "name": "hread",  "code": "proc hread*(hFile: HFILE; lpBuffer: LPVOID; lBytes: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_hread\".}" },  { "module": "windows",  "name": "hwrite",  "code": "proc hwrite*(hFile: HFILE; lpBuffer: LPCSTR; lBytes: int32): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_hwrite\".}" },  { "module": "windows",  "name": "lclose",  "code": "proc lclose*(file: HFILE): HFILE {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"_lclose\".}" },  { "module": "windows",  "name": "llseek",  "code": "proc llseek*(file: HFILE; lOffset: LONG; iOrigin: int32): LONG {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"_llseek\".}" },  { "module": "windows",  "name": "IsTextUnicode",  "code": "proc IsTextUnicode*(lpBuffer: LPVOID; cb: int32; lpi: LPINT): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"IsTextUnicode\".}" },  { "module": "windows",  "name": "TlsAlloc",  "code": "proc TlsAlloc*(): DWORD {.stdcall, dynlib: \"kernel32\", importc: \"TlsAlloc\".}" },  { "module": "windows",  "name": "TlsGetValue",  "code": "proc TlsGetValue*(dwTlsIndex: DWORD): LPVOID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"TlsGetValue\".}" },  { "module": "windows",  "name": "TlsSetValue",  "code": "proc TlsSetValue*(dwTlsIndex: DWORD; lpTlsValue: LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TlsSetValue\".}" },  { "module": "windows",  "name": "TlsFree",  "code": "proc TlsFree*(dwTlsIndex: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"TlsFree\".}" },  { "module": "windows",  "name": "SleepEx",  "code": "proc SleepEx*(dwMilliseconds: DWORD; bAlertable: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SleepEx\".}" },  { "module": "windows",  "name": "WaitForSingleObjectEx",  "code": "proc WaitForSingleObjectEx*(hHandle: HANDLE; dwMilliseconds: DWORD; \u000A                            bAlertable: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WaitForSingleObjectEx\".}" },  { "module": "windows",  "name": "WaitForMultipleObjectsEx",  "code": "proc WaitForMultipleObjectsEx*(nCount: DWORD; lpHandles: LPHANDLE; \u000A                               bWaitAll: WINBOOL; dwMilliseconds: DWORD; \u000A                               bAlertable: WINBOOL): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WaitForMultipleObjectsEx\".}" },  { "module": "windows",  "name": "ReadFileEx",  "code": "proc ReadFileEx*(hFile: HANDLE; lpBuffer: LPVOID; nNumberOfBytesToRead: DWORD; \u000A                 lpOverlapped: LPOVERLAPPED; \u000A                 lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadFileEx\".}" },  { "module": "windows",  "name": "WriteFileEx",  "code": "proc WriteFileEx*(hFile: HANDLE; lpBuffer: LPCVOID; \u000A                  nNumberOfBytesToWrite: DWORD; lpOverlapped: LPOVERLAPPED; \u000A                  lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteFileEx\".}" },  { "module": "windows",  "name": "BackupRead",  "code": "proc BackupRead*(hFile: HANDLE; lpBuffer: LPBYTE; nNumberOfBytesToRead: DWORD; \u000A                 lpNumberOfBytesRead: LPDWORD; bAbort: WINBOOL; \u000A                 bProcessSecurity: WINBOOL; lpContext: var LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BackupRead\".}" },  { "module": "windows",  "name": "BackupSeek",  "code": "proc BackupSeek*(hFile: HANDLE; dwLowBytesToSeek: DWORD; \u000A                 dwHighBytesToSeek: DWORD; lpdwLowByteSeeked: LPDWORD; \u000A                 lpdwHighByteSeeked: LPDWORD; lpContext: var LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BackupSeek\".}" },  { "module": "windows",  "name": "BackupWrite",  "code": "proc BackupWrite*(hFile: HANDLE; lpBuffer: LPBYTE; nNumberOfBytesToWrite: DWORD; \u000A                  lpNumberOfBytesWritten: LPDWORD; bAbort: WINBOOL; \u000A                  bProcessSecurity: WINBOOL; lpContext: var LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BackupWrite\".}" },  { "module": "windows",  "name": "SetProcessShutdownParameters",  "code": "proc SetProcessShutdownParameters*(dwLevel: DWORD; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetProcessShutdownParameters\".}" },  { "module": "windows",  "name": "GetProcessShutdownParameters",  "code": "proc GetProcessShutdownParameters*(lpdwLevel: LPDWORD; lpdwFlags: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessShutdownParameters\".}" },  { "module": "windows",  "name": "SetFileApisToOEM",  "code": "proc SetFileApisToOEM*() {.stdcall, dynlib: \"kernel32\", \u000A                           importc: \"SetFileApisToOEM\".}" },  { "module": "windows",  "name": "SetFileApisToANSI",  "code": "proc SetFileApisToANSI*() {.stdcall, dynlib: \"kernel32\", \u000A                            importc: \"SetFileApisToANSI\".}" },  { "module": "windows",  "name": "AreFileApisANSI",  "code": "proc AreFileApisANSI*(): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"AreFileApisANSI\".}" },  { "module": "windows",  "name": "CloseEventLog",  "code": "proc CloseEventLog*(hEventLog: HANDLE): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"CloseEventLog\".}" },  { "module": "windows",  "name": "DeregisterEventSource",  "code": "proc DeregisterEventSource*(hEventLog: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"DeregisterEventSource\".}" },  { "module": "windows",  "name": "NotifyChangeEventLog",  "code": "proc NotifyChangeEventLog*(hEventLog: HANDLE; hEvent: HANDLE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"NotifyChangeEventLog\".}" },  { "module": "windows",  "name": "GetNumberOfEventLogRecords",  "code": "proc GetNumberOfEventLogRecords*(hEventLog: HANDLE; NumberOfRecords: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetNumberOfEventLogRecords\".}" },  { "module": "windows",  "name": "GetOldestEventLogRecord",  "code": "proc GetOldestEventLogRecord*(hEventLog: HANDLE; OldestRecord: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetOldestEventLogRecord\".}" },  { "module": "windows",  "name": "DuplicateToken",  "code": "proc DuplicateToken*(ExistingTokenHandle: HANDLE; \u000A                     ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL; \u000A                     DuplicateTokenHandle: PHANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"DuplicateToken\".}" },  { "module": "windows",  "name": "GetKernelObjectSecurity",  "code": "proc GetKernelObjectSecurity*(Handle: HANDLE; \u000A                              RequestedInformation: SECURITY_INFORMATION; \u000A                              pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                              nLength: DWORD; lpnLengthNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetKernelObjectSecurity\".}" },  { "module": "windows",  "name": "ImpersonateNamedPipeClient",  "code": "proc ImpersonateNamedPipeClient*(hNamedPipe: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ImpersonateNamedPipeClient\".}" },  { "module": "windows",  "name": "ImpersonateLoggedOnUser",  "code": "proc ImpersonateLoggedOnUser*(hToken: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ImpersonateLoggedOnUser\".}" },  { "module": "windows",  "name": "ImpersonateSelf",  "code": "proc ImpersonateSelf*(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ImpersonateSelf\".}" },  { "module": "windows",  "name": "RevertToSelf",  "code": "proc RevertToSelf*(): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A                                importc: \"RevertToSelf\".}" },  { "module": "windows",  "name": "SetThreadToken",  "code": "proc SetThreadToken*(Thread: PHANDLE; Token: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetThreadToken\".}" },  { "module": "windows",  "name": "OpenProcessToken",  "code": "proc OpenProcessToken*(ProcessHandle: HANDLE; DesiredAccess: DWORD; \u000A                       TokenHandle: PHANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenProcessToken\".}" },  { "module": "windows",  "name": "OpenThreadToken",  "code": "proc OpenThreadToken*(ThreadHandle: HANDLE; DesiredAccess: DWORD; \u000A                      OpenAsSelf: WINBOOL; TokenHandle: PHANDLE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenThreadToken\".}" },  { "module": "windows",  "name": "GetTokenInformation",  "code": "proc GetTokenInformation*(TokenHandle: HANDLE; \u000A                          TokenInformationClass: TOKEN_INFORMATION_CLASS; \u000A                          TokenInformation: LPVOID; \u000A                          TokenInformationLength: DWORD; ReturnLength: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetTokenInformation\".}" },  { "module": "windows",  "name": "SetTokenInformation",  "code": "proc SetTokenInformation*(TokenHandle: HANDLE; \u000A                          TokenInformationClass: TOKEN_INFORMATION_CLASS; \u000A                          TokenInformation: LPVOID; \u000A                          TokenInformationLength: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetTokenInformation\".}" },  { "module": "windows",  "name": "AdjustTokenPrivileges",  "code": "proc AdjustTokenPrivileges*(TokenHandle: HANDLE; DisableAllPrivileges: WINBOOL; \u000A                            NewState: PTOKEN_PRIVILEGES; BufferLength: DWORD; \u000A                            PreviousState: PTOKEN_PRIVILEGES; \u000A                            ReturnLength: PDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AdjustTokenPrivileges\".}" },  { "module": "windows",  "name": "AdjustTokenGroups",  "code": "proc AdjustTokenGroups*(TokenHandle: HANDLE; ResetToDefault: WINBOOL; \u000A                        NewState: PTOKEN_GROUPS; BufferLength: DWORD; \u000A                        PreviousState: PTOKEN_GROUPS; ReturnLength: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AdjustTokenGroups\".}" },  { "module": "windows",  "name": "PrivilegeCheck",  "code": "proc PrivilegeCheck*(ClientToken: HANDLE; RequiredPrivileges: PPRIVILEGE_SET; \u000A                     pfResult: LPBOOL): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"PrivilegeCheck\".}" },  { "module": "windows",  "name": "IsValidSid",  "code": "proc IsValidSid*(pSid: PSID): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A                                        importc: \"IsValidSid\".}" },  { "module": "windows",  "name": "EqualSid",  "code": "proc EqualSid*(pSid1: PSID; pSid2: PSID): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"EqualSid\".}" },  { "module": "windows",  "name": "EqualPrefixSid",  "code": "proc EqualPrefixSid*(pSid1: PSID; pSid2: PSID): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"EqualPrefixSid\".}" },  { "module": "windows",  "name": "GetSidLengthRequired",  "code": "proc GetSidLengthRequired*(nSubAuthorityCount: UCHAR): DWORD {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetSidLengthRequired\".}" },  { "module": "windows",  "name": "AllocateAndInitializeSid",  "code": "proc AllocateAndInitializeSid*(pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY; \u000A                               nSubAuthorityCount: int8; nSubAuthority0: DWORD; \u000A                               nSubAuthority1: DWORD; nSubAuthority2: DWORD; \u000A                               nSubAuthority3: DWORD; nSubAuthority4: DWORD; \u000A                               nSubAuthority5: DWORD; nSubAuthority6: DWORD; \u000A                               nSubAuthority7: DWORD; pSid: var PSID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AllocateAndInitializeSid\".}" },  { "module": "windows",  "name": "FreeSid",  "code": "proc FreeSid*(pSid: PSID): PVOID {.stdcall, dynlib: \"advapi32\", \u000A                                   importc: \"FreeSid\".}" },  { "module": "windows",  "name": "InitializeSid",  "code": "proc InitializeSid*(Sid: PSID; pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY; \u000A                    nSubAuthorityCount: int8): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitializeSid\".}" },  { "module": "windows",  "name": "GetSidIdentifierAuthority",  "code": "proc GetSidIdentifierAuthority*(pSid: PSID): PSID_IDENTIFIER_AUTHORITY {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetSidIdentifierAuthority\".}" },  { "module": "windows",  "name": "GetSidSubAuthority",  "code": "proc GetSidSubAuthority*(pSid: PSID; nSubAuthority: DWORD): PDWORD {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetSidSubAuthority\".}" },  { "module": "windows",  "name": "GetSidSubAuthorityCount",  "code": "proc GetSidSubAuthorityCount*(pSid: PSID): PUCHAR {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"GetSidSubAuthorityCount\".}" },  { "module": "windows",  "name": "GetLengthSid",  "code": "proc GetLengthSid*(pSid: PSID): DWORD {.stdcall, dynlib: \"advapi32\", \u000A                                        importc: \"GetLengthSid\".}" },  { "module": "windows",  "name": "CopySid",  "code": "proc CopySid*(nDestinationSidLength: DWORD; pDestinationSid: PSID; \u000A              pSourceSid: PSID): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"CopySid\".}" },  { "module": "windows",  "name": "AreAllAccessesGranted",  "code": "proc AreAllAccessesGranted*(GrantedAccess: DWORD; DesiredAccess: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AreAllAccessesGranted\".}" },  { "module": "windows",  "name": "AreAnyAccessesGranted",  "code": "proc AreAnyAccessesGranted*(GrantedAccess: DWORD; DesiredAccess: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AreAnyAccessesGranted\".}" },  { "module": "windows",  "name": "MapGenericMask",  "code": "proc MapGenericMask*(AccessMask: PDWORD; GenericMapping: PGENERIC_MAPPING) {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"MapGenericMask\".}" },  { "module": "windows",  "name": "IsValidAcl",  "code": "proc IsValidAcl*(pAcl: PACL): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A                                        importc: \"IsValidAcl\".}" },  { "module": "windows",  "name": "InitializeAcl",  "code": "proc InitializeAcl*(pAcl: PACL; nAclLength: DWORD; dwAclRevision: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"InitializeAcl\".}" },  { "module": "windows",  "name": "GetAclInformation",  "code": "proc GetAclInformation*(pAcl: PACL; pAclInformation: LPVOID; \u000A                        nAclInformationLength: DWORD; \u000A                        dwAclInformationClass: ACL_INFORMATION_CLASS): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetAclInformation\".}" },  { "module": "windows",  "name": "SetAclInformation",  "code": "proc SetAclInformation*(pAcl: PACL; pAclInformation: LPVOID; \u000A                        nAclInformationLength: DWORD; \u000A                        dwAclInformationClass: ACL_INFORMATION_CLASS): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetAclInformation\".}" },  { "module": "windows",  "name": "AddAce",  "code": "proc AddAce*(pAcl: PACL; dwAceRevision: DWORD; dwStartingAceIndex: DWORD; \u000A             pAceList: LPVOID; nAceListLength: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AddAce\".}" },  { "module": "windows",  "name": "DeleteAce",  "code": "proc DeleteAce*(pAcl: PACL; dwAceIndex: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"DeleteAce\".}" },  { "module": "windows",  "name": "GetAce",  "code": "proc GetAce*(pAcl: PACL; dwAceIndex: DWORD; pAce: var LPVOID): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetAce\".}" },  { "module": "windows",  "name": "AddAccessAllowedAce",  "code": "proc AddAccessAllowedAce*(pAcl: PACL; dwAceRevision: DWORD; AccessMask: DWORD; \u000A                          pSid: PSID): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"AddAccessAllowedAce\".}" },  { "module": "windows",  "name": "AddAccessDeniedAce",  "code": "proc AddAccessDeniedAce*(pAcl: PACL; dwAceRevision: DWORD; AccessMask: DWORD; \u000A                         pSid: PSID): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"AddAccessDeniedAce\".}" },  { "module": "windows",  "name": "AddAuditAccessAce",  "code": "proc AddAuditAccessAce*(pAcl: PACL; dwAceRevision: DWORD; dwAccessMask: DWORD; \u000A                        pSid: PSID; bAuditSuccess: WINBOOL; \u000A                        bAuditFailure: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AddAuditAccessAce\".}" },  { "module": "windows",  "name": "FindFirstFreeAce",  "code": "proc FindFirstFreeAce*(pAcl: PACL; pAce: var LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"FindFirstFreeAce\".}" },  { "module": "windows",  "name": "InitializeSecurityDescriptor",  "code": "proc InitializeSecurityDescriptor*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                   dwRevision: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitializeSecurityDescriptor\".}" },  { "module": "windows",  "name": "IsValidSecurityDescriptor",  "code": "proc IsValidSecurityDescriptor*(pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"IsValidSecurityDescriptor\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorLength",  "code": "proc GetSecurityDescriptorLength*(pSecurityDescriptor: PSECURITY_DESCRIPTOR): DWORD {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetSecurityDescriptorLength\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorControl",  "code": "proc GetSecurityDescriptorControl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                   pControl: PSECURITY_DESCRIPTOR_CONTROL; \u000A                                   lpdwRevision: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetSecurityDescriptorControl\".}" },  { "module": "windows",  "name": "SetSecurityDescriptorDacl",  "code": "proc SetSecurityDescriptorDacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                bDaclPresent: WINBOOL; pDacl: PACL; \u000A                                bDaclDefaulted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetSecurityDescriptorDacl\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorDacl",  "code": "proc GetSecurityDescriptorDacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                lpbDaclPresent: LPBOOL; pDacl: var PACL; \u000A                                lpbDaclDefaulted: LPBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetSecurityDescriptorDacl\".}" },  { "module": "windows",  "name": "SetSecurityDescriptorSacl",  "code": "proc SetSecurityDescriptorSacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                bSaclPresent: WINBOOL; pSacl: PACL; \u000A                                bSaclDefaulted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetSecurityDescriptorSacl\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorSacl",  "code": "proc GetSecurityDescriptorSacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                lpbSaclPresent: LPBOOL; pSacl: var PACL; \u000A                                lpbSaclDefaulted: LPBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetSecurityDescriptorSacl\".}" },  { "module": "windows",  "name": "SetSecurityDescriptorOwner",  "code": "proc SetSecurityDescriptorOwner*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                 pOwner: PSID; bOwnerDefaulted: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetSecurityDescriptorOwner\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorOwner",  "code": "proc GetSecurityDescriptorOwner*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                 pOwner: var PSID; lpbOwnerDefaulted: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetSecurityDescriptorOwner\".}" },  { "module": "windows",  "name": "SetSecurityDescriptorGroup",  "code": "proc SetSecurityDescriptorGroup*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                 pGroup: PSID; bGroupDefaulted: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetSecurityDescriptorGroup\".}" },  { "module": "windows",  "name": "GetSecurityDescriptorGroup",  "code": "proc GetSecurityDescriptorGroup*(pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                 pGroup: var PSID; lpbGroupDefaulted: LPBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetSecurityDescriptorGroup\".}" },  { "module": "windows",  "name": "CreatePrivateObjectSecurity",  "code": "proc CreatePrivateObjectSecurity*(ParentDescriptor: PSECURITY_DESCRIPTOR; \u000A                                  CreatorDescriptor: PSECURITY_DESCRIPTOR; \u000A                                  NewDescriptor: var PSECURITY_DESCRIPTOR; \u000A                                  IsDirectoryObject: WINBOOL; Token: HANDLE; \u000A                                  GenericMapping: PGENERIC_MAPPING): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"CreatePrivateObjectSecurity\".}" },  { "module": "windows",  "name": "SetPrivateObjectSecurity",  "code": "proc SetPrivateObjectSecurity*(SecurityInformation: SECURITY_INFORMATION; \u000A                               ModificationDescriptor: PSECURITY_DESCRIPTOR; \u000A    ObjectsSecurityDescriptor: var PSECURITY_DESCRIPTOR; \u000A                               GenericMapping: PGENERIC_MAPPING; Token: HANDLE): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetPrivateObjectSecurity\".}" },  { "module": "windows",  "name": "GetPrivateObjectSecurity",  "code": "proc GetPrivateObjectSecurity*(ObjectDescriptor: PSECURITY_DESCRIPTOR; \u000A                               SecurityInformation: SECURITY_INFORMATION; \u000A                               ResultantDescriptor: PSECURITY_DESCRIPTOR; \u000A                               DescriptorLength: DWORD; ReturnLength: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"GetPrivateObjectSecurity\".}" },  { "module": "windows",  "name": "DestroyPrivateObjectSecurity",  "code": "proc DestroyPrivateObjectSecurity*(ObjectDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"DestroyPrivateObjectSecurity\".}" },  { "module": "windows",  "name": "MakeSelfRelativeSD",  "code": "proc MakeSelfRelativeSD*(pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                         pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                         lpdwBufferLength: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"MakeSelfRelativeSD\".}" },  { "module": "windows",  "name": "MakeAbsoluteSD",  "code": "proc MakeAbsoluteSD*(pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                     pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                     lpdwAbsoluteSecurityDescriptorSize: LPDWORD; pDacl: PACL; \u000A                     lpdwDaclSize: LPDWORD; pSacl: PACL; lpdwSaclSize: LPDWORD; \u000A                     pOwner: PSID; lpdwOwnerSize: LPDWORD; pPrimaryGroup: PSID; \u000A                     lpdwPrimaryGroupSize: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"MakeAbsoluteSD\".}" },  { "module": "windows",  "name": "SetKernelObjectSecurity",  "code": "proc SetKernelObjectSecurity*(Handle: HANDLE; \u000A                              SecurityInformation: SECURITY_INFORMATION; \u000A                              SecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetKernelObjectSecurity\".}" },  { "module": "windows",  "name": "FindNextChangeNotification",  "code": "proc FindNextChangeNotification*(hChangeHandle: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindNextChangeNotification\".}" },  { "module": "windows",  "name": "FindCloseChangeNotification",  "code": "proc FindCloseChangeNotification*(hChangeHandle: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindCloseChangeNotification\".}" },  { "module": "windows",  "name": "VirtualLock",  "code": "proc VirtualLock*(lpAddress: LPVOID; dwSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"VirtualLock\".}" },  { "module": "windows",  "name": "VirtualUnlock",  "code": "proc VirtualUnlock*(lpAddress: LPVOID; dwSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"VirtualUnlock\".}" },  { "module": "windows",  "name": "MapViewOfFileEx",  "code": "proc MapViewOfFileEx*(hFileMappingObject: HANDLE; dwDesiredAccess: DWORD; \u000A                      dwFileOffsetHigh: DWORD; dwFileOffsetLow: DWORD; \u000A                      dwNumberOfBytesToMap: DWORD; lpBaseAddress: LPVOID): LPVOID {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MapViewOfFileEx\".}" },  { "module": "windows",  "name": "SetPriorityClass",  "code": "proc SetPriorityClass*(hProcess: HANDLE; dwPriorityClass: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetPriorityClass\".}" },  { "module": "windows",  "name": "GetPriorityClass",  "code": "proc GetPriorityClass*(hProcess: HANDLE): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetPriorityClass\".}" },  { "module": "windows",  "name": "IsBadReadPtr",  "code": "proc IsBadReadPtr*(lp: pointer; ucb: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadReadPtr\".}" },  { "module": "windows",  "name": "IsBadWritePtr",  "code": "proc IsBadWritePtr*(lp: LPVOID; ucb: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadWritePtr\".}" },  { "module": "windows",  "name": "IsBadHugeReadPtr",  "code": "proc IsBadHugeReadPtr*(lp: pointer; ucb: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadHugeReadPtr\".}" },  { "module": "windows",  "name": "IsBadHugeWritePtr",  "code": "proc IsBadHugeWritePtr*(lp: LPVOID; ucb: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsBadHugeWritePtr\".}" },  { "module": "windows",  "name": "IsBadCodePtr",  "code": "proc IsBadCodePtr*(lpfn: FARPROC): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"IsBadCodePtr\".}" },  { "module": "windows",  "name": "AllocateLocallyUniqueId",  "code": "proc AllocateLocallyUniqueId*(Luid: PLUID): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AllocateLocallyUniqueId\".}" },  { "module": "windows",  "name": "QueryPerformanceCounter",  "code": "proc QueryPerformanceCounter*(lpPerformanceCount: PLARGE_INTEGER): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"QueryPerformanceCounter\".}" },  { "module": "windows",  "name": "QueryPerformanceFrequency",  "code": "proc QueryPerformanceFrequency*(lpFrequency: PLARGE_INTEGER): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"QueryPerformanceFrequency\".}" },  { "module": "windows",  "name": "ActivateKeyboardLayout",  "code": "proc ActivateKeyboardLayout*(hkl: HKL; Flags: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ActivateKeyboardLayout\".}" },  { "module": "windows",  "name": "UnloadKeyboardLayout",  "code": "proc UnloadKeyboardLayout*(hkl: HKL): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"UnloadKeyboardLayout\".}" },  { "module": "windows",  "name": "GetKeyboardLayoutList",  "code": "proc GetKeyboardLayoutList*(nBuff: int32; lpList: var HKL): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetKeyboardLayoutList\".}" },  { "module": "windows",  "name": "GetKeyboardLayout",  "code": "proc GetKeyboardLayout*(dwLayout: DWORD): HKL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetKeyboardLayout\".}" },  { "module": "windows",  "name": "OpenInputDesktop",  "code": "proc OpenInputDesktop*(dwFlags: DWORD; fInherit: WINBOOL; dwDesiredAccess: DWORD): HDESK {.\u000A    stdcall, dynlib: \"user32\", importc: \"OpenInputDesktop\".}" },  { "module": "windows",  "name": "EnumDesktopWindows",  "code": "proc EnumDesktopWindows*(hDesktop: HDESK; lpfn: ENUMWINDOWSPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumDesktopWindows\".}" },  { "module": "windows",  "name": "SwitchDesktop",  "code": "proc SwitchDesktop*(hDesktop: HDESK): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SwitchDesktop\".}" },  { "module": "windows",  "name": "SetThreadDesktop",  "code": "proc SetThreadDesktop*(hDesktop: HDESK): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetThreadDesktop\".}" },  { "module": "windows",  "name": "CloseDesktop",  "code": "proc CloseDesktop*(hDesktop: HDESK): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"CloseDesktop\".}" },  { "module": "windows",  "name": "GetThreadDesktop",  "code": "proc GetThreadDesktop*(dwThreadId: DWORD): HDESK {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetThreadDesktop\".}" },  { "module": "windows",  "name": "CloseWindowStation",  "code": "proc CloseWindowStation*(hWinSta: HWINSTA): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"CloseWindowStation\".}" },  { "module": "windows",  "name": "SetProcessWindowStation",  "code": "proc SetProcessWindowStation*(hWinSta: HWINSTA): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetProcessWindowStation\".}" },  { "module": "windows",  "name": "GetProcessWindowStation",  "code": "proc GetProcessWindowStation*(): HWINSTA {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetProcessWindowStation\".}" },  { "module": "windows",  "name": "SetUserObjectSecurity",  "code": "proc SetUserObjectSecurity*(hObj: HANDLE; pSIRequested: PSECURITY_INFORMATION; \u000A                            pSID: PSECURITY_DESCRIPTOR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetUserObjectSecurity\".}" },  { "module": "windows",  "name": "GetUserObjectSecurity",  "code": "proc GetUserObjectSecurity*(hObj: HANDLE; pSIRequested: PSECURITY_INFORMATION; \u000A                            pSID: PSECURITY_DESCRIPTOR; nLength: DWORD; \u000A                            lpnLengthNeeded: LPDWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetUserObjectSecurity\".}" },  { "module": "windows",  "name": "TranslateMessage",  "code": "proc TranslateMessage*(lpMsg: LPMSG): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"TranslateMessage\".}" },  { "module": "windows",  "name": "SetMessageQueue",  "code": "proc SetMessageQueue*(cMessagesMax: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetMessageQueue\".}" },  { "module": "windows",  "name": "RegisterHotKey",  "code": "proc RegisterHotKey*(wnd: HWND; anID: int32; fsModifiers: WINUINT; vk: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"RegisterHotKey\".}" },  { "module": "windows",  "name": "UnregisterHotKey",  "code": "proc UnregisterHotKey*(wnd: HWND; anID: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"UnregisterHotKey\".}" },  { "module": "windows",  "name": "ExitWindowsEx",  "code": "proc ExitWindowsEx*(uFlags: WINUINT; dwReserved: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ExitWindowsEx\".}" },  { "module": "windows",  "name": "SwapMouseButton",  "code": "proc SwapMouseButton*(fSwap: WINBOOL): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SwapMouseButton\".}" },  { "module": "windows",  "name": "GetMessagePos",  "code": "proc GetMessagePos*(): DWORD {.stdcall, dynlib: \"user32\", \u000A                               importc: \"GetMessagePos\".}" },  { "module": "windows",  "name": "GetMessageTime",  "code": "proc GetMessageTime*(): LONG {.stdcall, dynlib: \"user32\", \u000A                               importc: \"GetMessageTime\".}" },  { "module": "windows",  "name": "GetMessageExtraInfo",  "code": "proc GetMessageExtraInfo*(): LONG {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"GetMessageExtraInfo\".}" },  { "module": "windows",  "name": "SetMessageExtraInfo",  "code": "proc SetMessageExtraInfo*(lp: LPARAM): LPARAM {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetMessageExtraInfo\".}" },  { "module": "windows",  "name": "BroadcastSystemMessage",  "code": "proc BroadcastSystemMessage*(para1: DWORD; para2: LPDWORD; para3: WINUINT; \u000A                             para4: WPARAM; para5: LPARAM): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"BroadcastSystemMessage\".}" },  { "module": "windows",  "name": "AttachThreadInput",  "code": "proc AttachThreadInput*(idAttach: DWORD; idAttachTo: DWORD; fAttach: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"AttachThreadInput\".}" },  { "module": "windows",  "name": "ReplyMessage",  "code": "proc ReplyMessage*(lResult: LRESULT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ReplyMessage\".}" },  { "module": "windows",  "name": "WaitMessage",  "code": "proc WaitMessage*(): WINBOOL {.stdcall, dynlib: \"user32\", importc: \"WaitMessage\".}" },  { "module": "windows",  "name": "WaitForInputIdle",  "code": "proc WaitForInputIdle*(hProcess: HANDLE; dwMilliseconds: DWORD): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"WaitForInputIdle\".}" },  { "module": "windows",  "name": "PostQuitMessage",  "code": "proc PostQuitMessage*(nExitCode: int32) {.stdcall, dynlib: \"user32\", \u000A    importc: \"PostQuitMessage\".}" },  { "module": "windows",  "name": "InSendMessage",  "code": "proc InSendMessage*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                 importc: \"InSendMessage\".}" },  { "module": "windows",  "name": "GetDoubleClickTime",  "code": "proc GetDoubleClickTime*(): WINUINT {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"GetDoubleClickTime\".}" },  { "module": "windows",  "name": "SetDoubleClickTime",  "code": "proc SetDoubleClickTime*(para1: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetDoubleClickTime\".}" },  { "module": "windows",  "name": "IsWindow",  "code": "proc IsWindow*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"IsWindow\".}" },  { "module": "windows",  "name": "IsMenu",  "code": "proc IsMenu*(menu: HMENU): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"IsMenu\".}" },  { "module": "windows",  "name": "IsChild",  "code": "proc IsChild*(hWndParent: HWND; wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsChild\".}" },  { "module": "windows",  "name": "DestroyWindow",  "code": "proc DestroyWindow*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DestroyWindow\".}" },  { "module": "windows",  "name": "ShowWindow",  "code": "proc ShowWindow*(wnd: HWND; nCmdShow: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ShowWindow\".}" },  { "module": "windows",  "name": "ShowWindowAsync",  "code": "proc ShowWindowAsync*(wnd: HWND; nCmdShow: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ShowWindowAsync\".}" },  { "module": "windows",  "name": "FlashWindow",  "code": "proc FlashWindow*(wnd: HWND; bInvert: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"FlashWindow\".}" },  { "module": "windows",  "name": "ShowOwnedPopups",  "code": "proc ShowOwnedPopups*(wnd: HWND; fShow: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ShowOwnedPopups\".}" },  { "module": "windows",  "name": "OpenIcon",  "code": "proc OpenIcon*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"OpenIcon\".}" },  { "module": "windows",  "name": "CloseWindow",  "code": "proc CloseWindow*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"CloseWindow\".}" },  { "module": "windows",  "name": "MoveWindow",  "code": "proc MoveWindow*(wnd: HWND; X: int32; Y: int32; nWidth: int32; nHeight: int32; \u000A                 bRepaint: WINBOOL): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"MoveWindow\".}" },  { "module": "windows",  "name": "SetWindowPos",  "code": "proc SetWindowPos*(wnd: HWND; hWndInsertAfter: HWND; X: int32; Y: int32; \u000A                   cx: int32; cy: int32; uFlags: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowPos\".}" },  { "module": "windows",  "name": "GetWindowPlacement",  "code": "proc GetWindowPlacement*(wnd: HWND; lpwndpl: var WINDOWPLACEMENT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowPlacement\".}" },  { "module": "windows",  "name": "SetWindowPlacement",  "code": "proc SetWindowPlacement*(wnd: HWND; lpwndpl: var WINDOWPLACEMENT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetWindowPlacement\".}" },  { "module": "windows",  "name": "GetWindowPlacement",  "code": "proc GetWindowPlacement*(wnd: HWND; lpwndpl: PWINDOWPLACEMENT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowPlacement\".}" },  { "module": "windows",  "name": "SetWindowPlacement",  "code": "proc SetWindowPlacement*(wnd: HWND; lpwndpl: PWINDOWPLACEMENT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetWindowPlacement\".}" },  { "module": "windows",  "name": "BeginDeferWindowPos",  "code": "proc BeginDeferWindowPos*(nNumWindows: int32): HDWP {.stdcall, dynlib: \"user32\", \u000A    importc: \"BeginDeferWindowPos\".}" },  { "module": "windows",  "name": "DeferWindowPos",  "code": "proc DeferWindowPos*(hWinPosInfo: HDWP; wnd: HWND; hWndInsertAfter: HWND; \u000A                     x: int32; y: int32; cx: int32; cy: int32; uFlags: WINUINT): HDWP {.\u000A    stdcall, dynlib: \"user32\", importc: \"DeferWindowPos\".}" },  { "module": "windows",  "name": "EndDeferWindowPos",  "code": "proc EndDeferWindowPos*(hWinPosInfo: HDWP): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"EndDeferWindowPos\".}" },  { "module": "windows",  "name": "IsWindowVisible",  "code": "proc IsWindowVisible*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsWindowVisible\".}" },  { "module": "windows",  "name": "IsIconic",  "code": "proc IsIconic*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"IsIconic\".}" },  { "module": "windows",  "name": "AnyPopup",  "code": "proc AnyPopup*(): WINBOOL {.stdcall, dynlib: \"user32\", importc: \"AnyPopup\".}" },  { "module": "windows",  "name": "BringWindowToTop",  "code": "proc BringWindowToTop*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"BringWindowToTop\".}" },  { "module": "windows",  "name": "IsZoomed",  "code": "proc IsZoomed*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"IsZoomed\".}" },  { "module": "windows",  "name": "EndDialog",  "code": "proc EndDialog*(hDlg: HWND; nResult: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EndDialog\".}" },  { "module": "windows",  "name": "GetDlgItem",  "code": "proc GetDlgItem*(hDlg: HWND; nIDDlgItem: int32): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetDlgItem\".}" },  { "module": "windows",  "name": "SetDlgItemInt",  "code": "proc SetDlgItemInt*(hDlg: HWND; nIDDlgItem: int32; uValue: WINUINT; \u000A                    bSigned: WINBOOL): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetDlgItemInt\".}" },  { "module": "windows",  "name": "GetDlgItemInt",  "code": "proc GetDlgItemInt*(hDlg: HWND; nIDDlgItem: int32; lpTranslated: var WINBOOL; \u000A                    bSigned: WINBOOL): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetDlgItemInt\".}" },  { "module": "windows",  "name": "CheckDlgButton",  "code": "proc CheckDlgButton*(hDlg: HWND; nIDButton: int32; uCheck: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CheckDlgButton\".}" },  { "module": "windows",  "name": "CheckRadioButton",  "code": "proc CheckRadioButton*(hDlg: HWND; nIDFirstButton: int32; nIDLastButton: int32; \u000A                       nIDCheckButton: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CheckRadioButton\".}" },  { "module": "windows",  "name": "IsDlgButtonChecked",  "code": "proc IsDlgButtonChecked*(hDlg: HWND; nIDButton: int32): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDlgButtonChecked\".}" },  { "module": "windows",  "name": "GetNextDlgGroupItem",  "code": "proc GetNextDlgGroupItem*(hDlg: HWND; hCtl: HWND; bPrevious: WINBOOL): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetNextDlgGroupItem\".}" },  { "module": "windows",  "name": "GetNextDlgTabItem",  "code": "proc GetNextDlgTabItem*(hDlg: HWND; hCtl: HWND; bPrevious: WINBOOL): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetNextDlgTabItem\".}" },  { "module": "windows",  "name": "GetDlgCtrlID",  "code": "proc GetDlgCtrlID*(wnd: HWND): int32 {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"GetDlgCtrlID\".}" },  { "module": "windows",  "name": "GetDialogBaseUnits",  "code": "proc GetDialogBaseUnits*(): int32 {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"GetDialogBaseUnits\".}" },  { "module": "windows",  "name": "OpenClipboard",  "code": "proc OpenClipboard*(hWndNewOwner: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"OpenClipboard\".}" },  { "module": "windows",  "name": "CloseClipboard",  "code": "proc CloseClipboard*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                  importc: \"CloseClipboard\".}" },  { "module": "windows",  "name": "GetClipboardOwner",  "code": "proc GetClipboardOwner*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                  importc: \"GetClipboardOwner\".}" },  { "module": "windows",  "name": "SetClipboardViewer",  "code": "proc SetClipboardViewer*(hWndNewViewer: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetClipboardViewer\".}" },  { "module": "windows",  "name": "GetClipboardViewer",  "code": "proc GetClipboardViewer*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                   importc: \"GetClipboardViewer\".}" },  { "module": "windows",  "name": "ChangeClipboardChain",  "code": "proc ChangeClipboardChain*(hWndRemove: HWND; hWndNewNext: HWND): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeClipboardChain\".}" },  { "module": "windows",  "name": "SetClipboardData",  "code": "proc SetClipboardData*(uFormat: WINUINT; hMem: HANDLE): HANDLE {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetClipboardData\".}" },  { "module": "windows",  "name": "GetClipboardData",  "code": "proc GetClipboardData*(uFormat: WINUINT): HANDLE {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClipboardData\".}" },  { "module": "windows",  "name": "CountClipboardFormats",  "code": "proc CountClipboardFormats*(): int32 {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"CountClipboardFormats\".}" },  { "module": "windows",  "name": "EnumClipboardFormats",  "code": "proc EnumClipboardFormats*(format: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumClipboardFormats\".}" },  { "module": "windows",  "name": "EmptyClipboard",  "code": "proc EmptyClipboard*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                  importc: \"EmptyClipboard\".}" },  { "module": "windows",  "name": "IsClipboardFormatAvailable",  "code": "proc IsClipboardFormatAvailable*(format: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsClipboardFormatAvailable\".}" },  { "module": "windows",  "name": "GetPriorityClipboardFormat",  "code": "proc GetPriorityClipboardFormat*(paFormatPriorityList: var WINUINT; \u000A                                 cFormats: int32): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetPriorityClipboardFormat\".}" },  { "module": "windows",  "name": "GetOpenClipboardWindow",  "code": "proc GetOpenClipboardWindow*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                       importc: \"GetOpenClipboardWindow\".}" },  { "module": "windows",  "name": "CharNextExA",  "code": "proc CharNextExA*(CodePage: int16; lpCurrentChar: LPCSTR; dwFlags: DWORD): LPSTR {.\u000A    stdcall, dynlib: \"user32\", importc: \"CharNextExA\".}" },  { "module": "windows",  "name": "CharPrevExA",  "code": "proc CharPrevExA*(CodePage: int16; lpStart: LPCSTR; lpCurrentChar: LPCSTR; \u000A                  dwFlags: DWORD): LPSTR {.stdcall, dynlib: \"user32\", \u000A    importc: \"CharPrevExA\".}" },  { "module": "windows",  "name": "SetFocus",  "code": "proc SetFocus*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", importc: \"SetFocus\".}" },  { "module": "windows",  "name": "GetActiveWindow",  "code": "proc GetActiveWindow*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                importc: \"GetActiveWindow\".}" },  { "module": "windows",  "name": "GetFocus",  "code": "proc GetFocus*(): HWND {.stdcall, dynlib: \"user32\", importc: \"GetFocus\".}" },  { "module": "windows",  "name": "GetKBCodePage",  "code": "proc GetKBCodePage*(): WINUINT {.stdcall, dynlib: \"user32\", \u000A                                 importc: \"GetKBCodePage\".}" },  { "module": "windows",  "name": "GetKeyState",  "code": "proc GetKeyState*(nVirtKey: int32): SHORT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetKeyState\".}" },  { "module": "windows",  "name": "GetAsyncKeyState",  "code": "proc GetAsyncKeyState*(vKey: int32): SHORT {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetAsyncKeyState\".}" },  { "module": "windows",  "name": "GetKeyboardState",  "code": "proc GetKeyboardState*(lpKeyState: PBYTE): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetKeyboardState\".}" },  { "module": "windows",  "name": "SetKeyboardState",  "code": "proc SetKeyboardState*(lpKeyState: LPBYTE): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetKeyboardState\".}" },  { "module": "windows",  "name": "GetKeyboardType",  "code": "proc GetKeyboardType*(nTypeFlag: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetKeyboardType\".}" },  { "module": "windows",  "name": "ToAscii",  "code": "proc ToAscii*(uVirtKey: WINUINT; uScanCode: WINUINT; lpKeyState: PBYTE; \u000A              lpChar: LPWORD; uFlags: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"ToAscii\".}" },  { "module": "windows",  "name": "ToAsciiEx",  "code": "proc ToAsciiEx*(uVirtKey: WINUINT; uScanCode: WINUINT; lpKeyState: PBYTE; \u000A                lpChar: LPWORD; uFlags: WINUINT; dwhkl: HKL): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"ToAsciiEx\".}" },  { "module": "windows",  "name": "ToUnicode",  "code": "proc ToUnicode*(wVirtKey: WINUINT; wScanCode: WINUINT; lpKeyState: PBYTE; \u000A                pwszBuff: LPWSTR; cchBuff: int32; wFlags: WINUINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ToUnicode\".}" },  { "module": "windows",  "name": "OemKeyScan",  "code": "proc OemKeyScan*(wOemChar: int16): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"OemKeyScan\".}" },  { "module": "windows",  "name": "keybd_event",  "code": "proc keybd_event*(bVk: int8; bScan: int8; dwFlags: DWORD; dwExtraInfo: DWORD) {.\u000A    stdcall, dynlib: \"user32\", importc: \"keybd_event\".}" },  { "module": "windows",  "name": "mouse_event",  "code": "proc mouse_event*(dwFlags: DWORD; dx: DWORD; dy: DWORD; cButtons: DWORD; \u000A                  dwExtraInfo: DWORD) {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"mouse_event\".}" },  { "module": "windows",  "name": "GetInputState",  "code": "proc GetInputState*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                 importc: \"GetInputState\".}" },  { "module": "windows",  "name": "GetQueueStatus",  "code": "proc GetQueueStatus*(flags: WINUINT): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetQueueStatus\".}" },  { "module": "windows",  "name": "GetCapture",  "code": "proc GetCapture*(): HWND {.stdcall, dynlib: \"user32\", importc: \"GetCapture\".}" },  { "module": "windows",  "name": "SetCapture",  "code": "proc SetCapture*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"SetCapture\".}" },  { "module": "windows",  "name": "ReleaseCapture",  "code": "proc ReleaseCapture*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                  importc: \"ReleaseCapture\".}" },  { "module": "windows",  "name": "MsgWaitForMultipleObjects",  "code": "proc MsgWaitForMultipleObjects*(nCount: DWORD; pHandles: LPHANDLE; \u000A                                fWaitAll: WINBOOL; dwMilliseconds: DWORD; \u000A                                dwWakeMask: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"MsgWaitForMultipleObjects\".}" },  { "module": "windows",  "name": "SetTimer",  "code": "proc SetTimer*(wnd: HWND; nIDEvent: WINUINT; uElapse: WINUINT; \u000A               lpTimerFunc: TIMERPROC): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetTimer\".}" },  { "module": "windows",  "name": "KillTimer",  "code": "proc KillTimer*(wnd: HWND; uIDEvent: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"KillTimer\".}" },  { "module": "windows",  "name": "IsWindowUnicode",  "code": "proc IsWindowUnicode*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsWindowUnicode\".}" },  { "module": "windows",  "name": "EnableWindow",  "code": "proc EnableWindow*(wnd: HWND; bEnable: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnableWindow\".}" },  { "module": "windows",  "name": "IsWindowEnabled",  "code": "proc IsWindowEnabled*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsWindowEnabled\".}" },  { "module": "windows",  "name": "DestroyAcceleratorTable",  "code": "proc DestroyAcceleratorTable*(hAccel: HACCEL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DestroyAcceleratorTable\".}" },  { "module": "windows",  "name": "GetSystemMetrics",  "code": "proc GetSystemMetrics*(nIndex: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetSystemMetrics\".}" },  { "module": "windows",  "name": "GetMenu",  "code": "proc GetMenu*(wnd: HWND): HMENU {.stdcall, dynlib: \"user32\", importc: \"GetMenu\".}" },  { "module": "windows",  "name": "SetMenu",  "code": "proc SetMenu*(wnd: HWND; menu: HMENU): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetMenu\".}" },  { "module": "windows",  "name": "HiliteMenuItem",  "code": "proc HiliteMenuItem*(wnd: HWND; menu: HMENU; uIDHiliteItem: WINUINT; \u000A                     uHilite: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"HiliteMenuItem\".}" },  { "module": "windows",  "name": "GetMenuState",  "code": "proc GetMenuState*(menu: HMENU; uId: WINUINT; uFlags: WINUINT): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetMenuState\".}" },  { "module": "windows",  "name": "DrawMenuBar",  "code": "proc DrawMenuBar*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"DrawMenuBar\".}" },  { "module": "windows",  "name": "GetSystemMenu",  "code": "proc GetSystemMenu*(wnd: HWND; bRevert: WINBOOL): HMENU {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetSystemMenu\".}" },  { "module": "windows",  "name": "CreateMenu",  "code": "proc CreateMenu*(): HMENU {.stdcall, dynlib: \"user32\", importc: \"CreateMenu\".}" },  { "module": "windows",  "name": "CreatePopupMenu",  "code": "proc CreatePopupMenu*(): HMENU {.stdcall, dynlib: \"user32\", \u000A                                 importc: \"CreatePopupMenu\".}" },  { "module": "windows",  "name": "DestroyMenu",  "code": "proc DestroyMenu*(menu: HMENU): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DestroyMenu\".}" },  { "module": "windows",  "name": "CheckMenuItem",  "code": "proc CheckMenuItem*(menu: HMENU; uIDCheckItem: WINUINT; uCheck: WINUINT): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"CheckMenuItem\".}" },  { "module": "windows",  "name": "EnableMenuItem",  "code": "proc EnableMenuItem*(menu: HMENU; uIDEnableItem: WINUINT; uEnable: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnableMenuItem\".}" },  { "module": "windows",  "name": "GetSubMenu",  "code": "proc GetSubMenu*(menu: HMENU; nPos: int32): HMENU {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetSubMenu\".}" },  { "module": "windows",  "name": "GetMenuItemID",  "code": "proc GetMenuItemID*(menu: HMENU; nPos: int32): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuItemID\".}" },  { "module": "windows",  "name": "GetMenuItemCount",  "code": "proc GetMenuItemCount*(menu: HMENU): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMenuItemCount\".}" },  { "module": "windows",  "name": "RemoveMenu",  "code": "proc RemoveMenu*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"RemoveMenu\".}" },  { "module": "windows",  "name": "DeleteMenu",  "code": "proc DeleteMenu*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DeleteMenu\".}" },  { "module": "windows",  "name": "SetMenuItemBitmaps",  "code": "proc SetMenuItemBitmaps*(menu: HMENU; uPosition: WINUINT; uFlags: WINUINT; \u000A                         hBitmapUnchecked: HBITMAP; hBitmapChecked: HBITMAP): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetMenuItemBitmaps\".}" },  { "module": "windows",  "name": "GetMenuCheckMarkDimensions",  "code": "proc GetMenuCheckMarkDimensions*(): LONG {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMenuCheckMarkDimensions\".}" },  { "module": "windows",  "name": "TrackPopupMenu",  "code": "proc TrackPopupMenu*(menu: HMENU; uFlags: WINUINT; x: int32; y: int32; \u000A                     nReserved: int32; wnd: HWND; prcRect: var RECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"TrackPopupMenu\".}" },  { "module": "windows",  "name": "GetMenuDefaultItem",  "code": "proc GetMenuDefaultItem*(menu: HMENU; fByPos: WINUINT; gmdiFlags: WINUINT): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetMenuDefaultItem\".}" },  { "module": "windows",  "name": "SetMenuDefaultItem",  "code": "proc SetMenuDefaultItem*(menu: HMENU; uItem: WINUINT; fByPos: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetMenuDefaultItem\".}" },  { "module": "windows",  "name": "GetMenuItemRect",  "code": "proc GetMenuItemRect*(wnd: HWND; menu: HMENU; uItem: WINUINT; lprcItem: LPRECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetMenuItemRect\".}" },  { "module": "windows",  "name": "MenuItemFromPoint",  "code": "proc MenuItemFromPoint*(wnd: HWND; menu: HMENU; ptScreen: POINT): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"MenuItemFromPoint\".}" },  { "module": "windows",  "name": "DragObject",  "code": "proc DragObject*(para1: HWND; para2: HWND; para3: WINUINT; para4: DWORD; \u000A                 para5: HCURSOR): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"DragObject\".}" },  { "module": "windows",  "name": "DragDetect",  "code": "proc DragDetect*(wnd: HWND; pt: POINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DragDetect\".}" },  { "module": "windows",  "name": "DrawIcon",  "code": "proc DrawIcon*(hDC: HDC; X: int32; Y: int32; icon: HICON): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawIcon\".}" },  { "module": "windows",  "name": "UpdateWindow",  "code": "proc UpdateWindow*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"UpdateWindow\".}" },  { "module": "windows",  "name": "SetActiveWindow",  "code": "proc SetActiveWindow*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetActiveWindow\".}" },  { "module": "windows",  "name": "GetForegroundWindow",  "code": "proc GetForegroundWindow*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"GetForegroundWindow\".}" },  { "module": "windows",  "name": "PaintDesktop",  "code": "proc PaintDesktop*(hdc: HDC): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"PaintDesktop\".}" },  { "module": "windows",  "name": "SetForegroundWindow",  "code": "proc SetForegroundWindow*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetForegroundWindow\".}" },  { "module": "windows",  "name": "WindowFromDC",  "code": "proc WindowFromDC*(hDC: HDC): HWND {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"WindowFromDC\".}" },  { "module": "windows",  "name": "GetDC",  "code": "proc GetDC*(wnd: HWND): HDC {.stdcall, dynlib: \"user32\", importc: \"GetDC\".}" },  { "module": "windows",  "name": "GetDCEx",  "code": "proc GetDCEx*(wnd: HWND; hrgnClip: HRGN; flags: DWORD): HDC {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetDCEx\".}" },  { "module": "windows",  "name": "GetWindowDC",  "code": "proc GetWindowDC*(wnd: HWND): HDC {.stdcall, dynlib: \"user32\", \u000A                                    importc: \"GetWindowDC\".}" },  { "module": "windows",  "name": "ReleaseDC",  "code": "proc ReleaseDC*(wnd: HWND; hDC: HDC): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"ReleaseDC\".}" },  { "module": "windows",  "name": "BeginPaint",  "code": "proc BeginPaint*(wnd: HWND; lpPaint: LPPAINTSTRUCT): HDC {.stdcall, \u000A    dynlib: \"user32\", importc: \"BeginPaint\".}" },  { "module": "windows",  "name": "EndPaint",  "code": "proc EndPaint*(wnd: HWND; lpPaint: LPPAINTSTRUCT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EndPaint\".}" },  { "module": "windows",  "name": "GetUpdateRect",  "code": "proc GetUpdateRect*(wnd: HWND; lpRect: LPRECT; bErase: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUpdateRect\".}" },  { "module": "windows",  "name": "GetUpdateRgn",  "code": "proc GetUpdateRgn*(wnd: HWND; hRgn: HRGN; bErase: WINBOOL): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetUpdateRgn\".}" },  { "module": "windows",  "name": "SetWindowRgn",  "code": "proc SetWindowRgn*(wnd: HWND; hRgn: HRGN; bRedraw: WINBOOL): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowRgn\".}" },  { "module": "windows",  "name": "GetWindowRgn",  "code": "proc GetWindowRgn*(wnd: HWND; hRgn: HRGN): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowRgn\".}" },  { "module": "windows",  "name": "ExcludeUpdateRgn",  "code": "proc ExcludeUpdateRgn*(hDC: HDC; wnd: HWND): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"ExcludeUpdateRgn\".}" },  { "module": "windows",  "name": "InvalidateRect",  "code": "proc InvalidateRect*(wnd: HWND; lpRect: var RECT; bErase: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"InvalidateRect\".}" },  { "module": "windows",  "name": "InvalidateRect",  "code": "proc InvalidateRect*(wnd: HWND; lpRect: LPRECT; bErase: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"InvalidateRect\".}" },  { "module": "windows",  "name": "ValidateRect",  "code": "proc ValidateRect*(wnd: HWND; lpRect: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ValidateRect\".}" },  { "module": "windows",  "name": "ValidateRect",  "code": "proc ValidateRect*(wnd: HWND; lpRect: LPRECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ValidateRect\".}" },  { "module": "windows",  "name": "InvalidateRgn",  "code": "proc InvalidateRgn*(wnd: HWND; hRgn: HRGN; bErase: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InvalidateRgn\".}" },  { "module": "windows",  "name": "ValidateRgn",  "code": "proc ValidateRgn*(wnd: HWND; hRgn: HRGN): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ValidateRgn\".}" },  { "module": "windows",  "name": "RedrawWindow",  "code": "proc RedrawWindow*(wnd: HWND; lprcUpdate: var RECT; hrgnUpdate: HRGN; \u000A                   flags: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"RedrawWindow\".}" },  { "module": "windows",  "name": "RedrawWindow",  "code": "proc RedrawWindow*(wnd: HWND; lprcUpdate: LPRECT; hrgnUpdate: HRGN; \u000A                   flags: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"RedrawWindow\".}" },  { "module": "windows",  "name": "LockWindowUpdate",  "code": "proc LockWindowUpdate*(hWndLock: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"LockWindowUpdate\".}" },  { "module": "windows",  "name": "ScrollWindow",  "code": "proc ScrollWindow*(wnd: HWND; XAmount: int32; YAmount: int32; lpRect: var RECT; \u000A                   lpClipRect: var RECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ScrollWindow\".}" },  { "module": "windows",  "name": "ScrollDC",  "code": "proc ScrollDC*(hDC: HDC; dx: int32; dy: int32; lprcScroll: var RECT; \u000A               lprcClip: var RECT; hrgnUpdate: HRGN; lprcUpdate: LPRECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"ScrollDC\".}" },  { "module": "windows",  "name": "ScrollWindowEx",  "code": "proc ScrollWindowEx*(wnd: HWND; dx: int32; dy: int32; prcScroll: var RECT; \u000A                     prcClip: var RECT; hrgnUpdate: HRGN; prcUpdate: LPRECT; \u000A                     flags: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"ScrollWindowEx\".}" },  { "module": "windows",  "name": "SetScrollPos",  "code": "proc SetScrollPos*(wnd: HWND; nBar: int32; nPos: int32; bRedraw: WINBOOL): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetScrollPos\".}" },  { "module": "windows",  "name": "GetScrollPos",  "code": "proc GetScrollPos*(wnd: HWND; nBar: int32): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetScrollPos\".}" },  { "module": "windows",  "name": "SetScrollRange",  "code": "proc SetScrollRange*(wnd: HWND; nBar: int32; nMinPos: int32; nMaxPos: int32; \u000A                     bRedraw: WINBOOL): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetScrollRange\".}" },  { "module": "windows",  "name": "GetScrollRange",  "code": "proc GetScrollRange*(wnd: HWND; nBar: int32; lpMinPos: LPINT; lpMaxPos: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetScrollRange\".}" },  { "module": "windows",  "name": "ShowScrollBar",  "code": "proc ShowScrollBar*(wnd: HWND; wBar: int32; bShow: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ShowScrollBar\".}" },  { "module": "windows",  "name": "EnableScrollBar",  "code": "proc EnableScrollBar*(wnd: HWND; wSBflags: WINUINT; wArrows: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnableScrollBar\".}" },  { "module": "windows",  "name": "GetClientRect",  "code": "proc GetClientRect*(wnd: HWND; lpRect: LPRECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClientRect\".}" },  { "module": "windows",  "name": "GetWindowRect",  "code": "proc GetWindowRect*(wnd: HWND; lpRect: LPRECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowRect\".}" },  { "module": "windows",  "name": "AdjustWindowRect",  "code": "proc AdjustWindowRect*(lpRect: LPRECT; dwStyle: DWORD; bMenu: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"AdjustWindowRect\".}" },  { "module": "windows",  "name": "AdjustWindowRectEx",  "code": "proc AdjustWindowRectEx*(lpRect: LPRECT; dwStyle: DWORD; bMenu: WINBOOL; \u000A                         dwExStyle: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"AdjustWindowRectEx\".}" },  { "module": "windows",  "name": "SetWindowContextHelpId",  "code": "proc SetWindowContextHelpId*(para1: HWND; para2: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowContextHelpId\".}" },  { "module": "windows",  "name": "GetWindowContextHelpId",  "code": "proc GetWindowContextHelpId*(para1: HWND): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindowContextHelpId\".}" },  { "module": "windows",  "name": "SetMenuContextHelpId",  "code": "proc SetMenuContextHelpId*(para1: HMENU; para2: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetMenuContextHelpId\".}" },  { "module": "windows",  "name": "GetMenuContextHelpId",  "code": "proc GetMenuContextHelpId*(para1: HMENU): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMenuContextHelpId\".}" },  { "module": "windows",  "name": "MessageBeep",  "code": "proc MessageBeep*(uType: WINUINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"MessageBeep\".}" },  { "module": "windows",  "name": "ShowCursor",  "code": "proc ShowCursor*(bShow: WINBOOL): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"ShowCursor\".}" },  { "module": "windows",  "name": "SetCursorPos",  "code": "proc SetCursorPos*(X: int32; Y: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetCursorPos\".}" },  { "module": "windows",  "name": "SetCursor",  "code": "proc SetCursor*(cursor: HCURSOR): HCURSOR {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetCursor\".}" },  { "module": "windows",  "name": "GetCursorPos",  "code": "proc GetCursorPos*(lpPoint: LPPOINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetCursorPos\".}" },  { "module": "windows",  "name": "ClipCursor",  "code": "proc ClipCursor*(lpRect: LPRECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ClipCursor\".}" },  { "module": "windows",  "name": "GetClipCursor",  "code": "proc GetClipCursor*(lpRect: LPRECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClipCursor\".}" },  { "module": "windows",  "name": "GetCursor",  "code": "proc GetCursor*(): HCURSOR {.stdcall, dynlib: \"user32\", importc: \"GetCursor\".}" },  { "module": "windows",  "name": "CreateCaret",  "code": "proc CreateCaret*(wnd: HWND; hBitmap: HBITMAP; nWidth: int32; nHeight: int32): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateCaret\".}" },  { "module": "windows",  "name": "GetCaretBlinkTime",  "code": "proc GetCaretBlinkTime*(): WINUINT {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"GetCaretBlinkTime\".}" },  { "module": "windows",  "name": "SetCaretBlinkTime",  "code": "proc SetCaretBlinkTime*(uMSeconds: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetCaretBlinkTime\".}" },  { "module": "windows",  "name": "DestroyCaret",  "code": "proc DestroyCaret*(): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                importc: \"DestroyCaret\".}" },  { "module": "windows",  "name": "HideCaret",  "code": "proc HideCaret*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"HideCaret\".}" },  { "module": "windows",  "name": "ShowCaret",  "code": "proc ShowCaret*(wnd: HWND): WINBOOL {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"ShowCaret\".}" },  { "module": "windows",  "name": "SetCaretPos",  "code": "proc SetCaretPos*(X: int32; Y: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetCaretPos\".}" },  { "module": "windows",  "name": "GetCaretPos",  "code": "proc GetCaretPos*(lpPoint: LPPOINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetCaretPos\".}" },  { "module": "windows",  "name": "ClientToScreen",  "code": "proc ClientToScreen*(wnd: HWND; lpPoint: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ClientToScreen\".}" },  { "module": "windows",  "name": "ScreenToClient",  "code": "proc ScreenToClient*(wnd: HWND; lpPoint: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ScreenToClient\".}" },  { "module": "windows",  "name": "MapWindowPoints",  "code": "proc MapWindowPoints*(hWndFrom: HWND; hWndTo: HWND; lpPoints: LPPOINT; \u000A                      cPoints: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"MapWindowPoints\".}" },  { "module": "windows",  "name": "WindowFromPoint",  "code": "proc WindowFromPoint*(Point: POINT): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"WindowFromPoint\".}" },  { "module": "windows",  "name": "ChildWindowFromPoint",  "code": "proc ChildWindowFromPoint*(hWndParent: HWND; Point: POINT): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"ChildWindowFromPoint\".}" },  { "module": "windows",  "name": "GetSysColor",  "code": "proc GetSysColor*(nIndex: int32): DWORD {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetSysColor\".}" },  { "module": "windows",  "name": "GetSysColorBrush",  "code": "proc GetSysColorBrush*(nIndex: int32): HBRUSH {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetSysColorBrush\".}" },  { "module": "windows",  "name": "SetSysColors",  "code": "proc SetSysColors*(cElements: int32; lpaElements: var WINT; \u000A                   lpaRgbValues: var COLORREF): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetSysColors\".}" },  { "module": "windows",  "name": "DrawFocusRect",  "code": "proc DrawFocusRect*(hDC: HDC; lprc: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawFocusRect\".}" },  { "module": "windows",  "name": "FillRect",  "code": "proc FillRect*(hDC: HDC; lprc: var RECT; hbr: HBRUSH): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"FillRect\".}" },  { "module": "windows",  "name": "FrameRect",  "code": "proc FrameRect*(hDC: HDC; lprc: var RECT; hbr: HBRUSH): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"FrameRect\".}" },  { "module": "windows",  "name": "InvertRect",  "code": "proc InvertRect*(hDC: HDC; lprc: var RECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"InvertRect\".}" },  { "module": "windows",  "name": "SetRect",  "code": "proc SetRect*(lprc: LPRECT; xLeft: int32; yTop: int32; xRight: int32; \u000A              yBottom: int32): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetRect\".}" },  { "module": "windows",  "name": "SetRectEmpty",  "code": "proc SetRectEmpty*(lprc: LPRECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetRectEmpty\".}" },  { "module": "windows",  "name": "CopyRect",  "code": "proc CopyRect*(lprcDst: LPRECT; lprcSrc: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyRect\".}" },  { "module": "windows",  "name": "InflateRect",  "code": "proc InflateRect*(lprc: LPRECT; dx: int32; dy: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InflateRect\".}" },  { "module": "windows",  "name": "IntersectRect",  "code": "proc IntersectRect*(lprcDst: LPRECT; lprcSrc1: var RECT; lprcSrc2: var RECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"IntersectRect\".}" },  { "module": "windows",  "name": "UnionRect",  "code": "proc UnionRect*(lprcDst: LPRECT; lprcSrc1: var RECT; lprcSrc2: var RECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnionRect\".}" },  { "module": "windows",  "name": "SubtractRect",  "code": "proc SubtractRect*(lprcDst: LPRECT; lprcSrc1: var RECT; lprcSrc2: var RECT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SubtractRect\".}" },  { "module": "windows",  "name": "OffsetRect",  "code": "proc OffsetRect*(lprc: LPRECT; dx: int32; dy: int32): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OffsetRect\".}" },  { "module": "windows",  "name": "IsRectEmpty",  "code": "proc IsRectEmpty*(lprc: var RECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"IsRectEmpty\".}" },  { "module": "windows",  "name": "EqualRect",  "code": "proc EqualRect*(lprc1: var RECT; lprc2: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EqualRect\".}" },  { "module": "windows",  "name": "PtInRect",  "code": "proc PtInRect*(lprc: var RECT; pt: POINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"PtInRect\".}" },  { "module": "windows",  "name": "PtInRect",  "code": "proc PtInRect*(lprc: LPRECT; pt: POINT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"PtInRect\".}" },  { "module": "windows",  "name": "GetWindowWord",  "code": "proc GetWindowWord*(wnd: HWND; nIndex: int32): int16 {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowWord\".}" },  { "module": "windows",  "name": "SetWindowWord",  "code": "proc SetWindowWord*(wnd: HWND; nIndex: int32; wNewWord: int16): int16 {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetWindowWord\".}" },  { "module": "windows",  "name": "GetClassWord",  "code": "proc GetClassWord*(wnd: HWND; nIndex: int32): int16 {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClassWord\".}" },  { "module": "windows",  "name": "SetClassWord",  "code": "proc SetClassWord*(wnd: HWND; nIndex: int32; wNewWord: int16): int16 {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetClassWord\".}" },  { "module": "windows",  "name": "GetDesktopWindow",  "code": "proc GetDesktopWindow*(): HWND {.stdcall, dynlib: \"user32\", \u000A                                 importc: \"GetDesktopWindow\".}" },  { "module": "windows",  "name": "GetParent",  "code": "proc GetParent*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A                                   importc: \"GetParent\".}" },  { "module": "windows",  "name": "SetParent",  "code": "proc SetParent*(hWndChild: HWND; hWndNewParent: HWND): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetParent\".}" },  { "module": "windows",  "name": "EnumChildWindows",  "code": "proc EnumChildWindows*(hWndParent: HWND; lpEnumFunc: ENUMWINDOWSPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumChildWindows\".}" },  { "module": "windows",  "name": "EnumWindows",  "code": "proc EnumWindows*(lpEnumFunc: ENUMWINDOWSPROC; lp: LPARAM): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumWindows\".}" },  { "module": "windows",  "name": "EnumThreadWindows",  "code": "proc EnumThreadWindows*(dwThreadId: DWORD; lpfn: ENUMWINDOWSPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumThreadWindows\".}" },  { "module": "windows",  "name": "EnumTaskWindows",  "code": "proc EnumTaskWindows*(hTask: HWND; lpfn: FARPROC; lp: LPARAM): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"EnumThreadWindows\".}" },  { "module": "windows",  "name": "GetTopWindow",  "code": "proc GetTopWindow*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"GetTopWindow\".}" },  { "module": "windows",  "name": "GetWindowThreadProcessId",  "code": "proc GetWindowThreadProcessId*(wnd: HWND; lpdwProcessId: LPDWORD): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetWindowThreadProcessId\".}" },  { "module": "windows",  "name": "GetLastActivePopup",  "code": "proc GetLastActivePopup*(wnd: HWND): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetLastActivePopup\".}" },  { "module": "windows",  "name": "GetWindow",  "code": "proc GetWindow*(wnd: HWND; uCmd: WINUINT): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindow\".}" },  { "module": "windows",  "name": "UnhookWindowsHook",  "code": "proc UnhookWindowsHook*(nCode: int32; pfnFilterProc: HOOKPROC): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnhookWindowsHook\".}" },  { "module": "windows",  "name": "UnhookWindowsHookEx",  "code": "proc UnhookWindowsHookEx*(hhk: HHOOK): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"UnhookWindowsHookEx\".}" },  { "module": "windows",  "name": "CallNextHookEx",  "code": "proc CallNextHookEx*(hhk: HHOOK; nCode: int32; wp: WPARAM; lp: LPARAM): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"CallNextHookEx\".}" },  { "module": "windows",  "name": "CheckMenuRadioItem",  "code": "proc CheckMenuRadioItem*(para1: HMENU; para2: WINUINT; para3: WINUINT; \u000A                         para4: WINUINT; para5: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CheckMenuRadioItem\".}" },  { "module": "windows",  "name": "CreateCursor",  "code": "proc CreateCursor*(hInst: HINST; xHotSpot: int32; yHotSpot: int32; \u000A                   nWidth: int32; nHeight: int32; pvANDPlane: pointer; \u000A                   pvXORPlane: pointer): HCURSOR {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateCursor\".}" },  { "module": "windows",  "name": "DestroyCursor",  "code": "proc DestroyCursor*(cursor: HCURSOR): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DestroyCursor\".}" },  { "module": "windows",  "name": "SetSystemCursor",  "code": "proc SetSystemCursor*(hcur: HCURSOR; anID: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetSystemCursor\".}" },  { "module": "windows",  "name": "CreateIcon",  "code": "proc CreateIcon*(hInstance: HINST; nWidth: int32; nHeight: int32; cPlanes: int8; \u000A                 cBitsPixel: int8; lpbANDbits: var int8; lpbXORbits: var int8): HICON {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateIcon\".}" },  { "module": "windows",  "name": "DestroyIcon",  "code": "proc DestroyIcon*(icon: HICON): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DestroyIcon\".}" },  { "module": "windows",  "name": "LookupIconIdFromDirectory",  "code": "proc LookupIconIdFromDirectory*(presbits: PBYTE; fIcon: WINBOOL): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"LookupIconIdFromDirectory\".}" },  { "module": "windows",  "name": "LookupIconIdFromDirectoryEx",  "code": "proc LookupIconIdFromDirectoryEx*(presbits: PBYTE; fIcon: WINBOOL; \u000A                                  cxDesired: int32; cyDesired: int32; \u000A                                  Flags: WINUINT): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"LookupIconIdFromDirectoryEx\".}" },  { "module": "windows",  "name": "CreateIconFromResource",  "code": "proc CreateIconFromResource*(presbits: PBYTE; dwResSize: DWORD; fIcon: WINBOOL; \u000A                             dwVer: DWORD): HICON {.stdcall, dynlib: \"user32\", \u000A    importc: \"CreateIconFromResource\".}" },  { "module": "windows",  "name": "CreateIconFromResourceEx",  "code": "proc CreateIconFromResourceEx*(presbits: PBYTE; dwResSize: DWORD; \u000A                               fIcon: WINBOOL; dwVer: DWORD; cxDesired: int32; \u000A                               cyDesired: int32; Flags: WINUINT): HICON {.\u000A    stdcall, dynlib: \"user32\", importc: \"CreateIconFromResourceEx\".}" },  { "module": "windows",  "name": "CopyImage",  "code": "proc CopyImage*(para1: HANDLE; para2: WINUINT; para3: int32; para4: int32; \u000A                para5: WINUINT): HICON {.stdcall, dynlib: \"user32\", \u000A    importc: \"CopyImage\".}" },  { "module": "windows",  "name": "CreateIconIndirect",  "code": "proc CreateIconIndirect*(piconinfo: PICONINFO): HICON {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateIconIndirect\".}" },  { "module": "windows",  "name": "CopyIcon",  "code": "proc CopyIcon*(icon: HICON): HICON {.stdcall, dynlib: \"user32\", \u000A                                     importc: \"CopyIcon\".}" },  { "module": "windows",  "name": "GetIconInfo",  "code": "proc GetIconInfo*(icon: HICON; piconinfo: PICONINFO): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetIconInfo\".}" },  { "module": "windows",  "name": "MapDialogRect",  "code": "proc MapDialogRect*(hDlg: HWND; lpRect: LPRECT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"MapDialogRect\".}" },  { "module": "windows",  "name": "SetScrollInfo",  "code": "proc SetScrollInfo*(para1: HWND; para2: int32; para3: LPCSCROLLINFO; \u000A                    para4: WINBOOL): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetScrollInfo\".}" },  { "module": "windows",  "name": "GetScrollInfo",  "code": "proc GetScrollInfo*(para1: HWND; para2: int32; para3: LPSCROLLINFO): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetScrollInfo\".}" },  { "module": "windows",  "name": "TranslateMDISysAccel",  "code": "proc TranslateMDISysAccel*(hWndClient: HWND; lpMsg: LPMSG): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"TranslateMDISysAccel\".}" },  { "module": "windows",  "name": "ArrangeIconicWindows",  "code": "proc ArrangeIconicWindows*(wnd: HWND): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"ArrangeIconicWindows\".}" },  { "module": "windows",  "name": "TileWindows",  "code": "proc TileWindows*(hwndParent: HWND; wHow: WINUINT; lpRect: var RECT; \u000A                  cKids: WINUINT; lpKids: var HWND): int16 {.stdcall, \u000A    dynlib: \"user32\", importc: \"TileWindows\".}" },  { "module": "windows",  "name": "CascadeWindows",  "code": "proc CascadeWindows*(hwndParent: HWND; wHow: WINUINT; lpRect: var RECT; \u000A                     cKids: WINUINT; lpKids: var HWND): int16 {.stdcall, \u000A    dynlib: \"user32\", importc: \"CascadeWindows\".}" },  { "module": "windows",  "name": "SetLastErrorEx",  "code": "proc SetLastErrorEx*(dwErrCode: DWORD; dwType: DWORD) {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetLastErrorEx\".}" },  { "module": "windows",  "name": "SetDebugErrorLevel",  "code": "proc SetDebugErrorLevel*(dwLevel: DWORD) {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetDebugErrorLevel\".}" },  { "module": "windows",  "name": "DrawEdge",  "code": "proc DrawEdge*(hdc: HDC; qrc: LPRECT; edge: WINUINT; grfFlags: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawEdge\".}" },  { "module": "windows",  "name": "DrawFrameControl",  "code": "proc DrawFrameControl*(para1: HDC; para2: LPRECT; para3: WINUINT; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawFrameControl\".}" },  { "module": "windows",  "name": "DrawCaption",  "code": "proc DrawCaption*(para1: HWND; para2: HDC; para3: var RECT; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawCaption\".}" },  { "module": "windows",  "name": "DrawAnimatedRects",  "code": "proc DrawAnimatedRects*(wnd: HWND; idAni: int32; lprcFrom: var RECT; \u000A                        lprcTo: var RECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawAnimatedRects\".}" },  { "module": "windows",  "name": "TrackPopupMenuEx",  "code": "proc TrackPopupMenuEx*(para1: HMENU; para2: WINUINT; para3: int32; para4: int32; \u000A                       para5: HWND; para6: LPTPMPARAMS): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"TrackPopupMenuEx\".}" },  { "module": "windows",  "name": "ChildWindowFromPointEx",  "code": "proc ChildWindowFromPointEx*(para1: HWND; para2: POINT; para3: WINUINT): HWND {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChildWindowFromPointEx\".}" },  { "module": "windows",  "name": "DrawIconEx",  "code": "proc DrawIconEx*(hdc: HDC; xLeft: int32; yTop: int32; icon: HICON; \u000A                 cxWidth: int32; cyWidth: int32; istepIfAniCur: WINUINT; \u000A                 hbrFlickerFreeDraw: HBRUSH; diFlags: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawIconEx\".}" },  { "module": "windows",  "name": "AnimatePalette",  "code": "proc AnimatePalette*(para1: HPALETTE; para2: WINUINT; para3: WINUINT; \u000A                     para4: var PALETTEENTRY): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"AnimatePalette\".}" },  { "module": "windows",  "name": "Arc",  "code": "proc Arc*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A          para6: int32; para7: int32; para8: int32; para9: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"Arc\".}" },  { "module": "windows",  "name": "BitBlt",  "code": "proc BitBlt*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A             para6: HDC; para7: int32; para8: int32; para9: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"BitBlt\".}" },  { "module": "windows",  "name": "CancelDC",  "code": "proc CancelDC*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"CancelDC\".}" },  { "module": "windows",  "name": "Chord",  "code": "proc Chord*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A            para6: int32; para7: int32; para8: int32; para9: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"Chord\".}" },  { "module": "windows",  "name": "CloseMetaFile",  "code": "proc CloseMetaFile*(para1: HDC): HMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CloseMetaFile\".}" },  { "module": "windows",  "name": "CombineRgn",  "code": "proc CombineRgn*(para1: HRGN; para2: HRGN; para3: HRGN; para4: int32): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CombineRgn\".}" },  { "module": "windows",  "name": "CreateBitmap",  "code": "proc CreateBitmap*(para1: int32; para2: int32; para3: WINUINT; para4: WINUINT; \u000A                   para5: pointer): HBITMAP {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateBitmap\".}" },  { "module": "windows",  "name": "CreateBitmapIndirect",  "code": "proc CreateBitmapIndirect*(para1: var BITMAP): HBITMAP {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateBitmapIndirect\".}" },  { "module": "windows",  "name": "CreateBrushIndirect",  "code": "proc CreateBrushIndirect*(para1: var LOGBRUSH): HBRUSH {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateBrushIndirect\".}" },  { "module": "windows",  "name": "CreateCompatibleBitmap",  "code": "proc CreateCompatibleBitmap*(para1: HDC; para2: int32; para3: int32): HBITMAP {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateCompatibleBitmap\".}" },  { "module": "windows",  "name": "CreateDiscardableBitmap",  "code": "proc CreateDiscardableBitmap*(para1: HDC; para2: int32; para3: int32): HBITMAP {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDiscardableBitmap\".}" },  { "module": "windows",  "name": "CreateCompatibleDC",  "code": "proc CreateCompatibleDC*(para1: HDC): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateCompatibleDC\".}" },  { "module": "windows",  "name": "CreateDIBitmap",  "code": "proc CreateDIBitmap*(para1: HDC; para2: var BITMAPINFOHEADER; para3: DWORD; \u000A                     para4: pointer; para5: var BITMAPINFO; para6: WINUINT): HBITMAP {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDIBitmap\".}" },  { "module": "windows",  "name": "CreateDIBPatternBrush",  "code": "proc CreateDIBPatternBrush*(para1: HGLOBAL; para2: WINUINT): HBRUSH {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateDIBPatternBrush\".}" },  { "module": "windows",  "name": "CreateDIBPatternBrushPt",  "code": "proc CreateDIBPatternBrushPt*(para1: pointer; para2: WINUINT): HBRUSH {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateDIBPatternBrushPt\".}" },  { "module": "windows",  "name": "CreateEllipticRgn",  "code": "proc CreateEllipticRgn*(para1: int32; para2: int32; para3: int32; para4: int32): HRGN {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateEllipticRgn\".}" },  { "module": "windows",  "name": "CreateEllipticRgnIndirect",  "code": "proc CreateEllipticRgnIndirect*(para1: var RECT): HRGN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateEllipticRgnIndirect\".}" },  { "module": "windows",  "name": "CreateHatchBrush",  "code": "proc CreateHatchBrush*(para1: int32; para2: COLORREF): HBRUSH {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateHatchBrush\".}" },  { "module": "windows",  "name": "CreatePalette",  "code": "proc CreatePalette*(para1: var LOGPALETTE): HPALETTE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreatePalette\".}" },  { "module": "windows",  "name": "CreatePen",  "code": "proc CreatePen*(para1: int32; para2: int32; para3: COLORREF): HPEN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreatePen\".}" },  { "module": "windows",  "name": "CreatePenIndirect",  "code": "proc CreatePenIndirect*(para1: var LOGPEN): HPEN {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreatePenIndirect\".}" },  { "module": "windows",  "name": "CreatePolyPolygonRgn",  "code": "proc CreatePolyPolygonRgn*(para1: var POINT; para2: var WINT; para3: int32; \u000A                           para4: int32): HRGN {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreatePolyPolygonRgn\".}" },  { "module": "windows",  "name": "CreatePatternBrush",  "code": "proc CreatePatternBrush*(para1: HBITMAP): HBRUSH {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreatePatternBrush\".}" },  { "module": "windows",  "name": "CreateRectRgn",  "code": "proc CreateRectRgn*(para1: int32; para2: int32; para3: int32; para4: int32): HRGN {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateRectRgn\".}" },  { "module": "windows",  "name": "CreateRectRgnIndirect",  "code": "proc CreateRectRgnIndirect*(para1: var RECT): HRGN {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateRectRgnIndirect\".}" },  { "module": "windows",  "name": "CreateRoundRectRgn",  "code": "proc CreateRoundRectRgn*(para1: int32; para2: int32; para3: int32; para4: int32; \u000A                         para5: int32; para6: int32): HRGN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateRoundRectRgn\".}" },  { "module": "windows",  "name": "CreateSolidBrush",  "code": "proc CreateSolidBrush*(para1: COLORREF): HBRUSH {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateSolidBrush\".}" },  { "module": "windows",  "name": "DeleteDC",  "code": "proc DeleteDC*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"DeleteDC\".}" },  { "module": "windows",  "name": "DeleteMetaFile",  "code": "proc DeleteMetaFile*(para1: HMETAFILE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"DeleteMetaFile\".}" },  { "module": "windows",  "name": "DeleteObject",  "code": "proc DeleteObject*(para1: HGDIOBJ): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"DeleteObject\".}" },  { "module": "windows",  "name": "DrawEscape",  "code": "proc DrawEscape*(para1: HDC; para2: int32; para3: int32; para4: LPCSTR): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"DrawEscape\".}" },  { "module": "windows",  "name": "Ellipse",  "code": "proc Ellipse*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"Ellipse\".}" },  { "module": "windows",  "name": "EnumObjects",  "code": "proc EnumObjects*(para1: HDC; para2: int32; para3: ENUMOBJECTSPROC; \u000A                  para4: LPARAM): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumObjects\".}" },  { "module": "windows",  "name": "EqualRgn",  "code": "proc EqualRgn*(para1: HRGN; para2: HRGN): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EqualRgn\".}" },  { "module": "windows",  "name": "Escape",  "code": "proc Escape*(para1: HDC; para2: int32; para3: int32; para4: LPCSTR; \u000A             para5: LPVOID): int32 {.stdcall, dynlib: \"gdi32\", importc: \"Escape\".}" },  { "module": "windows",  "name": "ExtEscape",  "code": "proc ExtEscape*(para1: HDC; para2: int32; para3: int32; para4: LPCSTR; \u000A                para5: int32; para6: LPSTR): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ExtEscape\".}" },  { "module": "windows",  "name": "ExcludeClipRect",  "code": "proc ExcludeClipRect*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                      para5: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ExcludeClipRect\".}" },  { "module": "windows",  "name": "ExtCreateRegion",  "code": "proc ExtCreateRegion*(para1: var XFORM; para2: DWORD; para3: var RGNDATA): HRGN {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ExtCreateRegion\".}" },  { "module": "windows",  "name": "ExtFloodFill",  "code": "proc ExtFloodFill*(para1: HDC; para2: int32; para3: int32; para4: COLORREF; \u000A                   para5: WINUINT): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ExtFloodFill\".}" },  { "module": "windows",  "name": "FillRgn",  "code": "proc FillRgn*(para1: HDC; para2: HRGN; para3: HBRUSH): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"FillRgn\".}" },  { "module": "windows",  "name": "FloodFill",  "code": "proc FloodFill*(para1: HDC; para2: int32; para3: int32; para4: COLORREF): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"FloodFill\".}" },  { "module": "windows",  "name": "FrameRgn",  "code": "proc FrameRgn*(para1: HDC; para2: HRGN; para3: HBRUSH; para4: int32; \u000A               para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                        importc: \"FrameRgn\".}" },  { "module": "windows",  "name": "GetROP2",  "code": "proc GetROP2*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", importc: \"GetROP2\".}" },  { "module": "windows",  "name": "GetAspectRatioFilterEx",  "code": "proc GetAspectRatioFilterEx*(para1: HDC; para2: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetAspectRatioFilterEx\".}" },  { "module": "windows",  "name": "GetBkColor",  "code": "proc GetBkColor*(para1: HDC): COLORREF {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetBkColor\".}" },  { "module": "windows",  "name": "GetBkMode",  "code": "proc GetBkMode*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                     importc: \"GetBkMode\".}" },  { "module": "windows",  "name": "GetBitmapBits",  "code": "proc GetBitmapBits*(para1: HBITMAP; para2: LONG; para3: LPVOID): LONG {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBitmapBits\".}" },  { "module": "windows",  "name": "GetBitmapDimensionEx",  "code": "proc GetBitmapDimensionEx*(para1: HBITMAP; para2: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBitmapDimensionEx\".}" },  { "module": "windows",  "name": "GetBoundsRect",  "code": "proc GetBoundsRect*(para1: HDC; para2: LPRECT; para3: WINUINT): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetBoundsRect\".}" },  { "module": "windows",  "name": "GetBrushOrgEx",  "code": "proc GetBrushOrgEx*(para1: HDC; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBrushOrgEx\".}" },  { "module": "windows",  "name": "GetClipBox",  "code": "proc GetClipBox*(para1: HDC; para2: LPRECT): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetClipBox\".}" },  { "module": "windows",  "name": "GetClipRgn",  "code": "proc GetClipRgn*(para1: HDC; para2: HRGN): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetClipRgn\".}" },  { "module": "windows",  "name": "GetMetaRgn",  "code": "proc GetMetaRgn*(para1: HDC; para2: HRGN): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetMetaRgn\".}" },  { "module": "windows",  "name": "GetCurrentObject",  "code": "proc GetCurrentObject*(para1: HDC; para2: WINUINT): HGDIOBJ {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCurrentObject\".}" },  { "module": "windows",  "name": "GetCurrentPositionEx",  "code": "proc GetCurrentPositionEx*(para1: HDC; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCurrentPositionEx\".}" },  { "module": "windows",  "name": "GetDeviceCaps",  "code": "proc GetDeviceCaps*(para1: HDC; para2: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetDeviceCaps\".}" },  { "module": "windows",  "name": "GetDIBits",  "code": "proc GetDIBits*(para1: HDC; para2: HBITMAP; para3: WINUINT; para4: WINUINT; \u000A                para5: LPVOID; para6: LPBITMAPINFO; para7: WINUINT): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetDIBits\".}" },  { "module": "windows",  "name": "GetFontData",  "code": "proc GetFontData*(para1: HDC; para2: DWORD; para3: DWORD; para4: LPVOID; \u000A                  para5: DWORD): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetFontData\".}" },  { "module": "windows",  "name": "GetGraphicsMode",  "code": "proc GetGraphicsMode*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetGraphicsMode\".}" },  { "module": "windows",  "name": "GetMapMode",  "code": "proc GetMapMode*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"GetMapMode\".}" },  { "module": "windows",  "name": "GetMetaFileBitsEx",  "code": "proc GetMetaFileBitsEx*(para1: HMETAFILE; para2: WINUINT; para3: LPVOID): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetMetaFileBitsEx\".}" },  { "module": "windows",  "name": "GetNearestColor",  "code": "proc GetNearestColor*(para1: HDC; para2: COLORREF): COLORREF {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetNearestColor\".}" },  { "module": "windows",  "name": "GetNearestPaletteIndex",  "code": "proc GetNearestPaletteIndex*(para1: HPALETTE; para2: COLORREF): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetNearestPaletteIndex\".}" },  { "module": "windows",  "name": "GetObjectType",  "code": "proc GetObjectType*(h: HGDIOBJ): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetObjectType\".}" },  { "module": "windows",  "name": "GetPaletteEntries",  "code": "proc GetPaletteEntries*(para1: HPALETTE; para2: WINUINT; para3: WINUINT; \u000A                        para4: LPPALETTEENTRY): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetPaletteEntries\".}" },  { "module": "windows",  "name": "GetPixel",  "code": "proc GetPixel*(para1: HDC; para2: int32; para3: int32): COLORREF {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetPixel\".}" },  { "module": "windows",  "name": "GetPixelFormat",  "code": "proc GetPixelFormat*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetPixelFormat\".}" },  { "module": "windows",  "name": "GetPolyFillMode",  "code": "proc GetPolyFillMode*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetPolyFillMode\".}" },  { "module": "windows",  "name": "GetRasterizerCaps",  "code": "proc GetRasterizerCaps*(para1: LPRASTERIZER_STATUS; para2: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetRasterizerCaps\".}" },  { "module": "windows",  "name": "GetRegionData",  "code": "proc GetRegionData*(para1: HRGN; para2: DWORD; para3: LPRGNDATA): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetRegionData\".}" },  { "module": "windows",  "name": "GetRgnBox",  "code": "proc GetRgnBox*(para1: HRGN; para2: LPRECT): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetRgnBox\".}" },  { "module": "windows",  "name": "GetStockObject",  "code": "proc GetStockObject*(para1: int32): HGDIOBJ {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetStockObject\".}" },  { "module": "windows",  "name": "GetStretchBltMode",  "code": "proc GetStretchBltMode*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetStretchBltMode\".}" },  { "module": "windows",  "name": "GetSystemPaletteEntries",  "code": "proc GetSystemPaletteEntries*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                              para4: LPPALETTEENTRY): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetSystemPaletteEntries\".}" },  { "module": "windows",  "name": "GetSystemPaletteUse",  "code": "proc GetSystemPaletteUse*(para1: HDC): WINUINT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetSystemPaletteUse\".}" },  { "module": "windows",  "name": "GetTextCharacterExtra",  "code": "proc GetTextCharacterExtra*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextCharacterExtra\".}" },  { "module": "windows",  "name": "GetTextAlign",  "code": "proc GetTextAlign*(para1: HDC): WINUINT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextAlign\".}" },  { "module": "windows",  "name": "GetTextColor",  "code": "proc GetTextColor*(para1: HDC): COLORREF {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextColor\".}" },  { "module": "windows",  "name": "GetTextCharset",  "code": "proc GetTextCharset*(hdc: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                        importc: \"GetTextCharset\".}" },  { "module": "windows",  "name": "GetTextCharsetInfo",  "code": "proc GetTextCharsetInfo*(hdc: HDC; lpSig: LPFONTSIGNATURE; dwFlags: DWORD): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextCharsetInfo\".}" },  { "module": "windows",  "name": "TranslateCharsetInfo",  "code": "proc TranslateCharsetInfo*(lpSrc: var DWORD; lpCs: LPCHARSETINFO; dwFlags: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"TranslateCharsetInfo\".}" },  { "module": "windows",  "name": "GetFontLanguageInfo",  "code": "proc GetFontLanguageInfo*(para1: HDC): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetFontLanguageInfo\".}" },  { "module": "windows",  "name": "GetViewportExtEx",  "code": "proc GetViewportExtEx*(para1: HDC; para2: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetViewportExtEx\".}" },  { "module": "windows",  "name": "GetViewportOrgEx",  "code": "proc GetViewportOrgEx*(para1: HDC; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetViewportOrgEx\".}" },  { "module": "windows",  "name": "GetWindowExtEx",  "code": "proc GetWindowExtEx*(para1: HDC; para2: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWindowExtEx\".}" },  { "module": "windows",  "name": "GetWindowOrgEx",  "code": "proc GetWindowOrgEx*(para1: HDC; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWindowOrgEx\".}" },  { "module": "windows",  "name": "IntersectClipRect",  "code": "proc IntersectClipRect*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                        para5: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"IntersectClipRect\".}" },  { "module": "windows",  "name": "InvertRgn",  "code": "proc InvertRgn*(para1: HDC; para2: HRGN): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"InvertRgn\".}" },  { "module": "windows",  "name": "LineDDA",  "code": "proc LineDDA*(para1: int32; para2: int32; para3: int32; para4: int32; \u000A              para5: LINEDDAPROC; para6: LPARAM): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"LineDDA\".}" },  { "module": "windows",  "name": "LineTo",  "code": "proc LineTo*(para1: HDC; para2: int32; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"LineTo\".}" },  { "module": "windows",  "name": "MaskBlt",  "code": "proc MaskBlt*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A              para5: int32; para6: HDC; para7: int32; para8: int32; \u000A              para9: HBITMAP; para10: int32; para11: int32; para12: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"MaskBlt\".}" },  { "module": "windows",  "name": "PlgBlt",  "code": "proc PlgBlt*(para1: HDC; para2: var POINT; para3: HDC; para4: int32; \u000A             para5: int32; para6: int32; para7: int32; para8: HBITMAP; \u000A             para9: int32; para10: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"PlgBlt\".}" },  { "module": "windows",  "name": "OffsetClipRgn",  "code": "proc OffsetClipRgn*(para1: HDC; para2: int32; para3: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"OffsetClipRgn\".}" },  { "module": "windows",  "name": "OffsetRgn",  "code": "proc OffsetRgn*(para1: HRGN; para2: int32; para3: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"OffsetRgn\".}" },  { "module": "windows",  "name": "PatBlt",  "code": "proc PatBlt*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A             para6: DWORD): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"PatBlt\".}" },  { "module": "windows",  "name": "Pie",  "code": "proc Pie*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A          para6: int32; para7: int32; para8: int32; para9: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"Pie\".}" },  { "module": "windows",  "name": "PlayMetaFile",  "code": "proc PlayMetaFile*(para1: HDC; para2: HMETAFILE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PlayMetaFile\".}" },  { "module": "windows",  "name": "PaintRgn",  "code": "proc PaintRgn*(para1: HDC; para2: HRGN): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"PaintRgn\".}" },  { "module": "windows",  "name": "PolyPolygon",  "code": "proc PolyPolygon*(para1: HDC; para2: var POINT; para3: var WINT; para4: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyPolygon\".}" },  { "module": "windows",  "name": "PtInRegion",  "code": "proc PtInRegion*(para1: HRGN; para2: int32; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PtInRegion\".}" },  { "module": "windows",  "name": "PtVisible",  "code": "proc PtVisible*(para1: HDC; para2: int32; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PtVisible\".}" },  { "module": "windows",  "name": "RectInRegion",  "code": "proc RectInRegion*(para1: HRGN; para2: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"RectInRegion\".}" },  { "module": "windows",  "name": "RectVisible",  "code": "proc RectVisible*(para1: HDC; para2: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"RectVisible\".}" },  { "module": "windows",  "name": "Rectangle",  "code": "proc Rectangle*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"Rectangle\".}" },  { "module": "windows",  "name": "RestoreDC",  "code": "proc RestoreDC*(para1: HDC; para2: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"RestoreDC\".}" },  { "module": "windows",  "name": "RealizePalette",  "code": "proc RealizePalette*(para1: HDC): WINUINT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"RealizePalette\".}" },  { "module": "windows",  "name": "RoundRect",  "code": "proc RoundRect*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                para5: int32; para6: int32; para7: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"RoundRect\".}" },  { "module": "windows",  "name": "ResizePalette",  "code": "proc ResizePalette*(para1: HPALETTE; para2: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ResizePalette\".}" },  { "module": "windows",  "name": "SaveDC",  "code": "proc SaveDC*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", importc: \"SaveDC\".}" },  { "module": "windows",  "name": "SelectClipRgn",  "code": "proc SelectClipRgn*(para1: HDC; para2: HRGN): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SelectClipRgn\".}" },  { "module": "windows",  "name": "ExtSelectClipRgn",  "code": "proc ExtSelectClipRgn*(para1: HDC; para2: HRGN; para3: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ExtSelectClipRgn\".}" },  { "module": "windows",  "name": "SetMetaRgn",  "code": "proc SetMetaRgn*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"SetMetaRgn\".}" },  { "module": "windows",  "name": "SelectObject",  "code": "proc SelectObject*(para1: HDC; para2: HGDIOBJ): HGDIOBJ {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SelectObject\".}" },  { "module": "windows",  "name": "SelectPalette",  "code": "proc SelectPalette*(para1: HDC; para2: HPALETTE; para3: WINBOOL): HPALETTE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SelectPalette\".}" },  { "module": "windows",  "name": "SetBkColor",  "code": "proc SetBkColor*(para1: HDC; para2: COLORREF): COLORREF {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetBkColor\".}" },  { "module": "windows",  "name": "SetBkMode",  "code": "proc SetBkMode*(para1: HDC; para2: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetBkMode\".}" },  { "module": "windows",  "name": "SetBitmapBits",  "code": "proc SetBitmapBits*(para1: HBITMAP; para2: DWORD; para3: pointer): LONG {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetBitmapBits\".}" },  { "module": "windows",  "name": "SetBoundsRect",  "code": "proc SetBoundsRect*(para1: HDC; para2: var RECT; para3: WINUINT): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetBoundsRect\".}" },  { "module": "windows",  "name": "SetDIBits",  "code": "proc SetDIBits*(para1: HDC; para2: HBITMAP; para3: WINUINT; para4: WINUINT; \u000A                para5: pointer; para6: PBITMAPINFO; para7: WINUINT): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetDIBits\".}" },  { "module": "windows",  "name": "SetDIBitsToDevice",  "code": "proc SetDIBitsToDevice*(para1: HDC; para2: int32; para3: int32; para4: DWORD; \u000A                        para5: DWORD; para6: int32; para7: int32; \u000A                        para8: WINUINT; para9: WINUINT; para10: pointer; \u000A                        para11: var BITMAPINFO; para12: WINUINT): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetDIBitsToDevice\".}" },  { "module": "windows",  "name": "SetMapperFlags",  "code": "proc SetMapperFlags*(para1: HDC; para2: DWORD): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetMapperFlags\".}" },  { "module": "windows",  "name": "SetGraphicsMode",  "code": "proc SetGraphicsMode*(hdc: HDC; iMode: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetGraphicsMode\".}" },  { "module": "windows",  "name": "SetMapMode",  "code": "proc SetMapMode*(para1: HDC; para2: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetMapMode\".}" },  { "module": "windows",  "name": "SetMetaFileBitsEx",  "code": "proc SetMetaFileBitsEx*(para1: WINUINT; para2: var int8): HMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetMetaFileBitsEx\".}" },  { "module": "windows",  "name": "SetPaletteEntries",  "code": "proc SetPaletteEntries*(para1: HPALETTE; para2: WINUINT; para3: WINUINT; \u000A                        para4: var PALETTEENTRY): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetPaletteEntries\".}" },  { "module": "windows",  "name": "SetPixel",  "code": "proc SetPixel*(para1: HDC; para2: int32; para3: int32; para4: COLORREF): COLORREF {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetPixel\".}" },  { "module": "windows",  "name": "SetPixelV",  "code": "proc SetPixelV*(para1: HDC; para2: int32; para3: int32; para4: COLORREF): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetPixelV\".}" },  { "module": "windows",  "name": "SetPolyFillMode",  "code": "proc SetPolyFillMode*(para1: HDC; para2: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetPolyFillMode\".}" },  { "module": "windows",  "name": "StretchBlt",  "code": "proc StretchBlt*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                 para5: int32; para6: HDC; para7: int32; para8: int32; \u000A                 para9: int32; para10: int32; para11: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"StretchBlt\".}" },  { "module": "windows",  "name": "SetRectRgn",  "code": "proc SetRectRgn*(para1: HRGN; para2: int32; para3: int32; para4: int32; \u000A                 para5: int32): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetRectRgn\".}" },  { "module": "windows",  "name": "StretchDIBits",  "code": "proc StretchDIBits*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                    para5: int32; para6: int32; para7: int32; para8: int32; \u000A                    para9: int32; para10: pointer; para11: var BITMAPINFO; \u000A                    para12: WINUINT; para13: DWORD): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"StretchDIBits\".}" },  { "module": "windows",  "name": "SetROP2",  "code": "proc SetROP2*(para1: HDC; para2: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetROP2\".}" },  { "module": "windows",  "name": "SetStretchBltMode",  "code": "proc SetStretchBltMode*(para1: HDC; para2: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetStretchBltMode\".}" },  { "module": "windows",  "name": "SetSystemPaletteUse",  "code": "proc SetSystemPaletteUse*(para1: HDC; para2: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetSystemPaletteUse\".}" },  { "module": "windows",  "name": "SetTextCharacterExtra",  "code": "proc SetTextCharacterExtra*(para1: HDC; para2: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetTextCharacterExtra\".}" },  { "module": "windows",  "name": "SetTextColor",  "code": "proc SetTextColor*(para1: HDC; para2: COLORREF): COLORREF {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetTextColor\".}" },  { "module": "windows",  "name": "SetTextAlign",  "code": "proc SetTextAlign*(para1: HDC; para2: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetTextAlign\".}" },  { "module": "windows",  "name": "SetTextJustification",  "code": "proc SetTextJustification*(para1: HDC; para2: int32; para3: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetTextJustification\".}" },  { "module": "windows",  "name": "UpdateColors",  "code": "proc UpdateColors*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"UpdateColors\".}" },  { "module": "windows",  "name": "PlayMetaFileRecord",  "code": "proc PlayMetaFileRecord*(para1: HDC; para2: LPHANDLETABLE; para3: LPMETARECORD; \u000A                         para4: WINUINT): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"PlayMetaFileRecord\".}" },  { "module": "windows",  "name": "EnumMetaFile",  "code": "proc EnumMetaFile*(para1: HDC; para2: HMETAFILE; para3: ENUMMETAFILEPROC; \u000A                   para4: LPARAM): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"EnumMetaFile\".}" },  { "module": "windows",  "name": "CloseEnhMetaFile",  "code": "proc CloseEnhMetaFile*(para1: HDC): HENHMETAFILE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CloseEnhMetaFile\".}" },  { "module": "windows",  "name": "DeleteEnhMetaFile",  "code": "proc DeleteEnhMetaFile*(para1: HENHMETAFILE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"DeleteEnhMetaFile\".}" },  { "module": "windows",  "name": "EnumEnhMetaFile",  "code": "proc EnumEnhMetaFile*(para1: HDC; para2: HENHMETAFILE; para3: ENHMETAFILEPROC; \u000A                      para4: LPVOID; para5: var RECT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"EnumEnhMetaFile\".}" },  { "module": "windows",  "name": "GetEnhMetaFileHeader",  "code": "proc GetEnhMetaFileHeader*(para1: HENHMETAFILE; para2: WINUINT; \u000A                           para3: LPENHMETAHEADER): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetEnhMetaFileHeader\".}" },  { "module": "windows",  "name": "GetEnhMetaFilePaletteEntries",  "code": "proc GetEnhMetaFilePaletteEntries*(para1: HENHMETAFILE; para2: WINUINT; \u000A                                   para3: LPPALETTEENTRY): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetEnhMetaFilePaletteEntries\".}" },  { "module": "windows",  "name": "GetEnhMetaFileBits",  "code": "proc GetEnhMetaFileBits*(para1: HENHMETAFILE; para2: WINUINT; para3: LPBYTE): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetEnhMetaFileBits\".}" },  { "module": "windows",  "name": "GetWinMetaFileBits",  "code": "proc GetWinMetaFileBits*(para1: HENHMETAFILE; para2: WINUINT; para3: LPBYTE; \u000A                         para4: WINT; para5: HDC): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWinMetaFileBits\".}" },  { "module": "windows",  "name": "PlayEnhMetaFile",  "code": "proc PlayEnhMetaFile*(para1: HDC; para2: HENHMETAFILE; para3: RECT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PlayEnhMetaFile\".}" },  { "module": "windows",  "name": "PlayEnhMetaFileRecord",  "code": "proc PlayEnhMetaFileRecord*(para1: HDC; para2: LPHANDLETABLE; \u000A                            para3: var TENHMETARECORD; para4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PlayEnhMetaFileRecord\".}" },  { "module": "windows",  "name": "SetEnhMetaFileBits",  "code": "proc SetEnhMetaFileBits*(para1: WINUINT; para2: var int8): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetEnhMetaFileBits\".}" },  { "module": "windows",  "name": "SetWinMetaFileBits",  "code": "proc SetWinMetaFileBits*(para1: WINUINT; para2: var int8; para3: HDC; \u000A                         para4: var METAFILEPICT): HENHMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetWinMetaFileBits\".}" },  { "module": "windows",  "name": "GdiComment",  "code": "proc GdiComment*(para1: HDC; para2: WINUINT; para3: var int8): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GdiComment\".}" },  { "module": "windows",  "name": "AngleArc",  "code": "proc AngleArc*(para1: HDC; para2: int32; para3: int32; para4: DWORD; \u000A               para5: float32; para6: float32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"AngleArc\".}" },  { "module": "windows",  "name": "PolyPolyline",  "code": "proc PolyPolyline*(para1: HDC; para2: var POINT; para3: var DWORD; para4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyPolyline\".}" },  { "module": "windows",  "name": "GetWorldTransform",  "code": "proc GetWorldTransform*(para1: HDC; para2: LPXFORM): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWorldTransform\".}" },  { "module": "windows",  "name": "SetWorldTransform",  "code": "proc SetWorldTransform*(para1: HDC; para2: var XFORM): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetWorldTransform\".}" },  { "module": "windows",  "name": "ModifyWorldTransform",  "code": "proc ModifyWorldTransform*(para1: HDC; para2: var XFORM; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ModifyWorldTransform\".}" },  { "module": "windows",  "name": "CombineTransform",  "code": "proc CombineTransform*(para1: LPXFORM; para2: var XFORM; para3: var XFORM): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CombineTransform\".}" },  { "module": "windows",  "name": "CreateDIBSection",  "code": "proc CreateDIBSection*(para1: HDC; para2: var BITMAPINFO; para3: WINUINT; \u000A                       para4: var pointer; para5: HANDLE; para6: DWORD): HBITMAP {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreateDIBSection\".}" },  { "module": "windows",  "name": "GetDIBColorTable",  "code": "proc GetDIBColorTable*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                       para4: var RGBQUAD): WINUINT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetDIBColorTable\".}" },  { "module": "windows",  "name": "SetDIBColorTable",  "code": "proc SetDIBColorTable*(para1: HDC; para2: WINUINT; para3: WINUINT; \u000A                       para4: var RGBQUAD): WINUINT {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetDIBColorTable\".}" },  { "module": "windows",  "name": "SetColorAdjustment",  "code": "proc SetColorAdjustment*(para1: HDC; para2: var COLORADJUSTMENT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetColorAdjustment\".}" },  { "module": "windows",  "name": "GetColorAdjustment",  "code": "proc GetColorAdjustment*(para1: HDC; para2: LPCOLORADJUSTMENT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetColorAdjustment\".}" },  { "module": "windows",  "name": "CreateHalftonePalette",  "code": "proc CreateHalftonePalette*(para1: HDC): HPALETTE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CreateHalftonePalette\".}" },  { "module": "windows",  "name": "EndDoc",  "code": "proc EndDoc*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", importc: \"EndDoc\".}" },  { "module": "windows",  "name": "StartPage",  "code": "proc StartPage*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                     importc: \"StartPage\".}" },  { "module": "windows",  "name": "EndPage",  "code": "proc EndPage*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", importc: \"EndPage\".}" },  { "module": "windows",  "name": "AbortDoc",  "code": "proc AbortDoc*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A                                    importc: \"AbortDoc\".}" },  { "module": "windows",  "name": "SetAbortProc",  "code": "proc SetAbortProc*(para1: HDC; para2: TABORTPROC): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetAbortProc\".}" },  { "module": "windows",  "name": "ArcTo",  "code": "proc ArcTo*(para1: HDC; para2: int32; para3: int32; para4: int32; para5: int32; \u000A            para6: int32; para7: int32; para8: int32; para9: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ArcTo\".}" },  { "module": "windows",  "name": "BeginPath",  "code": "proc BeginPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                       importc: \"BeginPath\".}" },  { "module": "windows",  "name": "CloseFigure",  "code": "proc CloseFigure*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"CloseFigure\".}" },  { "module": "windows",  "name": "EndPath",  "code": "proc EndPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                     importc: \"EndPath\".}" },  { "module": "windows",  "name": "FillPath",  "code": "proc FillPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                      importc: \"FillPath\".}" },  { "module": "windows",  "name": "FlattenPath",  "code": "proc FlattenPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"FlattenPath\".}" },  { "module": "windows",  "name": "GetPath",  "code": "proc GetPath*(para1: HDC; para2: LPPOINT; para3: LPBYTE; para4: int32): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetPath\".}" },  { "module": "windows",  "name": "PathToRegion",  "code": "proc PathToRegion*(para1: HDC): HRGN {.stdcall, dynlib: \"gdi32\", \u000A                                       importc: \"PathToRegion\".}" },  { "module": "windows",  "name": "PolyDraw",  "code": "proc PolyDraw*(para1: HDC; para2: var POINT; para3: var int8; para4: int32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyDraw\".}" },  { "module": "windows",  "name": "SelectClipPath",  "code": "proc SelectClipPath*(para1: HDC; para2: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SelectClipPath\".}" },  { "module": "windows",  "name": "SetArcDirection",  "code": "proc SetArcDirection*(para1: HDC; para2: int32): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetArcDirection\".}" },  { "module": "windows",  "name": "SetMiterLimit",  "code": "proc SetMiterLimit*(para1: HDC; para2: float32; para3: ptr float32): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetMiterLimit\".}" },  { "module": "windows",  "name": "StrokeAndFillPath",  "code": "proc StrokeAndFillPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StrokeAndFillPath\".}" },  { "module": "windows",  "name": "StrokePath",  "code": "proc StrokePath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                        importc: \"StrokePath\".}" },  { "module": "windows",  "name": "WidenPath",  "code": "proc WidenPath*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A                                       importc: \"WidenPath\".}" },  { "module": "windows",  "name": "ExtCreatePen",  "code": "proc ExtCreatePen*(para1: DWORD; para2: DWORD; para3: var LOGBRUSH; \u000A                   para4: DWORD; para5: var DWORD): HPEN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ExtCreatePen\".}" },  { "module": "windows",  "name": "GetMiterLimit",  "code": "proc GetMiterLimit*(para1: HDC; para2: ptr float32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetMiterLimit\".}" },  { "module": "windows",  "name": "GetArcDirection",  "code": "proc GetArcDirection*(para1: HDC): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetArcDirection\".}" },  { "module": "windows",  "name": "MoveToEx",  "code": "proc MoveToEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"MoveToEx\".}" },  { "module": "windows",  "name": "CreatePolygonRgn",  "code": "proc CreatePolygonRgn*(para1: var POINT; para2: int32; para3: int32): HRGN {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreatePolygonRgn\".}" },  { "module": "windows",  "name": "DPtoLP",  "code": "proc DPtoLP*(para1: HDC; para2: LPPOINT; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"DPtoLP\".}" },  { "module": "windows",  "name": "LPtoDP",  "code": "proc LPtoDP*(para1: HDC; para2: LPPOINT; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"LPtoDP\".}" },  { "module": "windows",  "name": "Polygon",  "code": "proc Polygon*(para1: HDC; para2: LPPOINT; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"Polygon\".}" },  { "module": "windows",  "name": "Polyline",  "code": "proc Polyline*(para1: HDC; para2: LPPOINT; para3: int32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"Polyline\".}" },  { "module": "windows",  "name": "PolyBezier",  "code": "proc PolyBezier*(para1: HDC; para2: LPPOINT; para3: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolyBezier\".}" },  { "module": "windows",  "name": "PolyBezierTo",  "code": "proc PolyBezierTo*(para1: HDC; para2: POINT; para3: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolyBezierTo\".}" },  { "module": "windows",  "name": "PolylineTo",  "code": "proc PolylineTo*(para1: HDC; para2: LPPOINT; para3: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolylineTo\".}" },  { "module": "windows",  "name": "SetViewportExtEx",  "code": "proc SetViewportExtEx*(para1: HDC; para2: int32; para3: int32; para4: LPSIZE): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetViewportExtEx\".}" },  { "module": "windows",  "name": "SetViewportOrgEx",  "code": "proc SetViewportOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetViewportOrgEx\".}" },  { "module": "windows",  "name": "SetWindowExtEx",  "code": "proc SetWindowExtEx*(para1: HDC; para2: int32; para3: int32; para4: LPSIZE): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetWindowExtEx\".}" },  { "module": "windows",  "name": "SetWindowOrgEx",  "code": "proc SetWindowOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetWindowOrgEx\".}" },  { "module": "windows",  "name": "OffsetViewportOrgEx",  "code": "proc OffsetViewportOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"OffsetViewportOrgEx\".}" },  { "module": "windows",  "name": "OffsetWindowOrgEx",  "code": "proc OffsetWindowOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"OffsetWindowOrgEx\".}" },  { "module": "windows",  "name": "ScaleViewportExtEx",  "code": "proc ScaleViewportExtEx*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                         para5: int32; para6: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ScaleViewportExtEx\".}" },  { "module": "windows",  "name": "ScaleWindowExtEx",  "code": "proc ScaleWindowExtEx*(para1: HDC; para2: int32; para3: int32; para4: int32; \u000A                       para5: int32; para6: LPSIZE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ScaleWindowExtEx\".}" },  { "module": "windows",  "name": "SetBitmapDimensionEx",  "code": "proc SetBitmapDimensionEx*(para1: HBITMAP; para2: int32; para3: int32; \u000A                           para4: LPSIZE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetBitmapDimensionEx\".}" },  { "module": "windows",  "name": "SetBrushOrgEx",  "code": "proc SetBrushOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetBrushOrgEx\".}" },  { "module": "windows",  "name": "GetDCOrgEx",  "code": "proc GetDCOrgEx*(para1: HDC; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetDCOrgEx\".}" },  { "module": "windows",  "name": "FixBrushOrgEx",  "code": "proc FixBrushOrgEx*(para1: HDC; para2: int32; para3: int32; para4: LPPOINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"FixBrushOrgEx\".}" },  { "module": "windows",  "name": "UnrealizeObject",  "code": "proc UnrealizeObject*(para1: HGDIOBJ): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"UnrealizeObject\".}" },  { "module": "windows",  "name": "GdiFlush",  "code": "proc GdiFlush*(): WINBOOL {.stdcall, dynlib: \"gdi32\", importc: \"GdiFlush\".}" },  { "module": "windows",  "name": "GdiSetBatchLimit",  "code": "proc GdiSetBatchLimit*(para1: DWORD): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GdiSetBatchLimit\".}" },  { "module": "windows",  "name": "GdiGetBatchLimit",  "code": "proc GdiGetBatchLimit*(): DWORD {.stdcall, dynlib: \"gdi32\", \u000A                                  importc: \"GdiGetBatchLimit\".}" },  { "module": "windows",  "name": "SetICMMode",  "code": "proc SetICMMode*(para1: HDC; para2: int32): int32 {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SetICMMode\".}" },  { "module": "windows",  "name": "CheckColorsInGamut",  "code": "proc CheckColorsInGamut*(para1: HDC; para2: LPVOID; para3: LPVOID; para4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CheckColorsInGamut\".}" },  { "module": "windows",  "name": "GetColorSpace",  "code": "proc GetColorSpace*(para1: HDC): HANDLE {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetColorSpace\".}" },  { "module": "windows",  "name": "SetColorSpace",  "code": "proc SetColorSpace*(para1: HDC; para2: HCOLORSPACE): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetColorSpace\".}" },  { "module": "windows",  "name": "DeleteColorSpace",  "code": "proc DeleteColorSpace*(para1: HCOLORSPACE): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"DeleteColorSpace\".}" },  { "module": "windows",  "name": "GetDeviceGammaRamp",  "code": "proc GetDeviceGammaRamp*(para1: HDC; para2: LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetDeviceGammaRamp\".}" },  { "module": "windows",  "name": "SetDeviceGammaRamp",  "code": "proc SetDeviceGammaRamp*(para1: HDC; para2: LPVOID): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetDeviceGammaRamp\".}" },  { "module": "windows",  "name": "ColorMatchToTarget",  "code": "proc ColorMatchToTarget*(para1: HDC; para2: HDC; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ColorMatchToTarget\".}" },  { "module": "windows",  "name": "CreatePropertySheetPageA",  "code": "proc CreatePropertySheetPageA*(lppsp: LPCPROPSHEETPAGE): HPROPSHEETPAGE {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"CreatePropertySheetPageA\".}" },  { "module": "windows",  "name": "DestroyPropertySheetPage",  "code": "proc DestroyPropertySheetPage*(hPSPage: HPROPSHEETPAGE): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"DestroyPropertySheetPage\".}" },  { "module": "windows",  "name": "InitCommonControls",  "code": "proc InitCommonControls*() {.stdcall, dynlib: \"comctl32\", \u000A                             importc: \"InitCommonControls\".}" },  { "module": "windows",  "name": "ImageList_AddIcon",  "code": "proc ImageList_AddIcon*(himl: HIMAGELIST; hicon: HICON): int32" },  { "module": "windows",  "name": "ImageList_Create",  "code": "proc ImageList_Create*(cx: int32; cy: int32; flags: WINUINT; cInitial: int32; \u000A                       cGrow: int32): HIMAGELIST {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"ImageList_Create\".}" },  { "module": "windows",  "name": "ImageList_Destroy",  "code": "proc ImageList_Destroy*(himl: HIMAGELIST): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_Destroy\".}" },  { "module": "windows",  "name": "ImageList_GetImageCount",  "code": "proc ImageList_GetImageCount*(himl: HIMAGELIST): int32 {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_GetImageCount\".}" },  { "module": "windows",  "name": "ImageList_Add",  "code": "proc ImageList_Add*(himl: HIMAGELIST; hbmImage: HBITMAP; hbmMask: HBITMAP): int32 {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_Add\".}" },  { "module": "windows",  "name": "ImageList_ReplaceIcon",  "code": "proc ImageList_ReplaceIcon*(himl: HIMAGELIST; i: int32; hicon: HICON): int32 {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_ReplaceIcon\".}" },  { "module": "windows",  "name": "ImageList_SetBkColor",  "code": "proc ImageList_SetBkColor*(himl: HIMAGELIST; clrBk: COLORREF): COLORREF {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_SetBkColor\".}" },  { "module": "windows",  "name": "ImageList_GetBkColor",  "code": "proc ImageList_GetBkColor*(himl: HIMAGELIST): COLORREF {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_GetBkColor\".}" },  { "module": "windows",  "name": "ImageList_SetOverlayImage",  "code": "proc ImageList_SetOverlayImage*(himl: HIMAGELIST; iImage: int32; iOverlay: int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_SetOverlayImage\".}" },  { "module": "windows",  "name": "ImageList_Draw",  "code": "proc ImageList_Draw*(himl: HIMAGELIST; i: int32; hdcDst: HDC; x: int32; \u000A                     y: int32; fStyle: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_Draw\".}" },  { "module": "windows",  "name": "ImageList_Replace",  "code": "proc ImageList_Replace*(himl: HIMAGELIST; i: int32; hbmImage: HBITMAP; \u000A                        hbmMask: HBITMAP): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_Replace\".}" },  { "module": "windows",  "name": "ImageList_AddMasked",  "code": "proc ImageList_AddMasked*(himl: HIMAGELIST; hbmImage: HBITMAP; crMask: COLORREF): int32 {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_AddMasked\".}" },  { "module": "windows",  "name": "ImageList_DrawEx",  "code": "proc ImageList_DrawEx*(himl: HIMAGELIST; i: int32; hdcDst: HDC; x: int32; \u000A                       y: int32; dx: int32; dy: int32; rgbBk: COLORREF; \u000A                       rgbFg: COLORREF; fStyle: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_DrawEx\".}" },  { "module": "windows",  "name": "ImageList_Remove",  "code": "proc ImageList_Remove*(himl: HIMAGELIST; i: int32): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_Remove\".}" },  { "module": "windows",  "name": "ImageList_GetIcon",  "code": "proc ImageList_GetIcon*(himl: HIMAGELIST; i: int32; flags: WINUINT): HICON {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_GetIcon\".}" },  { "module": "windows",  "name": "ImageList_BeginDrag",  "code": "proc ImageList_BeginDrag*(himlTrack: HIMAGELIST; iTrack: int32; \u000A                          dxHotspot: int32; dyHotspot: int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_BeginDrag\".}" },  { "module": "windows",  "name": "ImageList_EndDrag",  "code": "proc ImageList_EndDrag*() {.stdcall, dynlib: \"comctl32\", \u000A                            importc: \"ImageList_EndDrag\".}" },  { "module": "windows",  "name": "ImageList_DragEnter",  "code": "proc ImageList_DragEnter*(hwndLock: HWND; x: int32; y: int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_DragEnter\".}" },  { "module": "windows",  "name": "ImageList_DragLeave",  "code": "proc ImageList_DragLeave*(hwndLock: HWND): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_DragLeave\".}" },  { "module": "windows",  "name": "ImageList_DragMove",  "code": "proc ImageList_DragMove*(x: int32; y: int32): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_DragMove\".}" },  { "module": "windows",  "name": "ImageList_SetDragCursorImage",  "code": "proc ImageList_SetDragCursorImage*(himlDrag: HIMAGELIST; iDrag: int32; \u000A                                   dxHotspot: int32; dyHotspot: int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_SetDragCursorImage\".}" },  { "module": "windows",  "name": "ImageList_DragShowNolock",  "code": "proc ImageList_DragShowNolock*(fShow: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_DragShowNolock\".}" },  { "module": "windows",  "name": "ImageList_GetDragImage",  "code": "proc ImageList_GetDragImage*(ppt: LPPOINT; pptHotspot: LPPOINT): HIMAGELIST {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_GetDragImage\".}" },  { "module": "windows",  "name": "ImageList_GetIconSize",  "code": "proc ImageList_GetIconSize*(himl: HIMAGELIST; cx: var int32; cy: var int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_GetIconSize\".}" },  { "module": "windows",  "name": "ImageList_SetIconSize",  "code": "proc ImageList_SetIconSize*(himl: HIMAGELIST; cx: int32; cy: int32): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_SetIconSize\".}" },  { "module": "windows",  "name": "ImageList_GetImageInfo",  "code": "proc ImageList_GetImageInfo*(himl: HIMAGELIST; i: int32; \u000A                             pImageInfo: var IMAGEINFO): WINBOOL {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_GetImageInfo\".}" },  { "module": "windows",  "name": "ImageList_Merge",  "code": "proc ImageList_Merge*(himl1: HIMAGELIST; i1: int32; himl2: HIMAGELIST; \u000A                      i2: int32; dx: int32; dy: int32): HIMAGELIST {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"ImageList_Merge\".}" },  { "module": "windows",  "name": "ImageList_SetImageCount",  "code": "proc ImageList_SetImageCount*(himl: HIMAGELIST; uNewCount: WINUINT): int {.\u000A    stdcall, dynlib: \"comctl32.dll\", importc: \"ImageList_SetImageCount\".}" },  { "module": "windows",  "name": "CreateToolbarEx",  "code": "proc CreateToolbarEx*(wnd: HWND; ws: DWORD; wID: WINUINT; nBitmaps: int32; \u000A                      hBMInst: HINST; wBMID: WINUINT; lpButtons: LPCTBBUTTON; \u000A                      iNumButtons: int32; dxButton: int32; dyButton: int32; \u000A                      dxBitmap: int32; dyBitmap: int32; uStructSize: WINUINT): HWND {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"CreateToolbarEx\".}" },  { "module": "windows",  "name": "CreateMappedBitmap",  "code": "proc CreateMappedBitmap*(hInstance: HINST; idBitmap: int32; wFlags: WINUINT; \u000A                         lpColorMap: LPCOLORMAP; iNumMaps: int32): HBITMAP {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"CreateMappedBitmap\".}" },  { "module": "windows",  "name": "MenuHelp",  "code": "proc MenuHelp*(uMsg: WINUINT; wp: WPARAM; lp: LPARAM; hMainMenu: HMENU; \u000A               hInst: HINST; hwndStatus: HWND; lpwIDs: var WINUINT) {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"MenuHelp\".}" },  { "module": "windows",  "name": "ShowHideMenuCtl",  "code": "proc ShowHideMenuCtl*(wnd: HWND; uFlags: WINUINT; lpInfo: LPINT): WINBOOL {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ShowHideMenuCtl\".}" },  { "module": "windows",  "name": "GetEffectiveClientRect",  "code": "proc GetEffectiveClientRect*(wnd: HWND; lprc: LPRECT; lpInfo: LPINT) {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"GetEffectiveClientRect\".}" },  { "module": "windows",  "name": "MakeDragList",  "code": "proc MakeDragList*(hLB: HWND): WINBOOL {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"MakeDragList\".}" },  { "module": "windows",  "name": "DrawInsert",  "code": "proc DrawInsert*(handParent: HWND; hLB: HWND; nItem: int32) {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"DrawInsert\".}" },  { "module": "windows",  "name": "LBItemFromPt",  "code": "proc LBItemFromPt*(hLB: HWND; pt: POINT; bAutoScroll: WINBOOL): int32 {.stdcall, \u000A    dynlib: \"comctl32\", importc: \"LBItemFromPt\".}" },  { "module": "windows",  "name": "CreateUpDownControl",  "code": "proc CreateUpDownControl*(dwStyle: DWORD; x: int32; y: int32; cx: int32; \u000A                          cy: int32; hParent: HWND; nID: int32; hInst: HINST; \u000A                          hBuddy: HWND; nUpper: int32; nLower: int32; \u000A                          nPos: int32): HWND {.stdcall, dynlib: \"comctl32\", \u000A    importc: \"CreateUpDownControl\".}" },  { "module": "windows",  "name": "RegCloseKey",  "code": "proc RegCloseKey*(key: HKEY): LONG {.stdcall, dynlib: \"advapi32\", \u000A                                     importc: \"RegCloseKey\".}" },  { "module": "windows",  "name": "RegSetKeySecurity",  "code": "proc RegSetKeySecurity*(key: HKEY; SecurityInformation: SECURITY_INFORMATION; \u000A                        pSecurityDescriptor: PSECURITY_DESCRIPTOR): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetKeySecurity\".}" },  { "module": "windows",  "name": "RegFlushKey",  "code": "proc RegFlushKey*(key: HKEY): LONG {.stdcall, dynlib: \"advapi32\", \u000A                                     importc: \"RegFlushKey\".}" },  { "module": "windows",  "name": "RegGetKeySecurity",  "code": "proc RegGetKeySecurity*(key: HKEY; SecurityInformation: SECURITY_INFORMATION; \u000A                        pSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                        lpcbSecurityDescriptor: LPDWORD): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegGetKeySecurity\".}" },  { "module": "windows",  "name": "RegNotifyChangeKeyValue",  "code": "proc RegNotifyChangeKeyValue*(key: HKEY; bWatchSubtree: WINBOOL; \u000A                              dwNotifyFilter: DWORD; hEvent: HANDLE; \u000A                              fAsynchronus: WINBOOL): LONG {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegNotifyChangeKeyValue\".}" },  { "module": "windows",  "name": "IsValidCodePage",  "code": "proc IsValidCodePage*(CodePage: WINUINT): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"IsValidCodePage\".}" },  { "module": "windows",  "name": "GetACP",  "code": "proc GetACP*(): WINUINT {.stdcall, dynlib: \"kernel32\", importc: \"GetACP\".}" },  { "module": "windows",  "name": "GetOEMCP",  "code": "proc GetOEMCP*(): WINUINT {.stdcall, dynlib: \"kernel32\", importc: \"GetOEMCP\".}" },  { "module": "windows",  "name": "GetCPInfo",  "code": "proc GetCPInfo*(para1: WINUINT; para2: LPCPINFO): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCPInfo\".}" },  { "module": "windows",  "name": "IsDBCSLeadByte",  "code": "proc IsDBCSLeadByte*(TestChar: int8): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"IsDBCSLeadByte\".}" },  { "module": "windows",  "name": "IsDBCSLeadByteEx",  "code": "proc IsDBCSLeadByteEx*(CodePage: WINUINT; TestChar: int8): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsDBCSLeadByteEx\".}" },  { "module": "windows",  "name": "MultiByteToWideChar",  "code": "proc MultiByteToWideChar*(CodePage: WINUINT; dwFlags: DWORD; \u000A                          lpMultiByteStr: LPCSTR; cchMultiByte: int32; \u000A                          lpWideCharStr: LPWSTR; cchWideChar: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MultiByteToWideChar\".}" },  { "module": "windows",  "name": "WideCharToMultiByte",  "code": "proc WideCharToMultiByte*(CodePage: WINUINT; dwFlags: DWORD; \u000A                          lpWideCharStr: LPCWSTR; cchWideChar: int32; \u000A                          lpMultiByteStr: LPSTR; cchMultiByte: int32; \u000A                          lpDefaultChar: LPCSTR; lpUsedDefaultChar: LPBOOL): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WideCharToMultiByte\".}" },  { "module": "windows",  "name": "IsValidLocale",  "code": "proc IsValidLocale*(Locale: LCID; dwFlags: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"IsValidLocale\".}" },  { "module": "windows",  "name": "ConvertDefaultLocale",  "code": "proc ConvertDefaultLocale*(Locale: LCID): LCID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ConvertDefaultLocale\".}" },  { "module": "windows",  "name": "GetThreadLocale",  "code": "proc GetThreadLocale*(): LCID {.stdcall, dynlib: \"kernel32\", \u000A                                importc: \"GetThreadLocale\".}" },  { "module": "windows",  "name": "SetThreadLocale",  "code": "proc SetThreadLocale*(Locale: LCID): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetThreadLocale\".}" },  { "module": "windows",  "name": "GetSystemDefaultLangID",  "code": "proc GetSystemDefaultLangID*(): LANGID {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemDefaultLangID\".}" },  { "module": "windows",  "name": "GetUserDefaultLangID",  "code": "proc GetUserDefaultLangID*(): LANGID {.stdcall, dynlib: \"kernel32\", \u000A                                       importc: \"GetUserDefaultLangID\".}" },  { "module": "windows",  "name": "GetSystemDefaultLCID",  "code": "proc GetSystemDefaultLCID*(): LCID {.stdcall, dynlib: \"kernel32\", \u000A                                     importc: \"GetSystemDefaultLCID\".}" },  { "module": "windows",  "name": "GetUserDefaultLCID",  "code": "proc GetUserDefaultLCID*(): LCID {.stdcall, dynlib: \"kernel32\", \u000A                                   importc: \"GetUserDefaultLCID\".}" },  { "module": "windows",  "name": "ReadConsoleOutputAttribute",  "code": "proc ReadConsoleOutputAttribute*(hConsoleOutput: HANDLE; lpAttribute: LPWORD; \u000A                                 nLength: DWORD; dwReadCoord: COORD; \u000A                                 lpNumberOfAttrsRead: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "WriteConsoleOutputAttribute",  "code": "proc WriteConsoleOutputAttribute*(hConsoleOutput: HANDLE; \u000A                                  lpAttribute: var int16; nLength: DWORD; \u000A                                  dwWriteCoord: COORD; \u000A                                  lpNumberOfAttrsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "FillConsoleOutputAttribute",  "code": "proc FillConsoleOutputAttribute*(hConsoleOutput: HANDLE; wAttribute: int16; \u000A                                 nLength: DWORD; dwWriteCoord: COORD; \u000A                                 lpNumberOfAttrsWritten: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "GetConsoleMode",  "code": "proc GetConsoleMode*(hConsoleHandle: HANDLE; lpMode: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetConsoleMode\".}" },  { "module": "windows",  "name": "GetNumberOfConsoleInputEvents",  "code": "proc GetNumberOfConsoleInputEvents*(hConsoleInput: HANDLE; \u000A                                    lpNumberOfEvents: PDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNumberOfConsoleInputEvents\".}" },  { "module": "windows",  "name": "GetConsoleScreenBufferInfo",  "code": "proc GetConsoleScreenBufferInfo*(hConsoleOutput: HANDLE; \u000A    lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetConsoleScreenBufferInfo\".}" },  { "module": "windows",  "name": "GetLargestConsoleWindowSize",  "code": "proc GetLargestConsoleWindowSize*(hConsoleOutput: HANDLE): COORD" },  { "module": "windows",  "name": "GetConsoleCursorInfo",  "code": "proc GetConsoleCursorInfo*(hConsoleOutput: HANDLE; \u000A                           lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetConsoleCursorInfo\".}" },  { "module": "windows",  "name": "GetNumberOfConsoleMouseButtons",  "code": "proc GetNumberOfConsoleMouseButtons*(lpNumberOfMouseButtons: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNumberOfConsoleMouseButtons\".}" },  { "module": "windows",  "name": "SetConsoleMode",  "code": "proc SetConsoleMode*(hConsoleHandle: HANDLE; dwMode: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleMode\".}" },  { "module": "windows",  "name": "SetConsoleActiveScreenBuffer",  "code": "proc SetConsoleActiveScreenBuffer*(hConsoleOutput: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleActiveScreenBuffer\".}" },  { "module": "windows",  "name": "FlushConsoleInputBuffer",  "code": "proc FlushConsoleInputBuffer*(hConsoleInput: HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FlushConsoleInputBuffer\".}" },  { "module": "windows",  "name": "SetConsoleScreenBufferSize",  "code": "proc SetConsoleScreenBufferSize*(hConsoleOutput: HANDLE; dwSize: COORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleScreenBufferSize\".}" },  { "module": "windows",  "name": "SetConsoleCursorPosition",  "code": "proc SetConsoleCursorPosition*(hConsoleOutput: HANDLE; dwCursorPosition: COORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleCursorPosition\".}" },  { "module": "windows",  "name": "SetConsoleCursorInfo",  "code": "proc SetConsoleCursorInfo*(hConsoleOutput: HANDLE; \u000A                           lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleCursorInfo\".}" },  { "module": "windows",  "name": "SetConsoleWindowInfo",  "code": "proc SetConsoleWindowInfo*(hConsoleOutput: HANDLE; bAbsolute: WINBOOL; \u000A                           lpConsoleWindow: var SMALL_RECT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleWindowInfo\".}" },  { "module": "windows",  "name": "SetConsoleTextAttribute",  "code": "proc SetConsoleTextAttribute*(hConsoleOutput: HANDLE; wAttributes: int16): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleTextAttribute\".}" },  { "module": "windows",  "name": "SetConsoleCtrlHandler",  "code": "proc SetConsoleCtrlHandler*(HandlerRoutine: PHANDLER_ROUTINE; Add: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleCtrlHandler\".}" },  { "module": "windows",  "name": "GenerateConsoleCtrlEvent",  "code": "proc GenerateConsoleCtrlEvent*(dwCtrlEvent: DWORD; dwProcessGroupId: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GenerateConsoleCtrlEvent\".}" },  { "module": "windows",  "name": "AllocConsole",  "code": "proc AllocConsole*(): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A                                importc: \"AllocConsole\".}" },  { "module": "windows",  "name": "FreeConsole",  "code": "proc FreeConsole*(): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A                               importc: \"FreeConsole\".}" },  { "module": "windows",  "name": "CreateConsoleScreenBuffer",  "code": "proc CreateConsoleScreenBuffer*(dwDesiredAccess: DWORD; dwShareMode: DWORD; \u000A                                lpSecurityAttributes: var SECURITY_ATTRIBUTES; \u000A                                dwFlags: DWORD; lpScreenBufferData: LPVOID): HANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateConsoleScreenBuffer\".}" },  { "module": "windows",  "name": "GetConsoleCP",  "code": "proc GetConsoleCP*(): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A                                importc: \"GetConsoleCP\".}" },  { "module": "windows",  "name": "SetConsoleCP",  "code": "proc SetConsoleCP*(wCodePageID: WINUINT): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetConsoleCP\".}" },  { "module": "windows",  "name": "GetConsoleOutputCP",  "code": "proc GetConsoleOutputCP*(): WINUINT {.stdcall, dynlib: \"kernel32\", \u000A                                      importc: \"GetConsoleOutputCP\".}" },  { "module": "windows",  "name": "SetConsoleOutputCP",  "code": "proc SetConsoleOutputCP*(wCodePageID: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetConsoleOutputCP\".}" },  { "module": "windows",  "name": "WNetConnectionDialog",  "code": "proc WNetConnectionDialog*(wnd: HWND; dwType: DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetConnectionDialog\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog",  "code": "proc WNetDisconnectDialog*(wnd: HWND; dwType: DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetDisconnectDialog\".}" },  { "module": "windows",  "name": "WNetCloseEnum",  "code": "proc WNetCloseEnum*(hEnum: HANDLE): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetCloseEnum\".}" },  { "module": "windows",  "name": "CloseServiceHandle",  "code": "proc CloseServiceHandle*(hSCObject: SC_HANDLE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"CloseServiceHandle\".}" },  { "module": "windows",  "name": "ControlService",  "code": "proc ControlService*(hService: SC_HANDLE; dwControl: DWORD; \u000A                     lpServiceStatus: LPSERVICE_STATUS): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ControlService\".}" },  { "module": "windows",  "name": "DeleteService",  "code": "proc DeleteService*(hService: SC_HANDLE): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"DeleteService\".}" },  { "module": "windows",  "name": "LockServiceDatabase",  "code": "proc LockServiceDatabase*(hSCManager: SC_HANDLE): SC_LOCK {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LockServiceDatabase\".}" },  { "module": "windows",  "name": "NotifyBootConfigStatus",  "code": "proc NotifyBootConfigStatus*(BootAcceptable: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"NotifyBootConfigStatus\".}" },  { "module": "windows",  "name": "QueryServiceObjectSecurity",  "code": "proc QueryServiceObjectSecurity*(hService: SC_HANDLE; \u000A                                 dwSecurityInformation: SECURITY_INFORMATION; \u000A                                 lpSecurityDescriptor: PSECURITY_DESCRIPTOR; \u000A                                 cbBufSize: DWORD; pcbBytesNeeded: LPDWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceObjectSecurity\".}" },  { "module": "windows",  "name": "QueryServiceStatus",  "code": "proc QueryServiceStatus*(hService: SC_HANDLE; lpServiceStatus: LPSERVICE_STATUS): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceStatus\".}" },  { "module": "windows",  "name": "SetServiceObjectSecurity",  "code": "proc SetServiceObjectSecurity*(hService: SC_HANDLE; \u000A                               dwSecurityInformation: SECURITY_INFORMATION; \u000A                               lpSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"SetServiceObjectSecurity\".}" },  { "module": "windows",  "name": "SetServiceStatus",  "code": "proc SetServiceStatus*(hServiceStatus: SERVICE_STATUS_HANDLE; \u000A                       lpServiceStatus: LPSERVICE_STATUS): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetServiceStatus\".}" },  { "module": "windows",  "name": "UnlockServiceDatabase",  "code": "proc UnlockServiceDatabase*(ScLock: SC_LOCK): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"UnlockServiceDatabase\".}" },  { "module": "windows",  "name": "ChoosePixelFormat",  "code": "proc ChoosePixelFormat*(para1: HDC; para2: PPIXELFORMATDESCRIPTOR): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ChoosePixelFormat\".}" },  { "module": "windows",  "name": "DescribePixelFormat",  "code": "proc DescribePixelFormat*(para1: HDC; para2: int32; para3: WINUINT; \u000A                          para4: LPPIXELFORMATDESCRIPTOR): int32 {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"DescribePixelFormat\".}" },  { "module": "windows",  "name": "SetPixelFormat",  "code": "proc SetPixelFormat*(para1: HDC; para2: int32; para3: PPIXELFORMATDESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetPixelFormat\".}" },  { "module": "windows",  "name": "SwapBuffers",  "code": "proc SwapBuffers*(para1: HDC): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"SwapBuffers\".}" },  { "module": "windows",  "name": "DragQueryPoint",  "code": "proc DragQueryPoint*(para1: HDROP; para2: LPPOINT): WINBOOL {.stdcall, \u000A    dynlib: \"shell32\", importc: \"DragQueryPoint\".}" },  { "module": "windows",  "name": "DragFinish",  "code": "proc DragFinish*(para1: HDROP) {.stdcall, dynlib: \"shell32\", \u000A                                 importc: \"DragFinish\".}" },  { "module": "windows",  "name": "DragAcceptFiles",  "code": "proc DragAcceptFiles*(para1: HWND; para2: WINBOOL) {.stdcall, dynlib: \"shell32\", \u000A    importc: \"DragAcceptFiles\".}" },  { "module": "windows",  "name": "DuplicateIcon",  "code": "proc DuplicateIcon*(para1: HINST; para2: HICON): HICON {.stdcall, \u000A    dynlib: \"shell32\", importc: \"DuplicateIcon\".}" },  { "module": "windows",  "name": "DdeAbandonTransaction",  "code": "proc DdeAbandonTransaction*(para1: DWORD; para2: HCONV; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeAbandonTransaction\".}" },  { "module": "windows",  "name": "DdeAccessData",  "code": "proc DdeAccessData*(para1: HDDEDATA; para2: PDWORD): PBYTE {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeAccessData\".}" },  { "module": "windows",  "name": "DdeAddData",  "code": "proc DdeAddData*(para1: HDDEDATA; para2: PBYTE; para3: DWORD; para4: DWORD): HDDEDATA {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeAddData\".}" },  { "module": "windows",  "name": "DdeClientTransaction",  "code": "proc DdeClientTransaction*(para1: PBYTE; para2: DWORD; para3: HCONV; para4: HSZ; \u000A                           para5: WINUINT; para6: WINUINT; para7: DWORD; \u000A                           para8: PDWORD): HDDEDATA {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeClientTransaction\".}" },  { "module": "windows",  "name": "DdeCmpStringHandles",  "code": "proc DdeCmpStringHandles*(para1: HSZ; para2: HSZ): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeCmpStringHandles\".}" },  { "module": "windows",  "name": "DdeConnect",  "code": "proc DdeConnect*(para1: DWORD; para2: HSZ; para3: HSZ; para4: var CONVCONTEXT): HCONV {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeConnect\".}" },  { "module": "windows",  "name": "DdeConnectList",  "code": "proc DdeConnectList*(para1: DWORD; para2: HSZ; para3: HSZ; para4: HCONVLIST; \u000A                     para5: PCONVCONTEXT): HCONVLIST {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeConnectList\".}" },  { "module": "windows",  "name": "DdeCreateDataHandle",  "code": "proc DdeCreateDataHandle*(para1: DWORD; para2: LPBYTE; para3: DWORD; \u000A                          para4: DWORD; para5: HSZ; para6: WINUINT; \u000A                          para7: WINUINT): HDDEDATA {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeCreateDataHandle\".}" },  { "module": "windows",  "name": "DdeDisconnect",  "code": "proc DdeDisconnect*(para1: HCONV): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeDisconnect\".}" },  { "module": "windows",  "name": "DdeDisconnectList",  "code": "proc DdeDisconnectList*(para1: HCONVLIST): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeDisconnectList\".}" },  { "module": "windows",  "name": "DdeEnableCallback",  "code": "proc DdeEnableCallback*(para1: DWORD; para2: HCONV; para3: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeEnableCallback\".}" },  { "module": "windows",  "name": "DdeFreeDataHandle",  "code": "proc DdeFreeDataHandle*(para1: HDDEDATA): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeFreeDataHandle\".}" },  { "module": "windows",  "name": "DdeFreeStringHandle",  "code": "proc DdeFreeStringHandle*(para1: DWORD; para2: HSZ): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeFreeStringHandle\".}" },  { "module": "windows",  "name": "DdeGetData",  "code": "proc DdeGetData*(para1: HDDEDATA; para2: LPBYTE; para3: DWORD; para4: DWORD): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeGetData\".}" },  { "module": "windows",  "name": "DdeGetLastError",  "code": "proc DdeGetLastError*(para1: DWORD): WINUINT {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeGetLastError\".}" },  { "module": "windows",  "name": "DdeImpersonateClient",  "code": "proc DdeImpersonateClient*(para1: HCONV): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeImpersonateClient\".}" },  { "module": "windows",  "name": "DdeKeepStringHandle",  "code": "proc DdeKeepStringHandle*(para1: DWORD; para2: HSZ): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeKeepStringHandle\".}" },  { "module": "windows",  "name": "DdeNameService",  "code": "proc DdeNameService*(para1: DWORD; para2: HSZ; para3: HSZ; para4: WINUINT): HDDEDATA {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeNameService\".}" },  { "module": "windows",  "name": "DdePostAdvise",  "code": "proc DdePostAdvise*(para1: DWORD; para2: HSZ; para3: HSZ): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdePostAdvise\".}" },  { "module": "windows",  "name": "DdeQueryConvInfo",  "code": "proc DdeQueryConvInfo*(para1: HCONV; para2: DWORD; para3: PCONVINFO): WINUINT {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeQueryConvInfo\".}" },  { "module": "windows",  "name": "DdeQueryNextServer",  "code": "proc DdeQueryNextServer*(para1: HCONVLIST; para2: HCONV): HCONV {.stdcall, \u000A    dynlib: \"user32\", importc: \"DdeQueryNextServer\".}" },  { "module": "windows",  "name": "DdeReconnect",  "code": "proc DdeReconnect*(para1: HCONV): HCONV {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeReconnect\".}" },  { "module": "windows",  "name": "DdeSetUserHandle",  "code": "proc DdeSetUserHandle*(para1: HCONV; para2: DWORD; para3: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeSetUserHandle\".}" },  { "module": "windows",  "name": "DdeUnaccessData",  "code": "proc DdeUnaccessData*(para1: HDDEDATA): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeUnaccessData\".}" },  { "module": "windows",  "name": "DdeUninitialize",  "code": "proc DdeUninitialize*(para1: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"DdeUninitialize\".}" },  { "module": "windows",  "name": "SHAddToRecentDocs",  "code": "proc SHAddToRecentDocs*(para1: WINUINT; para2: LPCVOID) {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHAddToRecentDocs\".}" },  { "module": "windows",  "name": "SHBrowseForFolder",  "code": "proc SHBrowseForFolder*(para1: LPBROWSEINFO): LPITEMIDLIST {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHBrowseForFolder\".}" },  { "module": "windows",  "name": "SHChangeNotify",  "code": "proc SHChangeNotify*(para1: LONG; para2: WINUINT; para3: LPCVOID; para4: LPCVOID) {.\u000A    stdcall, dynlib: \"shell32\", importc: \"SHChangeNotify\".}" },  { "module": "windows",  "name": "SHFileOperation",  "code": "proc SHFileOperation*(para1: LPSHFILEOPSTRUCT): int32 {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHFileOperation\".}" },  { "module": "windows",  "name": "SHFreeNameMappings",  "code": "proc SHFreeNameMappings*(para1: HANDLE) {.stdcall, dynlib: \"shell32\", \u000A    importc: \"SHFreeNameMappings\".}" },  { "module": "windows",  "name": "SHGetFileInfo",  "code": "proc SHGetFileInfo*(para1: LPCTSTR; para2: DWORD; para3: var SHFILEINFO; \u000A                    para4: WINUINT; para5: WINUINT): DWORD {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHGetFileInfo\".}" },  { "module": "windows",  "name": "SHGetPathFromIDList",  "code": "proc SHGetPathFromIDList*(para1: LPCITEMIDLIST; para2: LPTSTR): WINBOOL {.\u000A    stdcall, dynlib: \"shell32\", importc: \"SHGetPathFromIDList\".}" },  { "module": "windows",  "name": "SHGetSpecialFolderLocation",  "code": "proc SHGetSpecialFolderLocation*(para1: HWND; para2: int32; \u000A                                 para3: var LPITEMIDLIST): HRESULT {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHGetSpecialFolderLocation\".}" },  { "module": "windows",  "name": "CommDlgExtendedError",  "code": "proc CommDlgExtendedError*(): DWORD {.stdcall, dynlib: \"comdlg32\", \u000A                                      importc: \"CommDlgExtendedError\".}" },  { "module": "windows",  "name": "wglUseFontBitmaps",  "code": "proc wglUseFontBitmaps*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglUseFontBitmapsA\".}" },  { "module": "windows",  "name": "wglCreateContext",  "code": "proc wglCreateContext*(para1: HDC): HGLRC {.stdcall, dynlib: \"opengl32\", \u000A    importc: \"wglCreateContext\".}" },  { "module": "windows",  "name": "wglCreateLayerContext",  "code": "proc wglCreateLayerContext*(para1: HDC; para2: int32): HGLRC {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglCreateLayerContext\".}" },  { "module": "windows",  "name": "wglCopyContext",  "code": "proc wglCopyContext*(para1: HGLRC; para2: HGLRC; para3: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglCopyContext\".}" },  { "module": "windows",  "name": "wglDeleteContext",  "code": "proc wglDeleteContext*(para1: HGLRC): WINBOOL {.stdcall, dynlib: \"opengl32\", \u000A    importc: \"wglDeleteContext\".}" },  { "module": "windows",  "name": "wglGetCurrentContext",  "code": "proc wglGetCurrentContext*(): HGLRC {.stdcall, dynlib: \"opengl32\", \u000A                                      importc: \"wglGetCurrentContext\".}" },  { "module": "windows",  "name": "wglGetCurrentDC",  "code": "proc wglGetCurrentDC*(): HDC {.stdcall, dynlib: \"opengl32\", \u000A                               importc: \"wglGetCurrentDC\".}" },  { "module": "windows",  "name": "wglMakeCurrent",  "code": "proc wglMakeCurrent*(para1: HDC; para2: HGLRC): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglMakeCurrent\".}" },  { "module": "windows",  "name": "wglShareLists",  "code": "proc wglShareLists*(para1: HGLRC; para2: HGLRC): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglShareLists\".}" },  { "module": "windows",  "name": "wglUseFontBitmapsW",  "code": "proc wglUseFontBitmapsW*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglUseFontBitmapsW\".}" },  { "module": "windows",  "name": "wglUseFontOutlines",  "code": "proc wglUseFontOutlines*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD; \u000A                         para5: float32; para6: float32; para7: int32; \u000A                         para8: LPGLYPHMETRICSFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglUseFontOutlinesA\".}" },  { "module": "windows",  "name": "wglUseFontBitmapsA",  "code": "proc wglUseFontBitmapsA*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglUseFontBitmapsA\".}" },  { "module": "windows",  "name": "wglUseFontOutlinesA",  "code": "proc wglUseFontOutlinesA*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD; \u000A                          para5: float32; para6: float32; para7: int32; \u000A                          para8: LPGLYPHMETRICSFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglUseFontOutlinesA\".}" },  { "module": "windows",  "name": "wglDescribeLayerPlane",  "code": "proc wglDescribeLayerPlane*(para1: HDC; para2: int32; para3: int32; \u000A                            para4: WINUINT; para5: LPLAYERPLANEDESCRIPTOR): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglDescribeLayerPlane\".}" },  { "module": "windows",  "name": "wglGetLayerPaletteEntries",  "code": "proc wglGetLayerPaletteEntries*(para1: HDC; para2: int32; para3: int32; \u000A                                para4: int32; para5: var COLORREF): int32 {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglGetLayerPaletteEntries\".}" },  { "module": "windows",  "name": "wglGetProcAddress",  "code": "proc wglGetProcAddress*(para1: LPCSTR): TProc {.stdcall, dynlib: \"opengl32\", \u000A    importc: \"wglGetProcAddress\".}" },  { "module": "windows",  "name": "wglRealizeLayerPalette",  "code": "proc wglRealizeLayerPalette*(para1: HDC; para2: int32; para3: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglRealizeLayerPalette\".}" },  { "module": "windows",  "name": "wglSetLayerPaletteEntries",  "code": "proc wglSetLayerPaletteEntries*(para1: HDC; para2: int32; para3: int32; \u000A                                para4: int32; para5: var COLORREF): int32 {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglSetLayerPaletteEntries\".}" },  { "module": "windows",  "name": "wglSwapLayerBuffers",  "code": "proc wglSwapLayerBuffers*(para1: HDC; para2: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglSwapLayerBuffers\".}" },  { "module": "windows",  "name": "wglUseFontOutlinesW",  "code": "proc wglUseFontOutlinesW*(para1: HDC; para2: DWORD; para3: DWORD; para4: DWORD; \u000A                          para5: float32; para6: float32; para7: int32; \u000A                          para8: LPGLYPHMETRICSFLOAT): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglUseFontOutlinesW\".}" },  { "module": "windows",  "name": "Animate_Create",  "code": "proc Animate_Create*(hWndP: HWND; id: HMENU; dwStyle: DWORD; hInstance: HINST): HWND" },  { "module": "windows",  "name": "Animate_Open",  "code": "proc Animate_Open*(wnd: HWND; szName: LPTSTR): LRESULT" },  { "module": "windows",  "name": "Animate_Play",  "code": "proc Animate_Play*(wnd: HWND; `from`, `to`: int32; rep: WINUINT): LRESULT" },  { "module": "windows",  "name": "Animate_Stop",  "code": "proc Animate_Stop*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "Animate_Close",  "code": "proc Animate_Close*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "Animate_Seek",  "code": "proc Animate_Seek*(wnd: HWND; frame: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_AddPage",  "code": "proc PropSheet_AddPage*(hPropSheetDlg: HWND; hpage: HPROPSHEETPAGE): LRESULT" },  { "module": "windows",  "name": "PropSheet_Apply",  "code": "proc PropSheet_Apply*(hPropSheetDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_CancelToClose",  "code": "proc PropSheet_CancelToClose*(hPropSheetDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_Changed",  "code": "proc PropSheet_Changed*(hPropSheetDlg, hwndPage: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_GetCurrentPageHwnd",  "code": "proc PropSheet_GetCurrentPageHwnd*(hDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_GetTabControl",  "code": "proc PropSheet_GetTabControl*(hPropSheetDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_IsDialogMessage",  "code": "proc PropSheet_IsDialogMessage*(hDlg: HWND; pMsg: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_PressButton",  "code": "proc PropSheet_PressButton*(hPropSheetDlg: HWND; iButton: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_QuerySiblings",  "code": "proc PropSheet_QuerySiblings*(hPropSheetDlg: HWND; param1, param2: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_RebootSystem",  "code": "proc PropSheet_RebootSystem*(hPropSheetDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_RemovePage",  "code": "proc PropSheet_RemovePage*(hPropSheetDlg: HWND; hpage: HPROPSHEETPAGE; \u000A                           index: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_RestartWindows",  "code": "proc PropSheet_RestartWindows*(hPropSheetDlg: HWND): LRESULT" },  { "module": "windows",  "name": "PropSheet_SetCurSel",  "code": "proc PropSheet_SetCurSel*(hPropSheetDlg: HWND; hpage: HPROPSHEETPAGE; \u000A                          index: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_SetCurSelByID",  "code": "proc PropSheet_SetCurSelByID*(hPropSheetDlg: HWND; id: int32): LRESULT" },  { "module": "windows",  "name": "PropSheet_SetFinishText",  "code": "proc PropSheet_SetFinishText*(hPropSheetDlg: HWND; lpszText: LPTSTR): LRESULT" },  { "module": "windows",  "name": "PropSheet_SetTitle",  "code": "proc PropSheet_SetTitle*(hPropSheetDlg: HWND; dwStyle: DWORD; lpszText: LPCTSTR): LRESULT" },  { "module": "windows",  "name": "PropSheet_SetWizButtons",  "code": "proc PropSheet_SetWizButtons*(hPropSheetDlg: HWND; dwFlags: DWORD): LRESULT" },  { "module": "windows",  "name": "PropSheet_UnChanged",  "code": "proc PropSheet_UnChanged*(hPropSheetDlg: HWND; hwndPage: HWND): LRESULT" },  { "module": "windows",  "name": "Header_DeleteItem",  "code": "proc Header_DeleteItem*(hwndHD: HWND; index: int32): WINBOOL" },  { "module": "windows",  "name": "Header_GetItem",  "code": "proc Header_GetItem*(hwndHD: HWND; index: int32; hdi: var HD_ITEM): WINBOOL" },  { "module": "windows",  "name": "Header_GetItemCount",  "code": "proc Header_GetItemCount*(hwndHD: HWND): int32" },  { "module": "windows",  "name": "Header_InsertItem",  "code": "proc Header_InsertItem*(hwndHD: HWND; index: int32; hdi: var HD_ITEM): int32" },  { "module": "windows",  "name": "Header_Layout",  "code": "proc Header_Layout*(hwndHD: HWND; layout: var HD_LAYOUT): WINBOOL" },  { "module": "windows",  "name": "Header_SetItem",  "code": "proc Header_SetItem*(hwndHD: HWND; index: int32; hdi: var HD_ITEM): WINBOOL" },  { "module": "windows",  "name": "ListView_Arrange",  "code": "proc ListView_Arrange*(hwndLV: HWND; code: WINUINT): LRESULT" },  { "module": "windows",  "name": "ListView_CreateDragImage",  "code": "proc ListView_CreateDragImage*(wnd: HWND; i: int32; lpptUpLeft: LPPOINT): LRESULT" },  { "module": "windows",  "name": "ListView_DeleteAllItems",  "code": "proc ListView_DeleteAllItems*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_DeleteColumn",  "code": "proc ListView_DeleteColumn*(wnd: HWND; iCol: int32): LRESULT" },  { "module": "windows",  "name": "ListView_DeleteItem",  "code": "proc ListView_DeleteItem*(wnd: HWND; iItem: int32): LRESULT" },  { "module": "windows",  "name": "ListView_EditLabel",  "code": "proc ListView_EditLabel*(hwndLV: HWND; i: int32): LRESULT" },  { "module": "windows",  "name": "ListView_EnsureVisible",  "code": "proc ListView_EnsureVisible*(hwndLV: HWND; i, fPartialOK: int32): LRESULT" },  { "module": "windows",  "name": "ListView_FindItem",  "code": "proc ListView_FindItem*(wnd: HWND; iStart: int32; lvfi: var LV_FINDINFO): int32" },  { "module": "windows",  "name": "ListView_GetBkColor",  "code": "proc ListView_GetBkColor*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetCallbackMask",  "code": "proc ListView_GetCallbackMask*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetColumn",  "code": "proc ListView_GetColumn*(wnd: HWND; iCol: int32; col: var LV_COLUMN): LRESULT" },  { "module": "windows",  "name": "ListView_GetColumnWidth",  "code": "proc ListView_GetColumnWidth*(wnd: HWND; iCol: int32): LRESULT" },  { "module": "windows",  "name": "ListView_GetCountPerPage",  "code": "proc ListView_GetCountPerPage*(hwndLV: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetEditControl",  "code": "proc ListView_GetEditControl*(hwndLV: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetImageList",  "code": "proc ListView_GetImageList*(wnd: HWND; iImageList: WINT): LRESULT" },  { "module": "windows",  "name": "ListView_GetISearchString",  "code": "proc ListView_GetISearchString*(hwndLV: HWND; lpsz: LPTSTR): LRESULT" },  { "module": "windows",  "name": "ListView_GetItem",  "code": "proc ListView_GetItem*(wnd: HWND; item: var LV_ITEM): LRESULT" },  { "module": "windows",  "name": "ListView_GetItemCount",  "code": "proc ListView_GetItemCount*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetItemPosition",  "code": "proc ListView_GetItemPosition*(hwndLV: HWND; i: int32; pt: var POINT): int32" },  { "module": "windows",  "name": "ListView_GetItemSpacing",  "code": "proc ListView_GetItemSpacing*(hwndLV: HWND; fSmall: int32): LRESULT" },  { "module": "windows",  "name": "ListView_GetItemState",  "code": "proc ListView_GetItemState*(hwndLV: HWND; i, mask: int32): LRESULT" },  { "module": "windows",  "name": "ListView_GetNextItem",  "code": "proc ListView_GetNextItem*(wnd: HWND; iStart, flags: int32): LRESULT" },  { "module": "windows",  "name": "ListView_GetOrigin",  "code": "proc ListView_GetOrigin*(hwndLV: HWND; pt: var POINT): LRESULT" },  { "module": "windows",  "name": "ListView_GetSelectedCount",  "code": "proc ListView_GetSelectedCount*(hwndLV: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetStringWidth",  "code": "proc ListView_GetStringWidth*(hwndLV: HWND; psz: LPCTSTR): LRESULT" },  { "module": "windows",  "name": "ListView_GetTextBkColor",  "code": "proc ListView_GetTextBkColor*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetTextColor",  "code": "proc ListView_GetTextColor*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetTopIndex",  "code": "proc ListView_GetTopIndex*(hwndLV: HWND): LRESULT" },  { "module": "windows",  "name": "ListView_GetViewRect",  "code": "proc ListView_GetViewRect*(wnd: HWND; rc: var RECT): LRESULT" },  { "module": "windows",  "name": "ListView_HitTest",  "code": "proc ListView_HitTest*(hwndLV: HWND; info: var LV_HITTESTINFO): LRESULT" },  { "module": "windows",  "name": "ListView_InsertColumn",  "code": "proc ListView_InsertColumn*(wnd: HWND; iCol: int32; col: var LV_COLUMN): LRESULT" },  { "module": "windows",  "name": "ListView_InsertItem",  "code": "proc ListView_InsertItem*(wnd: HWND; item: var LV_ITEM): LRESULT" },  { "module": "windows",  "name": "ListView_RedrawItems",  "code": "proc ListView_RedrawItems*(hwndLV: HWND; iFirst, iLast: int32): LRESULT" },  { "module": "windows",  "name": "ListView_Scroll",  "code": "proc ListView_Scroll*(hwndLV: HWND; dx, dy: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetBkColor",  "code": "proc ListView_SetBkColor*(wnd: HWND; clrBk: COLORREF): LRESULT" },  { "module": "windows",  "name": "ListView_SetCallbackMask",  "code": "proc ListView_SetCallbackMask*(wnd: HWND; mask: WINUINT): LRESULT" },  { "module": "windows",  "name": "ListView_SetColumn",  "code": "proc ListView_SetColumn*(wnd: HWND; iCol: int32; col: var LV_COLUMN): LRESULT" },  { "module": "windows",  "name": "ListView_SetColumnWidth",  "code": "proc ListView_SetColumnWidth*(wnd: HWND; iCol, cx: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetImageList",  "code": "proc ListView_SetImageList*(wnd: HWND; himl: int32; iImageList: HIMAGELIST): LRESULT" },  { "module": "windows",  "name": "ListView_SetItem",  "code": "proc ListView_SetItem*(wnd: HWND; item: var LV_ITEM): LRESULT" },  { "module": "windows",  "name": "ListView_SetItemCount",  "code": "proc ListView_SetItemCount*(hwndLV: HWND; cItems: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetItemPosition",  "code": "proc ListView_SetItemPosition*(hwndLV: HWND; i, x, y: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetItemPosition32",  "code": "proc ListView_SetItemPosition32*(hwndLV: HWND; i, x, y: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetItemState",  "code": "proc ListView_SetItemState*(hwndLV: HWND; i, data, mask: int32): LRESULT" },  { "module": "windows",  "name": "ListView_SetItemText",  "code": "proc ListView_SetItemText*(hwndLV: HWND; i, iSubItem: int32; pszText: LPTSTR): LRESULT" },  { "module": "windows",  "name": "ListView_SetTextBkColor",  "code": "proc ListView_SetTextBkColor*(wnd: HWND; clrTextBk: COLORREF): LRESULT" },  { "module": "windows",  "name": "ListView_SetTextColor",  "code": "proc ListView_SetTextColor*(wnd: HWND; clrText: COLORREF): LRESULT" },  { "module": "windows",  "name": "ListView_SortItems",  "code": "proc ListView_SortItems*(hwndLV: HWND; pfnCompare: PFNLVCOMPARE; lPrm: LPARAM): LRESULT" },  { "module": "windows",  "name": "ListView_Update",  "code": "proc ListView_Update*(hwndLV: HWND; i: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_InsertItem",  "code": "proc TreeView_InsertItem*(wnd: HWND; lpis: LPTV_INSERTSTRUCT): LRESULT" },  { "module": "windows",  "name": "TreeView_DeleteItem",  "code": "proc TreeView_DeleteItem*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_DeleteAllItems",  "code": "proc TreeView_DeleteAllItems*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_Expand",  "code": "proc TreeView_Expand*(wnd: HWND; hitem: HTREEITEM; code: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_GetCount",  "code": "proc TreeView_GetCount*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_GetIndent",  "code": "proc TreeView_GetIndent*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_SetIndent",  "code": "proc TreeView_SetIndent*(wnd: HWND; indent: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_GetImageList",  "code": "proc TreeView_GetImageList*(wnd: HWND; iImage: WPARAM): LRESULT" },  { "module": "windows",  "name": "TreeView_SetImageList",  "code": "proc TreeView_SetImageList*(wnd: HWND; himl: HIMAGELIST; iImage: WPARAM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetNextItem",  "code": "proc TreeView_GetNextItem*(wnd: HWND; hitem: HTREEITEM; code: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_GetChild",  "code": "proc TreeView_GetChild*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetNextSibling",  "code": "proc TreeView_GetNextSibling*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetPrevSibling",  "code": "proc TreeView_GetPrevSibling*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetParent",  "code": "proc TreeView_GetParent*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetFirstVisible",  "code": "proc TreeView_GetFirstVisible*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_GetNextVisible",  "code": "proc TreeView_GetNextVisible*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetPrevVisible",  "code": "proc TreeView_GetPrevVisible*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetSelection",  "code": "proc TreeView_GetSelection*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_GetDropHilight",  "code": "proc TreeView_GetDropHilight*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_GetRoot",  "code": "proc TreeView_GetRoot*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_Select",  "code": "proc TreeView_Select*(wnd: HWND; hitem: HTREEITEM; code: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_SelectItem",  "code": "proc TreeView_SelectItem*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_SelectDropTarget",  "code": "proc TreeView_SelectDropTarget*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_SelectSetFirstVisible",  "code": "proc TreeView_SelectSetFirstVisible*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetItem",  "code": "proc TreeView_GetItem*(wnd: HWND; item: var TV_ITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_SetItem",  "code": "proc TreeView_SetItem*(wnd: HWND; item: var TV_ITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_EditLabel",  "code": "proc TreeView_EditLabel*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_GetEditControl",  "code": "proc TreeView_GetEditControl*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_GetVisibleCount",  "code": "proc TreeView_GetVisibleCount*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TreeView_HitTest",  "code": "proc TreeView_HitTest*(wnd: HWND; lpht: LPTV_HITTESTINFO): LRESULT" },  { "module": "windows",  "name": "TreeView_CreateDragImage",  "code": "proc TreeView_CreateDragImage*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_SortChildren",  "code": "proc TreeView_SortChildren*(wnd: HWND; hitem: HTREEITEM; recurse: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_EnsureVisible",  "code": "proc TreeView_EnsureVisible*(wnd: HWND; hitem: HTREEITEM): LRESULT" },  { "module": "windows",  "name": "TreeView_SortChildrenCB",  "code": "proc TreeView_SortChildrenCB*(wnd: HWND; psort: LPTV_SORTCB; recurse: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_EndEditLabelNow",  "code": "proc TreeView_EndEditLabelNow*(wnd: HWND; fCancel: int32): LRESULT" },  { "module": "windows",  "name": "TreeView_GetISearchString",  "code": "proc TreeView_GetISearchString*(hwndTV: HWND; lpsz: LPTSTR): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetImageList",  "code": "proc TabCtrl_GetImageList*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetImageList",  "code": "proc TabCtrl_SetImageList*(wnd: HWND; himl: HIMAGELIST): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetItemCount",  "code": "proc TabCtrl_GetItemCount*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetItem",  "code": "proc TabCtrl_GetItem*(wnd: HWND; iItem: int32; item: var TC_ITEM): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetItem",  "code": "proc TabCtrl_SetItem*(wnd: HWND; iItem: int32; item: var TC_ITEM): LRESULT" },  { "module": "windows",  "name": "TabCtrl_InsertItem",  "code": "proc TabCtrl_InsertItem*(wnd: HWND; iItem: int32; item: var TC_ITEM): LRESULT" },  { "module": "windows",  "name": "TabCtrl_DeleteItem",  "code": "proc TabCtrl_DeleteItem*(wnd: HWND; i: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_DeleteAllItems",  "code": "proc TabCtrl_DeleteAllItems*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetItemRect",  "code": "proc TabCtrl_GetItemRect*(wnd: HWND; i: int32; rc: var RECT): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetCurSel",  "code": "proc TabCtrl_GetCurSel*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetCurSel",  "code": "proc TabCtrl_SetCurSel*(wnd: HWND; i: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_HitTest",  "code": "proc TabCtrl_HitTest*(hwndTC: HWND; info: var TC_HITTESTINFO): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetItemExtra",  "code": "proc TabCtrl_SetItemExtra*(hwndTC: HWND; cb: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_AdjustRect",  "code": "proc TabCtrl_AdjustRect*(wnd: HWND; bLarger: WINBOOL; rc: var RECT): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetItemSize",  "code": "proc TabCtrl_SetItemSize*(wnd: HWND; x, y: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_RemoveImage",  "code": "proc TabCtrl_RemoveImage*(wnd: HWND; i: WPARAM): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetPadding",  "code": "proc TabCtrl_SetPadding*(wnd: HWND; cx, cy: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetRowCount",  "code": "proc TabCtrl_GetRowCount*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetToolTips",  "code": "proc TabCtrl_GetToolTips*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetToolTips",  "code": "proc TabCtrl_SetToolTips*(wnd: HWND; hwndTT: int32): LRESULT" },  { "module": "windows",  "name": "TabCtrl_GetCurFocus",  "code": "proc TabCtrl_GetCurFocus*(wnd: HWND): LRESULT" },  { "module": "windows",  "name": "TabCtrl_SetCurFocus",  "code": "proc TabCtrl_SetCurFocus*(wnd: HWND; i: int32): LRESULT" },  { "module": "windows",  "name": "SNDMSG",  "code": "proc SNDMSG*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetSpecA",  "code": "proc CommDlg_OpenSave_GetSpecA*(hdlg: HWND; psz: LPSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetSpecW",  "code": "proc CommDlg_OpenSave_GetSpecW*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetSpec",  "code": "proc CommDlg_OpenSave_GetSpec*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFilePathA",  "code": "proc CommDlg_OpenSave_GetFilePathA*(hdlg: HWND; psz: LPSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFilePathW",  "code": "proc CommDlg_OpenSave_GetFilePathW*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFilePath",  "code": "proc CommDlg_OpenSave_GetFilePath*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFolderPathA",  "code": "proc CommDlg_OpenSave_GetFolderPathA*(hdlg: HWND; psz: LPSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFolderPathW",  "code": "proc CommDlg_OpenSave_GetFolderPathW*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFolderPath",  "code": "proc CommDlg_OpenSave_GetFolderPath*(hdlg: HWND; psz: LPWSTR; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_GetFolderIDList",  "code": "proc CommDlg_OpenSave_GetFolderIDList*(hdlg: HWND; pidl: LPVOID; cbmax: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_SetControlText",  "code": "proc CommDlg_OpenSave_SetControlText*(hdlg: HWND; id: int32; text: LPSTR): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_HideControl",  "code": "proc CommDlg_OpenSave_HideControl*(hdlg: HWND; id: int32): LRESULT" },  { "module": "windows",  "name": "CommDlg_OpenSave_SetDefExt",  "code": "proc CommDlg_OpenSave_SetDefExt*(hdlg: HWND; pszext: LPSTR): LRESULT" },  { "module": "windows",  "name": "GetNextWindow",  "code": "proc GetNextWindow*(wnd: HWND; uCmd: WINUINT): HWND {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetWindow\".}" },  { "module": "windows",  "name": "GlobalAllocPtr",  "code": "proc GlobalAllocPtr*(flags, cb: DWord): pointer" },  { "module": "windows",  "name": "GlobalFreePtr",  "code": "proc GlobalFreePtr*(lp: pointer): pointer" },  { "module": "windows",  "name": "GlobalUnlockPtr",  "code": "proc GlobalUnlockPtr*(lp: pointer): pointer" },  { "module": "windows",  "name": "GlobalLockPtr",  "code": "proc GlobalLockPtr*(lp: pointer): pointer" },  { "module": "windows",  "name": "GlobalReAllocPtr",  "code": "proc GlobalReAllocPtr*(lp: pointer; cbNew, flags: DWord): pointer" },  { "module": "windows",  "name": "GlobalPtrHandle",  "code": "proc GlobalPtrHandle*(lp: pointer): pointer" },  { "module": "windows",  "name": "SetLayeredWindowAttributes",  "code": "proc SetLayeredWindowAttributes*(hwnd: HWND; crKey: COLORREF; bAlpha: int8; \u000A                                 dwFlags: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetLayeredWindowAttributes\".}" },  { "module": "windows",  "name": "MAKELANGID",  "code": "proc MAKELANGID*(PrimaryLang, SubLang: USHORT): int16" },  { "module": "windows",  "name": "PRIMARYLANGID",  "code": "proc PRIMARYLANGID*(LangId: int16): int16" },  { "module": "windows",  "name": "SUBLANGID",  "code": "proc SUBLANGID*(LangId: int16): int16" },  { "module": "windows",  "name": "MAKELCID",  "code": "proc MAKELCID*(LangId, SortId: int16): DWORD" },  { "module": "windows",  "name": "MAKESORTLCID",  "code": "proc MAKESORTLCID*(LangId, SortId, SortVersion: int16): DWORD" },  { "module": "windows",  "name": "LANGIDFROMLCID",  "code": "proc LANGIDFROMLCID*(LocaleId: LCID): int16" },  { "module": "windows",  "name": "SORTIDFROMLCID",  "code": "proc SORTIDFROMLCID*(LocaleId: LCID): int16" },  { "module": "windows",  "name": "SORTVERSIONFROMLCID",  "code": "proc SORTVERSIONFROMLCID*(LocaleId: LCID): int16" },  { "module": "windows",  "name": "LANG_SYSTEM_DEFAULT",  "code": "proc LANG_SYSTEM_DEFAULT*(): int16" },  { "module": "windows",  "name": "LANG_USER_DEFAULT",  "code": "proc LANG_USER_DEFAULT*(): int16" },  { "module": "windows",  "name": "LOCALE_NEUTRAL",  "code": "proc LOCALE_NEUTRAL*(): DWORD" },  { "module": "windows",  "name": "LOCALE_INVARIANT",  "code": "proc LOCALE_INVARIANT*(): DWORD" },  { "module": "windows",  "name": "Succeeded",  "code": "proc Succeeded*(Status: HRESULT): WINBOOL" },  { "module": "windows",  "name": "Failed",  "code": "proc Failed*(Status: HRESULT): WINBOOL" },  { "module": "windows",  "name": "IsError",  "code": "proc IsError*(Status: HRESULT): WINBOOL" },  { "module": "windows",  "name": "HResultCode",  "code": "proc HResultCode*(hr: HRESULT): int32" },  { "module": "windows",  "name": "HResultFacility",  "code": "proc HResultFacility*(hr: HRESULT): int32" },  { "module": "windows",  "name": "HResultSeverity",  "code": "proc HResultSeverity*(hr: HRESULT): int32" },  { "module": "windows",  "name": "MakeResult",  "code": "proc MakeResult*(p1, p2, mask: int32): HRESULT" },  { "module": "windows",  "name": "HResultFromWin32",  "code": "proc HResultFromWin32*(x: int32): HRESULT" },  { "module": "windows",  "name": "HResultFromNT",  "code": "proc HResultFromNT*(x: int32): HRESULT" },  { "module": "windows",  "name": "InitializeCriticalSection",  "code": "proc InitializeCriticalSection*(CriticalSection: var TRTLCriticalSection) {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"InitializeCriticalSection\".}" },  { "module": "windows",  "name": "EnterCriticalSection",  "code": "proc EnterCriticalSection*(CriticalSection: var TRTLCriticalSection) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"EnterCriticalSection\".}" },  { "module": "windows",  "name": "LeaveCriticalSection",  "code": "proc LeaveCriticalSection*(CriticalSection: var TRTLCriticalSection) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LeaveCriticalSection\".}" },  { "module": "windows",  "name": "DeleteCriticalSection",  "code": "proc DeleteCriticalSection*(CriticalSection: var TRTLCriticalSection) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"DeleteCriticalSection\".}" },  { "module": "windows",  "name": "InitializeCriticalSectionAndSpinCount",  "code": "proc InitializeCriticalSectionAndSpinCount*(\u000A    CriticalSection: var TRTLCriticalSection; dwSpinCount: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", \u000A    importc: \"InitializeCriticalSectionAndSpinCount\".}" },  { "module": "windows",  "name": "SetCriticalSectionSpinCount",  "code": "proc SetCriticalSectionSpinCount*(CriticalSection: var TRTLCriticalSection; \u000A                                  dwSpinCount: DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCriticalSectionSpinCount\".}" },  { "module": "windows",  "name": "TryEnterCriticalSection",  "code": "proc TryEnterCriticalSection*(CriticalSection: var TRTLCriticalSection): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"TryEnterCriticalSection\".}" },  { "module": "windows",  "name": "ControlService",  "code": "proc ControlService*(hService: SC_HANDLE; dwControl: DWORD; \u000A                     ServiceStatus: var TSERVICESTATUS): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ControlService\".}" },  { "module": "windows",  "name": "QueryServiceStatus",  "code": "proc QueryServiceStatus*(hService: SC_HANDLE; \u000A                         lpServiceStatus: var TSERVICESTATUS): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"QueryServiceStatus\".}" },  { "module": "windows",  "name": "SetServiceStatus",  "code": "proc SetServiceStatus*(hServiceStatus: SERVICE_STATUS_HANDLE; \u000A                       ServiceStatus: TSERVICESTATUS): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"SetServiceStatus\".}" },  { "module": "windows",  "name": "AdjustTokenPrivileges",  "code": "proc AdjustTokenPrivileges*(TokenHandle: THandle; DisableAllPrivileges: WINBOOL; \u000A                            NewState: TTokenPrivileges; BufferLength: DWORD; \u000A                            PreviousState: var TTokenPrivileges; \u000A                            ReturnLength: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AdjustTokenPrivileges\".}" },  { "module": "windows",  "name": "AdjustWindowRect",  "code": "proc AdjustWindowRect*(lpRect: var TRect; dwStyle: DWORD; bMenu: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"AdjustWindowRect\".}" },  { "module": "windows",  "name": "AdjustWindowRectEx",  "code": "proc AdjustWindowRectEx*(lpRect: var TRect; dwStyle: DWORD; bMenu: WINBOOL; \u000A                         dwExStyle: DWORD): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"AdjustWindowRectEx\".}" },  { "module": "windows",  "name": "AllocateAndInitializeSid",  "code": "proc AllocateAndInitializeSid*(pIdentifierAuthority: TSIDIdentifierAuthority; \u000A                               nSubAuthorityCount: int8; \u000A                               nSubAuthority0, nSubAuthority1: DWORD; \u000A    nSubAuthority2, nSubAuthority3, nSubAuthority4: DWORD; nSubAuthority5, \u000A    nSubAuthority6, nSubAuthority7: DWORD; pSid: var pointer): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"AllocateAndInitializeSid\".}" },  { "module": "windows",  "name": "AllocateLocallyUniqueId",  "code": "proc AllocateLocallyUniqueId*(Luid: var TLargeInteger): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"AllocateLocallyUniqueId\".}" },  { "module": "windows",  "name": "BackupRead",  "code": "proc BackupRead*(hFile: THandle; lpBuffer: PByte; nNumberOfBytesToRead: DWORD; \u000A                 lpNumberOfBytesRead: var DWORD; bAbort: WINBOOL; \u000A                 bProcessSecurity: WINBOOL; lpContext: var pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BackupRead\".}" },  { "module": "windows",  "name": "BackupSeek",  "code": "proc BackupSeek*(hFile: THandle; dwLowBytesToSeek, dwHighBytesToSeek: DWORD; \u000A                 lpdwLowByteSeeked, lpdwHighByteSeeked: var DWORD; \u000A                 lpContext: pointer): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"BackupSeek\".}" },  { "module": "windows",  "name": "BackupWrite",  "code": "proc BackupWrite*(hFile: THandle; lpBuffer: PByte; nNumberOfBytesToWrite: DWORD; \u000A                  lpNumberOfBytesWritten: var DWORD; \u000A                  bAbort, bProcessSecurity: WINBOOL; lpContext: var pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BackupWrite\".}" },  { "module": "windows",  "name": "BeginPaint",  "code": "proc BeginPaint*(wnd: HWND; lpPaint: var TPaintStruct): HDC {.stdcall, \u000A    dynlib: \"user32\", importc: \"BeginPaint\".}" },  { "module": "windows",  "name": "BuildCommDCB",  "code": "proc BuildCommDCB*(lpDef: cstring; lpDCB: var TDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBA\".}" },  { "module": "windows",  "name": "BuildCommDCBA",  "code": "proc BuildCommDCBA*(lpDef: LPCSTR; lpDCB: var TDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBA\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeouts",  "code": "proc BuildCommDCBAndTimeouts*(lpDef: cstring; lpDCB: var TDCB; \u000A                              lpCommTimeouts: var TCommTimeouts): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsA\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeoutsA",  "code": "proc BuildCommDCBAndTimeoutsA*(lpDef: LPCSTR; lpDCB: var TDCB; \u000A                               lpCommTimeouts: var TCommTimeouts): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsA\".}" },  { "module": "windows",  "name": "BuildCommDCBAndTimeoutsW",  "code": "proc BuildCommDCBAndTimeoutsW*(lpDef: LPWSTR; lpDCB: var TDCB; \u000A                               lpCommTimeouts: var TCommTimeouts): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"BuildCommDCBAndTimeoutsW\".}" },  { "module": "windows",  "name": "BuildCommDCBW",  "code": "proc BuildCommDCBW*(lpDef: LPWSTR; lpDCB: var TDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"BuildCommDCBW\".}" },  { "module": "windows",  "name": "CallMsgFilter",  "code": "proc CallMsgFilter*(lpMsg: var TMsg; nCode: int): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterA\".}" },  { "module": "windows",  "name": "CallMsgFilterA",  "code": "proc CallMsgFilterA*(lpMsg: var TMsg; nCode: int): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterA\".}" },  { "module": "windows",  "name": "CallMsgFilterW",  "code": "proc CallMsgFilterW*(lpMsg: var TMsg; nCode: int): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CallMsgFilterW\".}" },  { "module": "windows",  "name": "CallNamedPipe",  "code": "proc CallNamedPipe*(lpNamedPipeName: cstring; lpInBuffer: pointer; \u000A                    nInBufferSize: DWORD; lpOutBuffer: pointer; \u000A                    nOutBufferSize: DWORD; lpBytesRead: var DWORD; \u000A                    nTimeOut: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CallNamedPipeA\".}" },  { "module": "windows",  "name": "CallNamedPipeA",  "code": "proc CallNamedPipeA*(lpNamedPipeName: LPCSTR; lpInBuffer: pointer; \u000A                     nInBufferSize: DWORD; lpOutBuffer: pointer; \u000A                     nOutBufferSize: DWORD; lpBytesRead: var DWORD; \u000A                     nTimeOut: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CallNamedPipeA\".}" },  { "module": "windows",  "name": "CallNamedPipeW",  "code": "proc CallNamedPipeW*(lpNamedPipeName: LPWSTR; lpInBuffer: pointer; \u000A                     nInBufferSize: DWORD; lpOutBuffer: pointer; \u000A                     nOutBufferSize: DWORD; lpBytesRead: var DWORD; \u000A                     nTimeOut: DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CallNamedPipeW\".}" },  { "module": "windows",  "name": "CoRegisterClassObject",  "code": "proc CoRegisterClassObject*(para1: TCLSID; para2: pointer; para3: DWORD; \u000A                            para4: DWORD; out_para5: DWORD): HRESULT {.stdcall, \u000A    dynlib: \"ole32.dll\", importc: \"CoRegisterClassObject\".}" },  { "module": "windows",  "name": "ChangeDisplaySettings",  "code": "proc ChangeDisplaySettings*(lpDevMode: var TDeviceMode; dwFlags: DWORD): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsA\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsA",  "code": "proc ChangeDisplaySettingsA*(lpDevMode: var TDeviceModeA; dwFlags: DWORD): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsA\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsEx",  "code": "proc ChangeDisplaySettingsEx*(lpszDeviceName: cstring; \u000A                              lpDevMode: var TDeviceMode; wnd: HWND; \u000A                              dwFlags: DWORD; lParam: pointer): int32 {.stdcall, \u000A    dynlib: \"user32\", importc: \"ChangeDisplaySettingsExA\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsExA",  "code": "proc ChangeDisplaySettingsExA*(lpszDeviceName: LPCSTR; \u000A                               lpDevMode: var TDeviceModeA; wnd: HWND; \u000A                               dwFlags: DWORD; lParam: pointer): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsExA\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsExW",  "code": "proc ChangeDisplaySettingsExW*(lpszDeviceName: LPWSTR; \u000A                               lpDevMode: var TDeviceModeW; wnd: HWND; \u000A                               dwFlags: DWORD; lParam: pointer): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsExW\".}" },  { "module": "windows",  "name": "ChangeDisplaySettingsW",  "code": "proc ChangeDisplaySettingsW*(lpDevMode: var TDeviceModeW; dwFlags: DWORD): int32 {.\u000A    stdcall, dynlib: \"user32\", importc: \"ChangeDisplaySettingsW\".}" },  { "module": "windows",  "name": "ChoosePixelFormat",  "code": "proc ChoosePixelFormat*(para1: HDC; para2: var PIXELFORMATDESCRIPTOR): int32 {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"ChoosePixelFormat\".}" },  { "module": "windows",  "name": "ClearCommError",  "code": "proc ClearCommError*(hFile: THandle; lpErrors: var DWORD; lpStat: PComStat): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ClearCommError\".}" },  { "module": "windows",  "name": "ClientToScreen",  "code": "proc ClientToScreen*(wnd: HWND; lpPoint: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ClientToScreen\".}" },  { "module": "windows",  "name": "ClipCursor",  "code": "proc ClipCursor*(lpRect: var RECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ClipCursor\".}" },  { "module": "windows",  "name": "CommConfigDialog",  "code": "proc CommConfigDialog*(lpszName: cstring; wnd: HWND; lpCC: var TCommConfig): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogA\".}" },  { "module": "windows",  "name": "CommConfigDialogA",  "code": "proc CommConfigDialogA*(lpszName: LPCSTR; wnd: HWND; lpCC: var TCommConfig): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogA\".}" },  { "module": "windows",  "name": "CommConfigDialogW",  "code": "proc CommConfigDialogW*(lpszName: LPWSTR; wnd: HWND; lpCC: var TCommConfig): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CommConfigDialogW\".}" },  { "module": "windows",  "name": "CopyAcceleratorTable",  "code": "proc CopyAcceleratorTable*(hAccelSrc: HACCEL; lpAccelDst: pointer; \u000A                           cAccelEntries: int): int {.stdcall, dynlib: \"user32\", \u000A    importc: \"CopyAcceleratorTableA\".}" },  { "module": "windows",  "name": "CopyAcceleratorTableA",  "code": "proc CopyAcceleratorTableA*(hAccelSrc: HACCEL; lpAccelDst: pointer; \u000A                            cAccelEntries: int): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyAcceleratorTableA\".}" },  { "module": "windows",  "name": "CopyAcceleratorTableW",  "code": "proc CopyAcceleratorTableW*(hAccelSrc: HACCEL; lpAccelDst: pointer; \u000A                            cAccelEntries: int): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyAcceleratorTableW\".}" },  { "module": "windows",  "name": "CopyRect",  "code": "proc CopyRect*(lprcDst: var TRect; lprcSrc: TRect): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CopyRect\".}" },  { "module": "windows",  "name": "CreateAcceleratorTable",  "code": "proc CreateAcceleratorTable*(Accel: pointer; Count: int): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableA\".}" },  { "module": "windows",  "name": "CreateAcceleratorTableA",  "code": "proc CreateAcceleratorTableA*(Accel: pointer; Count: int): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableA\".}" },  { "module": "windows",  "name": "CreateAcceleratorTableW",  "code": "proc CreateAcceleratorTableW*(Accel: pointer; Count: int): HACCEL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateAcceleratorTableW\".}" },  { "module": "windows",  "name": "CreateColorSpace",  "code": "proc CreateColorSpace*(ColorSpace: var TLogColorSpace): HCOLORSPACE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateColorSpaceA\".}" },  { "module": "windows",  "name": "CreateColorSpaceA",  "code": "proc CreateColorSpaceA*(ColorSpace: var TLogColorSpaceA): HCOLORSPACE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreateColorSpaceA\".}" },  { "module": "windows",  "name": "CreateDialogIndirectParam",  "code": "proc CreateDialogIndirectParam*(hInstance: HINST; lpTemplate: TDlgTemplate; \u000A                                hWndParent: HWND; lpDialogFunc: TFNDlgProc; \u000A                                dwInitParam: LPARAM): HWND {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateDialogIndirectParamA\".}" },  { "module": "windows",  "name": "CreateIconIndirect",  "code": "proc CreateIconIndirect*(piconinfo: var TIconInfo): HICON {.stdcall, \u000A    dynlib: \"user32\", importc: \"CreateIconIndirect\".}" },  { "module": "windows",  "name": "CreatePipe",  "code": "proc CreatePipe*(hReadPipe, hWritePipe: var THandle; \u000A                 lpPipeAttributes: PSecurityAttributes; nSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreatePipe\".}" },  { "module": "windows",  "name": "CreatePolygonRgn",  "code": "proc CreatePolygonRgn*(Points: pointer; Count, FillMode: int): HRGN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"CreatePolygonRgn\".}" },  { "module": "windows",  "name": "CreatePolyPolygonRgn",  "code": "proc CreatePolyPolygonRgn*(pPtStructs: pointer; pIntArray: pointer; p3, p4: int): HRGN {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"CreatePolyPolygonRgn\".}" },  { "module": "windows",  "name": "CreateProcess",  "code": "proc CreateProcess*(lpApplicationName: cstring; lpCommandLine: cstring; \u000A    lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; \u000A                    bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                    lpEnvironment: pointer; lpCurrentDirectory: cstring; \u000A                    lpStartupInfo: TStartupInfo; \u000A                    lpProcessInformation: var TProcessInformation): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessA\".}" },  { "module": "windows",  "name": "CreateProcessA",  "code": "proc CreateProcessA*(lpApplicationName: LPCSTR; lpCommandLine: LPCSTR; \u000A    lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; \u000A                     bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                     lpEnvironment: pointer; lpCurrentDirectory: LPCSTR; \u000A                     lpStartupInfo: TStartupInfo; \u000A                     lpProcessInformation: var TProcessInformation): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessA\".}" },  { "module": "windows",  "name": "CreateProcessW",  "code": "proc CreateProcessW*(lpApplicationName: LPWSTR; lpCommandLine: LPWSTR; \u000A    lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; \u000A                     bInheritHandles: WINBOOL; dwCreationFlags: DWORD; \u000A                     lpEnvironment: pointer; lpCurrentDirectory: LPWSTR; \u000A                     lpStartupInfo: TStartupInfo; \u000A                     lpProcessInformation: var TProcessInformation): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessW\".}" },  { "module": "windows",  "name": "CreateRemoteThread",  "code": "proc CreateRemoteThread*(hProcess: THandle; lpThreadAttributes: pointer; \u000A                         dwStackSize: DWORD; \u000A                         lpStartAddress: TFNThreadStartRoutine; \u000A                         lpParameter: pointer; dwCreationFlags: DWORD; \u000A                         lpThreadId: var DWORD): THandle {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateRemoteThread\".}" },  { "module": "windows",  "name": "CreateThread",  "code": "proc CreateThread*(lpThreadAttributes: pointer; dwStackSize: DWORD; \u000A                   lpStartAddress: TFNThreadStartRoutine; lpParameter: pointer; \u000A                   dwCreationFlags: DWORD; lpThreadId: var DWORD): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateThread\".}" },  { "module": "windows",  "name": "DdeSetQualityOfService",  "code": "proc DdeSetQualityOfService*(hWndClient: HWnd; \u000A                             pqosNew: TSecurityQualityOfService; \u000A                             pqosPrev: PSecurityQualityOfService): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DdeSetQualityOfService\".}" },  { "module": "windows",  "name": "DescribePixelFormat",  "code": "proc DescribePixelFormat*(DC: HDC; p2: int; p3: WINUINT; \u000A                          p4: var TPixelFormatDescriptor): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"DescribePixelFormat\".}" },  { "module": "windows",  "name": "DeviceIoControl",  "code": "proc DeviceIoControl*(hDevice: THandle; dwIoControlCode: DWORD; \u000A                      lpInBuffer: pointer; nInBufferSize: DWORD; \u000A                      lpOutBuffer: pointer; nOutBufferSize: DWORD; \u000A                      lpBytesReturned: var DWORD; lpOverlapped: POverlapped): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"DeviceIoControl\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParam",  "code": "proc DialogBoxIndirectParam*(hInstance: HINST; lpDialogTemplate: TDlgTemplate; \u000A                             hWndParent: HWND; lpDialogFunc: TFNDlgProc; \u000A                             dwInitParam: LPARAM): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamA\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParamA",  "code": "proc DialogBoxIndirectParamA*(hInstance: HINST; lpDialogTemplate: TDlgTemplate; \u000A                              hWndParent: HWND; lpDialogFunc: TFNDlgProc; \u000A                              dwInitParam: LPARAM): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamA\".}" },  { "module": "windows",  "name": "DialogBoxIndirectParamW",  "code": "proc DialogBoxIndirectParamW*(hInstance: HINST; lpDialogTemplate: TDlgTemplate; \u000A                              hWndParent: HWND; lpDialogFunc: TFNDlgProc; \u000A                              dwInitParam: LPARAM): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"DialogBoxIndirectParamW\".}" },  { "module": "windows",  "name": "DispatchMessage",  "code": "proc DispatchMessage*(lpMsg: TMsg): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageA\".}" },  { "module": "windows",  "name": "DispatchMessageA",  "code": "proc DispatchMessageA*(lpMsg: TMsg): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageA\".}" },  { "module": "windows",  "name": "DispatchMessageW",  "code": "proc DispatchMessageW*(lpMsg: TMsg): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"DispatchMessageW\".}" },  { "module": "windows",  "name": "DosDateTimeToFileTime",  "code": "proc DosDateTimeToFileTime*(wFatDate, wFatTime: int16; lpFileTime: var TFileTime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"DosDateTimeToFileTime\".}" },  { "module": "windows",  "name": "DPtoLP",  "code": "proc DPtoLP*(DC: HDC; Points: pointer; Count: int): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"DPtoLP\".}" },  { "module": "windows",  "name": "DrawEdge",  "code": "proc DrawEdge*(hdc: HDC; qrc: var TRect; edge: WINUINT; grfFlags: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawEdge\".}" },  { "module": "windows",  "name": "DrawFrameControl",  "code": "proc DrawFrameControl*(DC: HDC; Rect: TRect; uType, uState: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawFrameControl\".}" },  { "module": "windows",  "name": "DrawText",  "code": "proc DrawText*(hDC: HDC; lpString: cstring; nCount: int; lpRect: var TRect; \u000A               uFormat: WINUINT): int {.stdcall, dynlib: \"user32\", \u000A                                        importc: \"DrawTextA\".}" },  { "module": "windows",  "name": "DrawTextA",  "code": "proc DrawTextA*(hDC: HDC; lpString: LPCSTR; nCount: int; lpRect: var TRect; \u000A                uFormat: WINUINT): int {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawTextA\".}" },  { "module": "windows",  "name": "DrawTextEx",  "code": "proc DrawTextEx*(DC: HDC; lpchText: cstring; cchText: int; p4: var TRect; \u000A                 dwDTFormat: WINUINT; DTParams: PDrawTextParams): int {.stdcall, \u000A    dynlib: \"user32\", importc: \"DrawTextExA\".}" },  { "module": "windows",  "name": "DrawTextExA",  "code": "proc DrawTextExA*(DC: HDC; lpchText: LPCSTR; cchText: int; p4: var TRect; \u000A                  dwDTFormat: WINUINT; DTParams: PDrawTextParams): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawTextExA\".}" },  { "module": "windows",  "name": "DrawTextExW",  "code": "proc DrawTextExW*(DC: HDC; lpchText: LPWSTR; cchText: int; p4: var TRect; \u000A                  dwDTFormat: WINUINT; DTParams: PDrawTextParams): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"DrawTextExW\".}" },  { "module": "windows",  "name": "DrawTextW",  "code": "proc DrawTextW*(hDC: HDC; lpString: LPWSTR; nCount: int; lpRect: var TRect; \u000A                uFormat: WINUINT): int {.stdcall, dynlib: \"user32\", \u000A    importc: \"DrawTextW\".}" },  { "module": "windows",  "name": "EndPaint",  "code": "proc EndPaint*(wnd: HWND; lpPaint: TPaintStruct): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EndPaint\".}" },  { "module": "windows",  "name": "EnumDisplaySettings",  "code": "proc EnumDisplaySettings*(lpszDeviceName: cstring; iModeNum: DWORD; \u000A                          lpDevMode: var TDeviceMode): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsA\".}" },  { "module": "windows",  "name": "EnumDisplaySettingsA",  "code": "proc EnumDisplaySettingsA*(lpszDeviceName: LPCSTR; iModeNum: DWORD; \u000A                           lpDevMode: var TDeviceModeA): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsA\".}" },  { "module": "windows",  "name": "EnumDisplaySettingsW",  "code": "proc EnumDisplaySettingsW*(lpszDeviceName: LPWSTR; iModeNum: DWORD; \u000A                           lpDevMode: var TDeviceModeW): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"EnumDisplaySettingsW\".}" },  { "module": "windows",  "name": "ExtCreatePen",  "code": "proc ExtCreatePen*(PenStyle, Width: DWORD; Brush: TLogBrush; StyleCount: DWORD; \u000A                   Style: pointer): HPEN {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ExtCreatePen\".}" },  { "module": "windows",  "name": "ExtCreateRegion",  "code": "proc ExtCreateRegion*(p1: PXForm; p2: DWORD; p3: TRgnData): HRGN {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"ExtCreateRegion\".}" },  { "module": "windows",  "name": "FileTimeToDosDateTime",  "code": "proc FileTimeToDosDateTime*(lpFileTime: TFileTime; \u000A                            lpFatDate, lpFatTime: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FileTimeToDosDateTime\".}" },  { "module": "windows",  "name": "FileTimeToLocalFileTime",  "code": "proc FileTimeToLocalFileTime*(lpFileTime: TFileTime; \u000A                              lpLocalFileTime: var TFileTime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FileTimeToLocalFileTime\".}" },  { "module": "windows",  "name": "FileTimeToSystemTime",  "code": "proc FileTimeToSystemTime*(lpFileTime: TFileTime; lpSystemTime: var TSystemTime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FileTimeToSystemTime\".}" },  { "module": "windows",  "name": "FillConsoleOutputAttribute",  "code": "proc FillConsoleOutputAttribute*(hConsoleOutput: THandle; wAttribute: int16; \u000A                                 nLength: DWORD; dwWriteCoord: TCoord; \u000A                                 lpNumberOfAttrsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacter",  "code": "proc FillConsoleOutputCharacter*(hConsoleOutput: THandle; cCharacter: char; \u000A                                 nLength: DWORD; dwWriteCoord: TCoord; \u000A                                 lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacterA",  "code": "proc FillConsoleOutputCharacterA*(hConsoleOutput: THandle; cCharacter: char; \u000A                                  nLength: DWORD; dwWriteCoord: TCoord; \u000A                                  lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "FillConsoleOutputCharacterW",  "code": "proc FillConsoleOutputCharacterW*(hConsoleOutput: THandle; cCharacter: WideChar; \u000A                                  nLength: DWORD; dwWriteCoord: TCoord; \u000A                                  lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FillConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "FindFirstFile",  "code": "proc FindFirstFile*(lpFileName: cstring; lpFindFileData: var TWIN32FindData): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileA\".}" },  { "module": "windows",  "name": "FindFirstFileA",  "code": "proc FindFirstFileA*(lpFileName: LPCSTR; lpFindFileData: var TWIN32FindDataA): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileA\".}" },  { "module": "windows",  "name": "FindFirstFileW",  "code": "proc FindFirstFileW*(lpFileName: LPWSTR; lpFindFileData: var TWIN32FindDataW): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindFirstFileW\".}" },  { "module": "windows",  "name": "FindNextFile",  "code": "proc FindNextFile*(hFindFile: THandle; lpFindFileData: var TWIN32FindData): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileA\".}" },  { "module": "windows",  "name": "FindNextFileA",  "code": "proc FindNextFileA*(hFindFile: THandle; lpFindFileData: var TWIN32FindDataA): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileA\".}" },  { "module": "windows",  "name": "FindNextFileW",  "code": "proc FindNextFileW*(hFindFile: THandle; lpFindFileData: var TWIN32FindDataW): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileW\".}" },  { "module": "windows",  "name": "GetAspectRatioFilterEx",  "code": "proc GetAspectRatioFilterEx*(DC: HDC; p2: var TSize): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetAspectRatioFilterEx\".}" },  { "module": "windows",  "name": "GetBinaryType",  "code": "proc GetBinaryType*(lpApplicationName: cstring; lpBinaryType: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeA\".}" },  { "module": "windows",  "name": "GetBinaryTypeA",  "code": "proc GetBinaryTypeA*(lpApplicationName: LPCSTR; lpBinaryType: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeA\".}" },  { "module": "windows",  "name": "GetBinaryTypeW",  "code": "proc GetBinaryTypeW*(lpApplicationName: LPWSTR; lpBinaryType: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetBinaryTypeW\".}" },  { "module": "windows",  "name": "GetBitmapDimensionEx",  "code": "proc GetBitmapDimensionEx*(p1: HBITMAP; p2: var TSize): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBitmapDimensionEx\".}" },  { "module": "windows",  "name": "GetBoundsRect",  "code": "proc GetBoundsRect*(DC: HDC; p2: var TRect; p3: WINUINT): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBoundsRect\".}" },  { "module": "windows",  "name": "GetBrushOrgEx",  "code": "proc GetBrushOrgEx*(DC: HDC; p2: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetBrushOrgEx\".}" },  { "module": "windows",  "name": "GetCaretPos",  "code": "proc GetCaretPos*(lpPoint: var TPoint): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetCaretPos\".}" },  { "module": "windows",  "name": "GetCharABCWidths",  "code": "proc GetCharABCWidths*(DC: HDC; p2, p3: WINUINT; ABCStructs: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsA",  "code": "proc GetCharABCWidthsA*(DC: HDC; p2, p3: WINUINT; ABCStructs: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloat",  "code": "proc GetCharABCWidthsFloat*(DC: HDC; p2, p3: WINUINT; ABCFloatSturcts: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloatA",  "code": "proc GetCharABCWidthsFloatA*(DC: HDC; p2, p3: WINUINT; ABCFloatSturcts: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatA\".}" },  { "module": "windows",  "name": "GetCharABCWidthsFloatW",  "code": "proc GetCharABCWidthsFloatW*(DC: HDC; p2, p3: WINUINT; ABCFloatSturcts: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsFloatW\".}" },  { "module": "windows",  "name": "GetCharABCWidthsW",  "code": "proc GetCharABCWidthsW*(DC: HDC; p2, p3: WINUINT; ABCStructs: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharABCWidthsW\".}" },  { "module": "windows",  "name": "GetCharacterPlacement",  "code": "proc GetCharacterPlacement*(DC: HDC; p2: cstring; p3, p4: WINBOOL; \u000A                            p5: var TGCPResults; p6: DWORD): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharacterPlacementA\".}" },  { "module": "windows",  "name": "GetCharacterPlacementA",  "code": "proc GetCharacterPlacementA*(DC: HDC; p2: LPCSTR; p3, p4: WINBOOL; \u000A                             p5: var TGCPResults; p6: DWORD): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharacterPlacementA\".}" },  { "module": "windows",  "name": "GetCharacterPlacementW",  "code": "proc GetCharacterPlacementW*(DC: HDC; p2: LPWSTR; p3, p4: WINBOOL; \u000A                             p5: var TGCPResults; p6: DWORD): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetCharacterPlacementW\".}" },  { "module": "windows",  "name": "GetCharWidth",  "code": "proc GetCharWidth*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthA\".}" },  { "module": "windows",  "name": "GetCharWidth32",  "code": "proc GetCharWidth32*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32A\".}" },  { "module": "windows",  "name": "GetCharWidth32A",  "code": "proc GetCharWidth32A*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32A\".}" },  { "module": "windows",  "name": "GetCharWidth32W",  "code": "proc GetCharWidth32W*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidth32W\".}" },  { "module": "windows",  "name": "GetCharWidthA",  "code": "proc GetCharWidthA*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthA\".}" },  { "module": "windows",  "name": "GetCharWidthFloat",  "code": "proc GetCharWidthFloat*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthFloatA\".}" },  { "module": "windows",  "name": "GetCharWidthFloatA",  "code": "proc GetCharWidthFloatA*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthFloatA\".}" },  { "module": "windows",  "name": "GetCharWidthFloatW",  "code": "proc GetCharWidthFloatW*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthFloatW\".}" },  { "module": "windows",  "name": "GetCharWidthW",  "code": "proc GetCharWidthW*(DC: HDC; p2, p3: WINUINT; Widths: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetCharWidthW\".}" },  { "module": "windows",  "name": "GetClassInfo",  "code": "proc GetClassInfo*(hInstance: HINST; lpClassName: cstring; \u000A                   lpWndClass: var TWndClass): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassInfoA\".}" },  { "module": "windows",  "name": "GetClassInfoA",  "code": "proc GetClassInfoA*(hInstance: HINST; lpClassName: LPCSTR; \u000A                    lpWndClass: var TWndClassA): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassInfoA\".}" },  { "module": "windows",  "name": "GetClassInfoEx",  "code": "proc GetClassInfoEx*(Instance: HINST; Classname: cstring; \u000A                     WndClass: var TWndClassEx): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClassInfoExA\".}" },  { "module": "windows",  "name": "GetClientRect",  "code": "proc GetClientRect*(wnd: HWND; lpRect: var TRect): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetClientRect\".}" },  { "module": "windows",  "name": "GetClipBox",  "code": "proc GetClipBox*(DC: HDC; Rect: var TRect): int {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetClipBox\".}" },  { "module": "windows",  "name": "GetClipCursor",  "code": "proc GetClipCursor*(lpRect: var TRect): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetClipCursor\".}" },  { "module": "windows",  "name": "GetColorAdjustment",  "code": "proc GetColorAdjustment*(DC: HDC; p2: var TColorAdjustment): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetColorAdjustment\".}" },  { "module": "windows",  "name": "GetCommConfig",  "code": "proc GetCommConfig*(hCommDev: THandle; lpCC: var TCommConfig; \u000A                    lpdwSize: var DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetCommConfig\".}" },  { "module": "windows",  "name": "GetCommMask",  "code": "proc GetCommMask*(hFile: THandle; lpEvtMask: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCommMask\".}" },  { "module": "windows",  "name": "GetCommModemStatus",  "code": "proc GetCommModemStatus*(hFile: THandle; lpModemStat: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommModemStatus\".}" },  { "module": "windows",  "name": "GetCommProperties",  "code": "proc GetCommProperties*(hFile: THandle; lpCommProp: var TCommProp): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommProperties\".}" },  { "module": "windows",  "name": "GetCommState",  "code": "proc GetCommState*(hFile: THandle; lpDCB: var TDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCommState\".}" },  { "module": "windows",  "name": "GetCommTimeouts",  "code": "proc GetCommTimeouts*(hFile: THandle; lpCommTimeouts: var TCommTimeouts): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetCommTimeouts\".}" },  { "module": "windows",  "name": "GetComputerName",  "code": "proc GetComputerName*(lpBuffer: cstring; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameA\".}" },  { "module": "windows",  "name": "GetComputerNameA",  "code": "proc GetComputerNameA*(lpBuffer: LPCSTR; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameA\".}" },  { "module": "windows",  "name": "GetComputerNameW",  "code": "proc GetComputerNameW*(lpBuffer: LPWSTR; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetComputerNameW\".}" },  { "module": "windows",  "name": "GetConsoleCursorInfo",  "code": "proc GetConsoleCursorInfo*(hConsoleOutput: THandle; \u000A                           lpConsoleCursorInfo: var TConsoleCursorInfo): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetConsoleCursorInfo\".}" },  { "module": "windows",  "name": "GetConsoleMode",  "code": "proc GetConsoleMode*(hConsoleHandle: THandle; lpMode: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetConsoleMode\".}" },  { "module": "windows",  "name": "GetConsoleScreenBufferInfo",  "code": "proc GetConsoleScreenBufferInfo*(hConsoleOutput: THandle; \u000A    lpConsoleScreenBufferInfo: var TConsoleScreenBufferInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetConsoleScreenBufferInfo\".}" },  { "module": "windows",  "name": "GetCPInfo",  "code": "proc GetCPInfo*(CodePage: WINUINT; lpCPInfo: var TCPInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetCPInfo\".}" },  { "module": "windows",  "name": "GetCursorInfo",  "code": "proc GetCursorInfo*(pci: var TCursorInfo): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetCursorInfo\".}" },  { "module": "windows",  "name": "GetCursorPos",  "code": "proc GetCursorPos*(lpPoint: var TPoint): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetCursorPos\".}" },  { "module": "windows",  "name": "GetDCOrgEx",  "code": "proc GetDCOrgEx*(DC: HDC; Origin: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetDCOrgEx\".}" },  { "module": "windows",  "name": "GetDefaultCommConfig",  "code": "proc GetDefaultCommConfig*(lpszName: cstring; lpCC: var TCommConfig; \u000A                           lpdwSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigA\".}" },  { "module": "windows",  "name": "GetDefaultCommConfigA",  "code": "proc GetDefaultCommConfigA*(lpszName: LPCSTR; lpCC: var TCommConfig; \u000A                            lpdwSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigA\".}" },  { "module": "windows",  "name": "GetDefaultCommConfigW",  "code": "proc GetDefaultCommConfigW*(lpszName: LPWSTR; lpCC: var TCommConfig; \u000A                            lpdwSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetDefaultCommConfigW\".}" },  { "module": "windows",  "name": "GetDIBColorTable",  "code": "proc GetDIBColorTable*(DC: HDC; p2, p3: WINUINT; RGBQuadStructs: pointer): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetDIBColorTable\".}" },  { "module": "windows",  "name": "GetDIBits",  "code": "proc GetDIBits*(DC: HDC; Bitmap: HBitmap; StartScan, NumScans: WINUINT; \u000A                Bits: pointer; BitInfo: var TBitmapInfo; Usage: WINUINT): int {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetDIBits\".}" },  { "module": "windows",  "name": "GetDiskFreeSpace",  "code": "proc GetDiskFreeSpace*(lpRootPathName: cstring; lpSectorsPerCluster, \u000A    lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceA",  "code": "proc GetDiskFreeSpaceA*(lpRootPathName: LPCSTR; lpSectorsPerCluster, \u000A    lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceEx",  "code": "proc GetDiskFreeSpaceEx*(lpDirectoryName: cstring; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: var TLargeInteger; \u000A                         lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceExA",  "code": "proc GetDiskFreeSpaceExA*(lpDirectoryName: LPCSTR; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: var TLargeInteger; \u000A                          lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceExW",  "code": "proc GetDiskFreeSpaceExW*(lpDirectoryName: LPWSTR; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: var TLargeInteger; \u000A                          lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExW\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceW",  "code": "proc GetDiskFreeSpaceW*(lpRootPathName: LPWSTR; lpSectorsPerCluster, \u000A    lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceW\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceEx",  "code": "proc GetDiskFreeSpaceEx*(lpDirectoryName: cstring; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: PLargeInteger; lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceExA",  "code": "proc GetDiskFreeSpaceExA*(lpDirectoryName: LPCSTR; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: PLargeInteger; lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExA\".}" },  { "module": "windows",  "name": "GetDiskFreeSpaceExW",  "code": "proc GetDiskFreeSpaceExW*(lpDirectoryName: LPWSTR; lpFreeBytesAvailableToCaller, \u000A    lpTotalNumberOfBytes: PLargeInteger; lpTotalNumberOfFreeBytes: PLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetDiskFreeSpaceExW\".}" },  { "module": "windows",  "name": "GetExitCodeProcess",  "code": "proc GetExitCodeProcess*(hProcess: THandle; lpExitCode: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetExitCodeProcess\".}" },  { "module": "windows",  "name": "GetExitCodeThread",  "code": "proc GetExitCodeThread*(hThread: THandle; lpExitCode: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetExitCodeThread\".}" },  { "module": "windows",  "name": "GetFileInformationByHandle",  "code": "proc GetFileInformationByHandle*(hFile: THandle; lpFileInformation: var TByHandleFileInformation): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFileInformationByHandle\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSize",  "code": "proc GetFileVersionInfoSize*(lptstrFilename: cstring; lpdwHandle: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeA\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSizeA",  "code": "proc GetFileVersionInfoSizeA*(lptstrFilename: LPCSTR; lpdwHandle: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeA\".}" },  { "module": "windows",  "name": "GetFileVersionInfoSizeW",  "code": "proc GetFileVersionInfoSizeW*(lptstrFilename: LPWSTR; lpdwHandle: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"version\", importc: \"GetFileVersionInfoSizeW\".}" },  { "module": "windows",  "name": "GetGlyphOutline",  "code": "proc GetGlyphOutline*(DC: HDC; p2, p3: WINUINT; p4: TGlyphMetrics; p5: DWORD; \u000A                      p6: pointer; p7: TMat2): DWORD {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetGlyphOutlineA\".}" },  { "module": "windows",  "name": "GetGlyphOutlineA",  "code": "proc GetGlyphOutlineA*(DC: HDC; p2, p3: WINUINT; p4: TGlyphMetrics; p5: DWORD; \u000A                       p6: pointer; p7: TMat2): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetGlyphOutlineA\".}" },  { "module": "windows",  "name": "GetGlyphOutlineW",  "code": "proc GetGlyphOutlineW*(DC: HDC; p2, p3: WINUINT; p4: TGlyphMetrics; p5: DWORD; \u000A                       p6: pointer; p7: TMat2): DWORD {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetGlyphOutlineW\".}" },  { "module": "windows",  "name": "GetHandleInformation",  "code": "proc GetHandleInformation*(hObject: THandle; lpdwFlags: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetHandleInformation\".}" },  { "module": "windows",  "name": "GetIconInfo",  "code": "proc GetIconInfo*(icon: HICON; piconinfo: var TIconInfo): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetIconInfo\".}" },  { "module": "windows",  "name": "GetKerningPairs",  "code": "proc GetKerningPairs*(DC: HDC; Count: DWORD; KerningPairs: pointer): DWORD {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetKerningPairs\".}" },  { "module": "windows",  "name": "GetKeyboardLayoutList",  "code": "proc GetKeyboardLayoutList*(nBuff: int; List: pointer): WINUINT {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetKeyboardLayoutList\".}" },  { "module": "windows",  "name": "GetSystemTime",  "code": "proc GetSystemTime*(lpSystemTime: var SYSTEMTIME) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemTime\".}" },  { "module": "windows",  "name": "GetLocalTime",  "code": "proc GetLocalTime*(SystemTime: var SYSTEMTIME) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetLocalTime\".}" },  { "module": "windows",  "name": "GetSystemInfo",  "code": "proc GetSystemInfo*(SystemInfo: var SYSTEM_INFO) {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetSystemInfo\".}" },  { "module": "windows",  "name": "SetSystemTime",  "code": "proc SetSystemTime*(lpSystemTime: var SYSTEMTIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetSystemTime\".}" },  { "module": "windows",  "name": "SetLocalTime",  "code": "proc SetLocalTime*(lpSystemTime: var SYSTEMTIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetLocalTime\".}" },  { "module": "windows",  "name": "GetLogColorSpace",  "code": "proc GetLogColorSpace*(p1: HCOLORSPACE; ColorSpace: var TLogColorSpace; \u000A                       Size: DWORD): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetLogColorSpaceA\".}" },  { "module": "windows",  "name": "GetLogColorSpaceA",  "code": "proc GetLogColorSpaceA*(p1: HCOLORSPACE; ColorSpace: var TLogColorSpaceA; \u000A                        Size: DWORD): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetLogColorSpaceA\".}" },  { "module": "windows",  "name": "GetMailslotInfo",  "code": "proc GetMailslotInfo*(hMailslot: THandle; lpMaxMessageSize: pointer; \u000A                      lpNextSize: var DWORD; \u000A                      lpMessageCount, lpReadTimeout: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetMailslotInfo\".}" },  { "module": "windows",  "name": "GetMenuItemInfo",  "code": "proc GetMenuItemInfo*(p1: HMENU; p2: WINUINT; p3: WINBOOL; p4: var TMenuItemInfo): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetMenuItemInfoA\".}" },  { "module": "windows",  "name": "GetMenuItemInfoA",  "code": "proc GetMenuItemInfoA*(p1: HMENU; p2: WINUINT; p3: WINBOOL; \u000A                       p4: var TMenuItemInfoA): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMenuItemInfoA\".}" },  { "module": "windows",  "name": "GetMenuItemRect",  "code": "proc GetMenuItemRect*(wnd: HWND; menu: HMENU; uItem: WINUINT; \u000A                      lprcItem: var TRect): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"GetMenuItemRect\".}" },  { "module": "windows",  "name": "GetMessage",  "code": "proc GetMessage*(lpMsg: var TMsg; wnd: HWND; \u000A                 wMsgFilterMin, wMsgFilterMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMessageA\".}" },  { "module": "windows",  "name": "GetMessageA",  "code": "proc GetMessageA*(lpMsg: var TMsg; wnd: HWND; \u000A                  wMsgFilterMin, wMsgFilterMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMessageA\".}" },  { "module": "windows",  "name": "GetMessageW",  "code": "proc GetMessageW*(lpMsg: var TMsg; wnd: HWND; \u000A                  wMsgFilterMin, wMsgFilterMax: WINUINT): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetMessageW\".}" },  { "module": "windows",  "name": "GetMiterLimit",  "code": "proc GetMiterLimit*(DC: HDC; Limit: var float32): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetMiterLimit\".}" },  { "module": "windows",  "name": "GetNamedPipeInfo",  "code": "proc GetNamedPipeInfo*(hNamedPipe: THandle; lpFlags: var DWORD; \u000A                       lpOutBufferSize, lpInBufferSize, lpMaxInstances: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNamedPipeInfo\".}" },  { "module": "windows",  "name": "GetNumberOfConsoleInputEvents",  "code": "proc GetNumberOfConsoleInputEvents*(hConsoleInput: THandle; \u000A                                    lpNumberOfEvents: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNumberOfConsoleInputEvents\".}" },  { "module": "windows",  "name": "GetNumberOfConsoleMouseButtons",  "code": "proc GetNumberOfConsoleMouseButtons*(lpNumberOfMouseButtons: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetNumberOfConsoleMouseButtons\".}" },  { "module": "windows",  "name": "GetOverlappedResult",  "code": "proc GetOverlappedResult*(hFile: THandle; lpOverlapped: TOverlapped; \u000A                          lpNumberOfBytesTransferred: var DWORD; bWait: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetOverlappedResult\".}" },  { "module": "windows",  "name": "GetPaletteEntries",  "code": "proc GetPaletteEntries*(Palette: HPALETTE; StartIndex, NumEntries: WINUINT; \u000A                        PaletteEntries: pointer): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetPaletteEntries\".}" },  { "module": "windows",  "name": "GetPath",  "code": "proc GetPath*(DC: HDC; Points, Types: pointer; nSize: int): int {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetPath\".}" },  { "module": "windows",  "name": "GetPriorityClipboardFormat",  "code": "proc GetPriorityClipboardFormat*(paFormatPriorityList: pointer; cFormats: int): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetPriorityClipboardFormat\".}" },  { "module": "windows",  "name": "GetPrivateProfileSectionNamesA",  "code": "proc GetPrivateProfileSectionNamesA*(lpszReturnBuffer: LPSTR; nSize: DWORD; \u000A                                     lpFileName: LPCSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionNamesA\".}" },  { "module": "windows",  "name": "GetPrivateProfileSectionNamesW",  "code": "proc GetPrivateProfileSectionNamesW*(lpszReturnBuffer: LPWSTR; nSize: DWORD; \u000A                                     lpFileName: LPCWSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionNamesW\".}" },  { "module": "windows",  "name": "GetPrivateProfileSectionNames",  "code": "proc GetPrivateProfileSectionNames*(lpszReturnBuffer: LPTSTR; nSize: DWORD; \u000A                                    lpFileName: LPCTSTR): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetPrivateProfileSectionNamesA\".}" },  { "module": "windows",  "name": "GetPrivateProfileStructA",  "code": "proc GetPrivateProfileStructA*(lpszSection, lpszKey: LPCSTR; lpStruct: LPVOID; \u000A                               uSizeStruct: WINUINT; szFile: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStructA\".}" },  { "module": "windows",  "name": "GetPrivateProfileStructW",  "code": "proc GetPrivateProfileStructW*(lpszSection, lpszKey: LPCWSTR; lpStruct: LPVOID; \u000A                               uSizeStruct: WINUINT; szFile: LPCWSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStructW\".}" },  { "module": "windows",  "name": "GetPrivateProfileStruct",  "code": "proc GetPrivateProfileStruct*(lpszSection, lpszKey: LPCTSTR; lpStruct: LPVOID; \u000A                              uSizeStruct: WINUINT; szFile: LPCTSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetPrivateProfileStructA\".}" },  { "module": "windows",  "name": "GetProcessAffinityMask",  "code": "proc GetProcessAffinityMask*(hProcess: THandle; lpProcessAffinityMask, \u000A    lpSystemAffinityMask: var DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProcessAffinityMask\".}" },  { "module": "windows",  "name": "GetProcessHeaps",  "code": "proc GetProcessHeaps*(NumberOfHeaps: DWORD; ProcessHeaps: var THandle): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessHeaps\".}" },  { "module": "windows",  "name": "GetProcessPriorityBoost",  "code": "proc GetProcessPriorityBoost*(hThread: THandle; \u000A                              DisablePriorityBoost: var WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessPriorityBoost\".}" },  { "module": "windows",  "name": "GetProcessShutdownParameters",  "code": "proc GetProcessShutdownParameters*(lpdwLevel, lpdwFlags: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetProcessShutdownParameters\".}" },  { "module": "windows",  "name": "GetProcessTimes",  "code": "proc GetProcessTimes*(hProcess: THandle; lpCreationTime, lpExitTime, \u000A    lpKernelTime, lpUserTime: var TFileTime): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcessTimes\".}" },  { "module": "windows",  "name": "GetProcessWorkingSetSize",  "code": "proc GetProcessWorkingSetSize*(hProcess: THandle; lpMinimumWorkingSetSize, \u000A    lpMaximumWorkingSetSize: var DWORD): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetProcessWorkingSetSize\".}" },  { "module": "windows",  "name": "GetQueuedCompletionStatus",  "code": "proc GetQueuedCompletionStatus*(CompletionPort: THandle; \u000A    lpNumberOfBytesTransferred, lpCompletionKey: var DWORD; \u000A                                lpOverlapped: var POverlapped; \u000A                                dwMilliseconds: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetQueuedCompletionStatus\".}" },  { "module": "windows",  "name": "GetRasterizerCaps",  "code": "proc GetRasterizerCaps*(p1: var TRasterizerStatus; p2: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetRasterizerCaps\".}" },  { "module": "windows",  "name": "GetRgnBox",  "code": "proc GetRgnBox*(RGN: HRGN; p2: var TRect): int {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetRgnBox\".}" },  { "module": "windows",  "name": "GetScrollInfo",  "code": "proc GetScrollInfo*(wnd: HWND; BarFlag: int; ScrollInfo: var TScrollInfo): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetScrollInfo\".}" },  { "module": "windows",  "name": "GetScrollRange",  "code": "proc GetScrollRange*(wnd: HWND; nBar: int; lpMinPos, lpMaxPos: var int): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetScrollRange\".}" },  { "module": "windows",  "name": "GetStartupInfo",  "code": "proc GetStartupInfo*(lpStartupInfo: var TSTARTUPINFO) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStartupInfoA\".}" },  { "module": "windows",  "name": "GetStringTypeA",  "code": "proc GetStringTypeA*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCSTR; \u000A                     cchSrc: WINBOOL; lpCharType: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeA\".}" },  { "module": "windows",  "name": "GetStringTypeEx",  "code": "proc GetStringTypeEx*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: cstring; \u000A                      cchSrc: int; lpCharType: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExA\".}" },  { "module": "windows",  "name": "GetStringTypeExA",  "code": "proc GetStringTypeExA*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPCSTR; \u000A                       cchSrc: int; lpCharType: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExA\".}" },  { "module": "windows",  "name": "GetStringTypeExW",  "code": "proc GetStringTypeExW*(Locale: LCID; dwInfoType: DWORD; lpSrcStr: LPWSTR; \u000A                       cchSrc: int; lpCharType: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeExW\".}" },  { "module": "windows",  "name": "GetStringTypeW",  "code": "proc GetStringTypeW*(dwInfoType: DWORD; lpSrcStr: WCHAR; cchSrc: WINBOOL; \u000A                     lpCharType: var int16): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetStringTypeW\".}" },  { "module": "windows",  "name": "GetSystemPaletteEntries",  "code": "proc GetSystemPaletteEntries*(DC: HDC; StartIndex, NumEntries: WINUINT; \u000A                              PaletteEntries: pointer): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetSystemPaletteEntries\".}" },  { "module": "windows",  "name": "GetSystemPowerStatus",  "code": "proc GetSystemPowerStatus*(lpSystemPowerStatus: var TSystemPowerStatus): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetSystemPowerStatus\".}" },  { "module": "windows",  "name": "GetSystemTimeAdjustment",  "code": "proc GetSystemTimeAdjustment*(lpTimeAdjustment, lpTimeIncrement: var DWORD; \u000A                              lpTimeAdjustmentDisabled: var WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetSystemTimeAdjustment\".}" },  { "module": "windows",  "name": "GetSystemTimeAsFileTime",  "code": "proc GetSystemTimeAsFileTime*(lpSystemTimeAsFileTime: var TFILETIME) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetSystemTimeAsFileTime\".}" },  { "module": "windows",  "name": "GetTabbedTextExtent",  "code": "proc GetTabbedTextExtent*(hDC: HDC; lpString: cstring; \u000A                          nCount, nTabPositions: int; \u000A                          lpnTabStopPositions: pointer): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetTabbedTextExtentA\".}" },  { "module": "windows",  "name": "GetTabbedTextExtentA",  "code": "proc GetTabbedTextExtentA*(hDC: HDC; lpString: LPCSTR; \u000A                           nCount, nTabPositions: int; \u000A                           lpnTabStopPositions: pointer): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetTabbedTextExtentA\".}" },  { "module": "windows",  "name": "GetTabbedTextExtentW",  "code": "proc GetTabbedTextExtentW*(hDC: HDC; lpString: LPWSTR; \u000A                           nCount, nTabPositions: int; \u000A                           lpnTabStopPositions: pointer): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetTabbedTextExtentW\".}" },  { "module": "windows",  "name": "GetTapeParameters",  "code": "proc GetTapeParameters*(hDevice: THandle; dwOperation: DWORD; \u000A                        lpdwSize: var DWORD; lpTapeInformation: pointer): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTapeParameters\".}" },  { "module": "windows",  "name": "GetTapePosition",  "code": "proc GetTapePosition*(hDevice: THandle; dwPositionType: DWORD; \u000A                      lpdwPartition, lpdwOffsetLow: var DWORD; \u000A                      lpdwOffsetHigh: pointer): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetTapePosition\".}" },  { "module": "windows",  "name": "GetTextExtentExPoint",  "code": "proc GetTextExtentExPoint*(DC: HDC; p2: cstring; p3, p4: int; p5, p6: PInteger; \u000A                           p7: var TSize): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointA\".}" },  { "module": "windows",  "name": "GetTextExtentExPointA",  "code": "proc GetTextExtentExPointA*(DC: HDC; p2: LPCSTR; p3, p4: int; p5, p6: PInteger; \u000A                            p7: var TSize): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointA\".}" },  { "module": "windows",  "name": "GetTextExtentExPointW",  "code": "proc GetTextExtentExPointW*(DC: HDC; p2: LPWSTR; p3, p4: int; p5, p6: PInteger; \u000A                            p7: var TSize): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"GetTextExtentExPointW\".}" },  { "module": "windows",  "name": "GetTextExtentPoint",  "code": "proc GetTextExtentPoint*(DC: HDC; Str: cstring; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPointA\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32",  "code": "proc GetTextExtentPoint32*(DC: HDC; Str: cstring; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPoint32A\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32A",  "code": "proc GetTextExtentPoint32A*(DC: HDC; Str: LPCSTR; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPoint32A\".}" },  { "module": "windows",  "name": "GetTextExtentPoint32W",  "code": "proc GetTextExtentPoint32W*(DC: HDC; Str: LPWSTR; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPoint32W\".}" },  { "module": "windows",  "name": "GetTextExtentPointA",  "code": "proc GetTextExtentPointA*(DC: HDC; Str: LPCSTR; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPointA\".}" },  { "module": "windows",  "name": "GetTextExtentPointW",  "code": "proc GetTextExtentPointW*(DC: HDC; Str: LPWSTR; Count: int; Size: var TSize): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"GetTextExtentPointW\".}" },  { "module": "windows",  "name": "GetTextMetrics",  "code": "proc GetTextMetrics*(DC: HDC; TM: var TTextMetric): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetTextMetricsA\".}" },  { "module": "windows",  "name": "GetThreadContext",  "code": "proc GetThreadContext*(hThread: THandle; lpContext: var TContext): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetThreadContext\".}" },  { "module": "windows",  "name": "GetThreadPriorityBoost",  "code": "proc GetThreadPriorityBoost*(hThread: THandle; DisablePriorityBoost: var WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetThreadPriorityBoost\".}" },  { "module": "windows",  "name": "GetThreadSelectorEntry",  "code": "proc GetThreadSelectorEntry*(hThread: THandle; dwSelector: DWORD; \u000A                             lpSelectorEntry: var TLDTEntry): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetThreadSelectorEntry\".}" },  { "module": "windows",  "name": "GetThreadTimes",  "code": "proc GetThreadTimes*(hThread: THandle; lpCreationTime, lpExitTime, lpKernelTime, \u000A                                       lpUserTime: var TFileTime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetThreadTimes\".}" },  { "module": "windows",  "name": "GetTimeZoneInformation",  "code": "proc GetTimeZoneInformation*(lpTimeZoneInformation: var TTimeZoneInformation): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetTimeZoneInformation\".}" },  { "module": "windows",  "name": "GetUpdateRect",  "code": "proc GetUpdateRect*(wnd: HWND; lpRect: var TRect; bErase: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUpdateRect\".}" },  { "module": "windows",  "name": "GetUserName",  "code": "proc GetUserName*(lpBuffer: cstring; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameA\".}" },  { "module": "windows",  "name": "GetUserNameA",  "code": "proc GetUserNameA*(lpBuffer: LPCSTR; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameA\".}" },  { "module": "windows",  "name": "GetUserNameW",  "code": "proc GetUserNameW*(lpBuffer: LPWSTR; nSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"GetUserNameW\".}" },  { "module": "windows",  "name": "GetUserObjectInformation",  "code": "proc GetUserObjectInformation*(hObj: THandle; nIndex: int; pvInfo: pointer; \u000A                               nLength: DWORD; lpnLengthNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationA\".}" },  { "module": "windows",  "name": "GetUserObjectInformationA",  "code": "proc GetUserObjectInformationA*(hObj: THandle; nIndex: int; pvInfo: pointer; \u000A                                nLength: DWORD; lpnLengthNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationA\".}" },  { "module": "windows",  "name": "GetUserObjectInformationW",  "code": "proc GetUserObjectInformationW*(hObj: THandle; nIndex: int; pvInfo: pointer; \u000A                                nLength: DWORD; lpnLengthNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"GetUserObjectInformationW\".}" },  { "module": "windows",  "name": "GetUserObjectSecurity",  "code": "proc GetUserObjectSecurity*(hObj: THandle; pSIRequested: var DWORD; \u000A                            pSID: PSecurityDescriptor; nLength: DWORD; \u000A                            lpnLengthNeeded: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetUserObjectSecurity\".}" },  { "module": "windows",  "name": "GetVersionEx",  "code": "proc GetVersionEx*(lpVersionInformation: var TOSVersionInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVersionExA\".}" },  { "module": "windows",  "name": "GetVersionExA",  "code": "proc GetVersionExA*(lpVersionInformation: var TOSVersionInfo): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetVersionExA\".}" },  { "module": "windows",  "name": "GetVersionExW",  "code": "proc GetVersionExW*(lpVersionInformation: var TOSVersionInfoW): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetVersionExW\".}" },  { "module": "windows",  "name": "GetViewportExtEx",  "code": "proc GetViewportExtEx*(DC: HDC; Size: var TSize): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetViewportExtEx\".}" },  { "module": "windows",  "name": "GetViewportOrgEx",  "code": "proc GetViewportOrgEx*(DC: HDC; Point: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetViewportOrgEx\".}" },  { "module": "windows",  "name": "GetVolumeInformation",  "code": "proc GetVolumeInformation*(lpRootPathName: cstring; lpVolumeNameBuffer: cstring; \u000A                           nVolumeNameSize: DWORD; lpVolumeSerialNumber: PDWORD; \u000A    lpMaximumComponentLength, lpFileSystemFlags: var DWORD; \u000A                           lpFileSystemNameBuffer: cstring; \u000A                           nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationA\".}" },  { "module": "windows",  "name": "GetVolumeInformationA",  "code": "proc GetVolumeInformationA*(lpRootPathName: LPCSTR; lpVolumeNameBuffer: LPCSTR; \u000A                            nVolumeNameSize: DWORD; \u000A                            lpVolumeSerialNumber: PDWORD; \u000A    lpMaximumComponentLength, lpFileSystemFlags: var DWORD; \u000A                            lpFileSystemNameBuffer: LPCSTR; \u000A                            nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationA\".}" },  { "module": "windows",  "name": "GetVolumeInformationW",  "code": "proc GetVolumeInformationW*(lpRootPathName: LPWSTR; lpVolumeNameBuffer: LPWSTR; \u000A                            nVolumeNameSize: DWORD; \u000A                            lpVolumeSerialNumber: PDWORD; \u000A    lpMaximumComponentLength, lpFileSystemFlags: var DWORD; \u000A                            lpFileSystemNameBuffer: LPWSTR; \u000A                            nFileSystemNameSize: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetVolumeInformationW\".}" },  { "module": "windows",  "name": "GetWindowExtEx",  "code": "proc GetWindowExtEx*(DC: HDC; Size: var TSize): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWindowExtEx\".}" },  { "module": "windows",  "name": "GetWindowOrgEx",  "code": "proc GetWindowOrgEx*(DC: HDC; Point: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWindowOrgEx\".}" },  { "module": "windows",  "name": "GetWindowRect",  "code": "proc GetWindowRect*(wnd: HWND; lpRect: var TRect): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"GetWindowRect\".}" },  { "module": "windows",  "name": "GetWorldTransform",  "code": "proc GetWorldTransform*(DC: HDC; p2: var TXForm): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"GetWorldTransform\".}" },  { "module": "windows",  "name": "GlobalMemoryStatus",  "code": "proc GlobalMemoryStatus*(Buffer: var MEMORYSTATUS) {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GlobalMemoryStatus\".}" },  { "module": "windows",  "name": "HeapWalk",  "code": "proc HeapWalk*(hHeap: THandle; lpEntry: var TProcessHeapEntry): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"HeapWalk\".}" },  { "module": "windows",  "name": "ImageList_GetDragImage",  "code": "proc ImageList_GetDragImage*(ppt: var POINT; pptHotspot: var POINT): HIMAGELIST {.\u000A    stdcall, dynlib: \"comctl32\", importc: \"ImageList_GetDragImage\".}" },  { "module": "windows",  "name": "InflateRect",  "code": "proc InflateRect*(lprc: var TRect; dx, dy: int): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"InflateRect\".}" },  { "module": "windows",  "name": "InitializeAcl",  "code": "proc InitializeAcl*(pAcl: var TACL; nAclLength, dwAclRevision: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"InitializeAcl\".}" },  { "module": "windows",  "name": "InitializeSid",  "code": "proc InitializeSid*(Sid: pointer; pIdentifierAuthority: TSIDIdentifierAuthority; \u000A                    nSubAuthorityCount: int8): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"InitializeSid\".}" },  { "module": "windows",  "name": "InsertMenuItemA",  "code": "proc InsertMenuItemA*(p1: HMENU; p2: WINUINT; p3: WINBOOL; p4: TMenuItemInfoA): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"InsertMenuItemA\".}" },  { "module": "windows",  "name": "IntersectRect",  "code": "proc IntersectRect*(lprcDst: var TRect; lprcSrc1, lprcSrc2: TRect): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"IntersectRect\".}" },  { "module": "windows",  "name": "IsDialogMessage",  "code": "proc IsDialogMessage*(hDlg: HWND; lpMsg: var TMsg): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageA\".}" },  { "module": "windows",  "name": "IsDialogMessageA",  "code": "proc IsDialogMessageA*(hDlg: HWND; lpMsg: var TMsg): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageA\".}" },  { "module": "windows",  "name": "IsDialogMessageW",  "code": "proc IsDialogMessageW*(hDlg: HWND; lpMsg: var TMsg): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"IsDialogMessageW\".}" },  { "module": "windows",  "name": "IsValidAcl",  "code": "proc IsValidAcl*(pAcl: TACL): WINBOOL {.stdcall, dynlib: \"advapi32\", \u000A                                        importc: \"IsValidAcl\".}" },  { "module": "windows",  "name": "LocalFileTimeToFileTime",  "code": "proc LocalFileTimeToFileTime*(lpLocalFileTime: TFileTime; \u000A                              lpFileTime: var TFileTime): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LocalFileTimeToFileTime\".}" },  { "module": "windows",  "name": "LockFileEx",  "code": "proc LockFileEx*(hFile: THandle; dwFlags, dwReserved: DWORD; \u000A                 nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh: DWORD; \u000A                 lpOverlapped: TOverlapped): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"LockFileEx\".}" },  { "module": "windows",  "name": "LogonUser",  "code": "proc LogonUser*(lpszUsername, lpszDomain, lpszPassword: cstring; \u000A                dwLogonType, dwLogonProvider: DWORD; phToken: var THandle): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LogonUserA\".}" },  { "module": "windows",  "name": "LogonUserA",  "code": "proc LogonUserA*(lpszUsername, lpszDomain, lpszPassword: LPCSTR; \u000A                 dwLogonType, dwLogonProvider: DWORD; phToken: var THandle): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LogonUserA\".}" },  { "module": "windows",  "name": "LogonUserW",  "code": "proc LogonUserW*(lpszUsername, lpszDomain, lpszPassword: LPWSTR; \u000A                 dwLogonType, dwLogonProvider: DWORD; phToken: var THandle): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LogonUserW\".}" },  { "module": "windows",  "name": "LookupAccountName",  "code": "proc LookupAccountName*(lpSystemName, lpAccountName: cstring; Sid: PSID; \u000A                        cbSid: var DWORD; ReferencedDomainName: cstring; \u000A                        cbReferencedDomainName: var DWORD; \u000A                        peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountNameA\".}" },  { "module": "windows",  "name": "LookupAccountNameA",  "code": "proc LookupAccountNameA*(lpSystemName, lpAccountName: LPCSTR; Sid: PSID; \u000A                         cbSid: var DWORD; ReferencedDomainName: LPCSTR; \u000A                         cbReferencedDomainName: var DWORD; \u000A                         peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountNameA\".}" },  { "module": "windows",  "name": "LookupAccountNameW",  "code": "proc LookupAccountNameW*(lpSystemName, lpAccountName: LPWSTR; Sid: PSID; \u000A                         cbSid: var DWORD; ReferencedDomainName: LPWSTR; \u000A                         cbReferencedDomainName: var DWORD; \u000A                         peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountNameW\".}" },  { "module": "windows",  "name": "LookupAccountSid",  "code": "proc LookupAccountSid*(lpSystemName: cstring; Sid: PSID; Name: cstring; \u000A                       cbName: var DWORD; ReferencedDomainName: cstring; \u000A                       cbReferencedDomainName: var DWORD; \u000A                       peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountSidA\".}" },  { "module": "windows",  "name": "LookupAccountSidA",  "code": "proc LookupAccountSidA*(lpSystemName: LPCSTR; Sid: PSID; Name: LPCSTR; \u000A                        cbName: var DWORD; ReferencedDomainName: LPCSTR; \u000A                        cbReferencedDomainName: var DWORD; \u000A                        peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountSidA\".}" },  { "module": "windows",  "name": "LookupAccountSidW",  "code": "proc LookupAccountSidW*(lpSystemName: LPWSTR; Sid: PSID; Name: LPWSTR; \u000A                        cbName: var DWORD; ReferencedDomainName: LPWSTR; \u000A                        cbReferencedDomainName: var DWORD; \u000A                        peUse: var SID_NAME_USE): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupAccountSidW\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayName",  "code": "proc LookupPrivilegeDisplayName*(lpSystemName, lpName: LPCSTR; \u000A                                 lpDisplayName: cstring; \u000A                                 cbDisplayName, lpLanguageId: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayNameA",  "code": "proc LookupPrivilegeDisplayNameA*(lpSystemName, lpName: LPCSTR; \u000A                                  lpDisplayName: LPCSTR; \u000A                                  cbDisplayName, lpLanguageId: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeDisplayNameW",  "code": "proc LookupPrivilegeDisplayNameW*(lpSystemName, lpName: LPCSTR; \u000A                                  lpDisplayName: LPWSTR; \u000A                                  cbDisplayName, lpLanguageId: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeDisplayNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeName",  "code": "proc LookupPrivilegeName*(lpSystemName: cstring; lpLuid: var TLargeInteger; \u000A                          lpName: cstring; cbName: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeNameA",  "code": "proc LookupPrivilegeNameA*(lpSystemName: LPCSTR; lpLuid: var TLargeInteger; \u000A                           lpName: LPCSTR; cbName: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeNameA\".}" },  { "module": "windows",  "name": "LookupPrivilegeNameW",  "code": "proc LookupPrivilegeNameW*(lpSystemName: LPWSTR; lpLuid: var TLargeInteger; \u000A                           lpName: LPWSTR; cbName: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"LookupPrivilegeNameW\".}" },  { "module": "windows",  "name": "LookupPrivilegeValue",  "code": "proc LookupPrivilegeValue*(lpSystemName, lpName: cstring; \u000A                           lpLuid: var TLargeInteger): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeValueA\".}" },  { "module": "windows",  "name": "LookupPrivilegeValueA",  "code": "proc LookupPrivilegeValueA*(lpSystemName, lpName: LPCSTR; \u000A                            lpLuid: var TLargeInteger): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeValueA\".}" },  { "module": "windows",  "name": "LookupPrivilegeValueW",  "code": "proc LookupPrivilegeValueW*(lpSystemName, lpName: LPWSTR; \u000A                            lpLuid: var TLargeInteger): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"LookupPrivilegeValueW\".}" },  { "module": "windows",  "name": "LPtoDP",  "code": "proc LPtoDP*(DC: HDC; Points: pointer; Count: int): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"LPtoDP\".}" },  { "module": "windows",  "name": "MakeAbsoluteSD",  "code": "proc MakeAbsoluteSD*(pSelfRelativeSecurityDescriptor: PSecurityDescriptor; \u000A                     pAbsoluteSecurityDescriptor: PSecurityDescriptor; \u000A                     lpdwAbsoluteSecurityDescriptorSi: var DWORD; \u000A                     pDacl: var TACL; lpdwDaclSize: var DWORD; pSacl: var TACL; \u000A                     lpdwSaclSize: var DWORD; pOwner: PSID; \u000A                     lpdwOwnerSize: var DWORD; pPrimaryGroup: pointer; \u000A                     lpdwPrimaryGroupSize: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"MakeAbsoluteSD\".}" },  { "module": "windows",  "name": "MakeSelfRelativeSD",  "code": "proc MakeSelfRelativeSD*(pAbsoluteSecurityDescriptor: PSecurityDescriptor; \u000A                         pSelfRelativeSecurityDescriptor: PSecurityDescriptor; \u000A                         lpdwBufferLength: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"MakeSelfRelativeSD\".}" },  { "module": "windows",  "name": "MapDialogRect",  "code": "proc MapDialogRect*(hDlg: HWND; lpRect: var TRect): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"MapDialogRect\".}" },  { "module": "windows",  "name": "MapWindowPoints",  "code": "proc MapWindowPoints*(hWndFrom, hWndTo: HWND; lpPoints: pointer; \u000A                      cPoints: WINUINT): int {.stdcall, dynlib: \"user32\", \u000A    importc: \"MapWindowPoints\".}" },  { "module": "windows",  "name": "MessageBoxIndirect",  "code": "proc MessageBoxIndirect*(MsgBoxParams: TMsgBoxParams): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxIndirectA\".}" },  { "module": "windows",  "name": "MessageBoxIndirectA",  "code": "proc MessageBoxIndirectA*(MsgBoxParams: TMsgBoxParamsA): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"MessageBoxIndirectA\".}" },  { "module": "windows",  "name": "MsgWaitForMultipleObjects",  "code": "proc MsgWaitForMultipleObjects*(nCount: DWORD; pHandles: pointer; \u000A                                fWaitAll: WINBOOL; \u000A                                dwMilliseconds, dwWakeMask: DWORD): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"MsgWaitForMultipleObjects\".}" },  { "module": "windows",  "name": "MsgWaitForMultipleObjectsEx",  "code": "proc MsgWaitForMultipleObjectsEx*(nCount: DWORD; pHandles: pointer; \u000A                                  dwMilliseconds, dwWakeMask, dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"user32\", importc: \"MsgWaitForMultipleObjectsEx\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarm",  "code": "proc ObjectOpenAuditAlarm*(SubsystemName: cstring; HandleId: pointer; \u000A                           ObjectTypeName: cstring; ObjectName: cstring; \u000A                           pSecurityDescriptor: PSecurityDescriptor; \u000A                           ClientToken: THandle; \u000A                           DesiredAccess, GrantedAccess: DWORD; \u000A                           Privileges: var TPrivilegeSet; \u000A                           ObjectCreation, AccessGranted: WINBOOL; \u000A                           GenerateOnClose: var WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarmA",  "code": "proc ObjectOpenAuditAlarmA*(SubsystemName: LPCSTR; HandleId: pointer; \u000A                            ObjectTypeName: LPCSTR; ObjectName: LPCSTR; \u000A                            pSecurityDescriptor: PSecurityDescriptor; \u000A                            ClientToken: THandle; \u000A                            DesiredAccess, GrantedAccess: DWORD; \u000A                            Privileges: var TPrivilegeSet; \u000A                            ObjectCreation, AccessGranted: WINBOOL; \u000A                            GenerateOnClose: var WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectOpenAuditAlarmW",  "code": "proc ObjectOpenAuditAlarmW*(SubsystemName: LPWSTR; HandleId: pointer; \u000A                            ObjectTypeName: LPWSTR; ObjectName: LPWSTR; \u000A                            pSecurityDescriptor: PSecurityDescriptor; \u000A                            ClientToken: THandle; \u000A                            DesiredAccess, GrantedAccess: DWORD; \u000A                            Privileges: var TPrivilegeSet; \u000A                            ObjectCreation, AccessGranted: WINBOOL; \u000A                            GenerateOnClose: var WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectOpenAuditAlarmW\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarm",  "code": "proc ObjectPrivilegeAuditAlarm*(SubsystemName: cstring; HandleId: pointer; \u000A                                ClientToken: THandle; DesiredAccess: DWORD; \u000A                                Privileges: var TPrivilegeSet; \u000A                                AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarmA",  "code": "proc ObjectPrivilegeAuditAlarmA*(SubsystemName: LPCSTR; HandleId: pointer; \u000A                                 ClientToken: THandle; DesiredAccess: DWORD; \u000A                                 Privileges: var TPrivilegeSet; \u000A                                 AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmA\".}" },  { "module": "windows",  "name": "ObjectPrivilegeAuditAlarmW",  "code": "proc ObjectPrivilegeAuditAlarmW*(SubsystemName: LPWSTR; HandleId: pointer; \u000A                                 ClientToken: THandle; DesiredAccess: DWORD; \u000A                                 Privileges: var TPrivilegeSet; \u000A                                 AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"ObjectPrivilegeAuditAlarmW\".}" },  { "module": "windows",  "name": "OffsetRect",  "code": "proc OffsetRect*(lprc: var TRect; dx, dy: int): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OffsetRect\".}" },  { "module": "windows",  "name": "OffsetViewportOrgEx",  "code": "proc OffsetViewportOrgEx*(DC: HDC; X, Y: int; Points: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"OffsetViewportOrgEx\".}" },  { "module": "windows",  "name": "OffsetWindowOrgEx",  "code": "proc OffsetWindowOrgEx*(DC: HDC; X, Y: int; Points: pointer): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"OffsetWindowOrgEx\".}" },  { "module": "windows",  "name": "OpenFile",  "code": "proc OpenFile*(lpFileName: LPCSTR; lpReOpenBuff: var TOFStruct; uStyle: WINUINT): HFILE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"OpenFile\".}" },  { "module": "windows",  "name": "OpenProcessToken",  "code": "proc OpenProcessToken*(ProcessHandle: THandle; DesiredAccess: DWORD; \u000A                       TokenHandle: var THandle): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"OpenProcessToken\".}" },  { "module": "windows",  "name": "OpenThreadToken",  "code": "proc OpenThreadToken*(ThreadHandle: THandle; DesiredAccess: DWORD; \u000A                      OpenAsSelf: WINBOOL; TokenHandle: var THandle): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"OpenThreadToken\".}" },  { "module": "windows",  "name": "PeekConsoleInput",  "code": "proc PeekConsoleInput*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                       nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputA\".}" },  { "module": "windows",  "name": "PeekConsoleInputA",  "code": "proc PeekConsoleInputA*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                        nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputA\".}" },  { "module": "windows",  "name": "PeekConsoleInputW",  "code": "proc PeekConsoleInputW*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                        nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"PeekConsoleInputW\".}" },  { "module": "windows",  "name": "PeekMessage",  "code": "proc PeekMessage*(lpMsg: var TMsg; wnd: HWND; \u000A                  wMsgFilterMin, wMsgFilterMax, wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageA\".}" },  { "module": "windows",  "name": "PeekMessageA",  "code": "proc PeekMessageA*(lpMsg: var TMsg; wnd: HWND; \u000A                   wMsgFilterMin, wMsgFilterMax, wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageA\".}" },  { "module": "windows",  "name": "PeekMessageW",  "code": "proc PeekMessageW*(lpMsg: var TMsg; wnd: HWND; \u000A                   wMsgFilterMin, wMsgFilterMax, wRemoveMsg: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"PeekMessageW\".}" },  { "module": "windows",  "name": "PlayEnhMetaFileRecord",  "code": "proc PlayEnhMetaFileRecord*(DC: HDC; p2: var THandleTable; p3: TEnhMetaRecord; \u000A                            p4: WINUINT): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"PlayEnhMetaFileRecord\".}" },  { "module": "windows",  "name": "PlayMetaFileRecord",  "code": "proc PlayMetaFileRecord*(DC: HDC; p2: THandleTable; p3: TMetaRecord; p4: WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PlayMetaFileRecord\".}" },  { "module": "windows",  "name": "PlgBlt",  "code": "proc PlgBlt*(DC: HDC; PointsArray: pointer; p3: HDC; p4, p5, p6, p7: int; \u000A             p8: HBITMAP; p9, p10: int): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"PlgBlt\".}" },  { "module": "windows",  "name": "PolyBezier",  "code": "proc PolyBezier*(DC: HDC; Points: pointer; Count: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolyBezier\".}" },  { "module": "windows",  "name": "PolyBezierTo",  "code": "proc PolyBezierTo*(DC: HDC; Points: pointer; Count: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolyBezierTo\".}" },  { "module": "windows",  "name": "PolyDraw",  "code": "proc PolyDraw*(DC: HDC; Points, Types: pointer; cCount: int): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolyDraw\".}" },  { "module": "windows",  "name": "Polygon",  "code": "proc Polygon*(DC: HDC; Points: pointer; Count: int): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"Polygon\".}" },  { "module": "windows",  "name": "Polyline",  "code": "proc Polyline*(DC: HDC; Points: pointer; Count: int): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"Polyline\".}" },  { "module": "windows",  "name": "PolyLineTo",  "code": "proc PolyLineTo*(DC: HDC; Points: pointer; Count: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"PolylineTo\".}" },  { "module": "windows",  "name": "PolyPolygon",  "code": "proc PolyPolygon*(DC: HDC; Points: pointer; nPoints: pointer; p4: int): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyPolygon\".}" },  { "module": "windows",  "name": "PolyPolyline",  "code": "proc PolyPolyline*(DC: HDC; PointStructs: pointer; Points: pointer; p4: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyPolyline\".}" },  { "module": "windows",  "name": "PolyTextOut",  "code": "proc PolyTextOut*(DC: HDC; PolyTextArray: pointer; Strings: int): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutA\".}" },  { "module": "windows",  "name": "PolyTextOutA",  "code": "proc PolyTextOutA*(DC: HDC; PolyTextArray: pointer; Strings: int): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutA\".}" },  { "module": "windows",  "name": "PolyTextOutW",  "code": "proc PolyTextOutW*(DC: HDC; PolyTextArray: pointer; Strings: int): WINBOOL {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"PolyTextOutW\".}" },  { "module": "windows",  "name": "PrivilegeCheck",  "code": "proc PrivilegeCheck*(ClientToken: THandle; RequiredPrivileges: TPrivilegeSet; \u000A                     pfResult: var WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegeCheck\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarm",  "code": "proc PrivilegedServiceAuditAlarm*(SubsystemName, ServiceName: cstring; \u000A                                  ClientToken: THandle; \u000A                                  Privileges: var TPrivilegeSet; \u000A                                  AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmA\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarmA",  "code": "proc PrivilegedServiceAuditAlarmA*(SubsystemName, ServiceName: LPCSTR; \u000A                                   ClientToken: THandle; \u000A                                   Privileges: var TPrivilegeSet; \u000A                                   AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmA\".}" },  { "module": "windows",  "name": "PrivilegedServiceAuditAlarmW",  "code": "proc PrivilegedServiceAuditAlarmW*(SubsystemName, ServiceName: LPWSTR; \u000A                                   ClientToken: THandle; \u000A                                   Privileges: var TPrivilegeSet; \u000A                                   AccessGranted: WINBOOL): WINBOOL {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"PrivilegedServiceAuditAlarmW\".}" },  { "module": "windows",  "name": "QueryPerformanceCounter",  "code": "proc QueryPerformanceCounter*(lpPerformanceCount: var TLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"QueryPerformanceCounter\".}" },  { "module": "windows",  "name": "QueryPerformanceFrequency",  "code": "proc QueryPerformanceFrequency*(lpFrequency: var TLargeInteger): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"QueryPerformanceFrequency\".}" },  { "module": "windows",  "name": "RaiseException",  "code": "proc RaiseException*(dwExceptionCode: DWORD; dwExceptionFlags: DWORD; \u000A                     nNumberOfArguments: DWORD; lpArguments: var DWORD) {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"RaiseException\".}" },  { "module": "windows",  "name": "UnhandledExceptionFilter",  "code": "proc UnhandledExceptionFilter*(ExceptionInfo: var emptyrecord): LONG {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"UnhandledExceptionFilter\".}" },  { "module": "windows",  "name": "ReadConsole",  "code": "proc ReadConsole*(hConsoleInput: THandle; lpBuffer: pointer; \u000A                  nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: var DWORD; \u000A                  lpReserved: pointer): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleA\".}" },  { "module": "windows",  "name": "ReadConsoleA",  "code": "proc ReadConsoleA*(hConsoleInput: THandle; lpBuffer: pointer; \u000A                   nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: var DWORD; \u000A                   lpReserved: pointer): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleA\".}" },  { "module": "windows",  "name": "ReadConsoleInput",  "code": "proc ReadConsoleInput*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                       nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputA\".}" },  { "module": "windows",  "name": "ReadConsoleInputA",  "code": "proc ReadConsoleInputA*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                        nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputA\".}" },  { "module": "windows",  "name": "ReadConsoleInputW",  "code": "proc ReadConsoleInputW*(hConsoleInput: THandle; lpBuffer: var TInputRecord; \u000A                        nLength: DWORD; lpNumberOfEventsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleInputW\".}" },  { "module": "windows",  "name": "ReadConsoleOutput",  "code": "proc ReadConsoleOutput*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                        dwBufferSize, dwBufferCoord: TCoord; \u000A                        lpReadRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputA",  "code": "proc ReadConsoleOutputA*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                         dwBufferSize, dwBufferCoord: TCoord; \u000A                         lpReadRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputAttribute",  "code": "proc ReadConsoleOutputAttribute*(hConsoleOutput: THandle; lpAttribute: pointer; \u000A                                 nLength: DWORD; dwReadCoord: TCoord; \u000A                                 lpNumberOfAttrsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacter",  "code": "proc ReadConsoleOutputCharacter*(hConsoleOutput: THandle; lpCharacter: LPCSTR; \u000A                                 nLength: DWORD; dwReadCoord: TCoord; \u000A                                 lpNumberOfCharsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacterA",  "code": "proc ReadConsoleOutputCharacterA*(hConsoleOutput: THandle; lpCharacter: LPCSTR; \u000A                                  nLength: DWORD; dwReadCoord: TCoord; \u000A                                  lpNumberOfCharsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "ReadConsoleOutputCharacterW",  "code": "proc ReadConsoleOutputCharacterW*(hConsoleOutput: THandle; lpCharacter: LPCSTR; \u000A                                  nLength: DWORD; dwReadCoord: TCoord; \u000A                                  lpNumberOfCharsRead: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "ReadConsoleOutputW",  "code": "proc ReadConsoleOutputW*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                         dwBufferSize, dwBufferCoord: TCoord; \u000A                         lpReadRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadConsoleOutputW\".}" },  { "module": "windows",  "name": "ReadConsoleW",  "code": "proc ReadConsoleW*(hConsoleInput: THandle; lpBuffer: pointer; \u000A                   nNumberOfCharsToRead: DWORD; lpNumberOfCharsRead: var DWORD; \u000A                   lpReserved: pointer): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ReadConsoleW\".}" },  { "module": "windows",  "name": "ReadEventLog",  "code": "proc ReadEventLog*(hEventLog: THandle; dwReadFlags, dwRecordOffset: DWORD; \u000A                   lpBuffer: pointer; nNumberOfBytesToRead: DWORD; \u000A                   pnBytesRead, pnMinNumberOfBytesNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReadEventLogA\".}" },  { "module": "windows",  "name": "ReadEventLogA",  "code": "proc ReadEventLogA*(hEventLog: THandle; dwReadFlags, dwRecordOffset: DWORD; \u000A                    lpBuffer: pointer; nNumberOfBytesToRead: DWORD; \u000A                    pnBytesRead, pnMinNumberOfBytesNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReadEventLogA\".}" },  { "module": "windows",  "name": "ReadEventLogW",  "code": "proc ReadEventLogW*(hEventLog: THandle; dwReadFlags, dwRecordOffset: DWORD; \u000A                    lpBuffer: pointer; nNumberOfBytesToRead: DWORD; \u000A                    pnBytesRead, pnMinNumberOfBytesNeeded: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"ReadEventLogW\".}" },  { "module": "windows",  "name": "ReadFile",  "code": "proc ReadFile*(hFile: THandle; Buffer: pointer; nNumberOfBytesToRead: DWORD; \u000A               lpNumberOfBytesRead: var DWORD; lpOverlapped: POverlapped): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadFile\".}" },  { "module": "windows",  "name": "ReadProcessMemory",  "code": "proc ReadProcessMemory*(hProcess: THandle; lpBaseAddress: pointer; \u000A                        lpBuffer: pointer; nSize: DWORD; \u000A                        lpNumberOfBytesRead: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ReadProcessMemory\".}" },  { "module": "windows",  "name": "RegConnectRegistry",  "code": "proc RegConnectRegistry*(lpMachineName: cstring; key: HKEY; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryA\".}" },  { "module": "windows",  "name": "RegConnectRegistryA",  "code": "proc RegConnectRegistryA*(lpMachineName: LPCSTR; key: HKEY; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryA\".}" },  { "module": "windows",  "name": "RegConnectRegistryW",  "code": "proc RegConnectRegistryW*(lpMachineName: LPWSTR; key: HKEY; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegConnectRegistryW\".}" },  { "module": "windows",  "name": "RegCreateKey",  "code": "proc RegCreateKey*(key: HKEY; lpSubKey: cstring; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyA\".}" },  { "module": "windows",  "name": "RegCreateKeyA",  "code": "proc RegCreateKeyA*(key: HKEY; lpSubKey: LPCSTR; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyA\".}" },  { "module": "windows",  "name": "RegCreateKeyEx",  "code": "proc RegCreateKeyEx*(key: HKEY; lpSubKey: cstring; Reserved: DWORD; \u000A                     lpClass: cstring; dwOptions: DWORD; samDesired: REGSAM; \u000A                     lpSecurityAttributes: PSecurityAttributes; \u000A                     phkResult: var HKEY; lpdwDisposition: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExA\".}" },  { "module": "windows",  "name": "RegCreateKeyExA",  "code": "proc RegCreateKeyExA*(key: HKEY; lpSubKey: LPCSTR; Reserved: DWORD; \u000A                      lpClass: LPCSTR; dwOptions: DWORD; samDesired: REGSAM; \u000A                      lpSecurityAttributes: PSecurityAttributes; \u000A                      phkResult: var HKEY; lpdwDisposition: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExA\".}" },  { "module": "windows",  "name": "RegCreateKeyExW",  "code": "proc RegCreateKeyExW*(key: HKEY; lpSubKey: LPWSTR; Reserved: DWORD; \u000A                      lpClass: LPWSTR; dwOptions: DWORD; samDesired: REGSAM; \u000A                      lpSecurityAttributes: PSecurityAttributes; \u000A                      phkResult: var HKEY; lpdwDisposition: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyExW\".}" },  { "module": "windows",  "name": "RegCreateKeyW",  "code": "proc RegCreateKeyW*(key: HKEY; lpSubKey: LPWSTR; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegCreateKeyW\".}" },  { "module": "windows",  "name": "RegEnumKeyEx",  "code": "proc RegEnumKeyEx*(key: HKEY; dwIndex: DWORD; lpName: cstring; \u000A                   lpcbName: var DWORD; lpReserved: pointer; lpClass: cstring; \u000A                   lpcbClass: PDWORD; lpftLastWriteTime: PFileTime): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyExA\".}" },  { "module": "windows",  "name": "RegEnumKeyExA",  "code": "proc RegEnumKeyExA*(key: HKEY; dwIndex: DWORD; lpName: LPCSTR; \u000A                    lpcbName: var DWORD; lpReserved: pointer; lpClass: LPCSTR; \u000A                    lpcbClass: PDWORD; lpftLastWriteTime: PFileTime): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyExA\".}" },  { "module": "windows",  "name": "RegEnumKeyExW",  "code": "proc RegEnumKeyExW*(key: HKEY; dwIndex: DWORD; lpName: LPWSTR; \u000A                    lpcbName: var DWORD; lpReserved: pointer; lpClass: LPWSTR; \u000A                    lpcbClass: PDWORD; lpftLastWriteTime: PFileTime): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumKeyExW\".}" },  { "module": "windows",  "name": "RegEnumValue",  "code": "proc RegEnumValue*(key: HKEY; dwIndex: DWORD; lpValueName: cstring; \u000A                   lpcbValueName: var DWORD; lpReserved: pointer; \u000A                   lpType: PDWORD; lpData: PByte; lpcbData: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumValueA\".}" },  { "module": "windows",  "name": "RegEnumValueA",  "code": "proc RegEnumValueA*(key: HKEY; dwIndex: DWORD; lpValueName: cstring; \u000A                    lpcbValueName: var DWORD; lpReserved: pointer; \u000A                    lpType: PDWORD; lpData: PByte; lpcbData: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumValueA\".}" },  { "module": "windows",  "name": "RegEnumValueW",  "code": "proc RegEnumValueW*(key: HKEY; dwIndex: DWORD; lpValueName: cstring; \u000A                    lpcbValueName: var DWORD; lpReserved: pointer; \u000A                    lpType: PDWORD; lpData: PByte; lpcbData: PDWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegEnumValueW\".}" },  { "module": "windows",  "name": "RegGetKeySecurity",  "code": "proc RegGetKeySecurity*(key: HKEY; SecurityInformation: SECURITY_INFORMATION; \u000A                        pSecurityDescriptor: PSecurityDescriptor; \u000A                        lpcbSecurityDescriptor: var DWORD): int32 {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegGetKeySecurity\".}" },  { "module": "windows",  "name": "RegSetValueEx",  "code": "proc RegSetValueEx*(key: HKEY; lpValueName: LPCSTR; Reserved: DWORD; \u000A                    dwType: DWORD; lpData: pointer; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExA\".}" },  { "module": "windows",  "name": "RegSetValueExA",  "code": "proc RegSetValueExA*(key: HKEY; lpValueName: LPCSTR; Reserved: DWORD; \u000A                     dwType: DWORD; lpData: pointer; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExA\".}" },  { "module": "windows",  "name": "RegSetValueExW",  "code": "proc RegSetValueExW*(key: HKEY; lpValueName: LPCWSTR; Reserved: DWORD; \u000A                     dwType: DWORD; lpData: pointer; cbData: DWORD): LONG {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegSetValueExW\".}" },  { "module": "windows",  "name": "RegisterClass",  "code": "proc RegisterClass*(lpWndClass: TWndClass): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassA\".}" },  { "module": "windows",  "name": "RegisterClassA",  "code": "proc RegisterClassA*(lpWndClass: TWndClassA): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassA\".}" },  { "module": "windows",  "name": "RegisterClassEx",  "code": "proc RegisterClassEx*(WndClass: TWndClassEx): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassExA\".}" },  { "module": "windows",  "name": "RegisterClassExA",  "code": "proc RegisterClassExA*(WndClass: TWndClassExA): ATOM {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterClassExA\".}" },  { "module": "windows",  "name": "RegisterClassExW",  "code": "proc RegisterClassExW*(WndClass: TWndClassExW): ATOM {.stdcall, \u000A    dynlib: \"user32\", importc: \"RegisterClassExW\".}" },  { "module": "windows",  "name": "RegisterClassW",  "code": "proc RegisterClassW*(lpWndClass: TWndClassW): ATOM {.stdcall, dynlib: \"user32\", \u000A    importc: \"RegisterClassW\".}" },  { "module": "windows",  "name": "RegOpenKey",  "code": "proc RegOpenKey*(key: HKEY; lpSubKey: cstring; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyA\".}" },  { "module": "windows",  "name": "RegOpenKeyA",  "code": "proc RegOpenKeyA*(key: HKEY; lpSubKey: LPCSTR; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyA\".}" },  { "module": "windows",  "name": "RegOpenKeyEx",  "code": "proc RegOpenKeyEx*(key: HKEY; lpSubKey: cstring; ulOptions: DWORD; \u000A                   samDesired: REGSAM; phkResult: var HKEY): int32 {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExA\".}" },  { "module": "windows",  "name": "RegOpenKeyExA",  "code": "proc RegOpenKeyExA*(key: HKEY; lpSubKey: LPCSTR; ulOptions: DWORD; \u000A                    samDesired: REGSAM; phkResult: var HKEY): int32 {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExA\".}" },  { "module": "windows",  "name": "RegOpenKeyExW",  "code": "proc RegOpenKeyExW*(key: HKEY; lpSubKey: LPWSTR; ulOptions: DWORD; \u000A                    samDesired: REGSAM; phkResult: var HKEY): int32 {.stdcall, \u000A    dynlib: \"advapi32\", importc: \"RegOpenKeyExW\".}" },  { "module": "windows",  "name": "RegOpenKeyW",  "code": "proc RegOpenKeyW*(key: HKEY; lpSubKey: LPWSTR; phkResult: var HKEY): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegOpenKeyW\".}" },  { "module": "windows",  "name": "RegQueryMultipleValues",  "code": "proc RegQueryMultipleValues*(key: HKEY; ValList: pointer; NumVals: DWORD; \u000A                             lpValueBuf: cstring; ldwTotsize: var DWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesA\".}" },  { "module": "windows",  "name": "RegQueryMultipleValuesA",  "code": "proc RegQueryMultipleValuesA*(key: HKEY; ValList: pointer; NumVals: DWORD; \u000A                              lpValueBuf: LPCSTR; ldwTotsize: var DWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesA\".}" },  { "module": "windows",  "name": "RegQueryMultipleValuesW",  "code": "proc RegQueryMultipleValuesW*(key: HKEY; ValList: pointer; NumVals: DWORD; \u000A                              lpValueBuf: LPWSTR; ldwTotsize: var DWORD): int32 {.\u000A    stdcall, dynlib: \"advapi32\", importc: \"RegQueryMultipleValuesW\".}" },  { "module": "windows",  "name": "RegQueryValue",  "code": "proc RegQueryValue*(key: HKEY; lpSubKey: cstring; lpValue: cstring; \u000A                    lpcbValue: var int32): int32 {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueA\".}" },  { "module": "windows",  "name": "RegQueryValueA",  "code": "proc RegQueryValueA*(key: HKEY; lpSubKey: LPCSTR; lpValue: LPCSTR; \u000A                     lpcbValue: var int32): int32 {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueA\".}" },  { "module": "windows",  "name": "RegQueryValueW",  "code": "proc RegQueryValueW*(key: HKEY; lpSubKey: LPWSTR; lpValue: LPWSTR; \u000A                     lpcbValue: var int32): int32 {.stdcall, dynlib: \"advapi32\", \u000A    importc: \"RegQueryValueW\".}" },  { "module": "windows",  "name": "ResetDC",  "code": "proc ResetDC*(DC: HDC; p2: TDeviceMode): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ResetDCA\".}" },  { "module": "windows",  "name": "ResetDCA",  "code": "proc ResetDCA*(DC: HDC; p2: TDeviceModeA): HDC {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"ResetDCA\".}" },  { "module": "windows",  "name": "ScreenToClient",  "code": "proc ScreenToClient*(wnd: HWND; lpPoint: var TPoint): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"ScreenToClient\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBuffer",  "code": "proc ScrollConsoleScreenBuffer*(hConsoleOutput: THandle; \u000A                                lpScrollRectangle: TSmallRect; \u000A                                lpClipRectangle: TSmallRect; \u000A                                dwDestinationOrigin: TCoord; \u000A                                lpFill: var TCharInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferA\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBufferA",  "code": "proc ScrollConsoleScreenBufferA*(hConsoleOutput: THandle; \u000A                                 lpScrollRectangle: TSmallRect; \u000A                                 lpClipRectangle: TSmallRect; \u000A                                 dwDestinationOrigin: TCoord; \u000A                                 lpFill: var TCharInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferA\".}" },  { "module": "windows",  "name": "ScrollConsoleScreenBufferW",  "code": "proc ScrollConsoleScreenBufferW*(hConsoleOutput: THandle; \u000A                                 lpScrollRectangle: TSmallRect; \u000A                                 lpClipRectangle: TSmallRect; \u000A                                 dwDestinationOrigin: TCoord; \u000A                                 lpFill: var TCharInfo): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"ScrollConsoleScreenBufferW\".}" },  { "module": "windows",  "name": "ScrollWindow",  "code": "proc ScrollWindow*(wnd: HWND; XAmount: int32; YAmount: int32; rect: LPRECT; \u000A                   lpClipRect: LPRECT): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"ScrollWindow\".}" },  { "module": "windows",  "name": "ScrollWindowEx",  "code": "proc ScrollWindowEx*(wnd: HWND; dx: int32; dy: int32; prcScroll: LPRECT; \u000A                     prcClip: LPRECT; hrgnUpdate: HRGN; prcUpdate: LPRECT; \u000A                     flags: WINUINT): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"ScrollWindowEx\".}" },  { "module": "windows",  "name": "SendMessageTimeout",  "code": "proc SendMessageTimeout*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                         fuFlags, uTimeout: WINUINT; lpdwResult: var DWORD): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageTimeoutA\".}" },  { "module": "windows",  "name": "SendMessageTimeoutA",  "code": "proc SendMessageTimeoutA*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                          fuFlags, uTimeout: WINUINT; lpdwResult: var DWORD): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageTimeoutA\".}" },  { "module": "windows",  "name": "SendMessageTimeoutW",  "code": "proc SendMessageTimeoutW*(wnd: HWND; Msg: WINUINT; wp: WPARAM; lp: LPARAM; \u000A                          fuFlags, uTimeout: WINUINT; lpdwResult: var DWORD): LRESULT {.\u000A    stdcall, dynlib: \"user32\", importc: \"SendMessageTimeoutW\".}" },  { "module": "windows",  "name": "SetCommConfig",  "code": "proc SetCommConfig*(hCommDev: THandle; lpCC: TCommConfig; dwSize: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetCommConfig\".}" },  { "module": "windows",  "name": "SetCommState",  "code": "proc SetCommState*(hFile: THandle; lpDCB: TDCB): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetCommState\".}" },  { "module": "windows",  "name": "SetCommTimeouts",  "code": "proc SetCommTimeouts*(hFile: THandle; lpCommTimeouts: TCommTimeouts): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetCommTimeouts\".}" },  { "module": "windows",  "name": "SetConsoleCursorInfo",  "code": "proc SetConsoleCursorInfo*(hConsoleOutput: THandle; \u000A                           lpConsoleCursorInfo: TConsoleCursorInfo): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetConsoleCursorInfo\".}" },  { "module": "windows",  "name": "SetDIBColorTable",  "code": "proc SetDIBColorTable*(DC: HDC; p2, p3: WINUINT; RGBQuadSTructs: pointer): WINUINT {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetDIBColorTable\".}" },  { "module": "windows",  "name": "SetDIBits",  "code": "proc SetDIBits*(DC: HDC; Bitmap: HBITMAP; StartScan, NumScans: WINUINT; \u000A                Bits: pointer; BitsInfo: var TBitmapInfo; Usage: WINUINT): int {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetDIBits\".}" },  { "module": "windows",  "name": "SetEnhMetaFileBits",  "code": "proc SetEnhMetaFileBits*(para1: WINUINT; para2: pointer): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetEnhMetaFileBits\".}" },  { "module": "windows",  "name": "SetFileTime",  "code": "proc SetFileTime*(hFile: HANDLE; lpCreationTime: var FILETIME; \u000A                  lpLastAccessTime: var FILETIME; lpLastWriteTime: var FILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileTime\".}" },  { "module": "windows",  "name": "SetMenuItemInfo",  "code": "proc SetMenuItemInfo*(p1: HMENU; p2: WINUINT; p3: WINBOOL; p4: TMenuItemInfo): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetMenuItemInfoA\".}" },  { "module": "windows",  "name": "SetMenuItemInfoA",  "code": "proc SetMenuItemInfoA*(p1: HMENU; p2: WINUINT; p3: WINBOOL; p4: TMenuItemInfoA): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetMenuItemInfoA\".}" },  { "module": "windows",  "name": "SetMetaFileBitsEx",  "code": "proc SetMetaFileBitsEx*(p1: WINUINT; p2: cstring): HMETAFILE {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetMetaFileBitsEx\".}" },  { "module": "windows",  "name": "SetNamedPipeHandleState",  "code": "proc SetNamedPipeHandleState*(hNamedPipe: THandle; lpMode: var DWORD; \u000A    lpMaxCollectionCount, lpCollectDataTimeout: pointer): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetNamedPipeHandleState\".}" },  { "module": "windows",  "name": "SetPaletteEntries",  "code": "proc SetPaletteEntries*(Palette: HPALETTE; StartIndex, NumEntries: WINUINT; \u000A                        PaletteEntries: pointer): WINUINT {.stdcall, \u000A    dynlib: \"gdi32\", importc: \"SetPaletteEntries\".}" },  { "module": "windows",  "name": "SetRect",  "code": "proc SetRect*(lprc: var TRect; xLeft, yTop, xRight, yBottom: int): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetRect\".}" },  { "module": "windows",  "name": "SetRectEmpty",  "code": "proc SetRectEmpty*(lprc: var TRect): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetRectEmpty\".}" },  { "module": "windows",  "name": "SetScrollInfo",  "code": "proc SetScrollInfo*(wnd: HWND; BarFlag: int; ScrollInfo: TScrollInfo; \u000A                    Redraw: WINBOOL): int {.stdcall, dynlib: \"user32\", \u000A    importc: \"SetScrollInfo\".}" },  { "module": "windows",  "name": "SetSysColors",  "code": "proc SetSysColors*(cElements: int; lpaElements: pointer; lpaRgbValues: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SetSysColors\".}" },  { "module": "windows",  "name": "SetThreadContext",  "code": "proc SetThreadContext*(hThread: THandle; lpContext: TContext): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetThreadContext\".}" },  { "module": "windows",  "name": "SetUserObjectSecurity",  "code": "proc SetUserObjectSecurity*(hObj: THandle; pSIRequested: var DWORD; \u000A                            pSID: PSecurityDescriptor): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"SetUserObjectSecurity\".}" },  { "module": "windows",  "name": "SetWaitableTimer",  "code": "proc SetWaitableTimer*(hTimer: THandle; lpDueTime: var TLargeInteger; \u000A                       lPeriod: int32; pfnCompletionRoutine: TFNTimerAPCRoutine; \u000A                       lpArgToCompletionRoutine: pointer; fResume: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetWaitableTimer\".}" },  { "module": "windows",  "name": "SetWinMetaFileBits",  "code": "proc SetWinMetaFileBits*(p1: WINUINT; p2: cstring; p3: HDC; p4: TMetaFilePict): HENHMETAFILE {.\u000A    stdcall, dynlib: \"gdi32\", importc: \"SetWinMetaFileBits\".}" },  { "module": "windows",  "name": "StartDoc",  "code": "proc StartDoc*(DC: HDC; p2: TDocInfo): int {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StartDocA\".}" },  { "module": "windows",  "name": "StartDocA",  "code": "proc StartDocA*(DC: HDC; p2: TDocInfoA): int {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"StartDocA\".}" },  { "module": "windows",  "name": "SubtractRect",  "code": "proc SubtractRect*(lprcDst: var TRect; lprcSrc1, lprcSrc2: TRect): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"SubtractRect\".}" },  { "module": "windows",  "name": "SystemTimeToFileTime",  "code": "proc SystemTimeToFileTime*(lpSystemTime: TSystemTime; lpFileTime: var TFileTime): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SystemTimeToFileTime\".}" },  { "module": "windows",  "name": "SystemTimeToTzSpecificLocalTime",  "code": "proc SystemTimeToTzSpecificLocalTime*(lpTimeZoneInformation: PTimeZoneInformation; \u000A    lpUniversalTime, lpLocalTime: var TSystemTime): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SystemTimeToTzSpecificLocalTime\".}" },  { "module": "windows",  "name": "TabbedTextOut",  "code": "proc TabbedTextOut*(hDC: HDC; X, Y: int; lpString: cstring; \u000A                    nCount, nTabPositions: int; lpnTabStopPositions: pointer; \u000A                    nTabOrigin: int): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"TabbedTextOutA\".}" },  { "module": "windows",  "name": "TabbedTextOutA",  "code": "proc TabbedTextOutA*(hDC: HDC; X, Y: int; lpString: LPCSTR; \u000A                     nCount, nTabPositions: int; lpnTabStopPositions: pointer; \u000A                     nTabOrigin: int): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"TabbedTextOutA\".}" },  { "module": "windows",  "name": "TabbedTextOutW",  "code": "proc TabbedTextOutW*(hDC: HDC; X, Y: int; lpString: LPWSTR; \u000A                     nCount, nTabPositions: int; lpnTabStopPositions: pointer; \u000A                     nTabOrigin: int): int32 {.stdcall, dynlib: \"user32\", \u000A    importc: \"TabbedTextOutW\".}" },  { "module": "windows",  "name": "TrackMouseEvent",  "code": "proc TrackMouseEvent*(EventTrack: var TTrackMouseEvent): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"TrackMouseEvent\".}" },  { "module": "windows",  "name": "TrackMouseEvent",  "code": "proc TrackMouseEvent*(lpEventTrack: PTrackMouseEvent): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"TrackMouseEvent\".}" },  { "module": "windows",  "name": "TrackPopupMenu",  "code": "proc TrackPopupMenu*(menu: HMENU; uFlags: WINUINT; x: int32; y: int32; \u000A                     nReserved: int32; wnd: HWND; prcRect: PRect): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"TrackPopupMenu\".}" },  { "module": "windows",  "name": "TransactNamedPipe",  "code": "proc TransactNamedPipe*(hNamedPipe: THandle; lpInBuffer: pointer; \u000A                        nInBufferSize: DWORD; lpOutBuffer: pointer; \u000A                        nOutBufferSize: DWORD; lpBytesRead: var DWORD; \u000A                        lpOverlapped: POverlapped): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TransactNamedPipe\".}" },  { "module": "windows",  "name": "TranslateAccelerator",  "code": "proc TranslateAccelerator*(wnd: HWND; hAccTable: HACCEL; lpMsg: var TMsg): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorA\".}" },  { "module": "windows",  "name": "TranslateAcceleratorA",  "code": "proc TranslateAcceleratorA*(wnd: HWND; hAccTable: HACCEL; lpMsg: var TMsg): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorA\".}" },  { "module": "windows",  "name": "TranslateAcceleratorW",  "code": "proc TranslateAcceleratorW*(wnd: HWND; hAccTable: HACCEL; lpMsg: var TMsg): int {.\u000A    stdcall, dynlib: \"user32\", importc: \"TranslateAcceleratorW\".}" },  { "module": "windows",  "name": "TranslateCharsetInfo",  "code": "proc TranslateCharsetInfo*(lpSrc: var DWORD; lpCs: var TCharsetInfo; \u000A                           dwFlags: DWORD): WINBOOL {.stdcall, dynlib: \"gdi32\", \u000A    importc: \"TranslateCharsetInfo\".}" },  { "module": "windows",  "name": "TranslateMDISysAccel",  "code": "proc TranslateMDISysAccel*(hWndClient: HWND; lpMsg: TMsg): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"TranslateMDISysAccel\".}" },  { "module": "windows",  "name": "TranslateMessage",  "code": "proc TranslateMessage*(lpMsg: TMsg): WINBOOL {.stdcall, dynlib: \"user32\", \u000A    importc: \"TranslateMessage\".}" },  { "module": "windows",  "name": "UnhandledExceptionFilter",  "code": "proc UnhandledExceptionFilter*(ExceptionInfo: TExceptionpointers): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UnhandledExceptionFilter\".}" },  { "module": "windows",  "name": "UnionRect",  "code": "proc UnionRect*(lprcDst: var TRect; lprcSrc1, lprcSrc2: TRect): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"UnionRect\".}" },  { "module": "windows",  "name": "UnlockFileEx",  "code": "proc UnlockFileEx*(hFile: THandle; dwReserved, nNumberOfBytesToUnlockLow: DWORD; \u000A                   nNumberOfBytesToUnlockHigh: DWORD; lpOverlapped: TOverlapped): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"UnlockFileEx\".}" },  { "module": "windows",  "name": "VerFindFile",  "code": "proc VerFindFile*(uFlags: DWORD; \u000A                  szFileName, szWinDir, szAppDir, szCurDir: cstring; \u000A                  lpuCurDirLen: var WINUINT; szDestDir: cstring; \u000A                  lpuDestDirLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileA\".}" },  { "module": "windows",  "name": "VerFindFileA",  "code": "proc VerFindFileA*(uFlags: DWORD; \u000A                   szFileName, szWinDir, szAppDir, szCurDir: LPCSTR; \u000A                   lpuCurDirLen: var WINUINT; szDestDir: LPCSTR; \u000A                   lpuDestDirLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileA\".}" },  { "module": "windows",  "name": "VerFindFileW",  "code": "proc VerFindFileW*(uFlags: DWORD; \u000A                   szFileName, szWinDir, szAppDir, szCurDir: LPWSTR; \u000A                   lpuCurDirLen: var WINUINT; szDestDir: LPWSTR; \u000A                   lpuDestDirLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerFindFileW\".}" },  { "module": "windows",  "name": "VerInstallFile",  "code": "proc VerInstallFile*(uFlags: DWORD; szSrcFileName, szDestFileName, szSrcDir, \u000A                                    szDestDir, szCurDir, szTmpFile: cstring; \u000A                     lpuTmpFileLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerInstallFileA\".}" },  { "module": "windows",  "name": "VerInstallFileA",  "code": "proc VerInstallFileA*(uFlags: DWORD; szSrcFileName, szDestFileName, szSrcDir, \u000A                                     szDestDir, szCurDir, szTmpFile: LPCSTR; \u000A                      lpuTmpFileLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerInstallFileA\".}" },  { "module": "windows",  "name": "VerInstallFileW",  "code": "proc VerInstallFileW*(uFlags: DWORD; szSrcFileName, szDestFileName, szSrcDir, \u000A                                     szDestDir, szCurDir, szTmpFile: LPWSTR; \u000A                      lpuTmpFileLen: var WINUINT): DWORD {.stdcall, \u000A    dynlib: \"version\", importc: \"VerInstallFileW\".}" },  { "module": "windows",  "name": "VerQueryValue",  "code": "proc VerQueryValue*(pBlock: pointer; lpSubBlock: cstring; \u000A                    lplpBuffer: var pointer; puLen: var WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"version\", importc: \"VerQueryValueA\".}" },  { "module": "windows",  "name": "VerQueryValueA",  "code": "proc VerQueryValueA*(pBlock: pointer; lpSubBlock: LPCSTR; \u000A                     lplpBuffer: var pointer; puLen: var WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"version\", importc: \"VerQueryValueA\".}" },  { "module": "windows",  "name": "VerQueryValueW",  "code": "proc VerQueryValueW*(pBlock: pointer; lpSubBlock: LPWSTR; \u000A                     lplpBuffer: var pointer; puLen: var WINUINT): WINBOOL {.\u000A    stdcall, dynlib: \"version\", importc: \"VerQueryValueW\".}" },  { "module": "windows",  "name": "VirtualQuery",  "code": "proc VirtualQuery*(lpAddress: pointer; lpBuffer: var TMemoryBasicInformation; \u000A                   dwLength: DWORD): DWORD {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"VirtualQuery\".}" },  { "module": "windows",  "name": "VirtualQueryEx",  "code": "proc VirtualQueryEx*(hProcess: THandle; lpAddress: pointer; \u000A                     lpBuffer: var TMemoryBasicInformation; dwLength: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"VirtualQueryEx\".}" },  { "module": "windows",  "name": "WaitCommEvent",  "code": "proc WaitCommEvent*(hFile: THandle; lpEvtMask: var DWORD; \u000A                    lpOverlapped: POverlapped): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WaitCommEvent\".}" },  { "module": "windows",  "name": "WaitForDebugEvent",  "code": "proc WaitForDebugEvent*(lpDebugEvent: var TDebugEvent; dwMilliseconds: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitForDebugEvent\".}" },  { "module": "windows",  "name": "wglDescribeLayerPlane",  "code": "proc wglDescribeLayerPlane*(p1: HDC; p2, p3: int; p4: int; \u000A                            p5: var TLayerPlaneDescriptor): WINBOOL {.stdcall, \u000A    dynlib: \"opengl32\", importc: \"wglDescribeLayerPlane\".}" },  { "module": "windows",  "name": "wglGetLayerPaletteEntries",  "code": "proc wglGetLayerPaletteEntries*(p1: HDC; p2, p3, p4: int; pcr: pointer): int {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglGetLayerPaletteEntries\".}" },  { "module": "windows",  "name": "wglSetLayerPaletteEntries",  "code": "proc wglSetLayerPaletteEntries*(p1: HDC; p2, p3, p4: int; pcr: pointer): int {.\u000A    stdcall, dynlib: \"opengl32\", importc: \"wglSetLayerPaletteEntries\".}" },  { "module": "windows",  "name": "WNetAddConnection2",  "code": "proc WNetAddConnection2*(lpNetResource: var TNetResource; \u000A                         lpPassword, lpUserName: cstring; dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetAddConnection2A\".}" },  { "module": "windows",  "name": "WNetAddConnection2A",  "code": "proc WNetAddConnection2A*(lpNetResource: var TNetResourceA; \u000A                          lpPassword, lpUserName: LPCSTR; dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetAddConnection2A\".}" },  { "module": "windows",  "name": "WNetAddConnection3",  "code": "proc WNetAddConnection3*(hwndOwner: HWND; lpNetResource: var TNetResource; \u000A                         lpPassword, lpUserName: cstring; dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetAddConnection3A\".}" },  { "module": "windows",  "name": "WNetAddConnection3A",  "code": "proc WNetAddConnection3A*(hwndOwner: HWND; lpNetResource: var TNetResourceA; \u000A                          lpPassword, lpUserName: LPCSTR; dwFlags: DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetAddConnection3A\".}" },  { "module": "windows",  "name": "WNetConnectionDialog1",  "code": "proc WNetConnectionDialog1*(lpConnDlgStruct: var TConnectDlgStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetConnectionDialog1A\".}" },  { "module": "windows",  "name": "WNetConnectionDialog1A",  "code": "proc WNetConnectionDialog1A*(lpConnDlgStruct: var TConnectDlgStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetConnectionDialog1A\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog1",  "code": "proc WNetDisconnectDialog1*(lpConnDlgStruct: var TDiscDlgStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetDisconnectDialog1A\".}" },  { "module": "windows",  "name": "WNetDisconnectDialog1A",  "code": "proc WNetDisconnectDialog1A*(lpConnDlgStruct: var TDiscDlgStructA): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetDisconnectDialog1A\".}" },  { "module": "windows",  "name": "WNetEnumResource",  "code": "proc WNetEnumResource*(hEnum: THandle; lpcCount: var DWORD; lpBuffer: pointer; \u000A                       lpBufferSize: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetEnumResourceA\".}" },  { "module": "windows",  "name": "WNetEnumResourceA",  "code": "proc WNetEnumResourceA*(hEnum: THandle; lpcCount: var DWORD; lpBuffer: pointer; \u000A                        lpBufferSize: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetEnumResourceA\".}" },  { "module": "windows",  "name": "WNetEnumResourceW",  "code": "proc WNetEnumResourceW*(hEnum: THandle; lpcCount: var DWORD; lpBuffer: pointer; \u000A                        lpBufferSize: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetEnumResourceW\".}" },  { "module": "windows",  "name": "WNetGetConnection",  "code": "proc WNetGetConnection*(lpLocalName: cstring; lpRemoteName: cstring; \u000A                        lpnLength: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionA\".}" },  { "module": "windows",  "name": "WNetGetConnectionA",  "code": "proc WNetGetConnectionA*(lpLocalName: LPCSTR; lpRemoteName: LPCSTR; \u000A                         lpnLength: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionA\".}" },  { "module": "windows",  "name": "WNetGetConnectionW",  "code": "proc WNetGetConnectionW*(lpLocalName: LPWSTR; lpRemoteName: LPWSTR; \u000A                         lpnLength: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetConnectionW\".}" },  { "module": "windows",  "name": "WNetGetLastError",  "code": "proc WNetGetLastError*(lpError: var DWORD; lpErrorBuf: cstring; \u000A                       nErrorBufSize: DWORD; lpNameBuf: cstring; \u000A                       nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorA\".}" },  { "module": "windows",  "name": "WNetGetLastErrorA",  "code": "proc WNetGetLastErrorA*(lpError: var DWORD; lpErrorBuf: LPCSTR; \u000A                        nErrorBufSize: DWORD; lpNameBuf: LPCSTR; \u000A                        nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorA\".}" },  { "module": "windows",  "name": "WNetGetLastErrorW",  "code": "proc WNetGetLastErrorW*(lpError: var DWORD; lpErrorBuf: LPWSTR; \u000A                        nErrorBufSize: DWORD; lpNameBuf: LPWSTR; \u000A                        nNameBufSize: DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetGetLastErrorW\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformation",  "code": "proc WNetGetNetworkInformation*(lpProvider: cstring; \u000A                                lpNetInfoStruct: var TNetInfoStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationA\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformationA",  "code": "proc WNetGetNetworkInformationA*(lpProvider: LPCSTR; \u000A                                 lpNetInfoStruct: var TNetInfoStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationA\".}" },  { "module": "windows",  "name": "WNetGetNetworkInformationW",  "code": "proc WNetGetNetworkInformationW*(lpProvider: LPWSTR; \u000A                                 lpNetInfoStruct: var TNetInfoStruct): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetNetworkInformationW\".}" },  { "module": "windows",  "name": "WNetGetProviderName",  "code": "proc WNetGetProviderName*(dwNetType: DWORD; lpProviderName: cstring; \u000A                          lpBufferSize: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameA\".}" },  { "module": "windows",  "name": "WNetGetProviderNameA",  "code": "proc WNetGetProviderNameA*(dwNetType: DWORD; lpProviderName: LPCSTR; \u000A                           lpBufferSize: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameA\".}" },  { "module": "windows",  "name": "WNetGetProviderNameW",  "code": "proc WNetGetProviderNameW*(dwNetType: DWORD; lpProviderName: LPWSTR; \u000A                           lpBufferSize: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetProviderNameW\".}" },  { "module": "windows",  "name": "WNetGetResourceParent",  "code": "proc WNetGetResourceParent*(lpNetResource: PNetResource; lpBuffer: pointer; \u000A                            cbBuffer: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetResourceParentA\".}" },  { "module": "windows",  "name": "WNetGetResourceParentA",  "code": "proc WNetGetResourceParentA*(lpNetResource: PNetResourceA; lpBuffer: pointer; \u000A                             cbBuffer: var DWORD): DWORD {.stdcall, \u000A    dynlib: \"mpr\", importc: \"WNetGetResourceParentA\".}" },  { "module": "windows",  "name": "WNetGetUniversalName",  "code": "proc WNetGetUniversalName*(lpLocalPath: cstring; dwInfoLevel: DWORD; \u000A                           lpBuffer: pointer; lpBufferSize: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameA\".}" },  { "module": "windows",  "name": "WNetGetUniversalNameA",  "code": "proc WNetGetUniversalNameA*(lpLocalPath: LPCSTR; dwInfoLevel: DWORD; \u000A                            lpBuffer: pointer; lpBufferSize: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameA\".}" },  { "module": "windows",  "name": "WNetGetUniversalNameW",  "code": "proc WNetGetUniversalNameW*(lpLocalPath: LPWSTR; dwInfoLevel: DWORD; \u000A                            lpBuffer: pointer; lpBufferSize: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUniversalNameW\".}" },  { "module": "windows",  "name": "WNetGetUser",  "code": "proc WNetGetUser*(lpName: cstring; lpUserName: cstring; lpnLength: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserA\".}" },  { "module": "windows",  "name": "WNetGetUserA",  "code": "proc WNetGetUserA*(lpName: LPCSTR; lpUserName: LPCSTR; lpnLength: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserA\".}" },  { "module": "windows",  "name": "WNetGetUserW",  "code": "proc WNetGetUserW*(lpName: LPWSTR; lpUserName: LPWSTR; lpnLength: var DWORD): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetGetUserW\".}" },  { "module": "windows",  "name": "WNetOpenEnum",  "code": "proc WNetOpenEnum*(dwScope, dwType, dwUsage: DWORD; lpNetResource: PNetResource; \u000A                   lphEnum: var THandle): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetOpenEnumA\".}" },  { "module": "windows",  "name": "WNetOpenEnumA",  "code": "proc WNetOpenEnumA*(dwScope, dwType, dwUsage: DWORD; \u000A                    lpNetResource: PNetResourceA; lphEnum: var THandle): DWORD {.\u000A    stdcall, dynlib: \"mpr\", importc: \"WNetOpenEnumA\".}" },  { "module": "windows",  "name": "WNetUseConnection",  "code": "proc WNetUseConnection*(hwndOwner: HWND; lpNetResource: var TNetResource; \u000A                        lpUserID: cstring; lpPassword: cstring; dwFlags: DWORD; \u000A                        lpAccessName: cstring; lpBufferSize: var DWORD; \u000A                        lpResult: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetUseConnectionA\".}" },  { "module": "windows",  "name": "WNetUseConnectionA",  "code": "proc WNetUseConnectionA*(hwndOwner: HWND; lpNetResource: var TNetResourceA; \u000A                         lpUserID: LPCSTR; lpPassword: LPCSTR; dwFlags: DWORD; \u000A                         lpAccessName: LPCSTR; lpBufferSize: var DWORD; \u000A                         lpResult: var DWORD): DWORD {.stdcall, dynlib: \"mpr\", \u000A    importc: \"WNetUseConnectionA\".}" },  { "module": "windows",  "name": "WriteConsole",  "code": "proc WriteConsole*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                   nNumberOfCharsToWrite: DWORD; \u000A                   lpNumberOfCharsWritten: var DWORD; lpReserved: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleA\".}" },  { "module": "windows",  "name": "WriteConsoleA",  "code": "proc WriteConsoleA*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                    nNumberOfCharsToWrite: DWORD; \u000A                    lpNumberOfCharsWritten: var DWORD; lpReserved: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleA\".}" },  { "module": "windows",  "name": "WriteConsoleInput",  "code": "proc WriteConsoleInput*(hConsoleInput: THandle; lpBuffer: TInputRecord; \u000A                        nLength: DWORD; lpNumberOfEventsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputA\".}" },  { "module": "windows",  "name": "WriteConsoleInputA",  "code": "proc WriteConsoleInputA*(hConsoleInput: THandle; lpBuffer: TInputRecord; \u000A                         nLength: DWORD; lpNumberOfEventsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputA\".}" },  { "module": "windows",  "name": "WriteConsoleInputW",  "code": "proc WriteConsoleInputW*(hConsoleInput: THandle; lpBuffer: TInputRecord; \u000A                         nLength: DWORD; lpNumberOfEventsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleInputW\".}" },  { "module": "windows",  "name": "WriteConsoleOutput",  "code": "proc WriteConsoleOutput*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                         dwBufferSize, dwBufferCoord: TCoord; \u000A                         lpWriteRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputA",  "code": "proc WriteConsoleOutputA*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                          dwBufferSize, dwBufferCoord: TCoord; \u000A                          lpWriteRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputAttribute",  "code": "proc WriteConsoleOutputAttribute*(hConsoleOutput: THandle; lpAttribute: pointer; \u000A                                  nLength: DWORD; dwWriteCoord: TCoord; \u000A                                  lpNumberOfAttrsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputAttribute\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacter",  "code": "proc WriteConsoleOutputCharacter*(hConsoleOutput: THandle; lpCharacter: cstring; \u000A                                  nLength: DWORD; dwWriteCoord: TCoord; \u000A                                  lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacterA",  "code": "proc WriteConsoleOutputCharacterA*(hConsoleOutput: THandle; lpCharacter: LPCSTR; \u000A                                   nLength: DWORD; dwWriteCoord: TCoord; \u000A                                   lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterA\".}" },  { "module": "windows",  "name": "WriteConsoleOutputCharacterW",  "code": "proc WriteConsoleOutputCharacterW*(hConsoleOutput: THandle; lpCharacter: LPWSTR; \u000A                                   nLength: DWORD; dwWriteCoord: TCoord; \u000A                                   lpNumberOfCharsWritten: var DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleOutputCharacterW\".}" },  { "module": "windows",  "name": "WriteConsoleOutputW",  "code": "proc WriteConsoleOutputW*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                          dwBufferSize, dwBufferCoord: TCoord; \u000A                          lpWriteRegion: var TSmallRect): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteConsoleOutputW\".}" },  { "module": "windows",  "name": "WriteConsoleW",  "code": "proc WriteConsoleW*(hConsoleOutput: THandle; lpBuffer: pointer; \u000A                    nNumberOfCharsToWrite: DWORD; \u000A                    lpNumberOfCharsWritten: var DWORD; lpReserved: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteConsoleW\".}" },  { "module": "windows",  "name": "WriteFile",  "code": "proc WriteFile*(hFile: THandle; Buffer: pointer; nNumberOfBytesToWrite: DWORD; \u000A                lpNumberOfBytesWritten: var DWORD; lpOverlapped: POverlapped): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteFile\".}" },  { "module": "windows",  "name": "WriteFileEx",  "code": "proc WriteFileEx*(hFile: THandle; lpBuffer: pointer; \u000A                  nNumberOfBytesToWrite: DWORD; lpOverlapped: TOverlapped; \u000A                  lpCompletionRoutine: FARPROC): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteFileEx\".}" },  { "module": "windows",  "name": "WritePrivateProfileStructA",  "code": "proc WritePrivateProfileStructA*(lpszSection, lpszKey: LPCSTR; lpStruct: LPVOID; \u000A                                 uSizeStruct: WINUINT; szFile: LPCSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WritePrivateProfileStructA\".}" },  { "module": "windows",  "name": "WritePrivateProfileStructW",  "code": "proc WritePrivateProfileStructW*(lpszSection, lpszKey: LPCWSTR; \u000A                                 lpStruct: LPVOID; uSizeStruct: WINUINT; \u000A                                 szFile: LPCWSTR): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WritePrivateProfileStructW\".}" },  { "module": "windows",  "name": "WritePrivateProfileStruct",  "code": "proc WritePrivateProfileStruct*(lpszSection, lpszKey: LPCTSTR; lpStruct: LPVOID; \u000A                                uSizeStruct: WINUINT; szFile: LPCTSTR): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WritePrivateProfileStructA\".}" },  { "module": "windows",  "name": "WriteProcessMemory",  "code": "proc WriteProcessMemory*(hProcess: THandle; lpBaseAddress: pointer; \u000A                         lpBuffer: pointer; nSize: DWORD; \u000A                         lpNumberOfBytesWritten: var DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"WriteProcessMemory\".}" },  { "module": "windows",  "name": "SHFileOperation",  "code": "proc SHFileOperation*(para1: var SHFILEOPSTRUCT): int32 {.stdcall, \u000A    dynlib: \"shell32\", importc: \"SHFileOperation\".}" },  { "module": "windows",  "name": "AnsiNext",  "code": "proc AnsiNext*(lpsz: LPCSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"CharNextA\".}" },  { "module": "windows",  "name": "AnsiPrev",  "code": "proc AnsiPrev*(lpszStart: LPCSTR; lpszCurrent: LPCSTR): LPSTR {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharPrevA\".}" },  { "module": "windows",  "name": "AnsiToOem",  "code": "proc AnsiToOem*(lpszSrc: LPCSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharToOemA\".}" },  { "module": "windows",  "name": "OemToAnsi",  "code": "proc OemToAnsi*(lpszSrc: LPCSTR; lpszDst: LPSTR): WINBOOL {.stdcall, \u000A    dynlib: \"user32\", importc: \"OemToCharA\".}" },  { "module": "windows",  "name": "AnsiToOemBuff",  "code": "proc AnsiToOemBuff*(lpszSrc: LPCSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"CharToOemBuffA\".}" },  { "module": "windows",  "name": "OemToAnsiBuff",  "code": "proc OemToAnsiBuff*(lpszSrc: LPCSTR; lpszDst: LPSTR; cchDstLength: DWORD): WINBOOL {.\u000A    stdcall, dynlib: \"user32\", importc: \"OemToCharBuffA\".}" },  { "module": "windows",  "name": "AnsiUpper",  "code": "proc AnsiUpper*(lpsz: LPSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"CharUpperA\".}" },  { "module": "windows",  "name": "AnsiUpperBuff",  "code": "proc AnsiUpperBuff*(lpsz: LPSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharUpperBuffA\".}" },  { "module": "windows",  "name": "AnsiLower",  "code": "proc AnsiLower*(lpsz: LPSTR): LPSTR {.stdcall, dynlib: \"user32\", \u000A                                      importc: \"CharLowerA\".}" },  { "module": "windows",  "name": "AnsiLowerBuff",  "code": "proc AnsiLowerBuff*(lpsz: LPSTR; cchLength: DWORD): DWORD {.stdcall, \u000A    dynlib: \"user32\", importc: \"CharLowerBuffA\".}" },  { "module": "windows",  "name": "FreeModule",  "code": "proc FreeModule*(h: HINST): WINBOOL" },  { "module": "windows",  "name": "MakeProcInstance",  "code": "proc MakeProcInstance*(p, i: pointer): pointer" },  { "module": "windows",  "name": "FreeProcInstance",  "code": "proc FreeProcInstance*(p: pointer): pointer" },  { "module": "windows",  "name": "GlobalDiscard",  "code": "proc GlobalDiscard*(hglbMem: HGLOBAL): HGLOBAL" },  { "module": "windows",  "name": "LocalDiscard",  "code": "proc LocalDiscard*(hlocMem: HLOCAL): HLOCAL" },  { "module": "windows",  "name": "RGB",  "code": "proc RGB*(r, g, b: int): COLORREF" },  { "module": "windows",  "name": "RGB",  "code": "proc RGB*(r, g, b: range[0 .. 255]): COLORREF" },  { "module": "windows",  "name": "PALETTERGB",  "code": "proc PALETTERGB*(r, g, b: range[0 .. 255]): COLORREF" },  { "module": "windows",  "name": "PALETTEINDEX",  "code": "proc PALETTEINDEX*(i: DWORD): COLORREF" },  { "module": "windows",  "name": "GetRValue",  "code": "proc GetRValue*(rgb: COLORREF): int8" },  { "module": "windows",  "name": "GetGValue",  "code": "proc GetGValue*(rgb: COLORREF): int8" },  { "module": "windows",  "name": "GetBValue",  "code": "proc GetBValue*(rgb: COLORREF): int8" },  { "module": "windows",  "name": "HIBYTE",  "code": "proc HIBYTE*(w: int32): int8" },  { "module": "windows",  "name": "HIWORD",  "code": "proc HIWORD*(L: int32): int16" },  { "module": "windows",  "name": "LOBYTE",  "code": "proc LOBYTE*(w: int32): int8" },  { "module": "windows",  "name": "LOWORD",  "code": "proc LOWORD*(L: int32): int16" },  { "module": "windows",  "name": "MAKELONG",  "code": "proc MAKELONG*(a, b: int32): LONG" },  { "module": "windows",  "name": "MAKEWORD",  "code": "proc MAKEWORD*(a, b: int32): int16" },  { "module": "windows",  "name": "SEXT_HIWORD",  "code": "proc SEXT_HIWORD*(L: int32): int32" },  { "module": "windows",  "name": "ZEXT_HIWORD",  "code": "proc ZEXT_HIWORD*(L: int32): int32" },  { "module": "windows",  "name": "SEXT_LOWORD",  "code": "proc SEXT_LOWORD*(L: int32): int32" },  { "module": "windows",  "name": "INDEXTOOVERLAYMASK",  "code": "proc INDEXTOOVERLAYMASK*(i: int32): int32" },  { "module": "windows",  "name": "INDEXTOSTATEIMAGEMASK",  "code": "proc INDEXTOSTATEIMAGEMASK*(i: int32): int32" },  { "module": "windows",  "name": "MAKEINTATOM",  "code": "proc MAKEINTATOM*(i: int32): LPTSTR" },  { "module": "windows",  "name": "MAKELANGID",  "code": "proc MAKELANGID*(p, s: int32): int32" },  { "module": "windows",  "name": "PRIMARYLANGID",  "code": "proc PRIMARYLANGID*(lgid: int32): int16" },  { "module": "windows",  "name": "SUBLANGID",  "code": "proc SUBLANGID*(lgid: int32): int32" },  { "module": "windows",  "name": "MAKELCID",  "code": "proc MAKELCID*(lgid, srtid: int32): DWORD" },  { "module": "windows",  "name": "MAKELPARAM",  "code": "proc MAKELPARAM*(L, h: int32): LPARAM" },  { "module": "windows",  "name": "MAKELRESULT",  "code": "proc MAKELRESULT*(L, h: int32): LRESULT" },  { "module": "windows",  "name": "MAKEROP4",  "code": "proc MAKEROP4*(fore, back: int32): DWORD" },  { "module": "windows",  "name": "MAKEWPARAM",  "code": "proc MAKEWPARAM*(L, h: int32): WPARAM" },  { "module": "windows",  "name": "GET_X_LPARAM",  "code": "proc GET_X_LPARAM*(lp: windows.LParam): int32" },  { "module": "windows",  "name": "GET_Y_LPARAM",  "code": "proc GET_Y_LPARAM*(lp: windows.LParam): int32" },  { "module": "windows",  "name": "UNICODE_NULL",  "code": "proc UNICODE_NULL*(): WCHAR" },  { "module": "windows",  "name": "GetFirstChild",  "code": "proc GetFirstChild*(h: HWND): HWND" },  { "module": "windows",  "name": "GetNextSibling",  "code": "proc GetNextSibling*(h: HWND): HWND" },  { "module": "windows",  "name": "GetWindowID",  "code": "proc GetWindowID*(h: HWND): int32" },  { "module": "windows",  "name": "SubclassWindow",  "code": "proc SubclassWindow*(h: HWND; p: LONG): LONG" },  { "module": "windows",  "name": "GET_WM_COMMAND_CMD",  "code": "proc GET_WM_COMMAND_CMD*(w, L: int32): int32" },  { "module": "winlean",  "name": "closeHandle",  "code": "proc closeHandle*(hObject: THandle): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"CloseHandle\".}" },  { "module": "winlean",  "name": "readFile",  "code": "proc readFile*(hFile: THandle; Buffer: pointer; nNumberOfBytesToRead: int32; \u000A               lpNumberOfBytesRead: ptr int32; lpOverlapped: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"ReadFile\".}" },  { "module": "winlean",  "name": "writeFile",  "code": "proc writeFile*(hFile: THandle; Buffer: pointer; nNumberOfBytesToWrite: int32; \u000A                lpNumberOfBytesWritten: ptr int32; lpOverlapped: pointer): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WriteFile\".}" },  { "module": "winlean",  "name": "createPipe",  "code": "proc createPipe*(hReadPipe, hWritePipe: var THandle; \u000A                 lpPipeAttributes: var TSECURITY_ATTRIBUTES; nSize: int32): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreatePipe\".}" },  { "module": "winlean",  "name": "createProcessW",  "code": "proc createProcessW*(lpApplicationName, lpCommandLine: WideCString; \u000A                     lpProcessAttributes: ptr TSECURITY_ATTRIBUTES; \u000A                     lpThreadAttributes: ptr TSECURITY_ATTRIBUTES; \u000A                     bInheritHandles: WINBOOL; dwCreationFlags: int32; \u000A                     lpEnvironment, lpCurrentDirectory: WideCString; \u000A                     lpStartupInfo: var TSTARTUPINFO; \u000A                     lpProcessInformation: var TPROCESS_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateProcessW\".}" },  { "module": "winlean",  "name": "suspendThread",  "code": "proc suspendThread*(hThread: THandle): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SuspendThread\".}" },  { "module": "winlean",  "name": "resumeThread",  "code": "proc resumeThread*(hThread: THandle): int32 {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"ResumeThread\".}" },  { "module": "winlean",  "name": "waitForSingleObject",  "code": "proc waitForSingleObject*(hHandle: THandle; dwMilliseconds: int32): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitForSingleObject\".}" },  { "module": "winlean",  "name": "terminateProcess",  "code": "proc terminateProcess*(hProcess: THandle; uExitCode: int): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"TerminateProcess\".}" },  { "module": "winlean",  "name": "getExitCodeProcess",  "code": "proc getExitCodeProcess*(hProcess: THandle; lpExitCode: var int32): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetExitCodeProcess\".}" },  { "module": "winlean",  "name": "getStdHandle",  "code": "proc getStdHandle*(nStdHandle: int32): THandle {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetStdHandle\".}" },  { "module": "winlean",  "name": "setStdHandle",  "code": "proc setStdHandle*(nStdHandle: int32; hHandle: THandle): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetStdHandle\".}" },  { "module": "winlean",  "name": "flushFileBuffers",  "code": "proc flushFileBuffers*(hFile: THandle): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"FlushFileBuffers\".}" },  { "module": "winlean",  "name": "getLastError",  "code": "proc getLastError*(): int32 {.importc: \"GetLastError\", stdcall, \u000A                              dynlib: \"kernel32\".}" },  { "module": "winlean",  "name": "formatMessageW",  "code": "proc formatMessageW*(dwFlags: int32; lpSource: pointer; \u000A                     dwMessageId, dwLanguageId: int32; lpBuffer: pointer; \u000A                     nSize: int32; Arguments: pointer): int32 {.\u000A    importc: \"FormatMessageW\", stdcall, dynlib: \"kernel32\".}" },  { "module": "winlean",  "name": "localFree",  "code": "proc localFree*(p: pointer) {.importc: \"LocalFree\", stdcall, dynlib: \"kernel32\".}" },  { "module": "winlean",  "name": "getCurrentDirectoryW",  "code": "proc getCurrentDirectoryW*(nBufferLength: int32; lpBuffer: WideCString): int32 {.\u000A    importc: \"GetCurrentDirectoryW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "setCurrentDirectoryW",  "code": "proc setCurrentDirectoryW*(lpPathName: WideCString): int32 {.\u000A    importc: \"SetCurrentDirectoryW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "createDirectoryW",  "code": "proc createDirectoryW*(pathName: WideCString; security: pointer = nil): int32 {.\u000A    importc: \"CreateDirectoryW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "removeDirectoryW",  "code": "proc removeDirectoryW*(lpPathName: WideCString): int32 {.\u000A    importc: \"RemoveDirectoryW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "setEnvironmentVariableW",  "code": "proc setEnvironmentVariableW*(lpName, lpValue: WideCString): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"SetEnvironmentVariableW\".}" },  { "module": "winlean",  "name": "getModuleFileNameW",  "code": "proc getModuleFileNameW*(handle: THandle; buf: WideCString; size: int32): int32 {.\u000A    importc: \"GetModuleFileNameW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "createSymbolicLinkW",  "code": "proc createSymbolicLinkW*(lpSymlinkFileName, lpTargetFileName: WideCString; \u000A                          flags: DWORD): int32 {.importc: \"CreateSymbolicLinkW\", \u000A    dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "createHardLinkW",  "code": "proc createHardLinkW*(lpFileName, lpExistingFileName: WideCString; \u000A                      security: pointer = nil): int32 {.\u000A    importc: \"CreateHardLinkW\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "findFirstFileW",  "code": "proc findFirstFileW*(lpFileName: WideCString; \u000A                     lpFindFileData: var TWIN32_FIND_DATA): THandle {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FindFirstFileW\".}" },  { "module": "winlean",  "name": "findNextFileW",  "code": "proc findNextFileW*(hFindFile: THandle; lpFindFileData: var TWIN32_FIND_DATA): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"FindNextFileW\".}" },  { "module": "winlean",  "name": "findClose",  "code": "proc findClose*(hFindFile: THandle) {.stdcall, dynlib: \"kernel32\", \u000A                                      importc: \"FindClose\".}" },  { "module": "winlean",  "name": "getFullPathNameW",  "code": "proc getFullPathNameW*(lpFileName: WideCString; nBufferLength: int32; \u000A                       lpBuffer: WideCString; lpFilePart: var WideCString): int32 {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFullPathNameW\".}" },  { "module": "winlean",  "name": "getFileAttributesW",  "code": "proc getFileAttributesW*(lpFileName: WideCString): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileAttributesW\".}" },  { "module": "winlean",  "name": "setFileAttributesW",  "code": "proc setFileAttributesW*(lpFileName: WideCString; dwFileAttributes: int32): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFileAttributesW\".}" },  { "module": "winlean",  "name": "copyFileW",  "code": "proc copyFileW*(lpExistingFileName, lpNewFileName: WideCString; \u000A                bFailIfExists: cint): cint {.importc: \"CopyFileW\", stdcall, \u000A    dynlib: \"kernel32\".}" },  { "module": "winlean",  "name": "getEnvironmentStringsW",  "code": "proc getEnvironmentStringsW*(): WideCString {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"GetEnvironmentStringsW\".}" },  { "module": "winlean",  "name": "freeEnvironmentStringsW",  "code": "proc freeEnvironmentStringsW*(para1: WideCString): int32 {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"FreeEnvironmentStringsW\".}" },  { "module": "winlean",  "name": "getCommandLineW",  "code": "proc getCommandLineW*(): WideCString {.importc: \"GetCommandLineW\", stdcall, \u000A                                       dynlib: \"kernel32\".}" },  { "module": "winlean",  "name": "rdFileTime",  "code": "proc rdFileTime*(f: TFILETIME): int64" },  { "module": "winlean",  "name": "rdFileSize",  "code": "proc rdFileSize*(f: TWIN32_FIND_DATA): int64" },  { "module": "winlean",  "name": "getSystemTimeAsFileTime",  "code": "proc getSystemTimeAsFileTime*(lpSystemTimeAsFileTime: var TFILETIME) {.\u000A    importc: \"GetSystemTimeAsFileTime\", dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "sleep",  "code": "proc sleep*(dwMilliseconds: int32) {.stdcall, dynlib: \"kernel32\", \u000A                                     importc: \"Sleep\".}" },  { "module": "winlean",  "name": "shellExecuteW",  "code": "proc shellExecuteW*(HWND: THandle; lpOperation, lpFile, lpParameters, \u000A                                   lpDirectory: WideCString; nShowCmd: int32): THandle {.\u000A    stdcall, dynlib: \"shell32.dll\", importc: \"ShellExecuteW\".}" },  { "module": "winlean",  "name": "getFileInformationByHandle",  "code": "proc getFileInformationByHandle*(hFile: THandle; lpFileInformation: ptr TBY_HANDLE_FILE_INFORMATION): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetFileInformationByHandle\".}" },  { "module": "winlean",  "name": "wsaGetLastError",  "code": "proc wsaGetLastError*(): cint {.importc: \"WSAGetLastError\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "`==`",  "code": "proc `==`*(x, y: SocketHandle): bool {.borrow.}" },  { "module": "winlean",  "name": "getservbyname",  "code": "proc getservbyname*(name, proto: cstring): ptr Servent {.stdcall, \u000A    importc: \"getservbyname\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "getservbyport",  "code": "proc getservbyport*(port: cint; proto: cstring): ptr Servent {.stdcall, \u000A    importc: \"getservbyport\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "gethostbyaddr",  "code": "proc gethostbyaddr*(ip: ptr InAddr; len: cuint; theType: cint): ptr Hostent {.\u000A    stdcall, importc: \"gethostbyaddr\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "gethostbyname",  "code": "proc gethostbyname*(name: cstring): ptr Hostent {.stdcall, \u000A    importc: \"gethostbyname\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "socket",  "code": "proc socket*(af, typ, protocol: cint): SocketHandle {.stdcall, \u000A    importc: \"socket\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "closesocket",  "code": "proc closesocket*(s: SocketHandle): cint {.stdcall, importc: \"closesocket\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "accept",  "code": "proc accept*(s: SocketHandle; a: ptr SockAddr; addrlen: ptr SockLen): SocketHandle {.\u000A    stdcall, importc: \"accept\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "bindSocket",  "code": "proc bindSocket*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.\u000A    stdcall, importc: \"bind\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "connect",  "code": "proc connect*(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {.\u000A    stdcall, importc: \"connect\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "getsockname",  "code": "proc getsockname*(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {.\u000A    stdcall, importc: \"getsockname\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "getsockopt",  "code": "proc getsockopt*(s: SocketHandle; level, optname: cint; optval: pointer; \u000A                 optlen: ptr SockLen): cint {.stdcall, importc: \"getsockopt\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "setsockopt",  "code": "proc setsockopt*(s: SocketHandle; level, optname: cint; optval: pointer; \u000A                 optlen: SockLen): cint {.stdcall, importc: \"setsockopt\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "listen",  "code": "proc listen*(s: SocketHandle; backlog: cint): cint {.stdcall, importc: \"listen\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "recv",  "code": "proc recv*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall, \u000A    importc: \"recv\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "recvfrom",  "code": "proc recvfrom*(s: SocketHandle; buf: cstring; len, flags: cint; \u000A               fromm: ptr SockAddr; fromlen: ptr SockLen): cint {.stdcall, \u000A    importc: \"recvfrom\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "select",  "code": "proc select*(nfds: cint; readfds, writefds, exceptfds: ptr TFdSet; \u000A             timeout: ptr Timeval): cint {.stdcall, importc: \"select\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "send",  "code": "proc send*(s: SocketHandle; buf: pointer; len, flags: cint): cint {.stdcall, \u000A    importc: \"send\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "sendto",  "code": "proc sendto*(s: SocketHandle; buf: pointer; len, flags: cint; to: ptr SockAddr; \u000A             tolen: SockLen): cint {.stdcall, importc: \"sendto\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "shutdown",  "code": "proc shutdown*(s: SocketHandle; how: cint): cint {.stdcall, importc: \"shutdown\", \u000A    dynlib: ws2dll.}" },  { "module": "winlean",  "name": "getnameinfo",  "code": "proc getnameinfo*(a1: ptr SockAddr; a2: SockLen; a3: cstring; a4: SockLen; \u000A                  a5: cstring; a6: SockLen; a7: cint): cint {.stdcall, \u000A    importc: \"getnameinfo\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "inet_addr",  "code": "proc inet_addr*(cp: cstring): int32 {.stdcall, importc: \"inet_addr\", \u000A                                      dynlib: ws2dll.}" },  { "module": "winlean",  "name": "FD_ISSET",  "code": "proc FD_ISSET*(socket: SocketHandle; set: var TFdSet): cint" },  { "module": "winlean",  "name": "FD_SET",  "code": "proc FD_SET*(socket: SocketHandle; s: var TFdSet)" },  { "module": "winlean",  "name": "FD_ZERO",  "code": "proc FD_ZERO*(s: var TFdSet)" },  { "module": "winlean",  "name": "wsaStartup",  "code": "proc wsaStartup*(wVersionRequired: int16; WSData: ptr WSAData): cint {.stdcall, \u000A    importc: \"WSAStartup\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "getaddrinfo",  "code": "proc getaddrinfo*(nodename, servname: cstring; hints: ptr AddrInfo; \u000A                  res: var ptr AddrInfo): cint {.stdcall, \u000A    importc: \"getaddrinfo\", dynlib: ws2dll.}" },  { "module": "winlean",  "name": "freeaddrinfo",  "code": "proc freeaddrinfo*(ai: ptr AddrInfo) {.stdcall, importc: \"freeaddrinfo\", \u000A                                       dynlib: ws2dll.}" },  { "module": "winlean",  "name": "inet_ntoa",  "code": "proc inet_ntoa*(i: InAddr): cstring {.stdcall, importc, dynlib: ws2dll.}" },  { "module": "winlean",  "name": "waitForMultipleObjects",  "code": "proc waitForMultipleObjects*(nCount: DWORD; lpHandles: PWOHandleArray; \u000A                             bWaitAll: WINBOOL; dwMilliseconds: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"WaitForMultipleObjects\".}" },  { "module": "winlean",  "name": "createFileW",  "code": "proc createFileW*(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD; \u000A                  lpSecurityAttributes: pointer; \u000A                  dwCreationDisposition, dwFlagsAndAttributes: DWORD; \u000A                  hTemplateFile: THandle): THandle {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"CreateFileW\".}" },  { "module": "winlean",  "name": "deleteFileW",  "code": "proc deleteFileW*(pathName: WideCString): int32 {.importc: \"DeleteFileW\", \u000A    dynlib: \"kernel32\", stdcall.}" },  { "module": "winlean",  "name": "setEndOfFile",  "code": "proc setEndOfFile*(hFile: THandle): WINBOOL {.stdcall, dynlib: \"kernel32\", \u000A    importc: \"SetEndOfFile\".}" },  { "module": "winlean",  "name": "setFilePointer",  "code": "proc setFilePointer*(hFile: THandle; lDistanceToMove: LONG; \u000A                     lpDistanceToMoveHigh: ptr LONG; dwMoveMethod: DWORD): DWORD {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"SetFilePointer\".}" },  { "module": "winlean",  "name": "getFileSize",  "code": "proc getFileSize*(hFile: THandle; lpFileSizeHigh: ptr DWORD): DWORD {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetFileSize\".}" },  { "module": "winlean",  "name": "mapViewOfFileEx",  "code": "proc mapViewOfFileEx*(hFileMappingObject: THandle; dwDesiredAccess: DWORD; \u000A                      dwFileOffsetHigh, dwFileOffsetLow: DWORD; \u000A                      dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"MapViewOfFileEx\".}" },  { "module": "winlean",  "name": "createFileMappingW",  "code": "proc createFileMappingW*(hFile: THandle; lpFileMappingAttributes: pointer; \u000A                         flProtect, dwMaximumSizeHigh: DWORD; \u000A                         dwMaximumSizeLow: DWORD; lpName: pointer): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateFileMappingW\".}" },  { "module": "winlean",  "name": "createFileMappingA",  "code": "proc createFileMappingA*(hFile: THANDLE; lpFileMappingAttributes: pointer; \u000A                         flProtect, dwMaximumSizeHigh: DWORD; \u000A                         dwMaximumSizeLow: DWORD; lpName: cstring): THANDLE {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateFileMappingA\".}" },  { "module": "winlean",  "name": "unmapViewOfFile",  "code": "proc unmapViewOfFile*(lpBaseAddress: pointer): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"UnmapViewOfFile\".}" },  { "module": "winlean",  "name": "createIoCompletionPort",  "code": "proc createIoCompletionPort*(FileHandle: THandle; \u000A                             ExistingCompletionPort: THandle; \u000A                             CompletionKey: DWORD; \u000A                             NumberOfConcurrentThreads: DWORD): THandle {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"CreateIoCompletionPort\".}" },  { "module": "winlean",  "name": "getQueuedCompletionStatus",  "code": "proc getQueuedCompletionStatus*(CompletionPort: THandle; \u000A                                lpNumberOfBytesTransferred: PDWORD; \u000A                                lpCompletionKey: PULONG; \u000A                                lpOverlapped: ptr POVERLAPPED; \u000A                                dwMilliseconds: DWORD): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetQueuedCompletionStatus\".}" },  { "module": "winlean",  "name": "getOverlappedResult",  "code": "proc getOverlappedResult*(hFile: THandle; lpOverlapped: TOVERLAPPED; \u000A                          lpNumberOfBytesTransferred: var DWORD; bWait: WINBOOL): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetOverlappedResult\".}" },  { "module": "winlean",  "name": "WSAIORW",  "code": "template WSAIORW*(x, y): expr" },  { "module": "winlean",  "name": "WSAIoctl",  "code": "proc WSAIoctl*(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer; \u000A               cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD; \u000A               lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED; \u000A               lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint {.\u000A    stdcall, importc: \"WSAIoctl\", dynlib: \"Ws2_32.dll\".}" },  { "module": "winlean",  "name": "WSARecv",  "code": "proc WSARecv*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; \u000A              bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED; \u000A              completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall, \u000A    importc: \"WSARecv\", dynlib: \"Ws2_32.dll\".}" },  { "module": "winlean",  "name": "WSASend",  "code": "proc WSASend*(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; \u000A              bytesSent: PDWORD; flags: DWORD; lpOverlapped: POVERLAPPED; \u000A              completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {.stdcall, \u000A    importc: \"WSASend\", dynlib: \"Ws2_32.dll\".}" },  { "module": "winlean",  "name": "get_osfhandle",  "code": "proc get_osfhandle*(fd: FileHandle): THandle {.importc: \"_get_osfhandle\", \u000A    header: \"<io.h>\".}" },  { "module": "winlean",  "name": "getSystemTimes",  "code": "proc getSystemTimes*(lpIdleTime, lpKernelTime, lpUserTime: var TFILETIME): WINBOOL {.\u000A    stdcall, dynlib: \"kernel32\", importc: \"GetSystemTimes\".}" },  { "module": "winlean",  "name": "getProcessTimes",  "code": "proc getProcessTimes*(hProcess: THandle; lpCreationTime, lpExitTime, \u000A    lpKernelTime, lpUserTime: var TFILETIME): WINBOOL {.stdcall, \u000A    dynlib: \"kernel32\", importc: \"GetProcessTimes\".}" },  { "module": "xmldom",  "name": "getDOM",  "code": "proc getDOM*(): PDOMImplementation",  "desc": "Returns a DOMImplementation" },  { "module": "xmldom",  "name": "createDocument",  "code": "proc createDocument*(dom: PDOMImplementation; namespaceURI: string; \u000A                     qualifiedName: string): PDocument",  "desc": "Creates an XML Document object of the specified type with its document element." },  { "module": "xmldom",  "name": "createDocument",  "code": "proc createDocument*(dom: PDOMImplementation; n: PElement): PDocument",  "desc": "Creates an XML Document object of the specified type with its document element." },  { "module": "xmldom",  "name": "hasFeature",  "code": "proc hasFeature*(dom: PDOMImplementation; feature: string; version: string = \"\"): bool",  "desc": "Returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> if this <tt class=\"docutils literal\"><span class=\"pre\">version</span></tt> of the DomImplementation implements <tt class=\"docutils literal\"><span class=\"pre\">feature</span></tt>, otherwise <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt>" },  { "module": "xmldom",  "name": "implementation",  "code": "proc implementation*(doc: PDocument): PDOMImplementation" },  { "module": "xmldom",  "name": "documentElement",  "code": "proc documentElement*(doc: PDocument): PElement" },  { "module": "xmldom",  "name": "createAttribute",  "code": "proc createAttribute*(doc: PDocument; name: string): PAttr",  "desc": "Creates an Attr of the given name. Note that the Attr instance can then be set on an Element using the setAttributeNode method. To create an attribute with a qualified name and namespace URI, use the createAttributeNS method." },  { "module": "xmldom",  "name": "createAttributeNS",  "code": "proc createAttributeNS*(doc: PDocument; namespaceURI: string; \u000A                        qualifiedName: string): PAttr",  "desc": "Creates an attribute of the given qualified name and namespace URI" },  { "module": "xmldom",  "name": "createCDATASection",  "code": "proc createCDATASection*(doc: PDocument; data: string): PCDataSection",  "desc": "Creates a CDATASection node whose value is the specified string." },  { "module": "xmldom",  "name": "createComment",  "code": "proc createComment*(doc: PDocument; data: string): PComment",  "desc": "Creates a Comment node given the specified string." },  { "module": "xmldom",  "name": "createDocumentFragment",  "code": "proc createDocumentFragment*(doc: PDocument): PDocumentFragment",  "desc": "Creates an empty DocumentFragment object." },  { "module": "xmldom",  "name": "createElement",  "code": "proc createElement*(doc: PDocument; tagName: string): PElement",  "desc": "Creates an element of the type specified." },  { "module": "xmldom",  "name": "createElementNS",  "code": "proc createElementNS*(doc: PDocument; namespaceURI: string; \u000A                      qualifiedName: string): PElement",  "desc": "Creates an element of the given qualified name and namespace URI." },  { "module": "xmldom",  "name": "createProcessingInstruction",  "code": "proc createProcessingInstruction*(doc: PDocument; target: string; data: string): PProcessingInstruction",  "desc": "Creates a ProcessingInstruction node given the specified name and data strings." },  { "module": "xmldom",  "name": "createTextNode",  "code": "proc createTextNode*(doc: PDocument; data: string): PText",  "desc": "Creates a Text node given the specified string." },  { "module": "xmldom",  "name": "getElementsByTagName",  "code": "proc getElementsByTagName*(doc: PDocument; tagName: string): seq[PNode]",  "desc": "Returns a NodeList of all the Elements with a given tag name in the order in which they are encountered in a preorder traversal of the Document tree." },  { "module": "xmldom",  "name": "getElementsByTagNameNS",  "code": "proc getElementsByTagNameNS*(doc: PDocument; namespaceURI: string; \u000A                             localName: string): seq[PNode]",  "desc": "Returns a NodeList of all the Elements with a given localName and namespaceURI in the order in which they are encountered in a preorder traversal of the Document tree." },  { "module": "xmldom",  "name": "importNode",  "code": "proc importNode*(doc: PDocument; importedNode: PNode; deep: bool): PNode",  "desc": "Imports a node from another document to this document" },  { "module": "xmldom",  "name": "firstChild",  "code": "proc firstChild*(n: PNode): PNode",  "desc": "Returns this node's first child" },  { "module": "xmldom",  "name": "lastChild",  "code": "proc lastChild*(n: PNode): PNode",  "desc": "Returns this node's last child" },  { "module": "xmldom",  "name": "localName",  "code": "proc localName*(n: PNode): string",  "desc": "Returns this nodes local name" },  { "module": "xmldom",  "name": "namespaceURI",  "code": "proc namespaceURI*(n: PNode): string",  "desc": "Returns this nodes namespace URI" },  { "module": "xmldom",  "name": "`namespaceURI=`",  "code": "proc `namespaceURI =`*(n: PNode; value: string)" },  { "module": "xmldom",  "name": "nextSibling",  "code": "proc nextSibling*(n: PNode): PNode",  "desc": "Returns the next sibling of this node" },  { "module": "xmldom",  "name": "nodeName",  "code": "proc nodeName*(n: PNode): string",  "desc": "Returns the name of this node" },  { "module": "xmldom",  "name": "nodeType",  "code": "proc nodeType*(n: PNode): int",  "desc": "Returns the type of this node" },  { "module": "xmldom",  "name": "ownerDocument",  "code": "proc ownerDocument*(n: PNode): PDocument",  "desc": "Returns the owner document of this node" },  { "module": "xmldom",  "name": "parentNode",  "code": "proc parentNode*(n: PNode): PNode",  "desc": "Returns the parent node of this node" },  { "module": "xmldom",  "name": "previousSibling",  "code": "proc previousSibling*(n: PNode): PNode",  "desc": "Returns the previous sibling of this node" },  { "module": "xmldom",  "name": "`prefix=`",  "code": "proc `prefix =`*(n: PNode; value: string)",  "desc": "Modifies the prefix of this node" },  { "module": "xmldom",  "name": "appendChild",  "code": "proc appendChild*(n: PNode; newChild: PNode)",  "desc": "Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed." },  { "module": "xmldom",  "name": "cloneNode",  "code": "proc cloneNode*(n: PNode; deep: bool): PNode",  "desc": "Returns a duplicate of this node, if <tt class=\"docutils literal\"><span class=\"pre\">deep</span></tt> is <cite>true</cite>, Element node's children are copied" },  { "module": "xmldom",  "name": "hasAttributes",  "code": "proc hasAttributes*(n: PNode): bool",  "desc": "Returns whether this node (if it is an element) has any attributes." },  { "module": "xmldom",  "name": "hasChildNodes",  "code": "proc hasChildNodes*(n: PNode): bool",  "desc": "Returns whether this node has any children." },  { "module": "xmldom",  "name": "insertBefore",  "code": "proc insertBefore*(n: PNode; newChild: PNode; refChild: PNode): PNode",  "desc": "Inserts the node <tt class=\"docutils literal\"><span class=\"pre\">newChild</span></tt> before the existing child node <tt class=\"docutils literal\"><span class=\"pre\">refChild</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">refChild</span></tt> is nil, insert <tt class=\"docutils literal\"><span class=\"pre\">newChild</span></tt> at the end of the list of children." },  { "module": "xmldom",  "name": "isSupported",  "code": "proc isSupported*(n: PNode; feature: string; version: string): bool",  "desc": "Tests whether the DOM implementation implements a specific feature and that feature is supported by this node." },  { "module": "xmldom",  "name": "normalize",  "code": "proc normalize*(n: PNode)",  "desc": "Merges all seperated TextNodes together, and removes any empty TextNodes" },  { "module": "xmldom",  "name": "removeChild",  "code": "proc removeChild*(n: PNode; oldChild: PNode): PNode",  "desc": "Removes the child node indicated by <tt class=\"docutils literal\"><span class=\"pre\">oldChild</span></tt> from the list of children, and returns it." },  { "module": "xmldom",  "name": "replaceChild",  "code": "proc replaceChild*(n: PNode; newChild: PNode; oldChild: PNode): PNode",  "desc": "Replaces the child node <tt class=\"docutils literal\"><span class=\"pre\">oldChild</span></tt> with <tt class=\"docutils literal\"><span class=\"pre\">newChild</span></tt> in the list of children, and returns the <tt class=\"docutils literal\"><span class=\"pre\">oldChild</span></tt> node." },  { "module": "xmldom",  "name": "getNamedItem",  "code": "proc getNamedItem*(nList: seq[PNode]; name: string): PNode",  "desc": "Retrieves a node specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>. If this node cannot be found returns <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>" },  { "module": "xmldom",  "name": "getNamedItem",  "code": "proc getNamedItem*(nList: seq[PAttr]; name: string): PAttr",  "desc": "Retrieves a node specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>. If this node cannot be found returns <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>" },  { "module": "xmldom",  "name": "getNamedItemNS",  "code": "proc getNamedItemNS*(nList: seq[PNode]; namespaceURI: string; localName: string): PNode",  "desc": "Retrieves a node specified by <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>. If this node cannot be found returns <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>" },  { "module": "xmldom",  "name": "getNamedItemNS",  "code": "proc getNamedItemNS*(nList: seq[PAttr]; namespaceURI: string; localName: string): PAttr",  "desc": "Retrieves a node specified by <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>. If this node cannot be found returns <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>" },  { "module": "xmldom",  "name": "item",  "code": "proc item*(nList: seq[PNode]; index: int): PNode",  "desc": "Returns the <tt class=\"docutils literal\"><span class=\"pre\">index</span></tt> th item in the map. If <tt class=\"docutils literal\"><span class=\"pre\">index</span></tt> is greater than or equal to the number of nodes in this map, this returns <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>." },  { "module": "xmldom",  "name": "removeNamedItem",  "code": "proc removeNamedItem*(nList: var seq[PNode]; name: string): PNode",  "desc": "Removes a node specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> Raises the <tt class=\"docutils literal\"><span class=\"pre\">ENotFoundErr</span></tt> exception, if the node was not found" },  { "module": "xmldom",  "name": "removeNamedItemNS",  "code": "proc removeNamedItemNS*(nList: var seq[PNode]; namespaceURI: string; \u000A                        localName: string): PNode",  "desc": "Removes a node specified by local name and namespace URI" },  { "module": "xmldom",  "name": "setNamedItem",  "code": "proc setNamedItem*(nList: var seq[PNode]; arg: PNode): PNode",  "desc": "Adds <tt class=\"docutils literal\"><span class=\"pre\">arg</span></tt> as a <tt class=\"docutils literal\"><span class=\"pre\">Node</span></tt> to the <tt class=\"docutils literal\"><span class=\"pre\">NList</span></tt> If a node with the same name is already present in this map, it is replaced by the new one." },  { "module": "xmldom",  "name": "setNamedItem",  "code": "proc setNamedItem*(nList: var seq[PAttr]; arg: PAttr): PAttr",  "desc": "Adds <tt class=\"docutils literal\"><span class=\"pre\">arg</span></tt> as a <tt class=\"docutils literal\"><span class=\"pre\">Node</span></tt> to the <tt class=\"docutils literal\"><span class=\"pre\">NList</span></tt> If a node with the same name is already present in this map, it is replaced by the new one." },  { "module": "xmldom",  "name": "setNamedItemNS",  "code": "proc setNamedItemNS*(nList: var seq[PNode]; arg: PNode): PNode",  "desc": "Adds a node using its <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt>" },  { "module": "xmldom",  "name": "setNamedItemNS",  "code": "proc setNamedItemNS*(nList: var seq[PAttr]; arg: PAttr): PAttr",  "desc": "Adds a node using its <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt>" },  { "module": "xmldom",  "name": "name",  "code": "proc name*(a: PAttr): string",  "desc": "Returns the name of the Attribute" },  { "module": "xmldom",  "name": "specified",  "code": "proc specified*(a: PAttr): bool",  "desc": "Specifies whether this attribute was specified in the original document" },  { "module": "xmldom",  "name": "ownerElement",  "code": "proc ownerElement*(a: PAttr): PElement",  "desc": "Returns this Attributes owner element" },  { "module": "xmldom",  "name": "tagName",  "code": "proc tagName*(el: PElement): string",  "desc": "Returns the Element Tag Name" },  { "module": "xmldom",  "name": "getAttribute",  "code": "proc getAttribute*(el: PElement; name: string): string",  "desc": "Retrieves an attribute value by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>" },  { "module": "xmldom",  "name": "getAttributeNS",  "code": "proc getAttributeNS*(el: PElement; namespaceURI: string; localName: string): string",  "desc": "Retrieves an attribute value by <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>" },  { "module": "xmldom",  "name": "getAttributeNode",  "code": "proc getAttributeNode*(el: PElement; name: string): PAttr",  "desc": "Retrieves an attribute node by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> To retrieve an attribute node by qualified name and namespace URI, use the <cite>getAttributeNodeNS</cite> method" },  { "module": "xmldom",  "name": "getAttributeNodeNS",  "code": "proc getAttributeNodeNS*(el: PElement; namespaceURI: string; localName: string): PAttr",  "desc": "Retrieves an <cite>Attr</cite> node by <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>" },  { "module": "xmldom",  "name": "getElementsByTagName",  "code": "proc getElementsByTagName*(el: PElement; name: string): seq[PNode]",  "desc": "Returns a <cite>NodeList</cite> of all descendant <cite>Elements</cite> of <tt class=\"docutils literal\"><span class=\"pre\">el</span></tt> with a given tag <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>, in the order in which they are encountered in a preorder traversal of this <cite>Element</cite> tree If <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> is <cite>*</cite>, returns all descendant of <tt class=\"docutils literal\"><span class=\"pre\">el</span></tt>" },  { "module": "xmldom",  "name": "getElementsByTagNameNS",  "code": "proc getElementsByTagNameNS*(el: PElement; namespaceURI: string; \u000A                             localName: string): seq[PNode]",  "desc": "Returns a <cite>NodeList</cite> of all the descendant Elements with a given <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt> in the order in which they are encountered in a preorder traversal of this Element tree" },  { "module": "xmldom",  "name": "hasAttribute",  "code": "proc hasAttribute*(el: PElement; name: string): bool",  "desc": "Returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> when an attribute with a given <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> is specified on this element , <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> otherwise." },  { "module": "xmldom",  "name": "hasAttributeNS",  "code": "proc hasAttributeNS*(el: PElement; namespaceURI: string; localName: string): bool",  "desc": "Returns <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> when an attribute with a given <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt> is specified on this element , <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> otherwise" },  { "module": "xmldom",  "name": "removeAttribute",  "code": "proc removeAttribute*(el: PElement; name: string)",  "desc": "Removes an attribute by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt>" },  { "module": "xmldom",  "name": "removeAttributeNS",  "code": "proc removeAttributeNS*(el: PElement; namespaceURI: string; localName: string)",  "desc": "Removes an attribute by <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>" },  { "module": "xmldom",  "name": "removeAttributeNode",  "code": "proc removeAttributeNode*(el: PElement; oldAttr: PAttr): PAttr",  "desc": "Removes the specified attribute node If the attribute node cannot be found raises <tt class=\"docutils literal\"><span class=\"pre\">ENotFoundErr</span></tt>" },  { "module": "xmldom",  "name": "setAttributeNode",  "code": "proc setAttributeNode*(el: PElement; newAttr: PAttr): PAttr",  "desc": "Adds a new attribute node, if an attribute with the same <cite>nodeName</cite> is present, it is replaced by the new one and the replaced attribute is returned, otherwise <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt> is returned." },  { "module": "xmldom",  "name": "setAttributeNodeNS",  "code": "proc setAttributeNodeNS*(el: PElement; newAttr: PAttr): PAttr",  "desc": "Adds a new attribute node, if an attribute with the localName and namespaceURI of <tt class=\"docutils literal\"><span class=\"pre\">newAttr</span></tt> is present, it is replaced by the new one and the replaced attribute is returned, otherwise <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt> is returned." },  { "module": "xmldom",  "name": "setAttribute",  "code": "proc setAttribute*(el: PElement; name: string; value: string)",  "desc": "Adds a new attribute, as specified by <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">value</span></tt> If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified <tt class=\"docutils literal\"><span class=\"pre\">name</span></tt> contains illegal characters" },  { "module": "xmldom",  "name": "setAttributeNS",  "code": "proc setAttributeNS*(el: PElement; namespaceURI, localName, value: string)",  "desc": "Adds a new attribute, as specified by <tt class=\"docutils literal\"><span class=\"pre\">namespaceURI</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">localName</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">value</span></tt>." },  { "module": "xmldom",  "name": "splitData",  "code": "proc splitData*(textNode: PText; offset: int): PText",  "desc": "Breaks this node into two nodes at the specified offset, keeping both in the tree as siblings." },  { "module": "xmldom",  "name": "target",  "code": "proc target*(pi: PProcessingInstruction): string",  "desc": "Returns the Processing Instructions target" },  { "module": "xmldom",  "name": "`$`",  "code": "proc `$`*(doc: PDocument): string",  "desc": "Converts a PDocument object into a string representation of it's XML" },  { "module": "xmldomparser",  "name": "loadXMLStream",  "code": "proc loadXMLStream*(stream: Stream): PDocument",  "desc": "Loads and parses XML from a stream specified by <tt class=\"docutils literal\"><span class=\"pre\">stream</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PDocument</span></tt>" },  { "module": "xmldomparser",  "name": "loadXML",  "code": "proc loadXML*(xml: string): PDocument",  "desc": "Loads and parses XML from a string specified by <tt class=\"docutils literal\"><span class=\"pre\">xml</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PDocument</span></tt>" },  { "module": "xmldomparser",  "name": "loadXMLFile",  "code": "proc loadXMLFile*(path: string): PDocument",  "desc": "Loads and parses XML from a file specified by <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PDocument</span></tt>" },  { "module": "xmlparser",  "name": "parseXml",  "code": "proc parseXml*(s: Stream; filename: string; errors: var seq[string]): XmlNode",  "desc": "parses the XML from stream <cite>s</cite> and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. Every occured parsing error is added to the <cite>errors</cite> sequence." },  { "module": "xmlparser",  "name": "parseXml",  "code": "proc parseXml*(s: Stream): XmlNode",  "desc": "parses the XTML from stream <cite>s</cite> and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. All parsing errors are turned into an <tt class=\"docutils literal\"><span class=\"pre\">EInvalidXML</span></tt> exception." },  { "module": "xmlparser",  "name": "loadXml",  "code": "proc loadXml*(path: string; errors: var seq[string]): XmlNode",  "desc": "Loads and parses XML from file specified by <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>. Every occured parsing error is added to the <cite>errors</cite> sequence." },  { "module": "xmlparser",  "name": "loadXml",  "code": "proc loadXml*(path: string): XmlNode",  "desc": "Loads and parses XML from file specified by <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>, and returns a <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt>.  All parsing errors are turned into an <tt class=\"docutils literal\"><span class=\"pre\">EInvalidXML</span></tt> exception.  " },  { "module": "xmltree",  "name": "newElement",  "code": "proc newElement*(tag: string): XmlNode",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt> of kind <tt class=\"docutils literal\"><span class=\"pre\">xnText</span></tt> with the given <cite>tag</cite>." },  { "module": "xmltree",  "name": "newText",  "code": "proc newText*(text: string): XmlNode",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt> of kind <tt class=\"docutils literal\"><span class=\"pre\">xnText</span></tt> with the text <cite>text</cite>." },  { "module": "xmltree",  "name": "newComment",  "code": "proc newComment*(comment: string): XmlNode",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt> of kind <tt class=\"docutils literal\"><span class=\"pre\">xnComment</span></tt> with the text <cite>comment</cite>." },  { "module": "xmltree",  "name": "newCData",  "code": "proc newCData*(cdata: string): XmlNode",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt> of kind <tt class=\"docutils literal\"><span class=\"pre\">xnComment</span></tt> with the text <cite>cdata</cite>." },  { "module": "xmltree",  "name": "newEntity",  "code": "proc newEntity*(entity: string): XmlNode",  "desc": "creates a new <tt class=\"docutils literal\"><span class=\"pre\">PXmlNode</span></tt> of kind <tt class=\"docutils literal\"><span class=\"pre\">xnEntity</span></tt> with the text <cite>entity</cite>." },  { "module": "xmltree",  "name": "text",  "code": "proc text*(n: XmlNode): string {.inline.}",  "desc": "gets the associated text with the node <cite>n</cite>. <cite>n</cite> can be a CDATA, Text, comment, or entity node." },  { "module": "xmltree",  "name": "rawText",  "code": "proc rawText*(n: XmlNode): string {.inline.}",  "desc": "returns the underlying 'text' string by reference. This is only used for speed hacks." },  { "module": "xmltree",  "name": "rawTag",  "code": "proc rawTag*(n: XmlNode): string {.inline.}",  "desc": "returns the underlying 'tag' string by reference. This is only used for speed hacks." },  { "module": "xmltree",  "name": "innerText",  "code": "proc innerText*(n: XmlNode): string",  "desc": "gets the inner text of <cite>n</cite>. <cite>n</cite> has to be an <tt class=\"docutils literal\"><span class=\"pre\">xnElement</span></tt> node. Only <tt class=\"docutils literal\"><span class=\"pre\">xnText</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">xnEntity</span></tt> nodes are considered part of <cite>n</cite>'s inner text, other child nodes are silently ignored." },  { "module": "xmltree",  "name": "tag",  "code": "proc tag*(n: XmlNode): string {.inline.}",  "desc": "gets the tag name of <cite>n</cite>. <cite>n</cite> has to be an <tt class=\"docutils literal\"><span class=\"pre\">xnElement</span></tt> node." },  { "module": "xmltree",  "name": "add",  "code": "proc add*(father, son: XmlNode) {.inline.}",  "desc": "adds the child <cite>son</cite> to <cite>father</cite>." },  { "module": "xmltree",  "name": "len",  "code": "proc len*(n: XmlNode): int {.inline.}",  "desc": "returns the number <cite>n</cite>'s children." },  { "module": "xmltree",  "name": "kind",  "code": "proc kind*(n: XmlNode): XmlNodeKind {.inline.}",  "desc": "returns <cite>n</cite>'s kind." },  { "module": "xmltree",  "name": "`[]`",  "code": "proc `[]`*(n: XmlNode; i: int): XmlNode {.inline.}",  "desc": "returns the <cite>i</cite>'th child of <cite>n</cite>." },  { "module": "xmltree",  "name": "items",  "code": "iterator items*(n: XmlNode): XmlNode {.inline.}",  "desc": "iterates over any child of <cite>n</cite>." },  { "module": "xmltree",  "name": "attrs",  "code": "proc attrs*(n: XmlNode): XmlAttributes {.inline.}",  "desc": "gets the attributes belonging to <cite>n</cite>. Returns <cite>nil</cite> if attributes have not been initialised for this node." },  { "module": "xmltree",  "name": "`attrs=`",  "code": "proc `attrs =`*(n: XmlNode; attr: XmlAttributes) {.inline.}",  "desc": "sets the attributes belonging to <cite>n</cite>." },  { "module": "xmltree",  "name": "attrsLen",  "code": "proc attrsLen*(n: XmlNode): int {.inline.}",  "desc": "returns the number of <cite>n</cite>'s attributes." },  { "module": "xmltree",  "name": "clientData",  "code": "proc clientData*(n: XmlNode): int {.inline.}",  "desc": "gets the client data of <cite>n</cite>. The client data field is used by the HTML parser and generator." },  { "module": "xmltree",  "name": "`clientData=`",  "code": "proc `clientData =`*(n: XmlNode; data: int) {.inline.}",  "desc": "sets the client data of <cite>n</cite>. The client data field is used by the HTML parser and generator." },  { "module": "xmltree",  "name": "addEscaped",  "code": "proc addEscaped*(result: var string; s: string)",  "desc": "same as <tt class=\"docutils literal\"><span class=\"pre\">result.add(escape(s))</span></tt>, but more efficient." },  { "module": "xmltree",  "name": "escape",  "code": "proc escape*(s: string): string",  "desc": "escapes <cite>s</cite> for inclusion into an XML document. Escapes these characters:<table border=\"1\" class=\"docutils\"><tr><th>char</th><th>is converted to</th></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;lt;</span></tt></td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">&gt;</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;gt;</span></tt></td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;amp;</span></tt></td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">&quot;</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;quot;</span></tt></td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">'</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;#x27;</span></tt></td></tr>\u000A<tr><td><tt class=\"docutils literal\"><span class=\"pre\">/</span></tt></td><td><tt class=\"docutils literal\"><span class=\"pre\">&amp;#x2F;</span></tt></td></tr>\u000A</table>" },  { "module": "xmltree",  "name": "add",  "code": "proc add*(result: var string; n: XmlNode; indent = 0; indWidth = 2)",  "desc": "adds the textual representation of <cite>n</cite> to <cite>result</cite>." },  { "module": "xmltree",  "name": "`$`",  "code": "proc `$`*(n: XmlNode): string",  "desc": "converts <cite>n</cite> into its string representation. No <tt class=\"docutils literal\"><span class=\"pre\">&lt;$xml ...$&gt;</span></tt> declaration is produced, so that the produced XML fragments are composable." },  { "module": "xmltree",  "name": "newXmlTree",  "code": "proc newXmlTree*(tag: string; children: openArray[XmlNode]; \u000A                 attributes: XmlAttributes = nil): XmlNode",  "desc": "creates a new XML tree with <cite>tag</cite>, <cite>children</cite> and <cite>attributes</cite>" },  { "module": "xmltree",  "name": "`&lt;&gt;`",  "code": "macro `<>`*(x: expr): expr {.immediate.}",  "desc": "Constructor macro for XML. Example usage:<pre><span class=\"Operator\">&lt;&gt;</span><span class=\"Identifier\">a</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">href</span><span class=\"Operator\">=</span><span class=\"StringLit\">&quot;http://nim-code.org&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">newText</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;Nim rules.&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">)</span></pre><p>Produces an XML tree for:<pre>\u000A&lt;a href=&quot;http://nim-code.org&quot;&gt;Nim rules.&lt;/a&gt;</pre>\u000A</p>\u000A" },  { "module": "xmltree",  "name": "child",  "code": "proc child*(n: XmlNode; name: string): XmlNode",  "desc": "Finds the first child element of <cite>n</cite> with a name of <cite>name</cite>. Returns <cite>nil</cite> on failure." },  { "module": "xmltree",  "name": "attr",  "code": "proc attr*(n: XmlNode; name: string): string",  "desc": "Finds the first attribute of <cite>n</cite> with a name of <cite>name</cite>. Returns &quot;&quot; on failure." },  { "module": "xmltree",  "name": "findAll",  "code": "proc findAll*(n: XmlNode; tag: string; result: var seq[XmlNode])",  "desc": "<p>Iterates over all the children of <cite>n</cite> returning those matching <cite>tag</cite>.</p>\u000A<p>Found nodes satisfying the condition will be appended to the <cite>result</cite> sequence, which can't be nil or the proc will crash. Usage example:</p>\u000A<pre><span class=\"Keyword\">var</span>\u000A  <span class=\"Identifier\">html</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">XmlNode</span>\u000A  <span class=\"Identifier\">tags</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">seq</span><span class=\"Punctuation\">[</span><span class=\"Identifier\">XmlNode</span><span class=\"Punctuation\">]</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctuation\">[</span><span class=\"Punctuation\">]</span>\u000A\u000A<span class=\"Identifier\">html</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">buildHtml</span><span class=\"Punctuation\">(</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Identifier\">findAll</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">html</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;img&quot;</span><span class=\"Punctuation\">,</span> <span class=\"Identifier\">tags</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">imgTag</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">tags</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">process</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">imgTag</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "xmltree",  "name": "findAll",  "code": "proc findAll*(n: XmlNode; tag: string): seq[XmlNode]",  "desc": "Shortcut version to assign in let blocks. Example:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">html</span><span class=\"Punctuation\">:</span> <span class=\"Identifier\">XmlNode</span>\u000A\u000A<span class=\"Identifier\">html</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">buildHtml</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">html</span><span class=\"Punctuation\">)</span>\u000A<span class=\"Keyword\">for</span> <span class=\"Identifier\">imgTag</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">html</span><span class=\"Operator\">.</span><span class=\"Identifier\">findAll</span><span class=\"Punctuation\">(</span><span class=\"StringLit\">&quot;img&quot;</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\u000A  <span class=\"Identifier\">process</span><span class=\"Punctuation\">(</span><span class=\"Identifier\">imgTag</span><span class=\"Punctuation\">)</span></pre>" },  { "module": "zipfiles",  "name": "open",  "code": "proc open*(z: var TZipArchive; filename: string; mode: FileMode = fmRead): bool",  "desc": "Opens a zip file for reading, writing or appending. All file modes are supported. Returns true iff successful, false otherwise." },  { "module": "zipfiles",  "name": "close",  "code": "proc close*(z: var TZipArchive)",  "desc": "Closes a zip file." },  { "module": "zipfiles",  "name": "createDir",  "code": "proc createDir*(z: var TZipArchive; dir: string)",  "desc": "Creates a directory within the <cite>z</cite> archive. This does not fail if the directory already exists. Note that for adding a file like <tt class=\"docutils literal\"><span class=\"pre\">&quot;path1/path2/filename&quot;</span></tt> it is not necessary to create the <tt class=\"docutils literal\"><span class=\"pre\">&quot;path/path2&quot;</span></tt> subdirectories - it will be done automatically by <tt class=\"docutils literal\"><span class=\"pre\">addFile</span></tt>. " },  { "module": "zipfiles",  "name": "addFile",  "code": "proc addFile*(z: var TZipArchive; dest, src: string)",  "desc": "Adds the file <cite>src</cite> to the archive <cite>z</cite> with the name <cite>dest</cite>. <cite>dest</cite> may contain a path that will be created. " },  { "module": "zipfiles",  "name": "addFile",  "code": "proc addFile*(z: var TZipArchive; file: string)",  "desc": "A shortcut for <tt class=\"docutils literal\"><span class=\"pre\">addFile(z, file, file)</span></tt>, i.e. the name of the source is the name of the destination." },  { "module": "zipfiles",  "name": "addFile",  "code": "proc addFile*(z: var TZipArchive; dest: string; src: Stream)",  "desc": "Adds a file named with <cite>dest</cite> to the archive <cite>z</cite>. <cite>dest</cite> may contain a path. The file's content is read from the <cite>src</cite> stream." },  { "module": "zipfiles",  "name": "getStream",  "code": "proc getStream*(z: var TZipArchive; filename: string): PZipFileStream",  "desc": "returns a stream that can be used to read the file named <cite>filename</cite> from the archive <cite>z</cite>. Returns nil in case of an error. The returned stream does not support the <cite>setPosition</cite>, <cite>getPosition</cite>, <cite>writeData</cite> or <cite>atEnd</cite> methods." },  { "module": "zipfiles",  "name": "walkFiles",  "code": "iterator walkFiles*(z: var TZipArchive): string",  "desc": "walks over all files in the archive <cite>z</cite> and returns the filename (including the path)." },  { "module": "zipfiles",  "name": "extractFile",  "code": "proc extractFile*(z: var TZipArchive; srcFile: string; dest: Stream)",  "desc": "extracts a file from the zip archive <cite>z</cite> to the destination stream." },  { "module": "zipfiles",  "name": "extractFile",  "code": "proc extractFile*(z: var TZipArchive; srcFile: string; dest: string)",  "desc": "extracts a file from the zip archive <cite>z</cite> to the destination filename." },  { "module": "zipfiles",  "name": "extractAll",  "code": "proc extractAll*(z: var TZipArchive; dest: string)",  "desc": "extracts all files from archive <cite>z</cite> to the destination directory." },  { "module": "zlib",  "name": "zlibVersion",  "code": "proc zlibVersion*(): cstring {.cdecl, dynlib: libz, importc: \"zlibVersion\".}" },  { "module": "zlib",  "name": "deflate",  "code": "proc deflate*(strm: var TZStream; flush: int32): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflate\".}" },  { "module": "zlib",  "name": "deflateEnd",  "code": "proc deflateEnd*(strm: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflateEnd\".}" },  { "module": "zlib",  "name": "inflate",  "code": "proc inflate*(strm: var TZStream; flush: int32): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflate\".}" },  { "module": "zlib",  "name": "inflateEnd",  "code": "proc inflateEnd*(strm: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateEnd\".}" },  { "module": "zlib",  "name": "deflateSetDictionary",  "code": "proc deflateSetDictionary*(strm: var TZStream; dictionary: Pbytef; \u000A                           dictLength: Uint): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflateSetDictionary\".}" },  { "module": "zlib",  "name": "deflateCopy",  "code": "proc deflateCopy*(dest, source: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflateCopy\".}" },  { "module": "zlib",  "name": "deflateReset",  "code": "proc deflateReset*(strm: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflateReset\".}" },  { "module": "zlib",  "name": "deflateParams",  "code": "proc deflateParams*(strm: var TZStream; level: int32; strategy: int32): int32 {.\u000A    cdecl, dynlib: libz, importc: \"deflateParams\".}" },  { "module": "zlib",  "name": "inflateSetDictionary",  "code": "proc inflateSetDictionary*(strm: var TZStream; dictionary: Pbytef; \u000A                           dictLength: Uint): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateSetDictionary\".}" },  { "module": "zlib",  "name": "inflateSync",  "code": "proc inflateSync*(strm: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateSync\".}" },  { "module": "zlib",  "name": "inflateReset",  "code": "proc inflateReset*(strm: var TZStream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateReset\".}" },  { "module": "zlib",  "name": "compress",  "code": "proc compress*(dest: Pbytef; destLen: Pulongf; source: Pbytef; sourceLen: Ulong): cint {.\u000A    cdecl, dynlib: libz, importc: \"compress\".}" },  { "module": "zlib",  "name": "compress2",  "code": "proc compress2*(dest: Pbytef; destLen: Pulongf; source: Pbytef; \u000A                sourceLen: Ulong; level: cint): cint {.cdecl, dynlib: libz, \u000A    importc: \"compress2\".}" },  { "module": "zlib",  "name": "uncompress",  "code": "proc uncompress*(dest: Pbytef; destLen: Pulongf; source: Pbytef; \u000A                 sourceLen: Ulong): cint {.cdecl, dynlib: libz, \u000A    importc: \"uncompress\".}" },  { "module": "zlib",  "name": "compressBound",  "code": "proc compressBound*(sourceLen: Ulong): Ulong {.cdecl, dynlib: libz, importc.}" },  { "module": "zlib",  "name": "gzopen",  "code": "proc gzopen*(path: cstring; mode: cstring): GzFile {.cdecl, dynlib: libz, \u000A    importc: \"gzopen\".}" },  { "module": "zlib",  "name": "gzdopen",  "code": "proc gzdopen*(fd: int32; mode: cstring): GzFile {.cdecl, dynlib: libz, \u000A    importc: \"gzdopen\".}" },  { "module": "zlib",  "name": "gzsetparams",  "code": "proc gzsetparams*(thefile: GzFile; level: int32; strategy: int32): int32 {.\u000A    cdecl, dynlib: libz, importc: \"gzsetparams\".}" },  { "module": "zlib",  "name": "gzread",  "code": "proc gzread*(thefile: GzFile; buf: pointer; length: int): int32 {.cdecl, \u000A    dynlib: libz, importc: \"gzread\".}" },  { "module": "zlib",  "name": "gzwrite",  "code": "proc gzwrite*(thefile: GzFile; buf: pointer; length: int): int32 {.cdecl, \u000A    dynlib: libz, importc: \"gzwrite\".}" },  { "module": "zlib",  "name": "gzprintf",  "code": "proc gzprintf*(thefile: GzFile; format: Pbytef): int32 {.varargs, cdecl, \u000A    dynlib: libz, importc: \"gzprintf\".}" },  { "module": "zlib",  "name": "gzputs",  "code": "proc gzputs*(thefile: GzFile; s: Pbytef): int32 {.cdecl, dynlib: libz, \u000A    importc: \"gzputs\".}" },  { "module": "zlib",  "name": "gzgets",  "code": "proc gzgets*(thefile: GzFile; buf: Pbytef; length: int32): Pbytef {.cdecl, \u000A    dynlib: libz, importc: \"gzgets\".}" },  { "module": "zlib",  "name": "gzputc",  "code": "proc gzputc*(thefile: GzFile; c: char): char {.cdecl, dynlib: libz, \u000A    importc: \"gzputc\".}" },  { "module": "zlib",  "name": "gzgetc",  "code": "proc gzgetc*(thefile: GzFile): char {.cdecl, dynlib: libz, importc: \"gzgetc\".}" },  { "module": "zlib",  "name": "gzflush",  "code": "proc gzflush*(thefile: GzFile; flush: int32): int32 {.cdecl, dynlib: libz, \u000A    importc: \"gzflush\".}" },  { "module": "zlib",  "name": "gzseek",  "code": "proc gzseek*(thefile: GzFile; offset: ZOffT; whence: int32): ZOffT {.cdecl, \u000A    dynlib: libz, importc: \"gzseek\".}" },  { "module": "zlib",  "name": "gzrewind",  "code": "proc gzrewind*(thefile: GzFile): int32 {.cdecl, dynlib: libz, \u000A    importc: \"gzrewind\".}" },  { "module": "zlib",  "name": "gztell",  "code": "proc gztell*(thefile: GzFile): ZOffT {.cdecl, dynlib: libz, importc: \"gztell\".}" },  { "module": "zlib",  "name": "gzeof",  "code": "proc gzeof*(thefile: GzFile): int {.cdecl, dynlib: libz, importc: \"gzeof\".}" },  { "module": "zlib",  "name": "gzclose",  "code": "proc gzclose*(thefile: GzFile): int32 {.cdecl, dynlib: libz, importc: \"gzclose\".}" },  { "module": "zlib",  "name": "gzerror",  "code": "proc gzerror*(thefile: GzFile; errnum: var int32): Pbytef {.cdecl, dynlib: libz, \u000A    importc: \"gzerror\".}" },  { "module": "zlib",  "name": "adler32",  "code": "proc adler32*(adler: Ulong; buf: Pbytef; length: Uint): Ulong {.cdecl, \u000A    dynlib: libz, importc: \"adler32\".}",  "desc": "<strong>Warning</strong>: Adler-32 requires at least a few hundred bytes to get rolling." },  { "module": "zlib",  "name": "crc32",  "code": "proc crc32*(crc: Ulong; buf: Pbytef; length: Uint): Ulong {.cdecl, dynlib: libz, \u000A    importc: \"crc32\".}" },  { "module": "zlib",  "name": "deflateInitu",  "code": "proc deflateInitu*(strm: var TZStream; level: int32; version: cstring; \u000A                   streamSize: int32): int32 {.cdecl, dynlib: libz, \u000A    importc: \"deflateInit_\".}" },  { "module": "zlib",  "name": "inflateInitu",  "code": "proc inflateInitu*(strm: var TZStream; version: cstring; streamSize: int32): int32 {.\u000A    cdecl, dynlib: libz, importc: \"inflateInit_\".}" },  { "module": "zlib",  "name": "deflateInit",  "code": "proc deflateInit*(strm: var TZStream; level: int32): int32" },  { "module": "zlib",  "name": "inflateInit",  "code": "proc inflateInit*(strm: var TZStream): int32" },  { "module": "zlib",  "name": "deflateInit2u",  "code": "proc deflateInit2u*(strm: var TZStream; level: int32; `method`: int32; \u000A                    windowBits: int32; memLevel: int32; strategy: int32; \u000A                    version: cstring; streamSize: int32): int32 {.cdecl, \u000A    dynlib: libz, importc: \"deflateInit2_\".}" },  { "module": "zlib",  "name": "inflateInit2u",  "code": "proc inflateInit2u*(strm: var TZStream; windowBits: int32; version: cstring; \u000A                    streamSize: int32): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateInit2_\".}" },  { "module": "zlib",  "name": "deflateInit2",  "code": "proc deflateInit2*(strm: var TZStream; \u000A                   level, `method`, windowBits, memLevel, strategy: int32): int32" },  { "module": "zlib",  "name": "inflateInit2",  "code": "proc inflateInit2*(strm: var TZStream; windowBits: int32): int32" },  { "module": "zlib",  "name": "zError",  "code": "proc zError*(err: int32): cstring {.cdecl, dynlib: libz, importc: \"zError\".}" },  { "module": "zlib",  "name": "inflateSyncPoint",  "code": "proc inflateSyncPoint*(z: PZstream): int32 {.cdecl, dynlib: libz, \u000A    importc: \"inflateSyncPoint\".}" },  { "module": "zlib",  "name": "getCrcTable",  "code": "proc getCrcTable*(): pointer {.cdecl, dynlib: libz, importc: \"get_crc_table\".}" },  { "module": "zlib",  "name": "zlibAllocMem",  "code": "proc zlibAllocMem*(appData: pointer; items, size: int): pointer {.cdecl.}" },  { "module": "zlib",  "name": "zlibFreeMem",  "code": "proc zlibFreeMem*(appData, `block`: pointer) {.cdecl.}" },  { "module": "zlib",  "name": "uncompress",  "code": "proc uncompress*(sourceBuf: cstring; sourceLen: int): string",  "desc": "<p>Given a deflated cstring returns its inflated version.</p>\u000A<p>Passing a nil cstring will crash this proc in release mode and assert in debug mode.</p>\u000A<p>Returns nil on problems. Failure is a very loose concept, it could be you passing a non deflated string, or it could mean not having enough memory for the inflated version.</p>\u000A<p>The uncompression algorithm is based on <a class=\"reference external\" href=\"http://stackoverflow.com/questions/17820664\">http://stackoverflow.com/questions/17820664</a> but does ignore some of the original signed/unsigned checks, so may fail with big chunks of data exceeding the positive size of an int32. The algorithm can deal with concatenated deflated values properly.</p>\u000A" },  { "module": "zlib",  "name": "inflate",  "code": "proc inflate*(buffer: var string): bool {.discardable.}",  "desc": "<p>Convenience proc which inflates a string containing compressed data.</p>\u000A<p>Passing a nil string will crash this proc in release mode and assert in debug mode. It is ok to pass a buffer which doesn't contain deflated data, in this case the proc won't modify the buffer.</p>\u000A<p>Returns true if <cite>buffer</cite> was successfully inflated.</p>\u000A" },  { "module": "zzip",  "name": "zzip_strerror",  "code": "proc zzip_strerror*(errcode: int32): cstring {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_strerror\".}" },  { "module": "zzip",  "name": "zzip_strerror_of",  "code": "proc zzip_strerror_of*(dir: ptr TZZipDir): cstring {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_strerror_of\".}" },  { "module": "zzip",  "name": "zzip_errno",  "code": "proc zzip_errno*(errcode: int32): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_errno\".}" },  { "module": "zzip",  "name": "zzip_geterror",  "code": "proc zzip_geterror*(dir: ptr TZZipDir): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_error\".}" },  { "module": "zzip",  "name": "zzip_seterror",  "code": "proc zzip_seterror*(dir: ptr TZZipDir; errcode: int32) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_seterror\".}" },  { "module": "zzip",  "name": "zzip_compr_str",  "code": "proc zzip_compr_str*(compr: int32): cstring {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_compr_str\".}" },  { "module": "zzip",  "name": "zzip_dirhandle",  "code": "proc zzip_dirhandle*(fp: ptr TZZipFile): ptr TZZipDir {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dirhandle\".}" },  { "module": "zzip",  "name": "zzip_dirfd",  "code": "proc zzip_dirfd*(dir: ptr TZZipDir): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dirfd\".}" },  { "module": "zzip",  "name": "zzip_dir_real",  "code": "proc zzip_dir_real*(dir: ptr TZZipDir): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dir_real\".}" },  { "module": "zzip",  "name": "zzip_file_real",  "code": "proc zzip_file_real*(fp: ptr TZZipFile): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_file_real\".}" },  { "module": "zzip",  "name": "zzip_realdir",  "code": "proc zzip_realdir*(dir: ptr TZZipDir): pointer {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_realdir\".}" },  { "module": "zzip",  "name": "zzip_realfd",  "code": "proc zzip_realfd*(fp: ptr TZZipFile): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_realfd\".}" },  { "module": "zzip",  "name": "zzip_dir_alloc",  "code": "proc zzip_dir_alloc*(fileext: cstringArray): ptr TZZipDir {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_dir_alloc\".}" },  { "module": "zzip",  "name": "zzip_dir_free",  "code": "proc zzip_dir_free*(para1: ptr TZZipDir): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dir_free\".}" },  { "module": "zzip",  "name": "zzip_dir_fdopen",  "code": "proc zzip_dir_fdopen*(fd: int32; errcode_p: ptr TZZipError): ptr TZZipDir {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_dir_fdopen\".}" },  { "module": "zzip",  "name": "zzip_dir_open",  "code": "proc zzip_dir_open*(filename: cstring; errcode_p: ptr TZZipError): ptr TZZipDir {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_dir_open\".}" },  { "module": "zzip",  "name": "zzip_dir_close",  "code": "proc zzip_dir_close*(dir: ptr TZZipDir) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dir_close\".}" },  { "module": "zzip",  "name": "zzip_dir_read",  "code": "proc zzip_dir_read*(dir: ptr TZZipDir; dirent: ptr TZZipDirent): int32 {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_dir_read\".}" },  { "module": "zzip",  "name": "zzip_opendir",  "code": "proc zzip_opendir*(filename: cstring): ptr TZZipDir {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_opendir\".}" },  { "module": "zzip",  "name": "zzip_closedir",  "code": "proc zzip_closedir*(dir: ptr TZZipDir) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_closedir\".}" },  { "module": "zzip",  "name": "zzip_readdir",  "code": "proc zzip_readdir*(dir: ptr TZZipDir): ptr TZZipDirent {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_readdir\".}" },  { "module": "zzip",  "name": "zzip_rewinddir",  "code": "proc zzip_rewinddir*(dir: ptr TZZipDir) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_rewinddir\".}" },  { "module": "zzip",  "name": "zzip_telldir",  "code": "proc zzip_telldir*(dir: ptr TZZipDir): int {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_telldir\".}" },  { "module": "zzip",  "name": "zzip_seekdir",  "code": "proc zzip_seekdir*(dir: ptr TZZipDir; offset: int) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_seekdir\".}" },  { "module": "zzip",  "name": "zzip_file_open",  "code": "proc zzip_file_open*(dir: ptr TZZipDir; name: cstring; flags: int32): ptr TZZipFile {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_file_open\".}" },  { "module": "zzip",  "name": "zzip_file_close",  "code": "proc zzip_file_close*(fp: ptr TZZipFile) {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_file_close\".}" },  { "module": "zzip",  "name": "zzip_file_read",  "code": "proc zzip_file_read*(fp: ptr TZZipFile; buf: pointer; length: int): int {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_file_read\".}" },  { "module": "zzip",  "name": "zzip_open",  "code": "proc zzip_open*(name: cstring; flags: int32): ptr TZZipFile {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_open\".}" },  { "module": "zzip",  "name": "zzip_close",  "code": "proc zzip_close*(fp: ptr TZZipFile) {.cdecl, dynlib: dllname, \u000A                                      importc: \"zzip_close\".}" },  { "module": "zzip",  "name": "zzip_read",  "code": "proc zzip_read*(fp: ptr TZZipFile; buf: pointer; length: int): int {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_read\".}" },  { "module": "zzip",  "name": "zzip_freopen",  "code": "proc zzip_freopen*(name: cstring; mode: cstring; para3: ptr TZZipFile): ptr TZZipFile {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_freopen\".}" },  { "module": "zzip",  "name": "zzip_fopen",  "code": "proc zzip_fopen*(name: cstring; mode: cstring): ptr TZZipFile {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_fopen\".}" },  { "module": "zzip",  "name": "zzip_fread",  "code": "proc zzip_fread*(p: pointer; size: int; nmemb: int; file: ptr TZZipFile): int {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_fread\".}" },  { "module": "zzip",  "name": "zzip_fclose",  "code": "proc zzip_fclose*(fp: ptr TZZipFile) {.cdecl, dynlib: dllname, \u000A                                       importc: \"zzip_fclose\".}" },  { "module": "zzip",  "name": "zzip_rewind",  "code": "proc zzip_rewind*(fp: ptr TZZipFile): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_rewind\".}" },  { "module": "zzip",  "name": "zzip_seek",  "code": "proc zzip_seek*(fp: ptr TZZipFile; offset: int; whence: int32): int {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_seek\".}" },  { "module": "zzip",  "name": "zzip_tell",  "code": "proc zzip_tell*(fp: ptr TZZipFile): int {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_tell\".}" },  { "module": "zzip",  "name": "zzip_dir_stat",  "code": "proc zzip_dir_stat*(dir: ptr TZZipDir; name: cstring; zs: ptr TZZipStat; \u000A                    flags: int32): int32 {.cdecl, dynlib: dllname, \u000A    importc: \"zzip_dir_stat\".}" },  { "module": "zzip",  "name": "zzip_file_stat",  "code": "proc zzip_file_stat*(fp: ptr TZZipFile; zs: ptr TZZipStat): int32 {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_file_stat\".}" },  { "module": "zzip",  "name": "zzip_fstat",  "code": "proc zzip_fstat*(fp: ptr TZZipFile; zs: ptr TZZipStat): int32 {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_fstat\".}" },  { "module": "zzip",  "name": "zzip_open_shared_io",  "code": "proc zzip_open_shared_io*(stream: ptr TZZipFile; name: cstring; o_flags: int32; \u000A                          o_modes: int32; ext: cstringArray; \u000A                          io: ptr TZZipPluginIO): ptr TZZipFile {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_open_shared_io\".}" },  { "module": "zzip",  "name": "zzip_open_ext_io",  "code": "proc zzip_open_ext_io*(name: cstring; o_flags: int32; o_modes: int32; \u000A                       ext: cstringArray; io: ptr TZZipPluginIO): ptr TZZipFile {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_open_ext_io\".}" },  { "module": "zzip",  "name": "zzip_opendir_ext_io",  "code": "proc zzip_opendir_ext_io*(name: cstring; o_modes: int32; ext: cstringArray; \u000A                          io: ptr TZZipPluginIO): ptr TZZipDir {.cdecl, \u000A    dynlib: dllname, importc: \"zzip_opendir_ext_io\".}" },  { "module": "zzip",  "name": "zzip_dir_open_ext_io",  "code": "proc zzip_dir_open_ext_io*(filename: cstring; errcode_p: ptr TZZipError; \u000A                           ext: cstringArray; io: ptr TZZipPluginIO): ptr TZZipDir {.\u000A    cdecl, dynlib: dllname, importc: \"zzip_dir_open_ext_io\".}" }]